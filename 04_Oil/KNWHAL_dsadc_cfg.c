/******************************************************************************/
/* !Layer           : HAL                                                     */
/* !Component       : KNWHAL                                                  */
/* !Description     : Knock Window Layer                                      */
/*                                                                            */
/* !File            : KNWHAL_dsadc_cfg.c                                      */
/* !Description     : KNWHAL Configuration                                    */
/*                                                                            */
/* !Reference       :                                                         */
/*                                                                            */
/* Coding language  : C                                                       */
/*                                                                            */
/* COPYRIGHT VALEO all rights reserved                                        */
/******************************************************************************/
/** 11/10/14, 10:16:17: generated by Genecode v2.6.0.0                        */
/******************************************************************************/
#include "KNWHAL_Cfg.h"
#include "KNWHAL_I.h"
#include "KNWHAL_dsadc_cfg.h"
#include "IfxDsAdc.h"


/*lint -save -e929 */
#define KNWHAL_START_SEC_VAR_CLEARED_32BIT
#include "KNWHAL_MemMap.h"

/*volatile*/ static uint32 u32LocalIndex;

#define KNWHAL_STOP_SEC_VAR_CLEARED_32BIT
#include "KNWHAL_MemMap.h"

#define KNWHAL_START_SEC_VAR_INIT_UNSPECIFIED
#include "KNWHAL_MemMap.h"

#define IFXDSADC_MOD_RUN ( ( (uint32)1 << (uint8)KNWHAL_snDSADCDRV_KNOCK_CONVERTER) )
#define IFXDSADC_CH_RUN  ( ( (uint32)IFXDSADC_MOD_RUN << (uint8)16) )

IfxDsadc_InitConfig IfxDsAdc_InitData =
{
   IFXDSADC_SLEEP_MODE_ACCEPT,           /* AdcSleepModeEnable */    /* CLC.EDIS = 0 */

   IfxDSADC_GLOBCFG_MASK                 /* GlobCfg */
   (
      IFXDSADC_MODULARCLK_FDSD,          /* GLOBCFG.MCSEL = 001 -> fDSD */
      IFXDSADC_LOWSUPVOLTAGE_5V          /* GLOBCFG.LOSUP =   0 -> 5 V power supply is connected */
   ),
   (IFXDSADC_MOD_RUN | IFXDSADC_CH_RUN), /* ChRunMod */
   /* GLOBRC.CH3RUN = 1  | GLOBRC.M3RUN  = 1 */
   6U                                    /*  TotCh */
};

static Ifx_DSADC_CH_MODCFG IfxDsadc_Modulator =
{
   .B =
   {
      IFXDSADC_INPUTLINECFG_INPUT,           /* INCFGP   [1:0] rw Configuration of Positive Input Line = 00B Input pin */
      IFXDSADC_INPUTLINECFG_INPUT,           /* INCFGN   [3:2] rw Configuration of Negative Input Line = 00B Input pin */
      IFXDSADC_GAINSEL_1,                    /* GAINSEL  [7:4] rw Gain Select of Analog Input Path = 0000B Gain factor 1 */
      KNWHAL_snDSADCDRV_KNOCK_CHANNEL,       /* INSEL    [9:8] rw Input Pin Selection = IFXDSADC_INPUTPINSEL_A = 0 */
      0U,                                    /* INMUX  [11:10] rh Input Multiplexer Setting = 00B Input pin position A */
      IFXDSADC_MUXCTRL_SOFTWARE,             /* INMODE [13:12] rw Input Multiplexer Control Mode = 00B Software control (INMUX follows INSEL) */
      IFXDSADC_MUXACTIONCTRL_PRESET,         /* INMAC       14 rw Input Multiplexer Action Control = 0B Preset mode (load INMUX upon a trigger)*/
      1U,                                    /* INCWC       15  w Write Control for Input Parameters = 1B Bitfields INCFGP, INCFGN, GAINSEL, INSEL, INMODE, INMAC can be written*/
      IFXDSADC_CLKDIVIDER_FCLK_6,            /* DIVM   [19:16] rw Divider Factor for Modulator Clock = 2H fMOD = fCLK / 6 */
      0U,                                    /*        [22:20]  r Reserved, write 0, read as 0 */
      1U,                                    /* DWC         23  w Write Control for Divider Factor = 1B Bitfield DIVM can be written*/ 
      IFXDSADC_COMMONMODEVOL_C_2P5,          /* CMVS   [25:24] rw Common Mode Voltage Selection  = 10B VCM = VAREF / 2.0 (2.5 V/1.65 V for VAREF = 5.0 V/3.3 V) */
      IFXDSADC_MODULATORCFG_NORMAL,          /* MCFG   [27:26] rw Modulator Configuration = 00B High-performance mode active */
      IFXDSADC_GAINCALIB_OFF,                /* GCEN        28 rw Gain Calibration Enable = 0B Normal operation */
      IFXDSADC_POWERCTRL_ON,                 /* APC         29 rw Automatic Power ControlIfxDsadc_PowerCtrl_Off = 1 On: Modulator active while MxRUN is set and the gate signal (selected trigger) is active high,*/
      0U,                                    /*             30  r Reserved, write 0, read as 0*/
      1U                                     /* MWC         31  w Write Control for Mode Selection = 1B Bitfields CMVS, MCFG, GCEN, APC can be written */
   }
};
/* this is fixed for the current version */
static Ifx_DSADC_CH_DICFG IfxDsadc_DeModulator =
{
   .B =
   {
      IFXDSADC_DEMODINPUTSEL_SINGLE,         /* DSRC       [3:0] rw Input Data Source Select = 0000BOn-chip modulator, standalone (3rd order)  */
      0U,                                    /*            [6:4]  r Reserved, write 0, read as 0 */
      1U,                                    /* DSWC           7  w Write Control for Data Selection  = 1B Bitfield DSRC can be written */
      0U,                                    /* ITRMODE    [9:8] rw Integrator Trigger Mode = 00B No integration trigger, integrator bypassed, INTEN = 0 all the time */
      0U,                                    /* TSTRMODE [11:10] rw Timestamp Trigger Mode = 00B No timestamp trigger */
      0U,                                    /* TRSEL    [14:12] rw Trigger Select = 0 */
      1U,                                    /* TRWC          15  w Write Control for Trigger Parameters */
      IFXDSADC_SAMPLECLK_INTERNAL,           /* CSRC     [19:16] rw Sample Clock Source Select  = 0000B Internal clock */ 
      1U,                                    /* STROBE   [23:20] rw Data Strobe Generation Mode = 0001B Direct clock, a sample trigger is generated at each rising clock edge */
      0U,                                    /*          [30:24] r Reserved, write 0, read as 0*/
      1U                                     /* SCWC         31 w Write Control for Strobe /Clock Selection = 1B Bitfields STROBE, CSRC can be written */
   }
};

static Ifx_DSADC_CH_FCFGM IfxDsadc_MainFilCfg =
{
   .B =
   {
      1U,                                    /* FIR0EN         0 rw FIR Filter 0 Enable = 1B Enable FIR filter 0 */
      1U,                                    /* FIR1EN         0 rw FIR Filter 1 Enable = 1B Enable FIR filter 1 */
      0U,                                    /* OCEN           2 rw Offset Compensation Filter Enable = 0B Offset compensation filter disabled and byp.*/
      IFXDSADC_DATASHIFTCTRL_SHIFT2,         /* DSH        [4:3] rw Data Shift Control = 10B Shift by 2 */
      IFXDSADCFIRSHIFT_1,                    /* FSH            5 rw FIR Shift Control  =  1B Shift by 1 */ 
      0U                                     /*           [31:6] r Reserved, write 0, read as 0 */
   }
};

static Ifx_DSADC_CH_FCFGC IfxDsadc_CombiFilCfg =
{
   .B =
   {
      63U,                                 /* CFMDF     [7:0] rw CIC Filter (Main Chain) Decimation Factor of the Main CIC filter = CFMDF + 1 = 63 + 1 */ 
      IFXDSADC_COMBFILTERCFG_COMB3,        /* CFMC      [9:8] rw CIC Filter (Main Chain) Configuration = 10B CIC3 */
      1U,                                  /* CFEN         10 rw CIC Filter Enable = 1B Enable CIC filter */
      0U,                                  /*              11  r Reserved, write 0, read as 0 */
      3U,                                  /* MFSC    [13:12] rw Main Filter Shift Control = 11B Shift by 3 */
      IFXDSADC_SRCGEN_NEVER,               /* SRGM    [15:14] rw Service Request Generation Main Chain = 00B Never, service requests disabled */
      IFXDSADC_CFMSV_DECIMATION,           /* CFMSV   [23:16] rw CIC Filter (Main Chain) Start Value = 4 */
      0U                                   /* CFMDCNT [31:24] rh CIC Filter (Main Chain) Decimation Counter*/ 
   }
};

/* Derived from the other parameters */
IfxDsadc_ChCfg IfxDsadc_Channel =
{
   &IfxDsadc_Modulator,             /* *ModulatorCfg        */
   &IfxDsadc_DeModulator,           /* *DemodulCfg          */
   IFXDSADC_TRIGGERSEL_DSADC_TRIG1, /* trigSel              */
   IFXDSADC_TRIG_1_ATOM2_4,         /* HwExtTrigOpSel : ATOM2.4 */
   &IfxDsadc_MainFilCfg,            /* *MainFilCfg          */
   &IfxDsadc_CombiFilCfg,           /* *CombiFilCfg         */
   (IfxDsadc_NotifFctPtrType)0U,    /* IfxDsadcNotifFuncPtr */
   0U,                              /* LinCircBufType       */
   0U                               /* Dma_BufferStatus     */
};

/* These tables are dependent on the values defined in the
 * KNWHAL specification for the values validated.
 */
/* The table below defines for fSPB = 100 Mhz */
IfxDsadc_OsrTbl Spb_100MHz_DIVM_6[IFXDSADC_DIVMM_6_COUNT] =
{
   {
      520830U,
      (8U-1U)
   },
   {
      320510U,
      (13U-1U)
   },
   {
      260420U,
      (16U-1U)
   },
   {
      154320U,
      (27U-1U)
   },
   {
      90580U,
      (46U-1U)
   },
   {
      65100U,
      (64U-1U)
   },
   {
      32550U,
      (128U-1U)
   }
};

IfxDsadc_OsrTbl Spb_100MHz_DIVM_8[IFXDSADC_DIVMM_8_COUNT] =
{
   {
      390630U,
      (8U-1U)
   },
   {
      312500U,
      (10U-1U)
   },
   {
      156250U,
      (20U-1U)
   },
   {
      97660U,
      (32U-1U)
   },
   {
      91910U,
      (34U-1U)
   },
   {
      48830U,
      (64U-1U)
   },
   {
      24410U,
      (128U-1U)
   }
};

IfxDsadc_OsrTbl Spb_100MHz_DIVM_10[IFXDSADC_DIVMM_10_COUNT] =
{
   {
      92590U,
      (27U-1U)
   },
   {
      78130U,
      (32U-1U)
   },
   {
      52080U,
      (48U-1U)
   },
   {
      39060U,
      (64U-1U)
   },
   {
      19530U,
      (128U-1U)
   }
};

#define KNWHAL_STOP_SEC_VAR_INIT_UNSPECIFIED
#include "KNWHAL_MemMap.h"

#define KNWHAL_START_SEC_CODE
#include "KNWHAL_MemMap.h"
/*************************** <AUTO_FUNCTION_HEADER> ***************************/
/*                                                                            */
/* !FuncName    : KNWHAL_vidGetOsr / A                                        */
/* !Description : Finds the closet OSR from the truth tables provided in      */
/*                in the configurations                                       */
/*                                                                            */
/* !LastAuthor  : Infineon                                                    */
/******************************************************************************/
void KNWHAL_vidGetOsr(uint32 u32Period)
{
   uint32   u32Osr_Val[3u];
   uint32   Index_Val[3u];
   uint32   u32WantedSamplingFrequency;


   /*actual applied frequency =
      *( (100Mhz /KNWHAL_u8KnockClockDividor) /
    * (KNWHAL_u8KnockOverSamplingRate * 4 ))
    * e.g: KNWHAL_u8KnockOverSamplingRate = 8
    * KNWHAL_u8KnockClockDividor = 6
    * applied sampling frequency = (100Mhz /6)/(64*4) = 65.101Khz
    **/

   u32WantedSamplingFrequency = (KNWHAL_u32PERIOD_TO_FREQ_SCALE_MULTIPLY) / (u32Period * KNWHAL_u32PERIOD_TO_FREQ_SCALE_DIVIDE);

   u32Osr_Val[0u] = KNWHAL_u32GetOsrFromTbl( (const IfxDsadc_OsrTbl *)Spb_100MHz_DIVM_6, IFXDSADC_DIVMM_6_COUNT,
                                            u32WantedSamplingFrequency, &u32LocalIndex);
   Index_Val[0u]  = u32LocalIndex;
   u32Osr_Val[1u] = KNWHAL_u32GetOsrFromTbl( (const IfxDsadc_OsrTbl *)Spb_100MHz_DIVM_8, IFXDSADC_DIVMM_8_COUNT,
                                            u32WantedSamplingFrequency, &u32LocalIndex);
   Index_Val[1u]  = u32LocalIndex;
   u32Osr_Val[2u] = KNWHAL_u32GetOsrFromTbl( (const IfxDsadc_OsrTbl *)Spb_100MHz_DIVM_10, IFXDSADC_DIVMM_10_COUNT,
                                            u32WantedSamplingFrequency, &u32LocalIndex);
   Index_Val[2u] = u32LocalIndex;

   if (u32Osr_Val[0u] < u32Osr_Val[1u])
   {
      if (u32Osr_Val[0u] < u32Osr_Val[2u])
      {
         KNWHAL_u8KnockClockDividor     = (uint8)IFXDSADC_CLKDIVIDER_FCLK_6;
         KNWHAL_u8KnockOverSamplingRate = (uint8)(Spb_100MHz_DIVM_6[Index_Val[0u]].Osr);
      }
      else
      {
         KNWHAL_u8KnockClockDividor     = (uint8)IFXDSADC_CLKDIVIDER_FCLK_10;
         KNWHAL_u8KnockOverSamplingRate = (uint8)(Spb_100MHz_DIVM_10[Index_Val[2u]].Osr);
      }
   }
   else
   {
      if (u32Osr_Val[1u] < u32Osr_Val[2u])
      {
         KNWHAL_u8KnockClockDividor     = (uint8)IFXDSADC_CLKDIVIDER_FCLK_8;
         KNWHAL_u8KnockOverSamplingRate = (uint8)(Spb_100MHz_DIVM_8[Index_Val[1u]].Osr);
      }
      else
      {
         KNWHAL_u8KnockClockDividor     = (uint8)IFXDSADC_CLKDIVIDER_FCLK_10 /*10U*/;
         KNWHAL_u8KnockOverSamplingRate = (uint8)(Spb_100MHz_DIVM_10[Index_Val[2u]].Osr);
      }
   }
}
/*lint -restore */
#define KNWHAL_STOP_SEC_CODE
#include "KNWHAL_MemMap.h"

/*------------------------------ end of file ---------------------------------*/
