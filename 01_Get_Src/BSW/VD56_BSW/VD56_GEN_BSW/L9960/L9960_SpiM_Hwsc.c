/**********************************************************************************************************************/
/* !Layer           : HAL                                                                                             */
/* !Component       : L9960                                                                                           */
/* !Description     : Driver for H-Bridge device ST L9960                                                             */
/*                                                                                                                    */
/* !File            : L9960_SpiM_Hswc.c                                                                               */
/* !Description     : State Machine to perform the HW Self Check                                                      */
/*                                                                                                                    */
/* !Reference       :                                                                                                 */
/*                                                                                                                    */
/* Coding language  : C                                                                                               */
/*                                                                                                                    */
/* COPYRIGHT VALEO all rights reserved                                                                                */
/**********************************************************************************************************************/
/* Dimension Informations
 * %PCMS_HEADER_SUBSTITUTION_START:%
 * The PID has this format: <Product ID>:<Item ID>.<Variant>-<Item Type>;<Revision>
 * %PID: LIBEMB:A6044.A-SRC;1 %
 * %PCMS_HEADER_SUBSTITUTION_END:%
 **********************************************************************************************************************/

#include "Std_Types.h"
#include "Spi.h"
#include "L9960.h"
#include "L9960_Private.h"
#include "L9960_Spi.h"
#include "L9960_SpiM.h"
#include "L9960_Types.h"
#include "SchM_L9960.h"


/* Number max of HWSC result read */
#define L9960_u8HWSC_MAX_NUMBER 2

/* Timeout to get a HWSC result */
/* TODO: generated by OIL */
#define L9960_u8HWSC_MAX_TIME 3

#define L9960_START_SEC_CODE
#include "L9960_MemMap.h"


/**********************************************************************************************************************/
/* !FuncName    : L9960_vidSpiM_HwscStart                                                                             */
/* !Description : This function starts the HWSC/LBIST test.                                                           */
/*                It launches a SPI communcation, and the sequence continues on SPI Interrupt                         */
/*                in the L9960_vidSpiM_HwscTxConf function.                                                           */
/*                                                                                                                    */
/* !LastAuthor  : L. Voilmy                                                                                           */
/**********************************************************************************************************************/
void L9960_vidSpiM_HwscStart(const L9960_tstrConfig *pkstrConfig,
                             L9960_strData          *pstrData)
{

   /* Initialize the number of HWSC status read try */
   pstrData->u8SpiM_HWSCCheckCounter = 0;

   /* Initialize the check timeout */
   /* Be careful this timeout must take into account the number or read status, and SPI load which can delay the HW result */
   pstrData->u8SpiM_HWSCTimeout = L9960_u8HWSC_MAX_TIME;

   /* Init the status */
   pstrData->u8HWSCLastStatus = L9960_E_SPI_RUNNING;
   
   /* Send the request */
   L9960_vidSpiStartHWSC(pkstrConfig, pstrData);
   
   /* Next state */
   pstrData->udtSpiM_StateMachine.HWSC = L9960_SPIM_SEQ_HWSC_SEND_RESTART_REG;
}

/**********************************************************************************************************************/
/* !FuncName    : L9960_vidSpiM_HwscMainFct                                                                           */
/* !Description : After a HW test fail, this function try to read again the HWSC status to prevent to disable         */
/*                the bridge until the next reset after one SPI read (unwanted event: SPI bus glitch)                 */
/*                                                                                                                    */
/* !LastAuthor  : L. Voilmy                                                                                           */
/**********************************************************************************************************************/
void L9960_vidSpiM_HwscMainFct(const L9960_tstrConfig *pkstrConfig,
                               L9960_strData          *pstrData)
{

   uint8 u8LocHWSCTimeout;
   
   /* This if u8SpiM_HWSCTimeout != 0 seams to be redundant, as this function is called            */
   /* only when HWSC is in progress, so with a u8SpiM_HWSCTimeout != 0                             */
   /* Unit test find that this test is always true, even if the timeout test case has been checked */
   u8LocHWSCTimeout = pstrData->u8SpiM_HWSCTimeout;
   if(u8LocHWSCTimeout != 0)
   {
      u8LocHWSCTimeout--;
      pstrData->u8SpiM_HWSCTimeout = u8LocHWSCTimeout;
      /* The test of timeout elapse is done on Tx confirmation */
      /* If we stop the sequence here, a SPI frame could be in progress and so, the Tx Confirmation will occurs */
      /* and produce a SWFAIl_vidErrorHook                                                                      */
   }
   
   if(pstrData->udtSpiM_StateMachine.HWSC == L9960_SPIM_SEQ_HWSC_RESEND_READ_STATE_1)
   {
      /* Read State Register 1 (contain HWSC result) */
      L9960_vidSpiSendCmdStateReq1(pkstrConfig, pstrData);
           
      /* Next state */
      pstrData->udtSpiM_StateMachine.HWSC = L9960_SPIM_SEQ_HWSC_READ_STATE_1;
   }
}

/**********************************************************************************************************************/
/* !FuncName    : L9960_vidSpiM_HwscTxConf                                                                            */
/* !Description : Called on SPI interrupt. This function handle the state machine to do HWSC.                         */
/*                This sequence has been started by a call to L9960_vidSpiM_HwscStart function.                       */
/*                                                                                                                    */
/* !LastAuthor  : L. Voilmy                                                                                           */
/**********************************************************************************************************************/
void L9960_vidSpiM_HwscTxConf(const L9960_tstrConfig *pkstrConfig,
                              L9960_strData          *pstrData,
                              uint16                  u16ReceiveData,
                              uint8                   u8SpiError)
{
   if(pstrData->u8SpiM_HWSCTimeout == 0)
   {
      /* The HW Self Check process take too long time so we cancel the action and go into failed mode */
      /* End of sequence */
      L9960_vidSpiM_EndOfSequence(pkstrConfig, pstrData);
      /* End of sequence, successful Notification */
      pstrData->u8HWSCLastStatus = L9960_E_NOT_OK;
   }
   else if(u8SpiError == L9960_u8SPI_OK)
   {
      switch (pstrData->udtSpiM_StateMachine.HWSC)
      {
         case L9960_SPIM_SEQ_HWSC_SEND_RESTART_REG:
            /* In this step we just send the command to start the HW Self Check      */
            /* Now we have to read the result which is contained in State Register 1 */
            
            /* Read State Register 1 (contain HWSC result) */
            L9960_vidSpiSendCmdStateReq1(pkstrConfig, pstrData);
            
            /* Next state */
            pstrData->udtSpiM_StateMachine.HWSC = L9960_SPIM_SEQ_HWSC_READ_STATE_1;
            break;
            
         case L9960_SPIM_SEQ_HWSC_READ_STATE_1:
            /* In this step we just read the result of the HW Self Check                                             */
            /* The results could be:                                                                                 */
            /* - L9960_bfSTATE_1_HWSC_OK_LBIST_OK : The HWSC success, and then the bridge could be used              */
            /*      The sequence stop with success (we notify the L9960 main manager)                                */
            /*                                                                                                       */
            /* - L9960_bfSTATE_1_HWSC_FAIL_LBIST_FAIL or                                                             */
            /* - L9960_bfSTATE_1_HWSC_FAIL_LBIST_OK: One of tests failed.                                            */
            /*      We don't relauch the test (the chip may have a real problem) but maybe the SPI line was corrupted*/
            /*      As this fault will block the L9960 until the next reset, we shall try to read again the result   */
            /*                                                                                                       */
            /*      The next read will be send on periodic task by L9960_vidSpiM_HwscMainFct, then we wait some time */
            /*      before to redo the read, and so have chance to wait enough to stop having SPi perturbation       */
            /*                                                                                                       */
            /*      If after L9960_u8HWSC_MAX_NUMBER read, we still have an error, then we stop the sequence and     */
            /*      notify the L9960 main manager about this error. The H-Bridge is in tristate.                     */
            /*                                                                                                       */
            /* - Default: All other case => the test is in progress                                                  */
            /*      In this case we have to ask again the L9960 (in L9960_vidSpiM_HwscMainFct to not overload the    */
            /*      SPI). TODO: out have to be implemented                                                           */
            
            switch( u16ReceiveData & L9960_bfSTATE_1_HWSC_BITS)
            {
               case L9960_bfSTATE_1_HWSC_FAIL_LBIST_FAIL:
               case L9960_bfSTATE_1_HWSC_FAIL_LBIST_OK:
                  /* Error, the L9960 cannot be used, try time before to go to in HW_FAILURE mode */
                  if(pstrData->u8SpiM_HWSCCheckCounter < L9960_u8HWSC_MAX_NUMBER)
                  {
                     /* For safety, we will not re launch a test, but just read again the status */
                     /* To prevent to disable the L9960 on a SPI glith.                          */
                     pstrData->u8SpiM_HWSCCheckCounter++;
                     
                     /* relaunch a read status command on Periodic L9960_vidSpiM_HwscMainFct Function */
                     pstrData->udtSpiM_StateMachine.HWSC = L9960_SPIM_SEQ_HWSC_RESEND_READ_STATE_1;
                  }
                  else
                  {
                     /* End of sequence */
                     L9960_vidSpiM_EndOfSequence(pkstrConfig, pstrData);
                     /* End of sequence, Error Notification */
                     pstrData->u8HWSCLastStatus = L9960_E_NOT_OK;
                  }
                  break;
            
               case L9960_bfSTATE_1_HWSC_OK_LBIST_OK:
                     /* End of sequence */
                     L9960_vidSpiM_EndOfSequence(pkstrConfig, pstrData);
                     /* End of sequence, successful Notification */
                     pstrData->u8HWSCLastStatus = L9960_E_OK;
                  break;
                  
               default:
                  /* Diag not finish : relaunch a read status command on Periodic L9960_vidSpiM_HwscMainFct Function */
                  pstrData->udtSpiM_StateMachine.HWSC = L9960_SPIM_SEQ_HWSC_RESEND_READ_STATE_1;

                  /* TODO: handle a timeout */
                  break;
            
            }
            break;

         case L9960_SPIM_SEQ_HWSC_RESEND_READ_STATE_1:
            /* We shall not be called in this state because no SPI transmit has been requested */
         default:
            SWFAIL_vidSoftwareErrorHook();
            L9960_vidSpiM_EndOfSequence(pkstrConfig, pstrData);
            pstrData->u8HWSCLastStatus = L9960_E_NOT_OK;
            break;
   
      }
   }
   else
   {
      if(pstrData->udtSpiM_StateMachine.HWSC == L9960_SPIM_SEQ_HWSC_SEND_RESTART_REG)
      {
         /* If the start HWSC fails, we stop the sequence, and let manager to relauch it */
         L9960_vidSpiM_EndOfSequence(pkstrConfig, pstrData);
         pstrData->u8HWSCLastStatus = L9960_E_SPI_ERROR;
      }
      else
      {
         /* otherwise relaunch the read and let the timeout to stop the sequence if too many error */
         pstrData->udtSpiM_StateMachine.HWSC = L9960_SPIM_SEQ_HWSC_RESEND_READ_STATE_1;
      }
   }
}

#define L9960_STOP_SEC_CODE
#include "L9960_MemMap.h"

/*------------------------------------------------- END OF FILE ------------------------------------------------------*/
