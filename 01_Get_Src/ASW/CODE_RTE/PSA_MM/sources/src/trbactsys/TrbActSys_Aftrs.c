/*******************************************************************************
*                           P. C. A.
*
*                    Peugeot Citroen Automobile
*
*        This file is the property of PCA. All rights are reserved
*        by PCA and this file must not be copied or disclosed
*       (in whole or in part) without prior written consent of PCA.
*
********************************************************************************
*
* %name: TrbActSys_Aftrs.c %
*
* %version: 1.3 %
*
* %date_modified: Wed Jul 24 14:39:59 2013 %
*
*
* %derived_by: u260001 %
* %release: EB2DT/SC4.3 %
* %full_filespec: TrbActSys_Aftrs.c-1.3:csrc:4 %
*
********************************************************************************
*
* generated by  %name: TrbActSys_Aftrs.c %   %version: 1.3 %  the 2012-08-01 16:27:06.518000
*
*******************************************************************************/

#include "TrbActSys_Aftrs.h"

#define TrbActSys_START_SEC_VAR_32BIT
#include "TrbActSys_MemMap.h"

TrbActSys_stNV_Z1_CONST_32BIT TrbActSys_sNV_Z1_CST_32BIT_cpy;

#define TrbActSys_STOP_SEC_VAR_32BIT
#include "TrbActSys_MemMap.h"

#define TrbActSys_START_SEC_INTERNAL_VAR_8BIT
#include "TrbActSys_MemMap.h"
AR_INTERNAL_VAR_DISP_8BIT UInt8 TrbActSys_ctLockRqAftsNvm;
AR_INTERNAL_VAR_DISP_8BIT UInt8 TrbActSys_stAftsNvm;
AR_INTERNAL_VAR_DISP_8BIT UInt8 TrbActSys_IDAftsNvm;
/* SSTG_REQ_TAG : 01552_09_00391-SSTG-C095(1) */
AR_INTERNAL_VAR_DISP_8BIT UInt8 TrbActSys_stRstNvmRtn[TrbActSys_NVMID_END];
#define TrbActSys_STOP_SEC_INTERNAL_VAR_8BIT
#include "TrbActSys_MemMap.h"

#define TrbActSys_START_SEC_INTERNAL_VAR_BOOLEAN
#include "TrbActSys_MemMap.h"
AR_INTERNAL_VAR_DISP_BOOLEAN Boolean TrbActSys_LockedAftsNvm;
#define TrbActSys_STOP_SEC_INTERNAL_VAR_BOOLEAN
#include "TrbActSys_MemMap.h"

#define TrbActSys_START_SEC_CONST_UNSPECIFIED
#include "TrbActSys_MemMap.h"
static const Boolean TrbActSys_tabStructNvramServAvailable[TrbActSys_NVMID_END]=
{
   /* Explication des services associées aux ID (avant avant dernier bit Read, avant dernier bit Write, dernier bit Reset) :
      7 si Read + Write + Reset
      6 si Read + Write
      5 si Read + Reset
      4 si Read
      3 si Write + Reset
      2 si Write
      1 si Reset
      0 si rien
      */
   /* TrbActSys_NVMID01 */
   0x06,
    /* TrbActSys_NVMID02 */
   0x00,
    /* TrbActSys_NVMID03 */
   0x01,
};
#define TrbActSys_STOP_SEC_CONST_UNSPECIFIED
#include "TrbActSys_MemMap.h"

#define TrbActSys_START_SEC_CODE
#include "TrbActSys_MemMap.h"



/*******************************************************************************
*  Function Name   : TrbActSys_Nvm_To_Cpy
*  Description     : Copy all data from NVM to NVM_cpy to guarentee consistency
*                    Function is called on lock rising edge.
*******************************************************************************/
FUNC(void, AUTOMATIC) TrbActSys_Nvm_To_Cpy(void)
{

   TrbActSys_sNV_Z1_CST_32BIT_cpy = TrbActSys_sNV_Z1_CONST_32BIT;


}

/*******************************************************************************
*  Function Name   : TrbActSys_Cpy_To_Nvm_And_Reinit
*  Description     : Copy all data from NVM_cpy to NVM and Reinit
*******************************************************************************/
FUNC(void, AUTOMATIC) TrbActSys_Cpy_To_Nvm_And_Reinit(UInt8 TrbActSys_Nvmid)
{
//#error "Please, check manually if reinitialisation is ok (nvm is not rewritten after functional treatment)."

   switch (TrbActSys_Nvmid)
   {
      case TrbActSys_NVMID01:
         TrbActSys_sNV_Z1_CONST_32BIT = TrbActSys_sNV_Z1_CST_32BIT_cpy;
         /* Reinit */
         //Rte_IrvWrite_RE_TrbActSys_AftsNvm_TrbAct_facAdpArTrbActErr_init(0);
         break;
      case TrbActSys_NVMID_RESERVED:
         TrbActSys_sNV_Z1_CONST_32BIT = TrbActSys_sNV_Z1_CST_32BIT_cpy;
         //Rte_IrvWrite_RE_TrbActSys_AftsNvm_TrbAct_facAdpArTrbActErr_init(0);
         break;
      default:
         /* Do nothing */
         break;
   }



}

/*******************************************************************************
*  Function Name   : TrbActSys_Recovery_To_Nvm_And_Reinit
*  Description     : Copy all data from NVM_recovery to NVM and Reinit
*******************************************************************************/
FUNC(void, AUTOMATIC) TrbActSys_Recovery_To_Nvm_And_Reinit(UInt8 TrbActSys_Nvmid)
{
//#error "Please, check manually if reinitialisation is ok (nvm is not rewritten after functional treatment)."

   switch (TrbActSys_Nvmid)
   {
      
	  case TrbActSys_NVMID03:
          TrbActSys_sNV_Z1_CONST_32BIT = TrbActSys_sNV_Z1_CONST_32BIT_r;
         /* Reinit */
         //Rte_IrvWrite_RE_TrbActSys_AftsNvm_TrbAct_facAdpArTrbActErr_init(0);
         break;
	  case TrbActSys_NVMID_RESERVED:
          TrbActSys_sNV_Z1_CONST_32BIT = TrbActSys_sNV_Z1_CONST_32BIT_r;
         break;
      default:
         /* Do nothing */
         break;
   }



}

/*******************************************************************************
*  Runnable Name   : RE_TrbActSys_AftsSesChgInd
*  Description     : 01552_09_00391-SSTG-C104(2)
*******************************************************************************/
FUNC(Std_ReturnType, RTE_APPL_CODE) RE_TrbActSys_AftsSesChgInd( Dcm_SesCtrlType SesCtrlTypeOld,Dcm_SesCtrlType SesCtrlTypeNew)
{

	UInt32 RtnId_index;
    P2VAR(UInt8 , AUTOMATIC, AUTOMATIC) TrbActSys_stRstNvmRtn_ptr;

    TrbActSys_stRstNvmRtn_ptr = (P2VAR(UInt8 , AUTOMATIC, AUTOMATIC))Rte_IrvRead_RE_TrbActSys_AftsSesChgInd_TrbActSys_stRstNvmRtn();
    SesCtrlTypeNew = SesCtrlTypeOld;

    /* Unconsistent setting */
    for(RtnId_index = 0; RtnId_index < TrbActSys_NVMID_END; RtnId_index++)
    {
        TrbActSys_stRstNvmRtn_ptr[RtnId_index] = RTN_ST_NOT_STARTED;
    }

    Rte_IrvWrite_RE_TrbActSys_AftsSesChgInd_TrbActSys_IDAftsNvm(TrbActSys_NVMID_RESERVED);

    return E_OK;

}

/*******************************************************************************
*  Runnable Name   : RE_TrbActSys_AftsGetSesChgPerm
*  Description     : 01552_09_00391-SSTG-C102(0)
*******************************************************************************/
FUNC(Std_ReturnType, RTE_APPL_CODE) RE_TrbActSys_AftsGetSesChgPerm(Dcm_SesCtrlType SesCtrlTypeActive, Dcm_SesCtrlType SesCtrlTypeNew)
{
    SesCtrlTypeNew = SesCtrlTypeActive;
	return E_OK;

}

/*******************************************************************************
*  Function Name   : RE_TrbActSys_AftrsInit
*  Description     : Initialisation of APV services
*******************************************************************************/
FUNC(Void, RTE_APPL_CODE) RE_TrbActSys_AftrsInit(void)
{

    UInt32 TrbActSys_index;

    /* Copy NVM data to avoid uninitialized data */
    TrbActSys_Nvm_To_Cpy();

    /* SSTG_REQ_TAG : 01552_09_00391-SSTG-C095(1) */
    for(TrbActSys_index=0; TrbActSys_index<TrbActSys_NVMID_END; TrbActSys_index++)
    {
        TrbActSys_stRstNvmRtn[TrbActSys_index] = RTN_ST_NOT_STARTED;
    }

	TrbActSys_LockedAftsNvm = 0;
    TrbActSys_stAftsNvm = CST_NOAFTERSALEREQUEST;
    TrbActSys_IDAftsNvm = TrbActSys_NVMID_RESERVED;
    TrbActSys_ctLockRqAftsNvm = 0;

    /* <PRQA_COMMENT><0306> Due to requirement of after sale specification on this IRV </0306></PRQA_COMMENT> */
    Rte_IrvWrite_RE_TrbActSys_AftrsInit_TrbActSys_IDAftsNvm(TrbActSys_IDAftsNvm);
    /* <PRQA_COMMENT><2100> Warning due to tool, conversion is ok </2100></PRQA_COMMENT> */
    Rte_IrvWrite_RE_TrbActSys_AftrsInit_TrbActSys_LockedAftsNvm(TrbActSys_LockedAftsNvm);
    Rte_IrvWrite_RE_TrbActSys_AftrsInit_TrbActSys_ctLockRqAftsNvm(TrbActSys_ctLockRqAftsNvm);
    Rte_IrvWrite_RE_TrbActSys_AftrsInit_TrbActSys_stAftsNvm(TrbActSys_stAftsNvm);
    Rte_IrvWrite_RE_TrbActSys_AftrsInit_TrbActSys_stRstNvmRtn((UInt32)&TrbActSys_stRstNvmRtn[0]);
	

}

/*******************************************************************************
*  Runnable Name   : RE_TrbActSys_AftsNvm
*  Description     : 01552_09_00391-SSTG-C032(5)
*******************************************************************************/
FUNC(void, RTE_APPL_CODE) RE_TrbActSys_AftsNvm(void)
{

	UInt8 TrbActSys_LockedAftsNvm_irv_in;
	UInt8 TrbActSys_ctLockRqAftsNvm_irv_in;
	UInt8 TrbActSys_stAftsNvm_irv_in;
	UInt8 TrbActSys_IDAftsNvm_irv_in;
	UInt16 ext_neng_swc_in;

	TrbActSys_LockedAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvm_TrbActSys_LockedAftsNvm();
	TrbActSys_ctLockRqAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvm_TrbActSys_ctLockRqAftsNvm();
	TrbActSys_stAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvm_TrbActSys_stAftsNvm();
	TrbActSys_IDAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvm_TrbActSys_IDAftsNvm();
	Rte_Read_R_Ext_nEng_Ext_nEng(&ext_neng_swc_in);

	if(TrbActSys_stAftsNvm_irv_in==CST_WRITE_OK || TrbActSys_stAftsNvm_irv_in==CST_READWRITE_NOK)
	{
		/* Initialize the necessary filter and data to keep the consistency of the NvRAM data structure on unblocking write of them by the non APV way. */

		if(  (((TrbActSys_NVMID_START <= TrbActSys_IDAftsNvm_irv_in) && (TrbActSys_IDAftsNvm_irv_in <= TrbActSys_NVMID_END))|| (TrbActSys_IDAftsNvm_irv_in == TrbActSys_NVMID_RESERVED) ) && (TrbActSys_stAftsNvm_irv_in == CST_WRITE_OK) ) 
		{
			/* NVM was correctly updated */
			/* And Call Task init functions. */
			TrbActSys_Cpy_To_Nvm_And_Reinit(TrbActSys_IDAftsNvm_irv_in);
		}
		else
		{
			/* Do nothing */
        }

		TrbActSys_LockedAftsNvm_irv_in = 0;
		TrbActSys_ctLockRqAftsNvm_irv_in = 0;
		TrbActSys_stAftsNvm_irv_in = CST_NOAFTERSALEREQUEST;

	}
	else 
	{
		/* Manage Read/Write/Reset request: Check if access to NVM in all functional runnables is locked  */
		/* Add on : préciser la 2eme condition plutot que le blabla => Update ST */
		if(TrbActSys_ctLockRqAftsNvm_irv_in > 0)
		{
			if( TrbActSys_LockedAftsNvm_irv_in == 0) 
			{
				TrbActSys_LockedAftsNvm_irv_in = 1;
				TrbActSys_Nvm_To_Cpy(); /* Utile uniquement lors d'un Read, mais on ne peut pas savoir cela ici */
			}
			else 
			{
				/* Do Nothing */
			}
		}
		else 
		{
			TrbActSys_LockedAftsNvm_irv_in = 0;
		}

		// Manage the running reset request
		if(TrbActSys_stAftsNvm_irv_in == CST_RESET)
		{
			// First check that the routine was not canceled on diagnostic session change
			// which set the diag ID to 0
			if( (TrbActSys_NVMID_START <= TrbActSys_IDAftsNvm_irv_in ) && (TrbActSys_IDAftsNvm_irv_in <= TrbActSys_NVMID_END) )
			{
				// Abort the routine if engine is running
				if( (UInt32)ext_neng_swc_in != 0 ) 
				{
					TrbActSys_ctLockRqAftsNvm_irv_in = 0;
					TrbActSys_LockedAftsNvm_irv_in = 0;
					TrbActSys_stAftsNvm_irv_in = CST_RESET_NOK;
				}
				else {
					// Manage the running reset request
					if(TrbActSys_LockedAftsNvm_irv_in == 1) 
					{
						/*
						a. copy all NVRAM recovery structures of the SW-C in the NVRAM data structures, only for data associated to <MSN>_IDAftsNvm_irv value
						b. Initialize the necessary filter and data to keep the consistency of the NvRAM data structure on unblocking write of them. The NvRAM data structure impacted  are identified by the NVMID which is given by the IRV <MSN>_IDAftsNvm_irv
						*/
						TrbActSys_Recovery_To_Nvm_And_Reinit(TrbActSys_IDAftsNvm_irv_in);

						TrbActSys_LockedAftsNvm_irv_in = 0;
						TrbActSys_ctLockRqAftsNvm_irv_in = 0;
						TrbActSys_stAftsNvm_irv_in = CST_RESET_OK;
					}
					else 
					{
						/* Routine aborted on diagnostic session change */
						TrbActSys_LockedAftsNvm_irv_in = 0;
						TrbActSys_ctLockRqAftsNvm_irv_in = 0;
						TrbActSys_stAftsNvm_irv_in = CST_NOAFTERSALEREQUEST;
					}
				}
			}
			else 
			{
				/* Add on : cas defaut non precisé dans la ST */
				/* Routine aborted on diagnostic session change */
				TrbActSys_LockedAftsNvm_irv_in = 0;
				TrbActSys_ctLockRqAftsNvm_irv_in = 0;
				TrbActSys_stAftsNvm_irv_in = CST_NOAFTERSALEREQUEST;
			}
		}
	}



	Rte_IrvWrite_RE_TrbActSys_AftsNvm_TrbActSys_LockedAftsNvm(TrbActSys_LockedAftsNvm_irv_in);
	Rte_IrvWrite_RE_TrbActSys_AftsNvm_TrbActSys_ctLockRqAftsNvm(TrbActSys_ctLockRqAftsNvm_irv_in);
	Rte_IrvWrite_RE_TrbActSys_AftsNvm_TrbActSys_stAftsNvm(TrbActSys_stAftsNvm_irv_in);

	TrbActSys_LockedAftsNvm = TrbActSys_LockedAftsNvm_irv_in;
	TrbActSys_ctLockRqAftsNvm = TrbActSys_ctLockRqAftsNvm_irv_in;
	TrbActSys_stAftsNvm = TrbActSys_stAftsNvm_irv_in;

}

/*******************************************************************************
*  Runnable Name   : RE_TrbActSys_AftsNvmRead
*  Description     : 01552_09_00391-SSTG-C013(4)
*******************************************************************************/
FUNC(Std_ReturnType, RTE_APPL_CODE) RE_TrbActSys_AftsNvmRead(UInt8 SrvId, P2VAR(UInt8, AUTOMATIC, RTE_APPL_DATA) data)
{

	UInt8 TrbActSys_stAftsNvm_irv_in;
	UInt8 TrbActSys_LockedAftsNvm_irv_in;
	UInt8 TrbActSys_ctLockRqAftsNvm_irv_in;
    Std_ReturnType return_value;
	UInt32 i;
	UInt32 j;
	UInt32 *Ptr32;
	UInt16 *Ptr16;
	UInt8 *Ptr8;

	TrbActSys_stAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmRead_TrbActSys_stAftsNvm();
	TrbActSys_LockedAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmRead_TrbActSys_LockedAftsNvm();
	TrbActSys_ctLockRqAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmRead_TrbActSys_ctLockRqAftsNvm();

	/* Unconsistent setting */
	/* Add On : Check not ok whether ID is not ok for Read => Update ST */
	if(TrbActSys_NVMID_START>SrvId || SrvId> TrbActSys_NVMID_END || (0x04&(TrbActSys_tabStructNvramServAvailable[SrvId-1]) != 0) )
	{
		return_value = E_NOT_OK;
	}
	/* Read Data */
	else 
	{
		if(TrbActSys_stAftsNvm_irv_in==CST_READ)
		{
			i=0;
            switch (SrvId)
            {
               case TrbActSys_NVMID01:
                  Ptr32 = (UInt32*) &(TrbActSys_sNV_Z1_CST_32BIT_cpy.TrbAct_facAdpArTrbActErr_NV);
                  PSA_UInt32ToTabUInt8(*Ptr32, &data[i]);
                  i+=4;
                  break;
            }


			/* Add On : Mecanisme de protection underflow => Update ST */
			if( TrbActSys_ctLockRqAftsNvm_irv_in ){
				TrbActSys_ctLockRqAftsNvm_irv_in = TrbActSys_ctLockRqAftsNvm_irv_in - 1;
			}
			else
			{
				/* Add On : Check not ok whether ID is not ok for Read => Update ST */
				return E_NOT_OK;
			}
			if( TrbActSys_ctLockRqAftsNvm_irv_in == 0 ){
				 /* This was the last DIDs requested in the last RDBI request */
				 TrbActSys_stAftsNvm_irv_in = CST_NOAFTERSALEREQUEST;
				 /* Add On : Il y a un manque dans la ST car sinon TrbActSys_LockedAftsNvm_irv_in n'est jamais remis à 0 => Update ST */
				 TrbActSys_LockedAftsNvm_irv_in = 0;
			}
			else
			{
				/* Nothing to do */
			}
			return_value = E_OK;
		}
		else
		{
			return_value = E_NOT_OK;
		}
	}

	Rte_IrvWrite_RE_TrbActSys_AftsNvmRead_TrbActSys_ctLockRqAftsNvm(TrbActSys_ctLockRqAftsNvm_irv_in);
    Rte_IrvWrite_RE_TrbActSys_AftsNvmRead_TrbActSys_stAftsNvm(TrbActSys_stAftsNvm_irv_in);
	Rte_IrvWrite_RE_TrbActSys_AftsNvmRead_TrbActSys_LockedAftsNvm(TrbActSys_LockedAftsNvm_irv_in);

    /* Update displayable data */
    TrbActSys_ctLockRqAftsNvm = TrbActSys_ctLockRqAftsNvm_irv_in;
    TrbActSys_stAftsNvm = TrbActSys_stAftsNvm_irv_in;
    TrbActSys_LockedAftsNvm = TrbActSys_LockedAftsNvm_irv_in;

    return return_value;

}

/*******************************************************************************
*  Runnable Name   : RE_TrbActSys_AftsNvmChkRead
*  Description     : 01552_09_00391-SSTG-C074(3)
*******************************************************************************/
FUNC(Std_ReturnType, RTE_APPL_CODE) RE_TrbActSys_AftsNvmChkRead(UInt8 SrvId, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode)
{

    Std_ReturnType return_value;
	UInt8 TrbActSys_stAftsNvm_irv_in;
	UInt8 TrbActSys_IDAftsNvm_irv_in;
	P2VAR(UInt8 , AUTOMATIC, AUTOMATIC) TrbActSys_stRstNvmRtn_ptr;
	UInt16 ext_neng_swc_in;
	UInt8 TrbActSys_ctLockRqAftsNvm_irv_in;
	UInt8 TrbActSys_LockedAftsNvm_irv_in;

	TrbActSys_stAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmChkRead_TrbActSys_stAftsNvm();
	TrbActSys_IDAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmChkRead_TrbActSys_IDAftsNvm();
	TrbActSys_stRstNvmRtn_ptr = (P2VAR(UInt8 , AUTOMATIC, AUTOMATIC))Rte_IrvRead_RE_TrbActSys_AftsNvmChkRead_TrbActSys_stRstNvmRtn();
	Rte_Read_R_Ext_nEng_Ext_nEng(&ext_neng_swc_in);
	TrbActSys_ctLockRqAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmChkRead_TrbActSys_ctLockRqAftsNvm();
	TrbActSys_LockedAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmChkRead_TrbActSys_LockedAftsNvm();


	/* Unconsistent setting */
	/* Add On : ErrorCode ne doit pas etre pointeur null => Update ST */
	/* Add On : Check not ok whether ID is not ok for Read => Update ST */

	if(TrbActSys_NVMID_START>SrvId || SrvId> TrbActSys_NVMID_END || ErrorCode == NULL || (0x04&(TrbActSys_tabStructNvramServAvailable[SrvId-1]) != 0) )
	{
		return_value = E_NOT_OK;
	}
	/* Handle invalid call sequence */
	else
	{
		if(TrbActSys_stAftsNvm_irv_in==CST_WRITE)
		{
			return_value = E_NOT_OK;
		}
		/* Prevent reading NVM data while a routine to reset/write NVM data is active,
		 or while routine is being canceled after a diagnostic session change */
		else
		{
			if(TrbActSys_stAftsNvm_irv_in==CST_RESET||TrbActSys_stAftsNvm_irv_in==CST_WRITE_OK)
			{
				*ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
				return_value = E_NOT_OK;
			}
			else
			{
				/* Previous active routine has completed => update routine status */
				if(TrbActSys_stAftsNvm_irv_in==CST_RESET_OK||TrbActSys_stAftsNvm_irv_in==CST_RESET_NOK)
				{
					if(TrbActSys_NVMID_START <= TrbActSys_IDAftsNvm_irv_in && TrbActSys_IDAftsNvm_irv_in <= TrbActSys_NVMID_END)
					{
						if(TrbActSys_stAftsNvm_irv_in==CST_RESET_OK)
						{
							TrbActSys_stRstNvmRtn_ptr[(UInt32)TrbActSys_IDAftsNvm_irv_in - 1] = RTN_ST_FINISHED_OK;
						}
						else
						{
							TrbActSys_stRstNvmRtn_ptr[(UInt32)TrbActSys_IDAftsNvm_irv_in - 1] = RTN_ST_FINISHED_NOK;
						}
						TrbActSys_stAftsNvm_irv_in = CST_NOAFTERSALEREQUEST;
					}
				}
                /* Manage the forbidden read on Engine On */
                if( (UInt32)ext_neng_swc_in != 0 )
                {
                    *ErrorCode = DCM_E_ENGINEISRUNNING;
                    TrbActSys_stAftsNvm_irv_in = CST_NOAFTERSALEREQUEST;
                    TrbActSys_ctLockRqAftsNvm_irv_in = 0;
                    return_value = E_NOT_OK;
                }
                else 
				{
                    /* SWC ready to launch the Read service protocol and operation called for the first DID
                    specified in the RDBI request implemented in this SW-C */
                    if(TrbActSys_stAftsNvm_irv_in==CST_NOAFTERSALEREQUEST)
					{
                        /* First call to operation for this DID,
                         or waiting for necessary synchronization w RE_<MSN>_AftsNvm after
                         completion/abortion of read operation */
                        if( TrbActSys_ctLockRqAftsNvm_irv_in == 0 )
						{
                            if( TrbActSys_LockedAftsNvm_irv_in == 1 )
							{
                            /* Synchronization required with runnable RE_<MSN>_AftsNvm to validate the
                                blocking NvRAM read/write access */

                                /* Add On : Cas normalement impossible, mais si on y arrive, que faire ? On retourne E_NOT_OK => Update ST */
                                /* return_value = E_PENDING; */
                                return_value = E_NOT_OK;
                            }
                            else 
							{
                                TrbActSys_ctLockRqAftsNvm_irv_in = 1;
                                return_value = E_PENDING;
                            }
                        }
                        /* Further call to operation for the same DID */
                        else 
						{
                            /* The SWC is ready to read NvRAM */
                            if( TrbActSys_LockedAftsNvm_irv_in == 1 )
							{
                                TrbActSys_stAftsNvm_irv_in = CST_READ;
                                return_value = E_OK;
                            }
                            else 
							{
                                return_value = E_PENDING;
                            }
                        }
                    }
                    else
					{
                        if(TrbActSys_stAftsNvm_irv_in==CST_READ)
						{
                            /* Add On : Risque d'overflow : on bloque à UInt8 max => Update ST */
                            if( TrbActSys_ctLockRqAftsNvm_irv_in < 255 ) 
							{
                                TrbActSys_ctLockRqAftsNvm_irv_in = TrbActSys_ctLockRqAftsNvm_irv_in + 1;
                                return_value = E_OK;
                            }
                            else 
							{
                                /* Nothing to do */
                                /* Add On : On atteind le max, cela parait louche donc on retourne E_NOT_OK => Update ST */
                                return_value = E_NOT_OK;
                            }
                        }
                        /* Unsupported value of <MSN>_stAftsNvm_irv */
                        else 
						{
                            /* => make DCM returning a NRC GeneralReject [$10] */
                            return_value = E_NOT_OK;
                        }
                    }
                }
			}
		}
	}



	Rte_IrvWrite_RE_TrbActSys_AftsNvmChkRead_TrbActSys_ctLockRqAftsNvm(TrbActSys_ctLockRqAftsNvm_irv_in);
    Rte_IrvWrite_RE_TrbActSys_AftsNvmChkRead_TrbActSys_stAftsNvm(TrbActSys_stAftsNvm_irv_in);

    /* Update displayable data */
    TrbActSys_ctLockRqAftsNvm = TrbActSys_ctLockRqAftsNvm_irv_in;
    TrbActSys_stAftsNvm = TrbActSys_stAftsNvm_irv_in;

	return return_value;

}

/*******************************************************************************
*  Runnable Name   : RE_TrbActSys_AftsNvmRDL
*  Description     : 01552_09_00391-SSTG-C099(2)
*******************************************************************************/
FUNC(Std_ReturnType, RTE_APPL_CODE) RE_TrbActSys_AftsNvmRDL(UInt8 SrvId, UInt16 *DidLength)
{

	Std_ReturnType return_value;

	if(  ((UInt32)SrvId < TrbActSys_NVMID_START) ||(TrbActSys_NVMID_END   < (UInt32)SrvId) || (DidLength == NULL) ){
	/* Unconsistent setting */
        return_value = E_NOT_OK;
    }
	/* Set *DidLength = length of the data corresponding to SrvId */
    else
	{
         switch (SrvId)
         {
            case TrbActSys_NVMID01:
               *DidLength = sizeof(TrbActSys_sNV_Z1_CONST_32BIT);
               break;				
         }

		return_value = E_OK;
	}

    return return_value;

}

/*******************************************************************************
*  Runnable Name   : RE_TrbActSys_AftsNvmWrite
*  Description     : 01552_09_00391-SSTG-C018(6)
*******************************************************************************/
FUNC(Std_ReturnType, RTE_APPL_CODE) RE_TrbActSys_AftsNvmWrite(UInt8 SrvId,
                                            P2VAR(UInt8, AUTOMATIC, RTE_APPL_DATA) data,
                                            UInt16 dataLength,
                                            P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode)
{


	UInt8 TrbActSys_stAftsNvm_irv_in;
	UInt32 j;
	UInt32 i;
	Std_ReturnType return_value;

	TrbActSys_stAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmWrite_TrbActSys_stAftsNvm();
	i = 0;

	/* Unconsistent setting */
	/* Add On : Check not ok whether ID is not ok for Write => Update ST */
	if(TrbActSys_NVMID_START>SrvId || SrvId> TrbActSys_NVMID_END || ErrorCode == NULL || (0x02&(TrbActSys_tabStructNvramServAvailable[SrvId-1]) != 0) )
	{
		return_value = E_NOT_OK;
	}
	/* Write Data */
	else 
	{
		if(TrbActSys_stAftsNvm_irv_in==CST_WRITE)
		{
            switch (SrvId)
            {
               case TrbActSys_NVMID01:
                  if(dataLength == sizeof(TrbActSys_sNV_Z1_CONST_32BIT) )
                  {
                     TrbActSys_sNV_Z1_CST_32BIT_cpy.TrbAct_facAdpArTrbActErr_NV = PSA_TabUInt8ToUInt32(&data[i]);
                     i+= 4;
                     TrbActSys_stAftsNvm_irv_in = CST_WRITE_OK;
                     return_value = E_OK;
                  }
                  else
                  {
                     *ErrorCode = DCM_E_REQUESTOUTOFRANGE;
                     TrbActSys_stAftsNvm_irv_in = CST_READWRITE_NOK;
                     return_value = E_NOT_OK;
                  }
                  break;
            }

		}
		else 
		{
			/* Invalid call sequence */
			return_value = E_NOT_OK;
		}
	}

    Rte_IrvWrite_RE_TrbActSys_AftsNvmWrite_TrbActSys_stAftsNvm(TrbActSys_stAftsNvm_irv_in);

    /* Update displayable data */
    TrbActSys_stAftsNvm = TrbActSys_stAftsNvm_irv_in;

    return return_value;

}

/*******************************************************************************
*  Runnable Name   : RE_TrbActSys_AftsNvmChkWrite
*  Description     : 01552_09_00391-SSTG-C076(4)
*******************************************************************************/
FUNC(Std_ReturnType, RTE_APPL_CODE) RE_TrbActSys_AftsNvmChkWrite(UInt8 SrvId, Dcm_NegativeResponseCodeType *ErrorCode)
{

	UInt16 ext_neng_swc_in;
	
	UInt8 TrbActSys_stAftsNvm_irv_in;
	UInt8 TrbActSys_IDAftsNvm_irv_in;
	UInt8 TrbActSys_ctLockRqAftsNvm_irv_in;
	UInt8 TrbActSys_LockedAftsNvm_irv_in;
	P2VAR(UInt8 , AUTOMATIC, AUTOMATIC) TrbActSys_stRstNvmRtn_ptr;

	Std_ReturnType return_value;

	Rte_Read_R_Ext_nEng_Ext_nEng(&ext_neng_swc_in);
	TrbActSys_stRstNvmRtn_ptr = (P2VAR(UInt8 , AUTOMATIC, AUTOMATIC))Rte_IrvRead_RE_TrbActSys_AftsNvmChkWrite_TrbActSys_stRstNvmRtn();

	TrbActSys_stAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmChkWrite_TrbActSys_stAftsNvm();
	TrbActSys_IDAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmChkWrite_TrbActSys_IDAftsNvm();
	TrbActSys_ctLockRqAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmChkWrite_TrbActSys_ctLockRqAftsNvm();
	TrbActSys_LockedAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_AftsNvmChkWrite_TrbActSys_LockedAftsNvm();

	/* Add On : Check not ok whether ID is not ok for Write => Update ST */
	if( (TrbActSys_NVMID_START > (UInt32)SrvId) || ((UInt32)SrvId > TrbActSys_NVMID_END) || ErrorCode == NULL || (0x02&(TrbActSys_tabStructNvramServAvailable[SrvId-1]) != 0) )
	{
		// Unconsistent setting
		return_value = E_NOT_OK;
	}
	else if((TrbActSys_stAftsNvm_irv_in == CST_READ) || (TrbActSys_stAftsNvm_irv_in == CST_WRITE))
	{
		// Handle invalid call sequence
		// => make DCM returning a NRC GeneralReject [$10]
		return_value = E_NOT_OK;
	}
	else if(TrbActSys_stAftsNvm_irv_in == CST_WRITE_OK)
	{
		// Wait for possible reinitialization after previous write operation to complete
		return_value = E_PENDING;
	}
	else if(TrbActSys_stAftsNvm_irv_in == CST_RESET)
	{
		// Prevent writing NVM data while a routine to reset NVM data is active,or while routine is being canceled after a diagnostic session change
		*ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
		return_value = E_NOT_OK;
	}
	else
	{
		if((TrbActSys_stAftsNvm_irv_in == CST_RESET_OK) || (TrbActSys_stAftsNvm_irv_in == CST_RESET_NOK))
		{
			// Previous active routine has completed => update routine status
			if((TrbActSys_NVMID_START <= TrbActSys_IDAftsNvm_irv_in) && (TrbActSys_IDAftsNvm_irv_in <= TrbActSys_NVMID_END))
			{
				if(TrbActSys_stAftsNvm_irv_in == CST_RESET_OK)
				{
					TrbActSys_stRstNvmRtn_ptr[(UInt32)TrbActSys_IDAftsNvm_irv_in -1] = RTN_ST_FINISHED_OK;
				}
				else
				{
					TrbActSys_stRstNvmRtn_ptr[(UInt32)TrbActSys_IDAftsNvm_irv_in -1] = RTN_ST_FINISHED_NOK;
				}
				TrbActSys_stAftsNvm_irv_in = CST_NOAFTERSALEREQUEST;
			}
		}
		if(TrbActSys_stAftsNvm_irv_in == CST_NOAFTERSALEREQUEST)
		{
			// SWC ready to launch the  Write service protocol
			// Manage the forbidden read on Engine On
			if( (UInt32)ext_neng_swc_in != 0 )
			{
				*ErrorCode = DCM_E_ENGINEISRUNNING;
				TrbActSys_ctLockRqAftsNvm_irv_in = 0;
				return_value = E_NOT_OK;
			}
			else
			{
				if(TrbActSys_ctLockRqAftsNvm_irv_in == 0)
				{
					// First call to operation for this DID,
					// or waiting for necessary synchronization with RE_<MSN>_AftsNvm after
					// completion/abortion of read operation
					// Synchronization required with runnable RE_<MSN>_AftsNvm
					if(TrbActSys_LockedAftsNvm_irv_in == 1)
					{
						return_value = E_PENDING;
					}
					else
					{
						// Synchronization required with runnable RE_<MSN>_AftsNvm to validate the
						// blocking NvRAM read/write access
						TrbActSys_ctLockRqAftsNvm_irv_in = 1;
						TrbActSys_IDAftsNvm_irv_in = SrvId;
						return_value = E_PENDING;
					}
				}
				else
				{
					// Further call to operation for this DID
					// The SWC is ready to read NvRAM
					if (TrbActSys_LockedAftsNvm_irv_in == 1)
					{
						TrbActSys_stAftsNvm_irv_in = CST_WRITE;
						return_value = E_OK;
					}
					else
					{
						// The SWC is not ready yet to read NvRAM
						return_value = E_PENDING;
					}
				}
			}
		}
		else
		{
			// Unsupported value of TrbActSys_stAftsNvm_irv
			// => make DCM returning a NRC GeneralReject [$10]
			return_value = E_NOT_OK;
		}
	}

	Rte_IrvWrite_RE_TrbActSys_AftsNvmChkWrite_TrbActSys_stAftsNvm(TrbActSys_stAftsNvm_irv_in);
	Rte_IrvWrite_RE_TrbActSys_AftsNvmChkWrite_TrbActSys_IDAftsNvm(TrbActSys_IDAftsNvm_irv_in);
	Rte_IrvWrite_RE_TrbActSys_AftsNvmChkWrite_TrbActSys_ctLockRqAftsNvm(TrbActSys_ctLockRqAftsNvm_irv_in);
	Rte_IrvWrite_RE_TrbActSys_AftsNvmChkWrite_TrbActSys_LockedAftsNvm(TrbActSys_LockedAftsNvm_irv_in);

	TrbActSys_stAftsNvm = TrbActSys_stAftsNvm_irv_in;
	TrbActSys_IDAftsNvm = TrbActSys_IDAftsNvm_irv_in;
	TrbActSys_ctLockRqAftsNvm = TrbActSys_ctLockRqAftsNvm_irv_in;
	TrbActSys_LockedAftsNvm = TrbActSys_LockedAftsNvm_irv_in;

	return return_value;

}

/*******************************************************************************
*  Runnable Name   : RE_TrbActSys_RstRqResults
*  Description     : 01552_09_00391-SSTG-C060(6)
*******************************************************************************/
FUNC(Std_ReturnType, RTE_APPL_CODE) RE_TrbActSys_RstRqResults( UInt8 SrvId, P2VAR(UInt8, AUTOMATIC, RTE_APPL_DATA) OutBuffer, P2VAR(Dcm_NegativeResponseCodeType, AUTOMATIC, RTE_APPL_DATA) ErrorCode)
{

    Std_ReturnType return_value;
	UInt8 TrbActSys_stAftsNvm_irv_in;
	UInt8 TrbActSys_IDAftsNvm_irv_in;
	P2VAR(UInt8 , AUTOMATIC, AUTOMATIC) TrbActSys_stRstNvmRtn_ptr;

	TrbActSys_stAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_RstRqResults_TrbActSys_stAftsNvm();
	TrbActSys_IDAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_RstRqResults_TrbActSys_IDAftsNvm();
	TrbActSys_stRstNvmRtn_ptr = (P2VAR(UInt8 , AUTOMATIC, AUTOMATIC))Rte_IrvRead_RE_TrbActSys_RstRqResults_TrbActSys_stRstNvmRtn();


	if( (TrbActSys_NVMID_START > (UInt32)SrvId) || ((UInt32)SrvId > TrbActSys_NVMID_END) || ErrorCode == NULL || OutBuffer == NULL || (0x01&(TrbActSys_tabStructNvramServAvailable[SrvId-1]) == 0) ) 
	{
		/* Unconsistent setting */
		return_value = E_NOT_OK;
	}
	else 
	{
		/* Reset done => Update of previous status routine */
		if( (TrbActSys_stAftsNvm_irv_in == CST_RESET_OK) || (TrbActSys_stAftsNvm_irv_in == CST_RESET_NOK) ) 
		{
			if( (TrbActSys_NVMID_START <= TrbActSys_IDAftsNvm_irv_in) && (TrbActSys_IDAftsNvm_irv_in <= TrbActSys_NVMID_END) ) 
			{
				if(TrbActSys_stAftsNvm_irv_in == CST_RESET_OK) 
				{
					// Reset done
					TrbActSys_stRstNvmRtn_ptr[TrbActSys_IDAftsNvm_irv_in-1]=RTN_ST_FINISHED_OK;
				}
				else 
				{
					// Reset stop from blocking event (i.e. : EngineRunning) => Relaunch Reset Request
					TrbActSys_stRstNvmRtn_ptr[TrbActSys_IDAftsNvm_irv_in-1]=RTN_ST_FINISHED_NOK;
				}
			}
			TrbActSys_stAftsNvm_irv_in = CST_NOAFTERSALEREQUEST;
		}

		/* Reset running/done */
		/* Add on : changer RTN_NOT_STARTED en RTN_ST_NOT_STARTED dans la ST */
		if(TrbActSys_stRstNvmRtn_ptr[SrvId - 1] > RTN_ST_NOT_STARTED) 
		{
			OutBuffer[0] = TrbActSys_stRstNvmRtn_ptr[SrvId - 1];
			return_value = E_OK;
		}
		else
		{
			*ErrorCode = DCM_E_REQUESTSEQUENCEERROR;
			return_value = E_NOT_OK;
		}
	}

    Rte_IrvWrite_RE_TrbActSys_RstRqResults_TrbActSys_stAftsNvm(TrbActSys_stAftsNvm_irv_in);

	/* Update displayable data */
	TrbActSys_stAftsNvm = TrbActSys_stAftsNvm_irv_in;

	return return_value;
}

/*******************************************************************************
*  Runnable Name   : RE_TrbActSys_RstStart
*  Description     : 01552_09_00391-SSTG-C023(6)
*******************************************************************************/
FUNC(Std_ReturnType, RTE_APPL_CODE) RE_TrbActSys_RstStart(UInt8 SrvId, UInt8 * InBuffer, UInt8 * OutBuffer, Dcm_NegativeResponseCodeType *ErrorCode)
{

    Std_ReturnType return_value;
	UInt8 TrbActSys_stAftsNvm_irv_in;
	UInt8 TrbActSys_IDAftsNvm_irv_in;
	P2VAR(UInt8 , AUTOMATIC, AUTOMATIC) TrbActSys_stRstNvmRtn_ptr;
	UInt16 ext_neng_swc_in;
	UInt8 TrbActSys_ctLockRqAftsNvm_irv_in;

	TrbActSys_stAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_RstStart_TrbActSys_stAftsNvm();
	TrbActSys_IDAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_RstStart_TrbActSys_IDAftsNvm();
	TrbActSys_stRstNvmRtn_ptr = (P2VAR(UInt8 , AUTOMATIC, AUTOMATIC))Rte_IrvRead_RE_TrbActSys_RstStart_TrbActSys_stRstNvmRtn();
	Rte_Read_R_Ext_nEng_Ext_nEng(&ext_neng_swc_in);
	TrbActSys_ctLockRqAftsNvm_irv_in = Rte_IrvRead_RE_TrbActSys_RstStart_TrbActSys_ctLockRqAftsNvm();
    //*OutBuffer = *InBuffer;


	if( (TrbActSys_NVMID_START > (UInt32)SrvId) || ((UInt32)SrvId > TrbActSys_NVMID_END) || ErrorCode == NULL || OutBuffer == NULL || (0x01&(TrbActSys_tabStructNvramServAvailable[SrvId-1]) == 0) ) 
	{
		return_value = E_NOT_OK;
	}
	else 
	{
		if( (TrbActSys_stAftsNvm_irv_in == CST_RESET) || (TrbActSys_stAftsNvm_irv_in == CST_WRITE_OK) )
		{
			// A routine to reset NVM data is active,
			// or a writing operation has still not completed (reinitialization after writing)
			*ErrorCode = DCM_E_CONDITIONSNOTCORRECT;
			return_value = E_NOT_OK;
		}
		else 
		{
			// Reset done => Update of previous status routine
			if( (TrbActSys_stAftsNvm_irv_in == CST_RESET_OK) || (TrbActSys_stAftsNvm_irv_in == CST_RESET_NOK) ) 
			{
				// Previous active routine has completed => update routine status
				if( (TrbActSys_NVMID_START <= TrbActSys_IDAftsNvm_irv_in) && (TrbActSys_IDAftsNvm_irv_in <= TrbActSys_NVMID_END) ) 
				{
					// Reset done
					if(TrbActSys_stAftsNvm_irv_in == CST_RESET_OK) 
					{
						TrbActSys_stRstNvmRtn_ptr[TrbActSys_IDAftsNvm_irv_in-1]=RTN_ST_FINISHED_OK;
					}
					else 
					{
						// Reset stop from blocking event (i.e. : EngineRunning) => Relaunch Reset Request
						TrbActSys_stRstNvmRtn_ptr[TrbActSys_IDAftsNvm_irv_in-1]=RTN_ST_FINISHED_NOK;
					}
					TrbActSys_stAftsNvm_irv_in = CST_NOAFTERSALEREQUEST;
				}
			}
			if(TrbActSys_stAftsNvm_irv_in == CST_NOAFTERSALEREQUEST) 
			{
				// Manage the Launch request of reset sequence
				if( (UInt32)ext_neng_swc_in != 0 ) 
				{
					// Manage the forbidden write on Engine On
					*ErrorCode = DCM_E_ENGINEISRUNNING;
					return_value = E_NOT_OK;
				}
				else 
				{
					// Manage the first reset request
					TrbActSys_ctLockRqAftsNvm_irv_in = 1;
					TrbActSys_IDAftsNvm_irv_in = SrvId;
					TrbActSys_stAftsNvm_irv_in = CST_RESET;
					TrbActSys_stRstNvmRtn_ptr[SrvId - 1] = RTN_ST_RUNNING;
					OutBuffer[0] = RTN_ST_RUNNING;
					return_value = E_OK;
				}
			}
			else 
			{
				// Unsupported value of <MSN>_stAftsNvm_irv_in including CST_READ and CST_WRITE
				// which is invalid call sequence
				// => make DCM returning a NRC GeneralReject [$10]
				return_value = E_NOT_OK;
			}
		}
	}

	Rte_IrvWrite_RE_TrbActSys_RstStart_TrbActSys_ctLockRqAftsNvm(TrbActSys_ctLockRqAftsNvm_irv_in);
    Rte_IrvWrite_RE_TrbActSys_RstStart_TrbActSys_stAftsNvm(TrbActSys_stAftsNvm_irv_in);
	Rte_IrvWrite_RE_TrbActSys_RstStart_TrbActSys_IDAftsNvm(TrbActSys_IDAftsNvm_irv_in);

    /* Update displayable data */
    TrbActSys_ctLockRqAftsNvm = TrbActSys_ctLockRqAftsNvm_irv_in;
    TrbActSys_stAftsNvm = TrbActSys_stAftsNvm_irv_in;
	TrbActSys_IDAftsNvm = TrbActSys_IDAftsNvm_irv_in;

	return return_value;
}

#define TrbActSys_STOP_SEC_CODE
#include "TrbActSys_MemMap.h"

