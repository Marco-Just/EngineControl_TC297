/**************************************************************************************************\
 *** 
 *** Simulink model       : MgtASECut_01460_10_02173_TL
 *** TargetLink subsystem : MgtASECut_01460_10_02173_TL/ASE_008
 *** Codefile             : ase_008_tev_fct.c
 ***
 *** Generated by TargetLink, the dSPACE production quality code generator
 *** Generation date: 2011-05-20 11:10:09
 ***
 *** CODE GENERATOR OPTIONS:
 *** Compiler                            : <unknown>
 *** Target                              : Generic
 *** ANSI-C compatible code              : yes
 *** Optimization level                  : 2
 *** Constant style                      : decimal
 *** Clean code option                   : enabled
 *** Logging mode                        : Do not log anything
 *** Linker sections                     : enabled
 *** Assembler statements                : disabled
 *** Variable name length                : 31 chars
 *** Use global bitfields                : disabled
 *** Stateflow: use of bitfields         : enabled
 *** State activity encoding limit       : 5
 *** Omit zero inits in restart function : disabled
 *** Share fcns between TL subsystems    : disabled
 *** Generate 64bit functions            : enabled
 *** Inlining Threshold                  : 6
 *** Line break limit                    : 100
 *** Target optimized boolean data type  : enabled
 *** Keep saturation elements            : disabled
 *** Extended variable sharing           : disabled
 *** Style definition file               : C:\dSPACE301\Matlab\Tl\config\codegen\cconfig.xml
 *** Root style sheet                    : C:\dSPACE301\Matlab\Tl\XML\CodeGen\Stylesheets\TL_CSource
 ***                                       CodeSS.xsl
 *** Enable Multirate codegeneration     : disabled
 *** Add model checksum                  : disabled
 ***
 *** SUBSYS                   CORRESPONDING SIMULINK SUBSYSTEM
 *** S0081                    MgtASECut_01460_10_02173_TL/ASE_008
 *** S0082                    ASE_008/F01_Traitement_booleen
 *** S0083                    ASE_008/F02_Calcul_de_Tattente1_et_Tattente2
 *** S0084                    ASE_008/F03_Synthese_Dde_coupure_horsT1T2
 *** S0085                    ASE_008/F04_Synth_se_Dde_coupure_en_Off
 *** S0086                    ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec
 *** S0087                    ASE_008/F06_Synthese_Dde_Coupure_en_Sortie_calage
 *** S0088                    ASE_008/F07_Synthese_Dde_coupure
 *** S0089                    ASE_008/F08_Dde_coupure_en_Coupure
 *** S00810                   ASE_008/F01_Traitement_booleen/Traitement_booleen
 *** S00811                   ASE_008/F01_Traitement_booleen/Traitement_booleen1
 *** S00812                   ASE_008/F01_Traitement_booleen/Traitement_booleen2
 *** S00813                   ASE_008/F01_Traitement_booleen/Traitement_booleen4
 *** S00814                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/BasculeRS1
 *** S00815                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/BasculeRS5
 *** S00816                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay
 *** S00817                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1
 *** S00818                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/rising_edge1
 *** S00819                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/rising_edge7
 *** S00820                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/BasculeRSspec
 ***                          ifique
 *** S00821                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/DetectSat
 *** S00822                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Turnondelay_P
 ***                          art
 *** S00823                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/rising_edge
 *** S00824                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/rising_edge2
 *** S00825                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/BasculeRSspe
 ***                          cifique
 *** S00826                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/DetectSat
 *** S00827                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Turnondelay_
 ***                          Part
 *** S00828                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/rising_edge
 *** S00829                   ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/rising_edge2
 *** S00830                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1
 *** S00831                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2
 *** S00832                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/DetectSat
 *** S00833                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/F03_Synthese_Dd
 ***                          e_coupure_horsT1T2
 *** S00834                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Turnondelay_Par
 ***                          t
 *** S00835                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/rising_edge
 *** S00836                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/rising_edge2
 *** S00837                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/DetectSat
 *** S00838                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/F03_Synthese_Dd
 ***                          e_coupure_horsT1T2
 *** S00839                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Turnondelay_Par
 ***                          t
 *** S00840                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/rising_edge
 *** S00841                   ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/rising_edge2
 *** S00842                   ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2
 *** S00843                   ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/DetectSat
 *** S00844                   ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/F04_Synth_se_Dde_
 ***                          coupure_en_Off
 *** S00845                   ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Turnondelay_Part
 *** S00846                   ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/rising_edge
 *** S00847                   ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/rising_edge2
 *** S00848                   ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1
 *** S00849                   ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Det
 ***                          ectSat
 *** S00850                   ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/F05
 ***                          _Synthese_Dde_coupure_en_Cale_et_Calage_ec
 *** S00851                   ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Tur
 ***                          nondelay_Part
 *** S00852                   ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/ris
 ***                          ing_edge
 *** S00853                   ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/ris
 ***                          ing_edge2
 *** 
 *** SF-NODE   CORRESPONDING STATEFLOW NODE                           DESCRIPTION
 *** 
 *** TargetLink version      : 3.0.1 from 26-May-2009
 *** Code generator version  : Build Id 3.0.1.7 from 2009-May-06 15:28:18
 *** Copyright (c) 2006 dSPACE GmbH
\**************************************************************************************************/

#ifndef _ASE_008_TEV_FCT_C_
#define _ASE_008_TEV_FCT_C_

/*----------------------------------------------------------------------------*\
  DEFINES (OPT)
\*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*\
  INCLUDES
\*----------------------------------------------------------------------------*/
#include "ASE_008_TEV_fct.h"
#include "ASE_008_calibrations.h"
/*----------------------------------------------------------------------------*\
  DEFINES
\*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*\
  TYPEDEFS
\*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*\
  ENUMS
\*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*\
  VARIABLES
\*----------------------------------------------------------------------------*/

#define ASE_START_SEC_GLOBAL_16BIT
#include "ASE_MemMap.h"
/******************************************************************************\
   AR_IF_GLOBAL_16BIT: Global 16 bits for AUTOSAR modules | Width: 16
\******************************************************************************/
AR_IF_GLOBAL_16BIT UInt16 RE_ASE_008_TEV_CoASE_spdVeh_in /* 
   Unit       : km/h
   Description: Vitesse véhicule traitée
   LSB: 2^-7 OFF:  0 MIN/MAX:  0 .. 500 */;

#define ASE_STOP_SEC_GLOBAL_16BIT
#include "ASE_MemMap.h"

#define ASE_START_SEC_GLOBAL_8BIT
#include "ASE_MemMap.h"

/******************************************************************************\
   AR_IF_GLOBAL_8BIT: Global 8 bits for AUTOSAR modules | Width: 8
\******************************************************************************/
AR_IF_GLOBAL_8BIT UInt8 ASE_008_CoEmCkg_stStrtRstrtFbCmd_in /* 
   Description: Retour de commande démarrage redémarrage du SEEM
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 3 */;
AR_IF_GLOBAL_8BIT UInt8 ASE_008_CoEmSTT_stEngRStrtReq_in /* 
   Description: Demande de redémarrage par le SEEM
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 4 */;
AR_IF_GLOBAL_8BIT UInt8 ASE_008_CoPtASE_stPwt_in /* 
   Description: Etat_GMP_SCAr
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 10 */;
AR_IF_GLOBAL_8BIT UInt8 ASE_008_CoReqCha_stEngRStrtInh_in /* 
   Description: Demande d'inhibition de redémarrage pour Easymove
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 3 */;
AR_IF_GLOBAL_8BIT UInt8 ASE_008_CoReqVeh_stEngRStrtReq_in /* 
   Description: Demande de redem/coupure moteur par sous-système Véhicule
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 4 */;
AR_IF_GLOBAL_8BIT UInt8 RE_ASE_008_TEV_CoASE_stEngASEReqClas_in /* 
   Description: Classe la plus élevée des demandes de Sortie calage présentes
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 5 */;

#define ASE_STOP_SEC_GLOBAL_8BIT
#include "ASE_MemMap.h"

#define ASE_START_SEC_GLOBAL_BOOLEAN
#include "ASE_MemMap.h"

/******************************************************************************\
   AR_IF_GLOBAL_BOOLEAN: Global boolean for AUTOSAR modules | Width: 8
\******************************************************************************/
AR_IF_GLOBAL_BOOLEAN Boolean ASE_008_CoPtUH_bDrvTraOp_in /* 
   Description: Pour APV, Etat CDT
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */;
AR_IF_GLOBAL_BOOLEAN Boolean ASE_008_CoPtUH_bRStrtMchAuth_in /* 
   Description: Autorisation boîte de vitesse pour le pilotage MEL en redémarrage
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */;
AR_IF_GLOBAL_BOOLEAN Boolean ASE_008_FRM_bAcvCutCoPtASE_in /* 
   Description: Demande de coupure si moteur calé
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */;
AR_IF_GLOBAL_BOOLEAN Boolean ASE_008_FRM_bAcvCutCoPtUH_in /* 
   Description: Demande de coupure si moteur en stop
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */;
AR_IF_GLOBAL_BOOLEAN Boolean CoPtASE_bEngCutOffReq_out /* 
   Description: Demande de coupure du moteur thermique par la fonction Sortie Calage (A1 : Dde_Coupu
   re_SCAr_MTh)
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */;
AR_IF_GLOBAL_BOOLEAN Boolean RE_ASE_008_TEV_CoStall_bEngStallAuth_in /* 
   Description: Autorisation d'entrer dans la fonction Sortie calage
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */;
AR_IF_GLOBAL_BOOLEAN Boolean RE_ASE_008_TEV_CoStall_bEngStallReq_in /* 
   Description: Demande d'entrée dans la fonction Sortie calage
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */;
AR_IF_GLOBAL_BOOLEAN Boolean RE_ASE_008_TEV_MgtStall_bMissRstrtTmp_in /* 
   Description: Temporisation de redémarrage manqué en SCAr
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */;
AR_IF_GLOBAL_BOOLEAN Boolean RE_ASE_008_TEV_MgtStall_bStallAuthNbASE_in /* 
   Description: Autorisation d'entrer en Sortie calage par nombre de tentatives de Sortie calage
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */;
AR_IF_GLOBAL_BOOLEAN Boolean RE_ASE_008_TEV_MgtStall_bStallAuthNbRstrt_in /* 
   Description: Autorisation d'entrer en Sortie calage par nombre de tentatives de redémarage en STT
    et en SCAr
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */;

#define ASE_STOP_SEC_GLOBAL_BOOLEAN
#include "ASE_MemMap.h"

#define ASE_START_SEC_GLOBAL_BOOLEAN
#include "ASE_MemMap.h"

/******************************************************************************\
   AR_IF_GLOBAL_BOOLEAN_IRV: Global boolean for AUTOSAR modules | Width: 8
\******************************************************************************/
Boolean MgtASECut_bRstrtMchInh /* 
   Description: Inhibition de la boite de vitesse pour le pilotage MEL en redémarrage
   LSB: 2^0 OFF:  0 MIN/MAX:  0 .. 1 */;

#define ASE_STOP_SEC_GLOBAL_BOOLEAN
#include "ASE_MemMap.h"

#define ASE_START_SEC_VAR_16BIT
#include "ASE_MemMap.h"

/******************************************************************************\
   UserSLStaticGlobalInit: SLStaticGlobalInit = { AR_SEC_VAR_BOOLEAN AR_SEC_UNSPECIFIED AR_SEC_VAR_8
   BIT AR_SEC_VAR_16BIT AR_SEC_VAR_32BIT AR_SEC_UNSPECIFIED } | Width: 16
\******************************************************************************/
static SInt16 X_S00816_UnitDelay1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
static SInt16 X_S00817_UnitDelay1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
static SInt16 X_S00830_UnitDelay1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
static SInt16 X_S00831_UnitDelay1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
static SInt16 X_S00842_UnitDelay1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
static SInt16 X_S00848_UnitDelay1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;

#define ASE_STOP_SEC_VAR_16BIT
#include "ASE_MemMap.h"

#define ASE_START_SEC_VAR_8BIT
#include "ASE_MemMap.h"

/******************************************************************************\
   UserSLStaticGlobalInit: SLStaticGlobalInit = { AR_SEC_VAR_BOOLEAN AR_SEC_UNSPECIFIED AR_SEC_VAR_8
   BIT AR_SEC_VAR_16BIT AR_SEC_VAR_32BIT AR_SEC_UNSPECIFIED } | Width: 8
\******************************************************************************/

#define ASE_STOP_SEC_VAR_8BIT
#include "ASE_MemMap.h"

#define ASE_START_SEC_VAR_BOOLEAN
#include "ASE_MemMap.h"

/******************************************************************************\
   UserSLStaticGlobalInit: SLStaticGlobalInit = { AR_SEC_VAR_BOOLEAN AR_SEC_UNSPECIFIED AR_SEC_VAR_8
   BIT AR_SEC_VAR_16BIT AR_SEC_VAR_32BIT AR_SEC_UNSPECIFIED } | Width: 8
\******************************************************************************/
static Boolean X_S00814_Unit_Delay;
static Boolean X_S00814_Unit_Delay1;
static Boolean X_S00815_Unit_Delay;
static Boolean X_S00815_Unit_Delay1;
static Boolean X_S00816_Unit_Delay;
static Boolean X_S00817_Unit_Delay;
static Boolean X_S00818_UnitDelay;
static Boolean X_S00819_UnitDelay;
static Boolean X_S00820_Unit_Delay;
static Boolean X_S00823_UnitDelay;
static Boolean X_S00824_UnitDelay;
static Boolean X_S00825_Unit_Delay;
static Boolean X_S00828_UnitDelay;
static Boolean X_S00829_UnitDelay;
static Boolean X_S00830_Unit_Delay;
static Boolean X_S00831_Unit_Delay;
static Boolean X_S00833_Unit_Delay;
static Boolean X_S00835_UnitDelay;
static Boolean X_S00836_UnitDelay;
static Boolean X_S00838_Unit_Delay;
static Boolean X_S00840_UnitDelay;
static Boolean X_S00841_UnitDelay;
static Boolean X_S00842_Unit_Delay;
static Boolean X_S00844_Unit_Delay;
static Boolean X_S00846_UnitDelay;
static Boolean X_S00847_UnitDelay;
static Boolean X_S00848_Unit_Delay;
static Boolean X_S00850_Unit_Delay;
static Boolean X_S00852_UnitDelay;
static Boolean X_S00853_UnitDelay;

#define ASE_STOP_SEC_VAR_BOOLEAN
#include "ASE_MemMap.h"

/*----------------------------------------------------------------------------*\
  PARAMETERIZED MACROS
\*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*\
  FUNCTION PROTOTYPES
\*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*\
  INLINE FUNCTIONS
\*----------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------*\
  FUNCTION DEFINITIONS
\*----------------------------------------------------------------------------*/

/**************************************************************************************************\
 ***  FUNCTION:
 ***      ASE_007_MSE_ini
 *** 
 ***  DESCRIPTION:
 ***      Main restart function
 ***      
 *** 
 ***  PARAMETERS:
 ***      Type               Name                Description
 ***      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ***
 ***  RETURNS:
 ***      Void
 ***
 ***  SETTINGS:
 ***
\**************************************************************************************************/

#define ASE_START_SEC_CODE
#include "ASE_MemMap.h"
Void ASE_007_MSE_ini(Void)
{
   ASE_008_FctVarInit();
}

#define ASE_STOP_SEC_CODE
#include "ASE_MemMap.h"

/**************************************************************************************************\
 ***  FUNCTION:
 ***      ASE_008_TEV_fct
 *** 
 ***  DESCRIPTION:
 ***      
 *** 
 ***  PARAMETERS:
 ***      Type               Name                Description
 ***      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ***
 ***  RETURNS:
 ***      Void
 ***
 ***  SETTINGS:
 ***
\**************************************************************************************************/

#define ASE_START_SEC_CODE
#include "ASE_MemMap.h"
Void ASE_008_TEV_fct(Void)
{
   /* SLLocal: Default storage class for local variables | Width: 16 */
   SInt16 S00816_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00816_Sum2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00817_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00817_Sum2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00822_Switch1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00827_Switch1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00830_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00830_Sum2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00831_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00831_Sum2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00834_Switch1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00839_Switch1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00842_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00842_Sum2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00845_Switch1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00848_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00848_Sum2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
   SInt16 S00851_Switch1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;

   /* SLLocal: Default storage class for local variables | Width: 8 */
   Boolean S00814_Switch;
   Boolean S00815_Switch;
   Boolean S00816_Relational_Operator1;
   Boolean S00816_Relational_Operator2;
   Boolean S00816_Switch2;
   Boolean S00817_Relational_Operator1;
   Boolean S00817_Relational_Operator2;
   Boolean S00817_Switch2;
   Boolean S00820_Logical_Operator5;
   Boolean S00825_Logical_Operator5;
   Boolean S00830_Relational_Operator1;
   Boolean S00830_Relational_Operator2;
   Boolean S00830_Switch2;
   Boolean S00831_Relational_Operator1;
   Boolean S00831_Relational_Operator2;
   Boolean S00831_Switch2;
   Boolean S00833_Logical_Operator5;
   Boolean S00838_Logical_Operator5;
   Boolean S0083_Logical_Operator2;
   Boolean S0083_Logical_Operator3;
   Boolean S0083_Relational_Operator3;
   Boolean S00842_Relational_Operator1;
   Boolean S00842_Relational_Operator2;
   Boolean S00842_Switch2;
   Boolean S00844_Logical_Operator5;
   Boolean S00848_Relational_Operator1;
   Boolean S00848_Relational_Operator2;
   Boolean S00848_Switch2;
   Boolean S0084_Relational_Operator1;
   Boolean S0084_Relational_Operator2;
   Boolean S00850_Logical_Operator5;
   Boolean S0086_Logical_Operator1;
   Boolean S0087_Logical_Operator12;
   Boolean S0087_Switch;

   /* SLLocal: Default storage class for local variables | Width: 16 */
   UInt16 Aux_U16;

   /* SLLocal: Default storage class for local variables | Width: 8 */
   UInt8 Aux_U8;

   S0083_Logical_Operator3 = (ASE_008_CoPtASE_stPwt_in == 4 /* 4. */) || (ASE_008_CoPtASE_stPwt_in
    == 2 /* 2. */);
   S0083_Relational_Operator3 = RE_ASE_008_TEV_CoASE_stEngASEReqClas_in == 1 /* 1. */;
   MgtASECut_bWaitTmp1Set_MP = S0083_Logical_Operator3 && S0083_Relational_Operator3;

   /* Switch: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/BasculeRS5/Switch
      ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/BasculeRS5/Switch: Omitted comparison with consta
      nt. */
   if (X_S00815_Unit_Delay1) {
      /* SLLocal: Default storage class for local variables | Width: 8 */
      Boolean S00819_Logical_Operator;

      S00819_Logical_Operator = MgtASECut_bWaitTmp1Set_MP && (!(X_S00819_UnitDelay));
      S00815_Switch = (S00819_Logical_Operator && S0083_Relational_Operator3) ||
       ((!(S00819_Logical_Operator)) && S0083_Relational_Operator3 && X_S00815_Unit_Delay);
   }
   else {
      S00815_Switch = 0 /* 0. */;
   }

   /* Multiport switch: ASE_008/F01_Traitement_booleen/Traitement_booleen/MgtASECut_bDrvTraOp_visu
    */
   switch (CoASE_stModDrvTraOp_C) {
      case 0: {
         MgtASECut_bDrvTraOp = ASE_008_CoPtUH_bDrvTraOp_in;
         break;
      }
      case 1: {
         MgtASECut_bDrvTraOp = !(ASE_008_CoPtUH_bDrvTraOp_in);
         break;
      }
      case 2: {
         MgtASECut_bDrvTraOp = 0 /* 0. */;
         break;
      }
      case 3: {
         MgtASECut_bDrvTraOp = 1 /* 1. */;
         break;
      }
   }
   S0086_Logical_Operator1 = (!(MgtASECut_bDrvTraOp)) && (RE_ASE_008_TEV_CoASE_stEngASEReqClas_in ==
     5 /* 5. */);
   Aux_U8 = MgtASECut_tiDlyCutReq2_C;

   /* MinMax: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/MinMax1 */
   if (Aux_U8) {
      S00848_MinMax1 = (SInt16) Aux_U8;
   }
   else {
      S00848_MinMax1 = 0 /* 0. */;
   }
   S00848_Relational_Operator1 = S00848_MinMax1 == 0 /* 0. */;

   /* Sum: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Sum2
      # combined # Product: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Divid
      e2
      
      ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Divide2: folded operation m
      ultiplication to constant value 0.1 */
   S00848_Sum2 = (SInt16) (UInt8) (((SInt8) S00848_MinMax1) + ((SInt8) 10 /* 0.1 */));

   /* Switch: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Turnondelay_Part/Sw
      itch1
      
      ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Turnondelay_Part/Switch1: O
      mitted comparison with constant. */
   if (X_S00848_Unit_Delay || (S0086_Logical_Operator1 && (!(X_S00852_UnitDelay)))) {
      S00851_Switch1 = 0 /* 0. */;
   }
   else {
      /* SLLocal: Default storage class for local variables | Width: 16 */
      SInt16 S00849_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
      SInt16 S00849_MinMax2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;

      /* MinMax: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/DetectSat/MinMax
         1 */
      if (X_S00848_UnitDelay1 > 0) {
         S00849_MinMax1 = X_S00848_UnitDelay1;
      }
      else {
         S00849_MinMax1 = 0 /* 0. */;
      }

      /* MinMax: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/DetectSat/MinMax
         2 */
      if (S00848_Sum2 < S00849_MinMax1) {
         S00849_MinMax2 = S00848_Sum2;
      }
      else {
         S00849_MinMax2 = S00849_MinMax1;
      }

      /* # combined # Sum: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Sum1
       */
      S00851_Switch1 = (SInt16) (((UInt16) S00849_MinMax2) + 1);
   }

   /* # combined # Sum: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Sum3
      # combined # Product: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Divid
      e1
      
      ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Divide1: folded operation d
      ivision to constant value 0.001 */
   S00848_Relational_Operator2 = (((SInt32) S00851_Switch1) * 10) >= ((SInt32) (SInt16) (((UInt16)
    (SInt16) (((SInt16) (S00848_MinMax1 * 10)) + 1 /* 0.001 */)) - 10));

   /* Switch: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Switch2
      ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Switch2: Omitted comparison
       with constant. */
   if (!(S00848_Relational_Operator1)) {
      S00848_Switch2 = S00848_Relational_Operator2 && (!(X_S00853_UnitDelay));
   }
   else {
      S00848_Switch2 = 1 /* 1. */;
   }
   S00850_Logical_Operator5 = (!(S0086_Logical_Operator1)) || ((!(S00848_Switch2)) &&
    X_S00850_Unit_Delay);
   MgtASECut_bEngCutReqOff_MP = RE_ASE_008_TEV_CoStall_bEngStallReq_in && (ASE_008_CoPtASE_stPwt_in
    == 1 /* 1. */) && (!(RE_ASE_008_TEV_CoStall_bEngStallAuth_in));
   Aux_U8 = MgtASECut_tiDlyCutReqIni_C;

   /* MinMax: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/MinMax1 */
   if (Aux_U8) {
      S00842_MinMax1 = (SInt16) Aux_U8;
   }
   else {
      S00842_MinMax1 = 0 /* 0. */;
   }
   S00842_Relational_Operator1 = S00842_MinMax1 == 0 /* 0. */;

   /* Sum: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Sum2
      # combined # Product: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Divide2
      ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Divide2: folded operation multiplication 
      to constant value 0.1 */
   S00842_Sum2 = (SInt16) (UInt8) (((SInt8) S00842_MinMax1) + ((SInt8) 10 /* 0.1 */));

   /* Switch: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Turnondelay_Part/Switch1
      ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Turnondelay_Part/Switch1: Omitted compari
      son with constant. */
   if (X_S00842_Unit_Delay || (MgtASECut_bEngCutReqOff_MP && (!(X_S00846_UnitDelay)))) {
      S00845_Switch1 = 0 /* 0. */;
   }
   else {
      /* SLLocal: Default storage class for local variables | Width: 16 */
      SInt16 S00843_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
      SInt16 S00843_MinMax2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;

      /* MinMax: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/DetectSat/MinMax1 */
      if (X_S00842_UnitDelay1 > 0) {
         S00843_MinMax1 = X_S00842_UnitDelay1;
      }
      else {
         S00843_MinMax1 = 0 /* 0. */;
      }

      /* MinMax: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/DetectSat/MinMax2 */
      if (S00842_Sum2 < S00843_MinMax1) {
         S00843_MinMax2 = S00842_Sum2;
      }
      else {
         S00843_MinMax2 = S00843_MinMax1;
      }

      /* # combined # Sum: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Sum1 */
      S00845_Switch1 = (SInt16) (((UInt16) S00843_MinMax2) + 1);
   }

   /* # combined # Sum: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Sum3
      # combined # Product: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Divide1
      ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Divide1: folded operation division to con
      stant value 0.001 */
   S00842_Relational_Operator2 = (((SInt32) S00845_Switch1) * 10) >= ((SInt32) (SInt16) (SInt8)
    (((SInt8) (SInt16) (UInt8) (((SInt8) (SInt16) (((UInt8) S00842_MinMax1) * 10)) + ((SInt8) 1 /* 0
   .001 */))) - 10));

   /* Switch: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Switch2
      ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Switch2: Omitted comparison with constant
      . */
   if (!(S00842_Relational_Operator1)) {
      S00842_Switch2 = S00842_Relational_Operator2 && (!(X_S00847_UnitDelay));
   }
   else {
      S00842_Switch2 = 1 /* 1. */;
   }
   S00844_Logical_Operator5 = (!(MgtASECut_bEngCutReqOff_MP)) || ((!(S00842_Switch2)) &&
    X_S00844_Unit_Delay);
   S0084_Relational_Operator2 = ASE_008_CoReqVeh_stEngRStrtReq_in == 4 /* 4. */;
   Aux_U8 = MgtASECut_tiDlyCutReq1_C;

   /* MinMax: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/MinMax1 */
   if (Aux_U8) {
      S00831_MinMax1 = (SInt16) Aux_U8;
   }
   else {
      S00831_MinMax1 = 0 /* 0. */;
   }
   S00831_Relational_Operator1 = S00831_MinMax1 == 0 /* 0. */;

   /* Sum: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Sum2
      # combined # Product: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Divide2
      ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Divide2: folded operation multiplicatio
      n to constant value 0.1 */
   S00831_Sum2 = (SInt16) (UInt8) (((SInt8) S00831_MinMax1) + ((SInt8) 10 /* 0.1 */));

   /* Switch: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Turnondelay_Part/Switch1
      ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Turnondelay_Part/Switch1: Omitted compa
      rison with constant. */
   if (X_S00831_Unit_Delay || (S0084_Relational_Operator2 && (!(X_S00840_UnitDelay)))) {
      S00839_Switch1 = 0 /* 0. */;
   }
   else {
      /* SLLocal: Default storage class for local variables | Width: 16 */
      SInt16 S00837_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
      SInt16 S00837_MinMax2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;

      /* MinMax: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/DetectSat/MinMax1 */
      if (X_S00831_UnitDelay1 > 0) {
         S00837_MinMax1 = X_S00831_UnitDelay1;
      }
      else {
         S00837_MinMax1 = 0 /* 0. */;
      }

      /* MinMax: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/DetectSat/MinMax2 */
      if (S00831_Sum2 < S00837_MinMax1) {
         S00837_MinMax2 = S00831_Sum2;
      }
      else {
         S00837_MinMax2 = S00837_MinMax1;
      }

      /* # combined # Sum: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Sum1 */
      S00839_Switch1 = (SInt16) (((UInt16) S00837_MinMax2) + 1);
   }

   /* # combined # Sum: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Sum3
      # combined # Product: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Divide1
      ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Divide1: folded operation division to c
      onstant value 0.001 */
   S00831_Relational_Operator2 = (((SInt32) S00839_Switch1) * 10) >= ((SInt32) (SInt16) (((UInt16)
    (SInt16) (((SInt16) (S00831_MinMax1 * 10)) + 1 /* 0.001 */)) - 10));

   /* Switch: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Switch2
      ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Switch2: Omitted comparison with consta
      nt. */
   if (!(S00831_Relational_Operator1)) {
      S00831_Switch2 = S00831_Relational_Operator2 && (!(X_S00841_UnitDelay));
   }
   else {
      S00831_Switch2 = 1 /* 1. */;
   }
   S00838_Logical_Operator5 = (!(S0084_Relational_Operator2)) || ((!(S00831_Switch2)) &&
    X_S00838_Unit_Delay);
   S0084_Relational_Operator1 = ASE_008_CoEmSTT_stEngRStrtReq_in == 4 /* 4. */;
   Aux_U8 = MgtASECut_tiDlyCutReq1_C;

   /* MinMax: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/MinMax1 */
   if (Aux_U8) {
      S00830_MinMax1 = (SInt16) Aux_U8;
   }
   else {
      S00830_MinMax1 = 0 /* 0. */;
   }
   S00830_Relational_Operator1 = S00830_MinMax1 == 0 /* 0. */;

   /* Sum: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Sum2
      # combined # Product: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Divide2
      ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Divide2: folded operation multiplicatio
      n to constant value 0.1 */
   S00830_Sum2 = (SInt16) (UInt8) (((SInt8) S00830_MinMax1) + ((SInt8) 10 /* 0.1 */));

   /* Switch: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Turnondelay_Part/Switch1
      ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Turnondelay_Part/Switch1: Omitted compa
      rison with constant. */
   if (X_S00830_Unit_Delay || (S0084_Relational_Operator1 && (!(X_S00835_UnitDelay)))) {
      S00834_Switch1 = 0 /* 0. */;
   }
   else {
      /* SLLocal: Default storage class for local variables | Width: 16 */
      SInt16 S00832_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
      SInt16 S00832_MinMax2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;

      /* MinMax: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/DetectSat/MinMax1 */
      if (X_S00830_UnitDelay1 > 0) {
         S00832_MinMax1 = X_S00830_UnitDelay1;
      }
      else {
         S00832_MinMax1 = 0 /* 0. */;
      }

      /* MinMax: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/DetectSat/MinMax2 */
      if (S00830_Sum2 < S00832_MinMax1) {
         S00832_MinMax2 = S00830_Sum2;
      }
      else {
         S00832_MinMax2 = S00832_MinMax1;
      }

      /* # combined # Sum: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Sum1 */
      S00834_Switch1 = (SInt16) (((UInt16) S00832_MinMax2) + 1);
   }

   /* # combined # Sum: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Sum3
      # combined # Product: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Divide1
      ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Divide1: folded operation division to c
      onstant value 0.001 */
   S00830_Relational_Operator2 = (((SInt32) S00834_Switch1) * 10) >= ((SInt32) (SInt16) (((UInt16)
    (SInt16) (((SInt16) (S00830_MinMax1 * 10)) + 1 /* 0.001 */)) - 10));

   /* Switch: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Switch2
      ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Switch2: Omitted comparison with consta
      nt. */
   if (!(S00830_Relational_Operator1)) {
      S00830_Switch2 = S00830_Relational_Operator2 && (!(X_S00836_UnitDelay));
   }
   else {
      S00830_Switch2 = 1 /* 1. */;
   }
   S00833_Logical_Operator5 = (!(S0084_Relational_Operator1)) || ((!(S00830_Switch2)) &&
    X_S00833_Unit_Delay);
   S0083_Logical_Operator2 = (RE_ASE_008_TEV_CoASE_stEngASEReqClas_in == 4 /* 4. */) ||
    (RE_ASE_008_TEV_CoASE_stEngASEReqClas_in == 3 /* 3. */) ||
    (RE_ASE_008_TEV_CoASE_stEngASEReqClas_in == 2 /* 2. */);
   MgtASECut_bWaitTmp2Set_MP = S0083_Logical_Operator2 && S0083_Logical_Operator3;

   /* Switch: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/BasculeRS1/Switch
      ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/BasculeRS1/Switch: Omitted comparison with consta
      nt. */
   if (X_S00814_Unit_Delay1) {
      /* SLLocal: Default storage class for local variables | Width: 8 */
      Boolean S00818_Logical_Operator;

      S00818_Logical_Operator = MgtASECut_bWaitTmp2Set_MP && (!(X_S00818_UnitDelay));
      S00814_Switch = (S00818_Logical_Operator && S0083_Logical_Operator2) ||
       ((!(S00818_Logical_Operator)) && S0083_Logical_Operator2 && X_S00814_Unit_Delay);
   }
   else {
      S00814_Switch = 0 /* 0. */;
   }

   /* ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/MgtASECut_bWaitTmp2_visu */
   MgtASECut_bWaitTmp2_MP = S00814_Switch;
   Aux_U16 = MgtASECut_tiDlyWait2_C;

   /* MinMax: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/MinMax1 */
   if (Aux_U16) {
      S00817_MinMax1 = (SInt16) Aux_U16;
   }
   else {
      S00817_MinMax1 = 0 /* 0. */;
   }
   S00817_Relational_Operator1 = S00817_MinMax1 == 0 /* 0. */;

   /* Sum: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Sum2
      # combined # Product: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Divide2
      ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Divide2: folded operation multiplica
      tion to constant value 0.1 */
   S00817_Sum2 = (SInt16) (S00817_MinMax1 + 10 /* 0.1 */);

   /* Switch: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Turnondelay_Part/Switch1
      ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Turnondelay_Part/Switch1: Omitted co
      mparison with constant. */
   if (X_S00817_Unit_Delay || (MgtASECut_bWaitTmp2_MP && (!(X_S00828_UnitDelay)))) {
      S00827_Switch1 = 0 /* 0. */;
   }
   else {
      /* SLLocal: Default storage class for local variables | Width: 16 */
      SInt16 S00826_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
      SInt16 S00826_MinMax2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;

      /* MinMax: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/DetectSat/MinMax1 */
      if (X_S00817_UnitDelay1 > 0) {
         S00826_MinMax1 = X_S00817_UnitDelay1;
      }
      else {
         S00826_MinMax1 = 0 /* 0. */;
      }

      /* MinMax: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/DetectSat/MinMax2 */
      if (S00817_Sum2 < S00826_MinMax1) {
         S00826_MinMax2 = S00817_Sum2;
      }
      else {
         S00826_MinMax2 = S00826_MinMax1;
      }

      /* # combined # Sum: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Sum1 */
      S00827_Switch1 = (SInt16) (((UInt16) S00826_MinMax2) + 1);
   }

   /* # combined # Sum: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Sum3
      # combined # Product: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Divide1
      ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Divide1: folded operation division t
      o constant value 0.001 */
   S00817_Relational_Operator2 = (((SInt32) S00827_Switch1) * 10) >= ((SInt32) (SInt16) (((UInt16)
    (SInt16) (((SInt16) (S00817_MinMax1 * 10)) + 1 /* 0.001 */)) - 10));

   /* Switch: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Switch2
      ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Switch2: Omitted comparison with con
      stant. */
   if (!(S00817_Relational_Operator1)) {
      S00817_Switch2 = S00817_Relational_Operator2 && (!(X_S00829_UnitDelay));
   }
   else {
      S00817_Switch2 = 1 /* 1. */;
   }
   S00825_Logical_Operator5 = (!(MgtASECut_bWaitTmp2_MP)) || ((!(S00817_Switch2)) &&
    X_S00825_Unit_Delay);

   /* ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/MgtASECut_bWaitTmp1_visu */
   MgtASECut_bWaitTmp1_MP = S00815_Switch;
   Aux_U16 = MgtASECut_tiDlyWait1_C;

   /* MinMax: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/MinMax1 */
   if (Aux_U16) {
      S00816_MinMax1 = (SInt16) Aux_U16;
   }
   else {
      S00816_MinMax1 = 0 /* 0. */;
   }
   S00816_Relational_Operator1 = S00816_MinMax1 == 0 /* 0. */;

   /* Sum: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Sum2
      # combined # Product: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Divide2
      ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Divide2: folded operation multiplicat
      ion to constant value 0.1 */
   S00816_Sum2 = (SInt16) (S00816_MinMax1 + 10 /* 0.1 */);

   /* Switch: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Turnondelay_Part/Switch1
      ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Turnondelay_Part/Switch1: Omitted com
      parison with constant. */
   if (X_S00816_Unit_Delay || (MgtASECut_bWaitTmp1_MP && (!(X_S00823_UnitDelay)))) {
      S00822_Switch1 = 0 /* 0. */;
   }
   else {
      /* SLLocal: Default storage class for local variables | Width: 16 */
      SInt16 S00821_MinMax1 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;
      SInt16 S00821_MinMax2 /* LSB: 0.01 OFF:  0 MIN/MAX:  -327.68 .. 327.67 */;

      /* MinMax: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/DetectSat/MinMax1 */
      if (X_S00816_UnitDelay1 > 0) {
         S00821_MinMax1 = X_S00816_UnitDelay1;
      }
      else {
         S00821_MinMax1 = 0 /* 0. */;
      }

      /* MinMax: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/DetectSat/MinMax2 */
      if (S00816_Sum2 < S00821_MinMax1) {
         S00821_MinMax2 = S00816_Sum2;
      }
      else {
         S00821_MinMax2 = S00821_MinMax1;
      }

      /* # combined # Sum: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Sum1 */
      S00822_Switch1 = (SInt16) (((UInt16) S00821_MinMax2) + 1);
   }

   /* # combined # Sum: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Sum3
      # combined # Product: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Divide1
      ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Divide1: folded operation division to
       constant value 0.001 */
   S00816_Relational_Operator2 = (((SInt32) S00822_Switch1) * 10) >= ((SInt32) (((UInt32) (((SInt32)
     (((SInt32) S00816_MinMax1) * 10)) + ((SInt32) 1 /* 0.001 */))) - 10));

   /* Switch: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Switch2
      ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Switch2: Omitted comparison with cons
      tant. */
   if (!(S00816_Relational_Operator1)) {
      S00816_Switch2 = S00816_Relational_Operator2 && (!(X_S00824_UnitDelay));
   }
   else {
      S00816_Switch2 = 1 /* 1. */;
   }
   S00820_Logical_Operator5 = (!(MgtASECut_bWaitTmp1_MP)) || ((!(S00816_Switch2)) &&
    X_S00820_Unit_Delay);

   /* Multiport switch: ASE_008/F01_Traitement_booleen/Traitement_booleen4/MgtASECut_bRstrtMchAuth_v
      isu */
   switch (MgtASECut_stModRstrtMchAuth_C) {
      case 0: {
         MgtASECut_bRstrtMchAuth = ASE_008_CoPtUH_bRStrtMchAuth_in;
         break;
      }
      case 1: {
         MgtASECut_bRstrtMchAuth = !(ASE_008_CoPtUH_bRStrtMchAuth_in);
         break;
      }
      case 2: {
         MgtASECut_bRstrtMchAuth = 0 /* 0. */;
         break;
      }
      case 3: {
         MgtASECut_bRstrtMchAuth = 1 /* 1. */;
         break;
      }
   }

   /* Switch: ASE_008/F06_Synthese_Dde_Coupure_en_Sortie_calage/MgtASECut_bEngASEHiReq_visu
      ASE_008/F06_Synthese_Dde_Coupure_en_Sortie_calage/MgtASECut_bEngASEHiReq_visu: Omitted compari
      son with constant. */
   if (RE_ASE_008_TEV_CoASE_stEngASEReqClas_in == 3) {
      MgtASECut_bEngASEHiReq_MP = RE_ASE_008_TEV_CoASE_spdVeh_in >= MgtASECut_spdRstrtAuth_C;
   }
   else {
      MgtASECut_bEngASEHiReq_MP = RE_ASE_008_TEV_CoASE_stEngASEReqClas_in == 4 /* 4. */;
   }
   S0087_Logical_Operator12 = MgtASECut_bRstrtMchAuth || MgtASECut_bEngASEHiReq_MP;

   /* TargetLink outport: ASE_008/RE_ASE_008_TEV_MgtASECut_bRstrtMchInh_irv_out */
   MgtASECut_bRstrtMchInh = !(S0087_Logical_Operator12);
   MgtASECut_bEngCutOffReqOff = !(S00844_Logical_Operator5);
   MgtASECut_bWaitTmp1 = !(S00820_Logical_Operator5);
   MgtASECut_bWaitTmp2 = !(S00825_Logical_Operator5);

   /* Multiport switch: ASE_008/F01_Traitement_booleen/Traitement_booleen1/MgtASECut_bAcvCutCoPtUH_v
      isu */
   switch (MgtASECut_stModAcvCutCoPtUH_C) {
      case 0: {
         MgtASECut_bAcvCutCoPtUH = ASE_008_FRM_bAcvCutCoPtUH_in;
         break;
      }
      case 1: {
         MgtASECut_bAcvCutCoPtUH = !(ASE_008_FRM_bAcvCutCoPtUH_in);
         break;
      }
      case 2: {
         MgtASECut_bAcvCutCoPtUH = 0 /* 0. */;
         break;
      }
      case 3: {
         MgtASECut_bAcvCutCoPtUH = 1 /* 1. */;
         break;
      }
   }

   /* Multiport switch: ASE_008/F01_Traitement_booleen/Traitement_booleen2/MgtASECut_bAcvCutCoPtASE_
      visu */
   switch (CoStall_stModAcvCutCoPtASE_C) {
      case 0: {
         MgtASECut_bAcvCutCoPtASE = ASE_008_FRM_bAcvCutCoPtASE_in;
         break;
      }
      case 1: {
         MgtASECut_bAcvCutCoPtASE = !(ASE_008_FRM_bAcvCutCoPtASE_in);
         break;
      }
      case 2: {
         MgtASECut_bAcvCutCoPtASE = 0 /* 0. */;
         break;
      }
      case 3: {
         MgtASECut_bAcvCutCoPtASE = 1 /* 1. */;
         break;
      }
   }
   MgtASECut_bEngCutOffReqSynt = (!(S00838_Logical_Operator5)) || (!(S00833_Logical_Operator5)) ||
    MgtASECut_bAcvCutCoPtUH || MgtASECut_bAcvCutCoPtASE || ((RE_ASE_008_TEV_CoASE_spdVeh_in >
    MgtASECut_spdEngCutOffReq_C) && MgtASECut_bAcvHiSpdEngCutReq_C);
   MgtASECut_bEngCutReqStall_MP = MgtASECut_bWaitTmp1 || MgtASECut_bWaitTmp2 ||
    (!(S00850_Logical_Operator5)) || MgtASECut_bEngCutOffReqSynt;
   MgtASECut_bEngCutOffReqStall = ((ASE_008_CoPtASE_stPwt_in == 4 /* 4. */) ||
    (ASE_008_CoPtASE_stPwt_in == 2 /* 2. */)) && MgtASECut_bEngCutReqStall_MP;
   MgtASECut_bEngCutReqASE31_MP = MgtASECut_bWaitTmp1 || MgtASECut_bWaitTmp2 ||
    (!(RE_ASE_008_TEV_CoStall_bEngStallAuth_in));

   /* Switch: ASE_008/F06_Synthese_Dde_Coupure_en_Sortie_calage/Switch
      ASE_008/F06_Synthese_Dde_Coupure_en_Sortie_calage/Switch: Omitted comparison with constant. */
   if (MgtASECut_bElMecIntrRstrt_C) {
      S0087_Switch = (!(RE_ASE_008_TEV_MgtStall_bStallAuthNbRstrt_in)) ||
       (!(RE_ASE_008_TEV_MgtStall_bStallAuthNbASE_in));
   }
   else {
      S0087_Switch = MgtASECut_bEngCutReqASE31_MP;
   }
   MgtASECut_bEngCutReqASE32_MP = (ASE_008_CoReqCha_stEngRStrtInh_in == 1 /* 1. */) ||
    RE_ASE_008_TEV_MgtStall_bMissRstrtTmp_in || (!(S0087_Logical_Operator12));
   MgtASECut_bEngCutReqASE3_MP = MgtASECut_bEngCutReqASE31_MP && MgtASECut_bEngCutReqASE32_MP;
   MgtASECut_bEngCutOffReqASE = (MgtASECut_bEngCutOffReqSynt ||
    ((ASE_008_CoEmCkg_stStrtRstrtFbCmd_in == 3 /* 3. */) && S0087_Switch) ||
    MgtASECut_bEngCutReqASE3_MP || ((!(S0087_Logical_Operator12)) &&
    (RE_ASE_008_TEV_CoASE_stEngASEReqClas_in == 5 /* 5. */))) && (ASE_008_CoPtASE_stPwt_in == 6 /* 6
   . */);
   MgtASECut_bEngCutOffReqCutIp = ASE_008_CoPtASE_stPwt_in == 8 /* 8. */;
   CoPtASE_bEngCutOffReq_out = MgtASECut_bEngCutOffReqOff || MgtASECut_bEngCutOffReqStall ||
    MgtASECut_bEngCutOffReqASE || MgtASECut_bEngCutOffReqCutIp;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/BasculeRS5/Unit Delay1 */
   X_S00815_Unit_Delay1 = 1 /* 1. */;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/rising_edge7/UnitDelay */
   X_S00819_UnitDelay = MgtASECut_bWaitTmp1Set_MP;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/BasculeRS5/Unit Delay */
   X_S00815_Unit_Delay = S00815_Switch;

   /* Unit delay: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/Unit Delay */
   X_S00848_Unit_Delay = S00848_Relational_Operator1;

   /* Unit delay: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/rising_edge/Uni
      tDelay */
   X_S00852_UnitDelay = S0086_Logical_Operator1;

   /* Unit delay: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/UnitDelay1 */
   X_S00848_UnitDelay1 = S00851_Switch1;

   /* Unit delay: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/rising_edge2/Un
      itDelay */
   X_S00853_UnitDelay = S00848_Relational_Operator2;

   /* Unit delay: ASE_008/F05_Synthese_Dde_coupure_en_Cale_et_Calage_ec/TurnOnDelay1/F05_Synthese_Dd
      e_coupure_en_Cale_et_Calage_ec/Unit Delay */
   X_S00850_Unit_Delay = S00850_Logical_Operator5;

   /* Unit delay: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/Unit Delay */
   X_S00842_Unit_Delay = S00842_Relational_Operator1;

   /* Unit delay: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/rising_edge/UnitDelay */
   X_S00846_UnitDelay = MgtASECut_bEngCutReqOff_MP;

   /* Unit delay: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/UnitDelay1 */
   X_S00842_UnitDelay1 = S00845_Switch1;

   /* Unit delay: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/rising_edge2/UnitDelay */
   X_S00847_UnitDelay = S00842_Relational_Operator2;

   /* Unit delay: ASE_008/F04_Synth_se_Dde_coupure_en_Off/TurnOnDelay2/F04_Synth_se_Dde_coupure_en_O
      ff/Unit Delay */
   X_S00844_Unit_Delay = S00844_Logical_Operator5;

   /* Unit delay: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/Unit Delay */
   X_S00831_Unit_Delay = S00831_Relational_Operator1;

   /* Unit delay: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/rising_edge/UnitDelay */
   X_S00840_UnitDelay = S0084_Relational_Operator2;

   /* Unit delay: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/UnitDelay1 */
   X_S00831_UnitDelay1 = S00839_Switch1;

   /* Unit delay: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/rising_edge2/UnitDelay */
   X_S00841_UnitDelay = S00831_Relational_Operator2;

   /* Unit delay: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay2/F03_Synthese_Dde_coupure_ho
      rsT1T2/Unit Delay */
   X_S00838_Unit_Delay = S00838_Logical_Operator5;

   /* Unit delay: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/Unit Delay */
   X_S00830_Unit_Delay = S00830_Relational_Operator1;

   /* Unit delay: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/rising_edge/UnitDelay */
   X_S00835_UnitDelay = S0084_Relational_Operator1;

   /* Unit delay: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/UnitDelay1 */
   X_S00830_UnitDelay1 = S00834_Switch1;

   /* Unit delay: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/rising_edge2/UnitDelay */
   X_S00836_UnitDelay = S00830_Relational_Operator2;

   /* Unit delay: ASE_008/F03_Synthese_Dde_coupure_horsT1T2/TurnOnDelay1/F03_Synthese_Dde_coupure_ho
      rsT1T2/Unit Delay */
   X_S00833_Unit_Delay = S00833_Logical_Operator5;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/BasculeRS1/Unit Delay1 */
   X_S00814_Unit_Delay1 = 1 /* 1. */;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/rising_edge1/UnitDelay */
   X_S00818_UnitDelay = MgtASECut_bWaitTmp2Set_MP;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/BasculeRS1/Unit Delay */
   X_S00814_Unit_Delay = S00814_Switch;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/Unit Delay */
   X_S00817_Unit_Delay = S00817_Relational_Operator1;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/rising_edge/UnitDelay */
   X_S00828_UnitDelay = MgtASECut_bWaitTmp2_MP;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/UnitDelay1 */
   X_S00817_UnitDelay1 = S00827_Switch1;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/rising_edge2/UnitDelay
    */
   X_S00829_UnitDelay = S00817_Relational_Operator2;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay1/BasculeRSspecifique/Unit
       Delay */
   X_S00825_Unit_Delay = S00825_Logical_Operator5;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/Unit Delay */
   X_S00816_Unit_Delay = S00816_Relational_Operator1;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/rising_edge/UnitDelay */
   X_S00823_UnitDelay = MgtASECut_bWaitTmp1_MP;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/UnitDelay1 */
   X_S00816_UnitDelay1 = S00822_Switch1;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/rising_edge2/UnitDelay */
   X_S00824_UnitDelay = S00816_Relational_Operator2;

   /* Unit delay: ASE_008/F02_Calcul_de_Tattente1_et_Tattente2/TurnOnDelay/BasculeRSspecifique/Unit 
      Delay */
   X_S00820_Unit_Delay = S00820_Logical_Operator5;
}

#define ASE_STOP_SEC_CODE
#include "ASE_MemMap.h"

/**************************************************************************************************\
 ***  FUNCTION:
 ***      ASE_008_FctVarInit
 *** 
 ***  DESCRIPTION:
 ***      AR_IF_GLOBAL_BOOLEAN_IRV
 *** 
 ***  PARAMETERS:
 ***      Type               Name                Description
 ***      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ***
 ***  RETURNS:
 ***      Void
 ***
 ***  SETTINGS:
 ***
\**************************************************************************************************/

#define ASE_START_SEC_CODE
#include "ASE_MemMap.h"
Void ASE_008_FctVarInit(Void)
{
   X_S00814_Unit_Delay = 0 /* 0. */;
   X_S00814_Unit_Delay1 = 0 /* 0. */;
   X_S00815_Unit_Delay = 0 /* 0. */;
   X_S00815_Unit_Delay1 = 0 /* 0. */;
   X_S00816_UnitDelay1 = 0 /* 0. */;
   X_S00816_Unit_Delay = 0 /* 0. */;
   X_S00817_UnitDelay1 = 0 /* 0. */;
   X_S00817_Unit_Delay = 0 /* 0. */;
   X_S00818_UnitDelay = 0 /* 0. */;
   X_S00819_UnitDelay = 0 /* 0. */;
   X_S00820_Unit_Delay = 0 /* 0. */;
   X_S00823_UnitDelay = 0 /* 0. */;
   X_S00824_UnitDelay = 0 /* 0. */;
   X_S00825_Unit_Delay = 0 /* 0. */;
   X_S00828_UnitDelay = 0 /* 0. */;
   X_S00829_UnitDelay = 0 /* 0. */;
   X_S00830_UnitDelay1 = 0 /* 0. */;
   X_S00830_Unit_Delay = 0 /* 0. */;
   X_S00831_UnitDelay1 = 0 /* 0. */;
   X_S00831_Unit_Delay = 0 /* 0. */;
   X_S00833_Unit_Delay = 0 /* 0. */;
   X_S00835_UnitDelay = 0 /* 0. */;
   X_S00836_UnitDelay = 0 /* 0. */;
   X_S00838_Unit_Delay = 0 /* 0. */;
   X_S00840_UnitDelay = 0 /* 0. */;
   X_S00841_UnitDelay = 0 /* 0. */;
   X_S00842_UnitDelay1 = 0 /* 0. */;
   X_S00842_Unit_Delay = 0 /* 0. */;
   X_S00844_Unit_Delay = 0 /* 0. */;
   X_S00846_UnitDelay = 0 /* 0. */;
   X_S00847_UnitDelay = 0 /* 0. */;
   X_S00848_UnitDelay1 = 0 /* 0. */;
   X_S00848_Unit_Delay = 0 /* 0. */;
   X_S00850_Unit_Delay = 0 /* 0. */;
   X_S00852_UnitDelay = 0 /* 0. */;
   X_S00853_UnitDelay = 0 /* 0. */;
}

#define ASE_STOP_SEC_CODE
#include "ASE_MemMap.h"

/*----------------------------------------------------------------------------*\
  MODULE LOCAL FUNCTION DEFINITIONS
\*----------------------------------------------------------------------------*/

#endif/*_ASE_008_TEV_FCT_C_ */
/*----------------------------------------------------------------------------*\
  END OF FILE
\*----------------------------------------------------------------------------*/
