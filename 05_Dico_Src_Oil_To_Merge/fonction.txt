Nom_fonction|Release_fonction|Prototype|Num_stc|Nom_module|Public|Reférence_spec_systéme|Reférence_spec_systéme_1|Reférence_spec_systéme_2|Reférence_spec_systéme_3|Fonction_à_supprimer|Validation|Export_part|Macro|function_description|MemSec
AC_EveRst_ACPresAcq|A|();|SCH.1|ACPRESACQ|1|PTS_DOC_6545428||||0|0|0|0|Fonction d'accroche à l'event AC_EveRst_ACPresAcq
AC_EveRst_ACPresAcqAdc|A|();|SCH3.2|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Evènement reset
AC_EveRst_ACPresAcqIf|B|();|SCH10.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reset|
AC_EveRst_AdHeatCmd|B|();|SCH.1|ADHEATCMD|1|PTS_DOC_6851368||||0|0|0|0|Reset event for additional heating command|
AC_EveRst_CmdDio|A|();|SCH.1|CMDDIO_DT|1|PTS_DOC_6913275||||0|0|0|0|Reset event for additional heating command|
AC_SdlFast_ACPresAcq|A|();|SCH.2|ACPRESACQ|1|PTS_DOC_6545428||||0|0|0|0|Fonction d'accroche à l'event AC_SdlFast_ACPresAcq
AC_SdlFast_ACPresAcqAdc|A|();|SCH3.1|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur rapide de la fonction climatisation
AC_SdlFast_ACPresAcqIf|B|();|SCH11.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide de la fonction climatisation|
AC_SdlMid_ACPresAcq|A|();|SCH.3|ACPRESACQ|1|PTS_DOC_6545428||||0|0|0|0|Fonction d'accroche à l'event AC_SdlMid_ACPresAcq
AC_SdlSlow_AdHeatCmd|B|();|SCH.2|ADHEATCMD|1|PTS_DOC_6851368||||0|0|0|0|Slow monitoring for additional heating command function|
AC_SdlSlow_AdHeatCmdDiag|A|();|SCH.2|ACQDGOHAL_DT|1|PTS_DOC_6854092||||0|0|0|0|Slow monitoring for additional heating command function|
AC_SdlSlow_CmdDio|A|();|SCH.2|CMDDIO_DT|1|PTS_DOC_6913275||||0|0|0|0|Slow monitoring for additional heating command function.|
AccP_EveKOf_AccPEM|A|();|SCH.2|ACCPEM|1|PTS_DOC_5021748||||0|0|0|0|Evénement clef On_Off
AccP_EveRst_AccPEM|A|();|SCH.1|ACCPEM|1|PTS_DOC_5021748||||0|0|0|0|Event reset.
AccP_EveRst_AccPMngModSec|A|();|SCH.1|ACCPMNGMODSECU|1|PTS_DOC_7317422||||0|0|0|0|ECU reset
AccP_EveRst_AcqPosn|F|();|SCH.1|ACCPACQPOS|1|PTS_DOC_6601121||||0|0|0|0|Fonction d'accroche à l'evenement AccP_EveRst_AcqPosn
AccP_EveRst_AcqPosnAdc|A|();|SCH3.8|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Evénement reset du calculateur
AccP_EveRst_Clc|A|();|SCH.1|ACCPCALCRPOS|1|PTS_DOC_7293537||||0|0|0|0|Evènement de reset
AccP_EveRst_FLrng|C|();|SCH.1|ACCPLRNPOS|1|V02 NT 08 03749||||0|0|0|0|Fonction d'accroche à l'événement AccP_EveRst_FLrng
AccP_EveRst_MonStuckAccP|B|();|SCH.1|ACCPSTUCKDIAG|1|V02 NT 09 01550||||0|0|0|0|Evènement reset de l'ECU
AccP_EveRst_SwtAcqDiag|A|();|SCH.1|ACCPSWTACQDIAG|1|PTS_DOC_6606841||||0|0|0|0|Evénement reset du calculateur
AccP_EveRstPed_FLrng|A|();|SCH.3|ACCPLRNPOS|1|V02 NT 08 03749||||0|0|0|0|Runnable Demande de reset apprentissage pédale accélérateur
AccP_SdlFast_AccPEM|A|();|SCH.3|ACCPEM|1|PTS_DOC_5021748||||0|0|0|0|Moniteur rapide de la fonction pédale d'accélérateur
AccP_SdlFast_AccPMngModSec|A|();|SCH.2|ACCPMNGMODSECU|1|PTS_DOC_7317422||||0|0|0|0|Fast scheduler
AccP_SdlFast_AcqPosn|G|();|SCH.2|ACCPACQPOS|1|PTS_DOC_6601121||||0|0|0|0|Fonction d'accroche à l'evenement AccP_SdlFast_AcqPosn
AccP_SdlFast_AcqPosnAdc|A|();|SCH3.9|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur rapide de la fonction pédale d'accélérateur
AccP_SdlFast_Clc|C|();|SCH.2|ACCPCALCRPOS|1|PTS_DOC_7293537||||0|0|0|0|Fonction d'accroche à l'evenement AccP_SdlFast_Clc
AccP_SdlFast_Ftm|A|();|SCH.2|ACCPFRM|1|V02 NT 08 03781||||0|0|0|0|Fonction moniteur activé suite à l'évènement AccP_SdlFast_Ftm
AccP_SdlFast_MonStuckAccP|B|();|SCH.2|ACCPSTUCKDIAG|1|V02 NT 09 01550||||0|0|0|0|Moniteur rapide
AccP_SdlFast_StIf|C|();|SCH1.2|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Moniteur de module d'interface.|
AccP_SdlFast_SwtAcqDiag|D|();|SCH.2|ACCPSWTACQDIAG|1|PTS_DOC_6606841||||0|0|0|0|Moniteur rapide pour la fonction pédale
AccP_SdlFast_SwtAcqDiagAdc|A|();|SCH3.10|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur rapide pour la fonction pédale
AccP_SdlSlow_FLrng|A|();|SCH.2|ACCPLRNPOS|1|V02 NT 08 03749||||0|0|0|0|Fonction d'accroche à l'événement AccP_SdlSlow_FLrng
ACCPACQPOS_vidDiagElecPiste1|A|();|FCT1.4|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|Production des variables bMponRun des diag elec qui sont conditionnés exclusivement par le FRM FRM_bInhAccPElDiag et des bDgo qui sont levés en cas de valeur hors plage de l’acquisition pédale.
ACCPACQPOS_vidDiagElecPiste2|A|();|FCT1.6|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|Production des variables bMponRun des diag elec qui sont conditionnés exclusivement par le FRM FRM_bInhAccPElDiag et des bDgo qui sont levés en cas de valeur hors plage de l’acquisition pédale.
ACCPACQPOS_vidDiagnosticCoh|G|();|FCT2.2|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|Fonction permettant de vérifier la cohérence électrique des deux signaux, en les comparant. La comparaison est effectuée avec la valeur absolue filtrée de la différence entre les deux mesures.
ACCPACQPOS_vidDoubleFaultAccP|B|();|FCT1.8|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|Le comptage des pannes découle si le booléen d’inhibition est positionné à 0.
ACCPACQPOS_vidElectCoherence|F|();|FCT2.1|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|En cas de défaut sur la batterie, la détection de défaut est inhibée ; dans le cas d'un  défaut sur les alimentations capteurs, la détection de défaut est inhibée sur le groupe de capteurs alimenté par l'alimentation en défaut.
ACCPACQPOS_vidInit|A|();|FCT1.1|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|Lors d’un Reset soft, AccP_rAccPSens1 et AccP_rAccPSens2 sont sauvegardées en RAM non volatile. Lors de l’initialisation du calculateur, ces 2 variables sont  initialisées à 0.
ACCPACQPOS_vidInitOutput|G|();|FCT2.3|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|Fonction d'initialisation
ACCPACQPOS_vidLinearFilterPiste1|A|();|FCT1.9|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|La tension pédale est linéarisée en un ratio (via la carto AccP1_LinPos_Map) puis filtrée par un par un filtre du premier ordre
ACCPACQPOS_vidLinearFilterPiste2|A|();|FCT1.10|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|La tension pédale est linéarisée en un ratio (via la carto AccP2_LinPos_Map) puis filtrée par un par un filtre du premier ordre
ACCPACQPOS_vidPanne1Measurement|F|();|FCT1.5|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|Le capteur 1 est déclaré en CC à la tension Batterie si la tension à la sortie du convertisseur A/N est supérieure à un seuil ; en circuit ouvert ou en CC à la masse si cette mesure est inférieure à un second seuil. Le comptage des pannes en découle.
ACCPACQPOS_vidPanne2Measurement|F|();|FCT1.7|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|Le test est effectué si le booléen d’inhibition est positionné à 0. Le capteur 2 est déclaré en CC à la tension batterie si la tension à la sortie du conv A/N est sup à un seuil;en circuit ouvert ou en CC à la masse si la tension est inf à un second seuil
ACCPACQPOS_vidPosPedalAcquisition|G|();|FCT1.3|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|Fonction permettant l'acquisition des positions pédale qui se fait en plusieurs étapes à savoir la linéarisation et le filtrage des tensions d’acquisitions des 2 capteurs et le diagnostic électrique sur ces tensions.
ACCPACQPOS_vidRstSw|A|();|FCT1.2|ACCPACQPOS|0|PTS_DOC_6601121||||0|0|0|0|Initialisation des variables AccP_rAccPSens1 et AccP_rAccPSens2
ACCPCALCRPOS_vidAcquisitionDVApp|B|();|FCT1.3|ACCPCALCRPOS|0|PTS_DOC_7293537||||0|0|0|0|Acquisition de la position pedale
ACCPCALCRPOS_vidApsPedPos|B|();|FCT1.4|ACCPCALCRPOS|0|PTS_DOC_7293537||||0|0|0|0|Calcul de la position pédale finale bornee par la position pédale RVV et la position pédale LVV
ACCPCALCRPOS_vidDetection_aps|A|();|FCT1.6|ACCPCALCRPOS|0|PTS_DOC_7293537||||0|0|0|0|L’information position pédale relative permet de détecter le pied levé et le pied à fond pédale, cette détection est  basée dans les deux cas sur un seuil avec hystérésis.
ACCPCALCRPOS_vidDVApp|B|();|FCT1.2|ACCPCALCRPOS|0|PTS_DOC_7293537||||0|0|0|0|Cette fonction calcule la position pedale relative a partir des  positions pied à fond et pied leve
ACCPCALCRPOS_vidEtat_pos_aps|A|();|FCT1.5|ACCPCALCRPOS|0|PTS_DOC_7293537||||0|0|0|0|Ce bloc décrit l’état de la pédale accélérateur à partir de l’information volonté conducteur.
ACCPCALCRPOS_vidFinal_Detection|A|();|FCT1.8|ACCPCALCRPOS|0|PTS_DOC_7293537||||0|0|0|0|L’information position pédale relative permet de détecter le pied levé, cette détection est  basée dans les deux cas sur un seuil avec hystérésis.
ACCPCALCRPOS_vidFinal_state_Pos|A|();|FCT1.7|ACCPCALCRPOS|0|PTS_DOC_7293537||||0|0|0|0|Prise en compte de l’issue VEMS V02 ECU#056991 : Ajout de la variable Dv_detection_pied_leve_final qui prend en compte le régulateur de vitesse.
ACCPCALCRPOS_vidInit|A|();|FCT1.1|ACCPCALCRPOS|0|PTS_DOC_7293537||||0|0|0|0|Cette fonction initialise les variables produites par le module ACCPCALCRPOS
ACCPEM_vidAccPCohAuth|A|();|FCT1.6|ACCPEM|0|PTS_DOC_5021748||||0|0|0|0|Le test de cohérence est autorisé lorsqu’on est au Key ON. Il est inhibé lorsque le défaut pédale bloquée passe en état fugitif pendant un temps calibrable.
ACCPEM_vidAccPCohDiag|B|();|FCT1.7|ACCPEM|0|PTS_DOC_5021748||||0|0|0|0|Si la position pédale pour Easy Move est supérieure à la position pédale AccP_rAccP et si le paramètre P334 n’est pas à la valeur invalide, on lève un diagnostic de cohérence.
ACCPEM_vidAccPReinfPos|A|();|FCT2.1|ACCPEM|0|PTS_DOC_5021748||||0|0|0|0|Cete fonction permet de calculer une position pédale robuste à partir du minimum des 3 dernières valeurs des positions pédales brutes recalées des capteurs 1 et 2.
ACCPEM_vidAccPSatPos|A|();|FCT2.2|ACCPEM|0|PTS_DOC_5021748||||0|0|0|0|Cette fonction  permet d’effectuer un bouclage de la position pédale robuste à sa dernière valeur lorsqu’un défaut électrique sur les capteurs de position pédale est en état ponctuel présent et de saturer cette position pédale à 99.5
ACCPEM_vidDiagCoh|A|();|FCT1.3|ACCPEM|0|PTS_DOC_5021748||||0|0|0|0|test de cohérence des enfoncements pédale entre la variable position pédale et la position pédale pour Easy Move.
ACCPEM_vidInit|A|();|FCT1.8|ACCPEM|0|PTS_DOC_5021748||||0|0|0|0|Cette fonction permet d'initialiser l'indicateur de l'invalidité et la sortie AccPEM_rAccP.
ACCPEM_vidInitOutput|B|();|FCT1.1|ACCPEM|0|PTS_DOC_5021748||||0|0|0|0|Initialisation des sorties
ACCPEM_vidPosPedFinale|A|();|FCT1.2|ACCPEM|0|PTS_DOC_5021748||||0|0|0|0|En cas de défaut pédale bloquée confirmé l’enfoncement pédale est forcé à 0.
ACCPEM_vidPosPedKOff|A|();|FCT1.5|ACCPEM|0|PTS_DOC_5021748||||0|0|0|0|Au Key-Off, si le paramètre P334 n’est pas à sa valeur invalide alors on force sa valeur à 0.
ACCPEM_vidPosPedRst|A|();|FCT1.9|ACCPEM|0|PTS_DOC_5021748||||0|0|0|0|Cette fonction permet d'ecrire en mémoire sur évènement.
ACCPEM_vidPosPedValid|A|();|FCT1.4|ACCPEM|0|PTS_DOC_5021748||||0|0|0|0|Forcer la variable AccPEM_rAccP à sa valeur invalide avant de la transmettre sur le CAN en cas de défaut électrique , ou en cas de  défaut de cohérence entre les enfoncements pédale,
ACCPFRM_vidEntryInit|B|();|SCH.1|ACCPFRM|1|V02 NT 08 03781||||0|0|0|0|Fonction moniteur Reset
ACCPFRM_vidInitOutput|D|();|FCT1.1|ACCPFRM|0|V02 NT 08 03781||||0|0|0|0|Fonction d'initialisation des variables de sortie
ACCPFRM_vidMuxFormatPosPed|F|();|FCT1.3|ACCPFRM|0|V02 NT 08 03781||||0|0|0|0|La fonction qui définie la stratégie de détection de pied levé basée sur la valeur des signaux renvoyés par les 2 pistes du capteur pédale.
ACCPFRM_vidMuxFormatting|A|();|FCT1.2|ACCPFRM|0|V02 NT 08 03781||||0|0|0|0|Fonction qui gère le formatage de la volonté conducteur à envoyer sur le CAN
ACCPLRNPOS_NVMSRV_vidInit|A|();|FCT1.6|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|A la première mise sous tension, les valeurs butées haute et basse sont initialisée à des valeurs calibrable
ACCPLRNPOS_vidCalculation|A|();|FCT1.5|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|Les calculs sont inhibés sur des pannes mémorisées concernant les deux capteurs de la pédale d’accélérateur.
ACCPLRNPOS_vidDvLrnFootFullDown1|B|();|FCT2.1|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|Calcul des apprentissages de la position pied à fond de la pédale d’accélérateur sur le signal 1
ACCPLRNPOS_vidDvLrnFootFullDown2|B|();|FCT2.2|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|Calcul des apprentissages de la position pied à fond de la pédale d’accélérateur sur le signal 2
ACCPLRNPOS_vidDvLrnFootUp1|B|();|FCT3.1|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|Calcul des apprentissages de la position pied levé de la pédale d’accélérateur sur le signal 1
ACCPLRNPOS_vidDvLrnFootUp1D|B|();|FCT3.3|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|l'apprentissage butée basse se faire par incrémentation par pas de l'ancienne valeur butée basse apprise, la butée basse prend alors la valeur minimum entre le résultat d'incrémentation et la valeur du rapport de tension.
ACCPLRNPOS_vidDvLrnFootUp1M|B|();|FCT3.4|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|l'apprentissage de la butée basse peut se faire par decrémentation par pas ou instantanément. Le choix se fait par calibration .
ACCPLRNPOS_vidDvLrnFootUp2|B|();|FCT3.2|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|Calcul des apprentissages de la position pied levé de la pédale d’accélérateur sur le signal 2
ACCPLRNPOS_vidDvLrnFootUp2D|B|();|FCT3.5|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|l'apprentissage de la butée basse peut se faire par decrémentation par pas ou instantanément. Le choix se fait par calibration .la butée basse prend alors la valeur maximum entre le résultat de décrémentation et la valeur du rapport de tension.
ACCPLRNPOS_vidDvLrnFootUp2M|B|();|FCT3.6|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|l'apprentissage butée basse peut se faire par incrémentation par pas de l'ancienne valeur butée basse apprise, la butée basse prend alors la valeur minimum entre le résultat de d'incrémentation et la valeur du rapport de tension.
ACCPLRNPOS_vidDvLrnFtFlDown1D|B|();|FCT2.3|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|l'apprentissage butée haute peut se faire par décrémentation par pas de la dernière valeur butée haute apprise, la butée haute prend alors la valeur du minimum entre le résultat de décrémentation et la valeur du rapport de tension.
ACCPLRNPOS_vidDvLrnFtFlDown1M|B|();|FCT2.4|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|l'apprentissage butée haute est faite par incrémentation par pas de la dernière valeur butée haute apprise. le choix se fait par calibration. la butée haute prend la valeur du minimum entre le résultat d'incrémentation et la valeur du rapport de tension.
ACCPLRNPOS_vidDvLrnFtFlDown2D|B|();|FCT2.5|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|l'apprentissage butée haute peut se faire par décrémentation par pas de la dernière valeur butée haute apprise, la butée haute prend alors la valeur du minimum entre le résultat de décrémentation et la valeur du rapport de tension.
ACCPLRNPOS_vidDvLrnFtFlDown2M|B|();|FCT2.6|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|l'apprentissage butée haute est faite par incrémentation par pas de la dernière valeur butée haute apprise. Le choix se fait par calibration. La butée haute prend la valeur du minimum entre le résultat d'incrémentation et la valeur du rapport de tension.
ACCPLRNPOS_vidFreeLearningMgt|B|();|FCT1.2|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|Calcul des apprentissages des positions pied levé et pied à fond de la pédale d’accélérateur sur deux signaux des capteurs haut et bas de cette dernière
ACCPLRNPOS_vidInitDiagsrv|A|();|FCT3.7|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|Fonction de reset de l'apprentissage pédale accélérateur
ACCPLRNPOS_vidInitOutput|B|();|FCT1.1|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|A la première mise sous tension, les valeurs butées haute et basse sont initialisée à des valeurs calibrables (respectivement Rpli et Rpfi)
ACCPLRNPOS_vidLrnMgtDetectorHigh|B|();|FCT1.3|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|Calcul des apprentissages des positions pied levé et pied à fond de la pédale d’accélérateur sur le signal du capteur haut de cette dernière
ACCPLRNPOS_vidLrnMgtDetectorLow|B|();|FCT1.4|ACCPLRNPOS|0|V02 NT 08 03749||||0|0|0|0|Calcul des apprentissages des positions pied levé et pied à fond de la pédale d’accélérateur sur le signal du capteur has de cette dernière
ACCPMNGMODSECU_vidComputeAccPMng|A|();|FCT1.3|ACCPMNGMODSECU|0|PTS_DOC_7317422||||0|0|0|0|This function determines the calculation of the position of the accelerator pedal with the request of the driver.
ACCPMNGMODSECU_vidInit|A|();|FCT1.1|ACCPMNGMODSECU|0|PTS_DOC_7317422||||0|0|0|0|All the secured pedal positions are set to 0 at the ECU reset.The secured pedal state is considered as nominal mode.
ACCPMNGMODSECU_vidInitOutput|A|();|FCT1.2|ACCPMNGMODSECU|0|PTS_DOC_7317422||||0|0|0|0|Initialisation des variables de sorties.
ACCPMNGMODSECU_vidMngPosSecu|A|();|FCT1.5|ACCPMNGMODSECU|0|PTS_DOC_7317422||||0|0|0|0|For the secured gas pedal position, there are 8 modes. The transitions between all these modes depend on the failures on the gas pedal (coherency failure, stuck failure, electrical failures).
ACCPMNGMODSECU_vidPedalPosfilter|A|();|FCT1.6|ACCPMNGMODSECU|0|PTS_DOC_7317422||||0|0|0|0|In order to ensure the continuity of the gas pedal position, a slew rate is applied.  AccP_rGrdAccP represents the gradient of the pedal position.
ACCPMNGMODSECU_vidPedalPosInCalc|A|();|FCT1.4|ACCPMNGMODSECU|0|PTS_DOC_7317422||||0|0|0|0|Some intermediary variables are calculated: AccP_bPsenPctlEl, AccP_bPsenNoDftEl, AccP_bPsenOneDftEl ,AccP_bPsenNoBoothDftEl, AccP_bCohPctl, AccP_bCohPSenPctl.
ACCPMNGMODSECU_vidStateTransit|A|();|FCT1.8|ACCPMNGMODSECU|0|PTS_DOC_7317422||||0|0|0|0|Inclut le traitement relatif au transitions entre ces modes
ACCPMNGMODSECU_vidStuckPedalPos|A|();|FCT1.7|ACCPMNGMODSECU|0|PTS_DOC_7317422||||0|0|0|0|Depending  on  the  failures  on  the  gas  pedal  the  pedal  position  used  for  the  stuck  pedal  diagnosis (AccP_rAccPFctMon) can take several values.
ACCPSTUCKDIAG_vidInitOutput|B|();|FCT1.1|ACCPSTUCKDIAG|0|V02 NT 09 01550||||0|0|0|0|Initialisation des variables produites dans ce module
ACCPSTUCKDIAG_vidMngMonRun|E|();|FCT1.4|ACCPSTUCKDIAG|0|V02 NT 09 01550||||0|0|0|0|Cette fonction gère les phases d’activation du diagnostic.
ACCPSTUCKDIAG_vidStuckAccPMonRun|B|();|FCT1.3|ACCPSTUCKDIAG|0|V02 NT 09 01550||||0|0|0|0|Cette fonction gère les phases d’activation du diagnostic.
ACCPSTUCKDIAG_vidStuckAccPPdlin|B|();|FCT1.2|ACCPSTUCKDIAG|0|V02 NT 09 01550||||0|0|0|0|Cette fonction donne l’état «frein appuyé ».
ACCPSWTACQDIAG_vidAccPedSwtAff|E|();|FCT3.1|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Affectation de Passage_point_dur, recopie de Etat_point_dur en absence de panne sur capteur point dur
ACCPSWTACQDIAG_vidEndPointAffKD|B|();|FCT1.10|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Ce bloc décrit le cas où il y'a un défaut électrique du capteur point dur , ou un défaut de cohérence entre pédale d’accélération et information point dur est confirmé.
ACCPSWTACQDIAG_vidEndPointCohAff|F|();|FCT1.9|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Contrôle de  la cohérence entre l’état point dur et l’enfoncement de la pédale et affectation de l’indicateur  de  passage  point  dur
ACCPSWTACQDIAG_vidEndPointPedCoh|E|();|FCT2.9|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Contrôle  la  cohérence  entre  la  position  pédale  et  l’état  point  dur.
ACCPSWTACQDIAG_vidEndPtCounter|A|();|FCT3.3|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Incréméntation de Tempo_maintien_etat_pt_dur.
ACCPSWTACQDIAG_vidEndPtInstTempo|A|();|FCT3.2|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|incrémntation instantanée du Tempo_maintien_etat_pt_dur.
ACCPSWTACQDIAG_vidHightFailTrans|B|();|FCT2.6|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Les transitions de l'état DEFAUT_HAUT
ACCPSWTACQDIAG_vidHightStabTrans|B|();|FCT2.1|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Les transitions de l'état LVV_STABLE_HAUT
ACCPSWTACQDIAG_vidInitOutput|D|();|FCT1.1|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Initialisation des variables produites par le module
ACCPSWTACQDIAG_vidInitPointDur|B|();|FCT1.2|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Initialisation du point dur
ACCPSWTACQDIAG_vidInvFailTrans|B|();|FCT2.7|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Les transitions de l'état DEFAUT_INVALIDE
ACCPSWTACQDIAG_vidLowFailTrans|B|();|FCT2.8|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Les transitions de l'état DEFAUT_BAS
ACCPSWTACQDIAG_vidLowStableTrans|B|();|FCT2.5|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Les transitions de l'état LVV_STABLE_BAS
ACCPSWTACQDIAG_vidLvvSwtAcq|C|();|FCT1.4|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Acquisition du signal point dur au cours du temps
ACCPSWTACQDIAG_vidLvvSwtAcqCond|C|();|FCT1.3|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Condition d'acquisition et de diagnostic du point dur
ACCPSWTACQDIAG_vidLvvSwtDiag|C|();|FCT1.6|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Les pannes à monter ou à descendre en fonction de la tension du contacteur LVV sonde
ACCPSWTACQDIAG_vidLvvSwtDiagCond|C|();|FCT1.5|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Condition de diagnostique de l'état de la tension du contacteur LVV
ACCPSWTACQDIAG_vidMonitoringMng|C|();|FCT1.8|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Traitement du signal du capteur du contacteur electrique pour juger l’information et sa stabilité
ACCPSWTACQDIAG_vidMonitorMngCond|C|();|FCT1.7|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Le traitement du signal capteur du contacteur electrique LVV est fait après une demande d’acquisition analogique sur la voie LVV_PT_DUR
ACCPSWTACQDIAG_vidPtDurSensDetec|A|();|FCT3.4|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|En présence d’un capteur point dur, le point dur sera calculé à partir de AccP_rAccp : Si AccP_rAccp> seuil, alors point dur atteint.
ACCPSWTACQDIAG_vidTempoHightTrans|B|();|FCT2.2|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Les transitions de l'état LVV_TRANSITOIRE_HAUT
ACCPSWTACQDIAG_vidTempoInvTrans|B|();|FCT2.3|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Les transition de l'état LVV_TRANSITOIRE_INVALIDE
ACCPSWTACQDIAG_vidTempoLowTrans|B|();|FCT2.4|ACCPSWTACQDIAG|0|PTS_DOC_6606841||||0|0|0|0|Les transitions de l'état LVV_TRANSITOIRE_BAS
ACPRESACQ_vidDiagnosisConversion|B|();|FCT1.4|ACPRESACQ|0|PTS_DOC_6545428||||0|0|0|0|Le signal de ratiométrie de tension (-) est converti via un gain (Pa/-) et un offset (Pa) en  signal de pression (Pa)  La dynamique de la pression de fluide réfrigérant est [0..4194240] Pa et de résolution 64  Pa.
ACPRESACQ_vidElectricDiagnosis|A|();|FCT1.5|ACPRESACQ|0|PTS_DOC_6545428||||0|0|0|0|Ce sous-système compare la tension issue du capteur aux valeurs minimales et  maximales de fonctionnement du capteur dans la zone correcte.
ACPRESACQ_vidFiltering|C|();|FCT1.6|ACPRESACQ|0|PTS_DOC_6545428||||0|0|0|0|On réalise un filtrage passe-bas de la tension capteur. A cet effet, on utilise la méthode  des rectangles supérieurs qui donne le signal filtré en fonction du signal non filtré à  l'instant courant et du signal filtré à l'instant précédent.
ACPRESACQ_vidFunctionalDetection|B|();|FCT1.8|ACPRESACQ|0|PTS_DOC_6545428||||0|0|0|0|Ce système génère la panne fonctionnelle.
ACPRESACQ_vidInit|A|();|FCT1.2|ACPRESACQ|0|PTS_DOC_6545428||||0|0|0|0|L'acquisition de la pression de fluide réfrigérant doit être effectué dès le réveil principal  du calculateur .
ACPRESACQ_vidInitOutput|A|();|FCT1.1|ACPRESACQ|0|PTS_DOC_6545428||||0|0|0|0|Fonction qui initialise les sorties.
ACPRESACQ_vidMgtDefaultTracking|A|();|FCT1.9|ACPRESACQ|0|PTS_DOC_6545428||||0|0|0|0|Le coefficient AC_SampleTiMid_SC permet de prendre en compte la période d'activation de la fonction tout en conservant Ac_cooling_max_tracker_value en kPa/s (et non pas en kPa/ AC_SampleTiMid_SC s).
ACPRESACQ_VidPressRefriDiagFunc|B|();|FCT1.7|ACPRESACQ|0|PTS_DOC_6545428||||0|0|0|0|Outre le test électrique, un test fonctionnel sur le gradient est effectué. Si le gradient dépasse la calibration  Ac_cooling_max_tracker_value, la panne  Ext_bDgoGrd_pACMes est générée.
ACPRESACQ_vidPressure_refri|B|();|FCT1.3|ACPRESACQ|0|PTS_DOC_6545428||||0|0|0|0|En cas de défaut sur la batterie, la détection de défaut est inhibée ; dans le cas d'un  défaut sur les alimentations capteurs, la détection de défaut est inhibée sur le groupe de capteurs alimenté par l'alimentation en défaut
ACQADC_DT_vidInit|A|();|FCT1.1|ACQADC_DT|0|PTS_DOC_6913284||||0|0|0|0|The outputs are initialized to zero at event reset.|
ACQADC_DT_vidOilPresAcq|A|();|FCT1.4|ACQADC_DT|0|PTS_DOC_6913284||||0|0|0|0|The raw voltage is acquired by the oil proportional pressure sensor according to the standard supply voltage of the sensor before being sent to the application software|
ACQADC_DT_vidPFuAcq_Inj|A|();|FCT1.6|ACQADC_DT|0|PTS_DOC_6913284||||0|0|0|0|The raw voltage is acquired by the rail pressure sensor if the engine is not running or at INJ event when the engine is running.|
ACQADC_DT_vidPFuAcq_Spill|A|();|FCT1.5|ACQADC_DT|0|PTS_DOC_6913284||||0|0|0|0|The raw voltage is acquired by the rail pressure sensor if the engine is not synchronized or at “spill event” when the engine is synchronized.|
ACQADC_DT_vidSpgPresAcq|A|();|FCT1.2|ACQADC_DT|0|PTS_DOC_6913284||||0|0|0|0|The raw voltage is acquired by the boost pressure sensor according to the standard supply voltage of the sensor before being sent to the application software.|
ACQADC_DT_vidTECUAcq|A|();|FCT1.7|ACQADC_DT|0|PTS_DOC_6913284||||0|0|0|0|The raw voltage is acquired by the power supply sensor according to the standard supply voltage of the sensor before being sent to the application software.|
ACQADC_DT_vidTIGBTAcq|A|();|FCT1.3|ACQADC_DT|0|PTS_DOC_6913284||||0|0|0|0|The raw voltage is acquired by the IGBT temperature sensor according to the standard supply voltage of the sensor before being sent to the application software.|
AcqAdc_EveRst_AcqAdc|A|();|SCH.1|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|Rest event|
ACQADC_vidAcqAdcAccP1|A|();|FCT2.6|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de la position pédale d'accélérateur
ACQADC_vidAcqAdcAccP2|A|();|FCT2.7|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de la tension analogique du contacteur point dur de la pédale d’accélérateur LVV
ACQADC_vidAcqAdcAirT|A|();|FCT2.5|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de la tension du capteur de température d'air
ACQADC_vidAcqAdcAlim|A|();|FCT1.2|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|acquisition de la tesion d'alimentaion des capteurs 1,2,3 et 4
ACQADC_vidAcqAdcBatt|A|();|FCT1.3|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de la tension batterie
ACQADC_vidAcqAdcCoT|A|();|FCT2.4|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de la tension du capteur de température d'eau
ACQADC_vidAcqAdcEngSt|A|();|FCT1.8|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de l'information état BICD
ACQADC_vidAcqAdcPresAC|A|();|FCT2.3|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de la tension du capteur de pression fluide réfrigérant
ACQADC_vidAcqAdcThr|A|();|FCT2.8|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de la position papillion capteur 1 et la position papillion capteur 2
ACQADC_vidAcqSenO2Ds|A|();|FCT2.2|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition A/N de la tension  de la sonde aval
ACQADC_vidAcqSenO2Us|A|();|FCT2.1|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition A/N de la tension  de la sonde amont
ACQADC_vidAirExtPresAcq|A|();|FCT1.5|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de la pression atmosphérique
ACQADC_vidBrkAsiAcq|A|();|FCT1.6|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de la tension aux bornes du capteur Pression
ACQADC_vidHeatSenO2Ds|A|();|FCT1.9|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Demande d'activation du chauffage de la sonde aval
ACQADC_vidHeatSenO2Us|A|();|FCT1.10|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Demande d'activation du chauffage de la sonde amont
ACQADC_vidInit|A|();|FCT1.1|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Fonction d'initialisation des sorties
ACQADC_vidInMnfPresAcq|A|();|FCT1.4|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de la pression de collecteur
ACQADC_vidRelBrkAsiAcq|A|();|FCT1.7|ACQADC|0|PTS_DOC_6669203||||0|0|0|0|Acquisition de la tension mesurée aux bornes du capteur de pression mastervac relative
ACQAIRT_vidAirTemperatureAcqui|E|();|FCT1.2|ACQAIRT|0|PTS_DOC_6535285||||0|0|0|0|Temperature_air_mesuree qui correspond à la conversion du  signal électrique en une température d’air en °C. Ceci se fait par le biais d’une cartographie avec points d’appui calibrables.|
ACQAIRT_vidAirTemperatureMeas|E|();|FCT1.5|ACQAIRT|0|PTS_DOC_6535285||||0|0|0|0|Si le diagnostic électrique est correct, on effectue un slew rate sur la température d’air, sinon on passe dans la gestion d’un mode défaut.|
ACQAIRT_vidElectricFailDetection|F|();|FCT1.3|ACQAIRT|0|PTS_DOC_6535285||||0|0|0|0|detection des defauts electriques.|
ACQAIRT_vidFunctionalDiagnosis|E|();|FCT1.6|ACQAIRT|0|PTS_DOC_6535285||||0|0|0|0|Le diagnostic fonctionnel est inhibé sur la demande de reconfiguration issue du GAR.|
ACQAIRT_vidGradientTest|E|();|FCT1.8|ACQAIRT|0|PTS_DOC_6535285||||0|0|0|0|Le test sur le gradient est effectué sur le signal  échantillonné. L'accroissement de la température d'air ne doit pas être supérieur à une calibration (en °C/s).|
ACQAIRT_vidGradientTestParams|D|();|FCT1.7|ACQAIRT|0|PTS_DOC_6535285||||0|0|0|0|Temperature_air_mesuree_prev doit être initialisée à la valeur deTemperature_air_mesuree.|
ACQAIRT_vidInitOutput|E|();|FCT1.1|ACQAIRT|0|PTS_DOC_6535285||||0|0|0|0|initialisation des sorties.|
ACQAIRT_vidResetAirIntakeTemp|E|();|FCT1.4|ACQAIRT|0|PTS_DOC_6535285||||0|0|0|0|Cette initialisation est réalisée à la mise sous tension du calculateur (RESET).|
ACQAIRT_vidThrMesTempAir|B|();|FCT1.9|ACQAIRT|0|PTS_DOC_6535285||||0|0|0|0|Fonction qui permet la production de la variable Température d’air mesurée après papillon au démarrage (Ext_tDsThrstrtMes).|
ACQCLUPED_vidClutchReadInput|H|();|FCT1.2|ACQCLUPED|0|PTS_DOC_6509293||||0|0|0|0|l’acquisition n’est effective qu’en présence d’un capteur  de pédale d’embrayage Tout ou Rien.|
ACQCLUPED_vidRead|F|();|FCT1.3|ACQCLUPED|0|PTS_DOC_6509293||||0|0|0|0|Lecture entrée embrayage.|
ACQCLUPED_vidResetCpsCluPedInput|H|();|FCT1.1|ACQCLUPED|0|PTS_DOC_6509293||||0|0|0|0|A la mise sous tension du calculateur, on initialise la donnée Cps_clutch_pedal_input avec Clu_bCluPedInpIni_C.|
ACQCMDDIO_vidAcqCmdCoFan|A|();|FCT2.8|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|L'activation du signal de commande du GMV depend du type d'equipements GMV sur véhicule.
ACQCMDDIO_vidAcqDioBrk|A|();|FCT2.5|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Acquisition de l'information pédale de frein secondaire TOR.
ACQCMDDIO_vidAcqDioClu|A|();|FCT2.2|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Acquisition de l'information pédale embrayage TOR.
ACQCMDDIO_vidAcqDioCoFan|A|();|FCT3.1|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|L'acquisition de l'information ETAT_GMV brut avant filtrage anti-rebond est realisée selon le type  d'équipements GMV sur le véhicule.
ACQCMDDIO_vidAcqDioCoFanB1|A|();|FCT3.2|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Acquisition de l'information ETAT_GMV brut avant filtrage anti-rebond (B1).
ACQCMDDIO_vidAcqDioCoFanB2|A|();|FCT3.3|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Acquisition de l'information ETAT_GMV brut avant filtrage anti-rebond (B2).
ACQCMDDIO_vidAcqDioGear|A|();|FCT2.4|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Acquisition de l'information Start Lock TOR
ACQCMDDIO_vidAcqDioKey|A|();|FCT3.4|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Acquisition de la valeur logique brute de l'entrée clef provenant du LDB (hystérésis et seuil de changement d'état).
ACQCMDDIO_vidAcqDioOil|A|();|FCT2.3|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Acquisition manocontact de pression huile
ACQCMDDIO_vidAcqDioSTT|A|();|FCT2.6|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Acquisition de l'information brute de la ligne Key/Push.
ACQCMDDIO_vidAuthStrtSTT|A|();|FCT1.7|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Etat de la commande de l'actionneur suivant que l'actionneur soit commandé  en low side (piolté à la masse: 0 = fermé, 1 = ouvert) ou en high side (0 = ouvert, 1 = fermé).
ACQCMDDIO_vidBlowBy1|A|();|FCT1.8|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|State of the actuator control of the Blowby1 heater
ACQCMDDIO_vidBlowBy2|A|();|FCT1.9|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|State of the actuator control of the Blowby2 heater
ACQCMDDIO_vidCmdDioCoFanB1|A|();|FCT2.9|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Demande d'activation du signal de commande du GMV 1 (équipements B1 et B2).
ACQCMDDIO_vidCmdDioCoFanB2|A|();|FCT2.10|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Demande d'activation du signal de commande du GMV 1 (équipements B2 et C').
ACQCMDDIO_vidCmdDioPwr|A|();|FCT1.2|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Commande du DMTR pour maintenir la tension réseau.
ACQCMDDIO_vidFCmdDml|A|();|FCT1.5|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Etat de la commande de l'actionneur de la sortie logique.
ACQCMDDIO_vidInit|B|();|FCT1.1|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Fonction d'initialisation des sorties
ACQCMDDIO_vidInitCoFan|A|();|FCT2.7|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Sur Reset CMM, il faut configurer le type de l’entré état GMV. Elle est de type booléen en B1 ou B2, et RCO en C’.
ACQCMDDIO_vidMainRly|A|();|FCT1.3|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Commande du relais principal.
ACQCMDDIO_vidOutpIdc|A|();|FCT1.6|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Etat de la commande de l'actionneur de la sortie information moteur tournant,  commandé en low side (0 = fermé, 1 = ouvert).
ACQCMDDIO_vidPowerRly|A|();|FCT1.4|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Commande du relais de puissance.
ACQCMDDIO_vidSenO2Ds|A|();|FCT1.10|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Demande d'activation du chauffage de la sonde aval
ACQCMDDIO_vidSenO2Us|A|();|FCT2.1|ACQCMDDIO|0|PTS_DOC_6509298||||0|0|0|0|Demande d'activation du chauffage de la sonde amont.
ACQCOT_NVMSRV_vidInit|A|();|FCT2.6|ACQCOT|1|PTS_DOC_6529851||||0|0|0|0|La variable Ext_tCoMesPwrl est initialisée à la réinitialisation  de l' EEPROM avec la calibration Ext_tCoMesPwrl_C.
ACQCOT_vidCrTRunWaterTemp|D|();|FCT2.1|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|Fonction de production de Crank_to_run_water_temp représentant la température à l'événement crank to run.
ACQCOT_vidElecFailureDetection|E|();|FCT1.8|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|Inhibtion des diagnostics électriques.
ACQCOT_vidGradientTest|D|();|FCT1.4|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|Le défaut unitaire est détecté si le delta de température d'eau est supérieur à un seuil.
ACQCOT_vidGradientTestParameters|F|();|FCT1.3|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|Tester les parametres gradient
ACQCOT_vidInitialization|F|();|FCT1.1|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|Phases de vie et initialisation.
ACQCOT_vidInitTemperature|E|();|FCT1.9|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|Init function.
ACQCOT_vidRunWaterTemp|C|();|FCT2.2|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|Fonction de production de la variable Temperature_eau_a_stall.
ACQCOT_vidStallWaterTemp|E|();|FCT2.3|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|Fonction d'actualisation de la variable Temperature_eau_a_stall lors d'un démarrage.
ACQCOT_vidStoragetCoPwrl|A|();|FCT2.5|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|la variable Ext_tCoMesPwrl est rafraîchie sur l’évènement  powerlatch
ACQCOT_vidTreatment|E|();|FCT1.5|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|traitement des données.
ACQCOT_vidWaterCalTemp|B|();|FCT2.4|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|Fonction de mise à jour de la variable Temperature_eau_a_stall.
ACQCOT_vidWaterFailure|F|();|FCT1.6|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|La temperature d'eau Ext_tCoMes est limitée par un slew rate configuré à 1 C.
ACQCOT_vidWaterTempAcquisition|G|();|FCT1.7|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|Acquisition température d'eau.
ACQCOT_vidWaterTempTreatment|E|();|FCT1.2|ACQCOT|0|PTS_DOC_6529851||||0|0|0|0|Traitement température d'eau.
ACQDGOHAL_DT_vidDgoHalASICGDI|A|();|FCT1.8|ACQDGOHAL_DT|0|PTS_DOC_6854092||||0|0|0|0|This block realizes the acquisition of diagnoses states and results for the ASIC GDI and VBOOST components.|
ACQDGOHAL_DT_vidDgoHalCmdWgc|A|();|FCT1.3|ACQDGOHAL_DT|0|PTS_DOC_6854092||||0|0|0|0|This block realizes the acquisition of diagnoses states and results for the wastegate command.|
ACQDGOHAL_DT_vidDgoHalCtlPmpReq|A|();|FCT1.2|ACQDGOHAL_DT|0|PTS_DOC_6854092||||0|0|0|0|This block realizes the acquisition of diagnoses states and results for the oil pump solenoid valve.|
ACQDGOHAL_DT_vidDgoHalCTP|A|();|FCT1.7|ACQDGOHAL_DT|0|PTS_DOC_6854092||||0|0|0|0|This block realizes the acquisition of diagnoses states and results for the CTP components.|
ACQDGOHAL_DT_vidDgoHalDmpVlvCmd|A|();|FCT1.4|ACQDGOHAL_DT|0|PTS_DOC_6854092||||0|0|0|0|This block realizes the acquisition of diagnoses states and results for the dump-valve command.|
ACQDGOHAL_DT_vidDgoHalInit|A|();|FCT1.1|ACQDGOHAL_DT|0|PTS_DOC_6854092||||0|0|0|0|All the outputs of the API DGOHAL BSW are initialized to 0.|
ACQDGOHAL_DT_vidDgoHalOilLvlAcq|A|();|FCT1.9|ACQDGOHAL_DT|0|PTS_DOC_6854092||||0|0|0|0|This block realizes the acquisition of diagnoses states and results for the oil level acquisition.|
ACQDGOHAL_DT_vidDgoHalTrbWaPmp|A|();|FCT1.6|ACQDGOHAL_DT|0|PTS_DOC_6854092||||0|0|0|0|This block realizes the acquisition of diagnoses states and results for the turbo cooling pump command.|
ACQDGOHAL_DT_vidDgoHlHPPmpActCmd|A|();|FCT1.5|ACQDGOHAL_DT|0|PTS_DOC_6854092||||0|0|0|0|This block realizes the acquisition of diagnoses states and results for the HP fuel pump command.|
ACQDGOHAL_vidCmdDiagAuthStrtSTT|A|();|FCT1.7|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités: panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit à la fonction STT
ACQDGOHAL_vidCmdDiagBlowBy1|A|();|FCT1.1|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités: panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit au réchauffeur BlowBy
ACQDGOHAL_vidCmdDiagBlowBy2|A|();|FCT1.2|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités: panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit au réchauffeur BlowBy
ACQDGOHAL_vidCmdDiagCstr|A|();|FCT1.8|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités: panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit à L’ELECTROVANNE PURGE CANISTER.
ACQDGOHAL_vidCmdDiagDmtr|A|();|FCT2.1|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités: panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit au dispositif de maintient en tension reseau (MAINTIENT DMTR)
ACQDGOHAL_vidCmdDiagDrvO2Ds|A|();|FCT1.5|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités: panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit à la fonction HeatSenO2 aval.
ACQDGOHAL_vidCmdDiagDrvO2Us|A|();|FCT1.6|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités: panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit à la fonction HeatSenO2 amont.
ACQDGOHAL_vidCmdDiagECTReq|A|();|FCT2.6|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités pour le ECT command : panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit
ACQDGOHAL_vidCmdDiagEngStOutIdc|A|();|FCT1.9|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités: panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit à la sortie filaire information moteur tournant
ACQDGOHAL_vidCmdDiagGMV1GMV2|A|();|FCT2.5|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités pour le driver du GMV1 et GMV2 :panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit
ACQDGOHAL_vidCmdDiagPropFuPmp|A|();|FCT1.10|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités: panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit à la sortie FUEL PUMP
ACQDGOHAL_vidCmdDiagRly|A|();|FCT2.2|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes sont traités: panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit à l'ACTUATOR RELAY
ACQDGOHAL_vidCmdDiagStrtr|A|();|FCT2.3|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Trois types de diagnostic de pannes à la sortie logique DML sont traités: panne circuit ouvert /panne Court-circuit à la masse/panne Court-circuit.
ACQDGOHAL_vidCmdDiagThrOverload|A|();|FCT2.7|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Fonction qui gère le diagnostic du papillon motorise actif
ACQDGOHAL_vidCmdDiagVlvActEx|A|();|FCT1.3|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Fonction de diagnostique défaut du driver de la VVT échappement.
ACQDGOHAL_vidCmdDiagVlvActIn|A|();|FCT1.4|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Fonction de diagnostique défaut du driver de la VVT admission.
ACQDGOHAL_vidInit_OutPutCmdDiag|A|();|FCT2.4|ACQDGOHAL|0|PTS_DOC_6669624||||0|0|0|0|Fonction d'initialisation des sorties.
ACQPWD_vidCluPedAcq|A|();|FCT1.3|ACQPWD|0|PTS_DOC_6717056||||0|0|0|0|L’acquisition du  signal PWM issu du capteur de la pédale d'embrayage est réalisée de façon temporelle et débutera dès le réveil du calculateur.
ACQPWD_vidCmdDiagCoFanAcq|A|();|FCT1.9|ACQPWD|0|PTS_DOC_6717056||||0|0|0|0|Cette fonction réalise l’acquisition d’ETAT_GMV provenant du LdB en équipement C.
ACQPWD_vidFuPmpDiagAcq|A|();|FCT1.7|ACQPWD|0|PTS_DOC_6717056||||0|0|0|0|L’acquisition du signal de diagnostic de la pompe de gavage est réalisée de façon temporelle et débutera dès le réveil du calculateur.
ACQPWD_vidInit|B|();|FCT1.1|ACQPWD|0|PTS_DOC_6717056||||0|0|0|0|Ce bloc représente les valeurs des différents sorties au réveil calculateur.
ACQPWD_vidInitCmdDiagCoFan|A|();|FCT1.8|ACQPWD|0|PTS_DOC_6717056||||0|0|0|0|Initialisation du CoFan.
ACQPWD_vidInitFlowMng|A|();|FCT1.2|ACQPWD|0|PTS_DOC_6717056||||0|0|0|0|Initialisation du FlowMng.
ACQPWD_vidInitFuPmp|A|();|FCT1.6|ACQPWD|0|PTS_DOC_6717056||||0|0|0|0|Initialisation du FuPmp.
ACQPWD_vidInitNeutPosn|A|();|FCT1.4|ACQPWD|0|PTS_DOC_6717056||||0|0|0|0|Initialisation du NeutPosn.
ACQPWD_vidNeutPosnAcq|A|();|FCT1.5|ACQPWD|0|PTS_DOC_6717056||||0|0|0|0|Ce bloc met à la disposition du LDA le rapport cyclique du signal délivré par le capteur de position point mort. Le  calcul du rapport cyclique de ce signal est effectué par le LDB.
ACQWKUSIG_vidInitOutPut|B|();|FCT1.2|ACQWKUSIG|0|PTS_DOC_6884549||||0|0|0|0|fonction d'initialisation des sorties|
ACQWKUSIG_vidKeyOnOffInit|E|();|FCT1.1|ACQWKUSIG|0|PTS_DOC_6884549||||0|0|0|0|Au reset du calculateur, le signal RCD est supposé actif|
ACQWKUSIG_vidKeyTreatement|I|();|FCT1.3|ACQWKUSIG|0|PTS_DOC_6884549||||0|0|0|0|Fonction qui permet le traitement clef.|
ACQWKUSIG_vidRcdModeActive|E|();|FCT1.4|ACQWKUSIG|0|PTS_DOC_6884549||||0|0|0|0|Le filtrage du signal APC_CD est déjà effectué dans le LDB, donc pour éviter la redondance, le signal_RCD prend directement les valeurs de Clef_signal_filt|
ACQWKUSIG_vidRcdModeNoAct|A|();|FCT1.5|ACQWKUSIG|0|PTS_DOC_6884549||||0|0|0|0|Si la variable Rcd_mode_active est à ON, Ext_bAPCLine doit rester à OFF. Sinon elle prend la valeur de Clef_signal_filt|
ActivateTask|A|(argin uint8 Taskid);|2|HEADER|1|NONE||||0|0|0|0||
ACTRTSTCTP_vidCPTChart|A|();|FCT1.4|ACTRTSTCTP|0|V02 NT 12 05323||||0|0|0|0|During a test request (conditions met and actuator code matches), records of battery voltage are made at different time.|
ACTRTSTCTP_vidCTPTst|A|();|FCT1.3|ACTRTSTCTP|0|V02 NT 12 05323||||0|0|0|0|During a test request (conditions met and actuator code matches), records of battery voltage are made at different time.|
ACTRTSTCTP_vidDft1dActrTst|A|();|FCT1.5|ACTRTSTCTP|0|V02 NT 12 05323||||0|0|0|0|A default is declared (CTP_bDft1dActrTst = 1) if this condition is false :ActrTstCTP_uMinBattMem1_C < ActrTstCTP_uBattMesMem0 - ActrTstCTP_uBattMesMem1 < ActrTstCTP_uMaxBattMem1_C.|
ACTRTSTCTP_vidDft2dActrTst|A|();|FCT1.6|ACTRTSTCTP|0|V02 NT 12 05323||||0|0|0|0|A default is declared (CTP_bDft2dActrTst = 1) if this condition is false :ActrTstCTP_uMinBattMem2_C < ActrTstCTP_uBattMesMem0 - ActrTstCTP_uBattMesMem2 < ActrTstCTP_uMaxBattMem2_C.|
ACTRTSTCTP_vidInitOutput|A|();|FCT1.2|ACTRTSTCTP|0|V02 NT 12 05323||||0|0|0|0|Internal variables and outputs initialization.|
ACTRTSTCTP_vidRstDft|A|();|FCT1.1|ACTRTSTCTP|0|V02 NT 12 05323||||0|0|0|0|At the reset, default boolean must be reseted|
ACTRTSTDV_vidDVTST|A|();|FCT1.2|ACTRTSTDV|0|V02 NT 11 02175||||0|0|0|0|During a test request (conditions met and actuator code matches), the actuator is commanded alternatively by DmpVlv_rSpActrTstPos1_C for a time ActrTstDV_OnTime_C, and by DmpVlv_rSpActrTstPos2_C for ActrTstDV_OffTime_C.|
ACTRTSTDV_vidInitOutput|A|();|FCT1.1|ACTRTSTDV|0|V02 NT 11 02175||||0|0|0|0|Fonction d'initialisation des sorties.|
ACTRTSTECT_vidECTTst|A|();|FCT1.2|ACTRTSTECT|0|V02 NT 11 06916||||0|0|0|0|This stateflow describes the specific test command.|
ACTRTSTECT_vidInitOutput|A|();|FCT1.1|ACTRTSTECT|0|V02 NT 11 06916||||0|0|0|0|Outputs initialization.|
ACTRTSTFARSP_vidFarSpUsActrTst|D|();|FCT1.2|ACTRTSTFARSP|0|PTS_DOC_5066987||||0|0|0|0|Ce test est activé par les outils de diagnostic constructeur en fin de chaîne, en après-vente ou pour des besoins de formation. Le test s’interrompt si au moins une des conditions d’activation du test n’est pas vérifiée.|
ACTRTSTFARSP_vidFarSpUsLeanTst|D|();|FCT1.4|ACTRTSTFARSP|0|PTS_DOC_5066987||||0|0|0|0|Cette fonction permet la détection de la sonde bloquée pauvre.|
ACTRTSTFARSP_vidFarSpUsMainTst|D|();|FCT1.3|ACTRTSTFARSP|0|PTS_DOC_5066987||||0|0|0|0|Automate de la stratégie d'apprentissage des défauts.|
ACTRTSTFARSP_vidFarSpUsRichTst|D|();|FCT1.5|ACTRTSTFARSP|0|PTS_DOC_5066987||||0|0|0|0|Cette fonction permet la détection de la sonde bloquée riche|
ACTRTSTFARSP_vidInitOutput|D|();|FCT1.1|ACTRTSTFARSP|0|PTS_DOC_5066987||||0|0|0|0|initialisation des sorties.|
ACTRTSTFARSP_vidTransition_END|D|();|FCT1.7|ACTRTSTFARSP|0|PTS_DOC_5066987||||0|0|0|0|cette fonction decrit le comportement du systeme lors de l'entrée à la transition FARSP_ACTRTST_END|
ACTRTSTFARSP_vidTransition_IDLE|D|();|FCT1.6|ACTRTSTFARSP|0|PTS_DOC_5066987||||0|0|0|0|cette fonction decrit le comportement du systeme lors de l'entrée à la transition FARSP_ACTRTST_IDLE|
ACTRTSTMEAP_vidEntryIdleState|A|();|FCT1.4|ACTRTSTMEAP|0|V02 NT 12 05332||||0|0|0|0|Description of the state MEAP_ACTRTEST_IDLE|
ACTRTSTMEAP_vidInitOutput|A|();|FCT1.1|ACTRTSTMEAP|0|V02 NT 12 05332||||0|0|0|0|Initialization module outputs|
ACTRTSTMEAP_vidMEAPTst|A|();|FCT1.3|ACTRTSTMEAP|0|V02 NT 12 05332||||0|0|0|0|During a test request (conditions met and actuator code matches), several tests are made|
ACTRTSTMEAP_vidRstDft|A|();|FCT1.2|ACTRTSTMEAP|0|V02 NT 12 05332||||0|0|0|0|At the reset, default booleans must be reseted.|
ADCHAL_udtDisableNotification|B|func_ADCHAL_udtDisableNotification|0x03|ADCHAL|1|V01 NT 08 05204||||0|0|0|1|
ADCHAL_udtEnableNotification|B|func_ADCHAL_udtEnableNotification|0x02|ADCHAL|1|V01 NT 08 05204||||0|0|0|1|
ADCHAL_udtPrivateDisableNotification|A|func_ADCHAL_udtPrivateDisableNotification|0x03|ADCHAL|0|V01 NT 08 05204||||0|0|0|0|
ADCHAL_udtPrivateEnableNotification|A|func_ADCHAL_udtPrivateEnableNotification|0x02|ADCHAL|0|V01 NT 08 05204||||0|0|0|0|
ADCHAL_udtPrivateRead|A|func_ADCHAL_udtPrivateRead|0x01|ADCHAL|0|V01 NT 08 05204||||0|0|0|0|Read acquisition value of the channel udtChannel
ADCHAL_udtRead|B|func_ADCHAL_udtRead|0x01|ADCHAL|1|V01 NT 08 05204||||0|0|0|1|Read acquisition value of the channel udtChannel
ADCHAL_vidInit|A|();|0x00|ADCHAL|1|V01 NT 08 05204||||0|0|0|0|ADCHAL Initialization
ADDONADVMAX_vidCalibration_1|A|();|FCT1.7|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_10|A|();|FCT2.6|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_11|A|();|FCT2.7|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_12|A|();|FCT2.8|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_13|A|();|FCT2.9|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_14|A|();|FCT2.10|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_2|A|();|FCT1.8|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_3|A|();|FCT1.9|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_4|A|();|FCT1.10|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_5|A|();|FCT2.1|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_6|A|();|FCT2.2|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_7|A|();|FCT2.3|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_8|A|();|FCT2.4|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibration_9|A|();|FCT2.5|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMAX_vidCalibrations|A|();|FCT1.5|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce bloc regroupe les différentes calibrations de la fonction.|
ADDONADVMAX_vidEntryInit|A|();|SCH.1|ADDONADVMAX|1|V02 NT 11 01471||||0|0|0|0|Evènement de reset du calculateur.|
ADDONADVMAX_vidInitOutput|A|();|FCT1.1|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Cette fonction initialise les sorties du module.|
ADDONADVMAX_vidInterpolation|A|();|FCT3.3|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce bloc permet d’interpoler l’offset d’avance maximale entre les valeurs pour les modes courants et de consigne.|
ADDONADVMAX_vidMode_Mask|A|();|FCT1.4|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce bloc permet de sélectionner le numéro des cartographies utiles.|
ADDONADVMAX_vidOffset_Aamaxi|A|();|FCT1.2|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|La fonction est constituée de 5 blocs permettant de calculer l’offset d’avance maximale.|
ADDONADVMAX_vidSelect_Modes|A|();|FCT3.2|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce bloc permet de calculer l’offset d’avance maximale pour les modes courants et de consigne.|
ADDONADVMAX_vidUnvectorize_Mode|B|();|FCT1.3|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce bloc permet de sélectionner les informations provenant du gestionnaire de modes de combustion EOM.|
ADDONADVMAX_vidUnvectrzActivBool|A|();|FCT1.6|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce bloc permet de démultiplexer le flux de sélection des cartographies utiles.|
ADDONADVMAX_vidVectorizeCalibs|A|();|FCT3.1|ADDONADVMAX|0|V02 NT 11 01471||||0|0|0|0|Ce bloc permet de calculer l’offset d’avance maximale.|
ADDONADVMIN_vidCalibration_1|A|();|FCT1.7|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_10|A|();|FCT2.6|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_11|A|();|FCT2.7|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_12|A|();|FCT2.8|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_13|A|();|FCT2.9|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_14|A|();|FCT2.10|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_2|A|();|FCT1.8|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_3|A|();|FCT1.9|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_4|A|();|FCT1.10|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_5|A|();|FCT2.1|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_6|A|();|FCT2.2|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_7|A|();|FCT2.3|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_8|A|();|FCT2.4|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibration_9|A|();|FCT2.5|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce  bloc  contient  une  des  cartographies  de  la  fonction.  Il  n’est  calculé  que  lorsque  le mode  de  fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
ADDONADVMIN_vidCalibrations|A|();|FCT1.5|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce bloc regroupe les différentes calibrations de la fonction.|
ADDONADVMIN_vidEntryInit|A|();|SCH.1|ADDONADVMIN|1|V02 NT 11 01472||||0|0|0|0|Evènement de reset du calculateur.|
ADDONADVMIN_vidInitOutput|A|();|FCT1.1|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Cette fonction initialise les sorties du module.|
ADDONADVMIN_vidInterpolation|B|();|FCT3.3|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce bloc permet d’interpoler l’offset d’avance minimale entre les valeurs pour les modes courants et de consigne.|
ADDONADVMIN_vidMode_Mask|A|();|FCT1.4|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce bloc permet de sélectionner le numéro des cartographies utiles.|
ADDONADVMIN_vidOffset_Aamini|A|();|FCT1.2|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|La fonction est constituée de 5 blocs permettant de calculer l’offset d’avance minimale.|
ADDONADVMIN_vidSelect_Modes|A|();|FCT3.2|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce bloc permet de calculer l’offset d’avance minimale pour les modes courants et de consigne.|
ADDONADVMIN_vidUnvectorize_Mode|B|();|FCT1.3|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce bloc permet de sélectionner les informations provenant du gestionnaire de modes de combustion EOM.|
ADDONADVMIN_vidUnvectrzActivBool|A|();|FCT1.6|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce bloc permet de démultiplexer le flux de sélection des cartographies utiles.|
ADDONADVMIN_vidVectorizeCalibs|A|();|FCT3.1|ADDONADVMIN|0|V02 NT 11 01472||||0|0|0|0|Ce bloc permet de calculer l’offset d’avance minimale.|
ADDONADVOPTM_vidCalibration_1|A|();|FCT1.7|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_10|A|();|FCT2.6|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_11|A|();|FCT2.7|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnemen courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_12|A|();|FCT2.8|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_13|A|();|FCT2.9|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_14|A|();|FCT2.10|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_15|A|();|FCT3.1|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_16|A|();|FCT3.2|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_17|A|();|FCT3.3|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  contient une des calibrations de la fonction. Ce scalaire n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite un appel de cette calibration.|
ADDONADVOPTM_vidCalibration_2|A|();|FCT1.8|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_3|A|();|FCT1.9|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_4|A|();|FCT1.10|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_5|A|();|FCT2.1|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_6|A|();|FCT2.2|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_7|A|();|FCT2.3|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette  contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_8|A|();|FCT2.4|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette  contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibration_9|A|();|FCT2.5|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement  courant ou celui de consigne nécessite une interpolation dans cette cartographie|
ADDONADVOPTM_vidCalibrations|A|();|FCT1.5|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette  fonction  regroupe les différentes calibrations de la fonction|
ADDONADVOPTM_vidEntryInit|A|();|SCH.1|ADDONADVOPTM|1|V02 NT 11 01474||||0|0|0|0|Evènement pour la fonction initialisation|
ADDONADVOPTM_vidInitOutput|A|();|FCT1.1|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Fonction pour initialiser les sorties|
ADDONADVOPTM_vidInterpolation|A|();|FCT3.6|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  permet de calculer l’offset d’avance optimale à partir des modes courants et de consigne.|
ADDONADVOPTM_vidMode_Mask|A|();|FCT1.4|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette  fonction  permet de sélectionner le numéro des cartographies utiles|
ADDONADVOPTM_vidOffset_AAO|A|();|FCT1.2|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|La fonction est constituée de 5 sous fonctions  permettant de calculer l’offset d’avance optimale|
ADDONADVOPTM_vidSelect_Modes|A|();|FCT3.5|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  permet de calculer l’offset d’avance optimale pour les modes courants et de consigne.|
ADDONADVOPTM_vidUnvectorActvBool|A|();|FCT1.6|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction permet de démultiplexeur le flux de sélection des cartographies utiles|
ADDONADVOPTM_vidUnvectorize_Mode|B|();|FCT1.3|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  bloc permet de sélectionner les informations provenant du gestionnaire de modes de fonctionnements|
ADDONADVOPTM_vidVectorize_Calib|A|();|FCT3.4|ADDONADVOPTM|0|V02 NT 11 01474||||0|0|0|0|Cette fonction  permet de calculer l’offset d’avance optimale pour tous les modes.|
ADDONAGCOR_vidCalibration_1|A|();|FCT1.7|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction appelée lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans la cartographie de la fonction|
ADDONAGCOR_vidCalibration_2|A|();|FCT1.8|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction appelée lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans la cartographie de la fonction|
ADDONAGCOR_vidCalibrations|A|();|FCT1.4|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction qui regroupe les différentes calibrations|
ADDONAGCOR_vidCoordination|C|();|FCT2.2|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction qui coordonne les valeurs de coefficients de déformation de la courbe de rendement d’avance pour les différents combustibles et pour les différents modes de fonctionnement.|
ADDONAGCOR_vidEntryInit|A|();|SCH.1|ADDONAGCOR|1|V02 NT 11 01473||||0|0|0|0|Evénement Reset|
ADDONAGCOR_vidInitOutput|A|();|FCT1.1|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction d'initialisation des sorties.|
ADDONAGCOR_vidInterpolation|A|();|FCT2.1|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction qui permet de calculer la valeur du coefficient de déformation de la courbe de rendement d’avance à partir des valeurs des modes courants et de consigne.|
ADDONAGCOR_vidMode_Mask|A|();|FCT1.3|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction de sélection de numéro des cartographies utiles|
ADDONAGCOR_vidSel_T_utilisee|A|();|FCT1.5|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction de sélection de la température à prendre en compte.|
ADDONAGCOR_vidSelect_Modes|A|();|FCT1.10|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction de calcule des valeurs du coefficient de déformation de la courbe de rendement d’avance pour les modes courants et de consigne.|
ADDONAGCOR_vidUnvectorize_Mode|B|();|FCT1.2|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction de sélection des informations provenant du gestionnaire de modes de combustion EOM|
ADDONAGCOR_vidUnvectorz_Act_Bool|A|();|FCT1.6|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction de démultiplication du flux de sélection des cartographies utiles|
ADDONAGCOR_vidVectorize_Calib|A|();|FCT1.9|ADDONAGCOR|0|V02 NT 11 01473||||0|0|0|0|Fonction de calcule de la valeur du coefficient de déformation de la courbe de rendement d’avance pour les différents modes.|
ADHEATCMD_vidAdHeatCmdCalc|B|();|FCT1.2|ADHEATCMD|0|PTS_DOC_6851368||||0|0|0|0|According to the different values of the CAN parameter CoReqVeh_stAdHeat the activation request flags are set to 1 or not.|
ADHEATCMD_vidCmdCTP1|B|();|FCT1.3|ADHEATCMD|0|PTS_DOC_6851368||||0|0|0|0|The activation command of the CTP1 additional heater is sent to the BSW using a DIOHAL API.|
ADHEATCMD_vidCmdCTP2|B|();|FCT1.4|ADHEATCMD|0|PTS_DOC_6851368||||0|0|0|0|The activation command of the CTP2 additional heater is sent to the BSW using a DIOHAL API.|
ADHEATCMD_vidDiagCTP1|B|();|FCT1.5|ADHEATCMD|0|PTS_DOC_6851368||||0|0|0|0|This bloc manages with the electrical diagnoses of the CTP1. The diagnoses are activated only if there is no inhibition requested.|
ADHEATCMD_vidDiagCTP2|B|();|FCT1.6|ADHEATCMD|0|PTS_DOC_6851368||||0|0|0|0|This bloc manages with the electrical diagnoses of the CTP2. The diagnoses are activated only if there is no inhibition requested.|
ADHEATCMD_vidInit|B|();|FCT1.1|ADHEATCMD|0|PTS_DOC_6851368||||0|0|0|0|The outputs variables are initialized on reset event.|
AIREXTPRESACQ_vidAcquisition|D|();|FCT1.3|AIREXTPRESACQ|0|PTS_DOC_6525166||||0|0|0|0|The function deals with the pressure sensor voltage acquisition and the voltage-|
AIREXTPRESACQ_vidAtmPresDiag|C|();|FCT1.4|AIREXTPRESACQ|0|PTS_DOC_6525166||||0|0|0|0|Generate the dgo internal values and lunch the elictricals diagnostic|
AIREXTPRESACQ_vidAtmPreTreat|E|();|FCT1.6|AIREXTPRESACQ|0|PTS_DOC_6525166||||0|0|0|0|In the nominal functioning case, the specification sends the measured value.|
AIREXTPRESACQ_vidCalc|C|();|FCT1.2|AIREXTPRESACQ|0|PTS_DOC_6525166||||0|0|0|0|lunch the 3 steps of the atmospheric pressure calculation.|
AIREXTPRESACQ_vidElectDiag|D|();|FCT1.5|AIREXTPRESACQ|0|PTS_DOC_6525166||||0|0|0|0|The electrical diagnosis is managed in this sub-system.|
AIREXTPRESACQ_vidInit|D|();|FCT1.1|AIREXTPRESACQ|0|PTS_DOC_6525166||||0|0|0|0|Initilyze the value of atmospheric pressure.|
AIREXTPRESACQ_vidInterfacage|B|();|FCT1.7|AIREXTPRESACQ|0|PTS_DOC_6525166||||0|0|0|0|Mesurement of atmospheric pressure interfacing|
AirPres_Eve14TDC_AcqAdc|A|();|SCH.2|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|Quarter TDC event for SpgPresAcq.|
AirPres_Eve14TDC_DiagTrbPres|A|();|SCH.3|FCTDIAGTRBPRES|1|PTS_DOC_5198884||||0|0|0|0|Evenement sur 1/4 de PMH|
AirPres_Eve14TDC_InMnfPresAcq|G|();|SCH.2|INMNFPRESACQ|1|PTS_DOC_6525158||||0|0|0|0|Fonction d'accroche moniteur à l'evenement 1/4TDC du CMM|
AirPres_Eve14TDC_InMnfPresAcqAdc|A|();|SCH2.3|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Evénement d'appel de tâche "quart de PMH" du CMM
AirPres_Eve14TDC_SpgPresAcq|E|();|SCH.3|SPGPRESACQ|1|PTS_DOC_6851381||||0|0|0|0|Evénement d'appel de tâche "quart de PMH" du CMM|
AirPres_Eve14TDC_SpgPresAcqif|D|();|SCH1.8|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Evénement d'appel de tâche "quart de PMH" du CMM|
AirPres_EveCrTSt_InMnfPresDiag|E|();|SCH.3|INMNFPRESDIAG|1|PTS_DOC_6539920||||0|0|0|0|Evènement d'arrêt moteur
AirPres_EveKOf_DiagAirExtPres|A|();|SCH.4|DIAGAIREXTPRES|1|V02 NT 11 03594||||0|0|0|0|Evénement clef On_Off|
AirPres_EveKOn_DiagAirExtPres|A|();|SCH.2|DIAGAIREXTPRES|1|V02 NT 11 03594||||0|0|0|0|Evénement clef Off_On|
AirPres_EveRst_AirExtPresAcq|D|();|SCH.1|AIREXTPRESACQ|1|PTS_DOC_6525166||||0|0|0|0|EveRst for AirExtPresAcq|
AirPres_EveRst_AirExtPresAcqIf|B|();|SCH1.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset du calculateur.|
AirPres_EveRst_BrkAsiAcq|E|();|SCH.1|BRKASIACQ|1|PTS_DOC_6525171||||0|0|0|0|Fonction d'accroche à l'évènement reset|
AirPres_EveRst_DiagAirExtPres|A|();|SCH.1|DIAGAIREXTPRES|1|V02 NT 11 03594||||0|0|0|0|Evénement reset du calculateur|
AirPres_EveRst_FctDiagTrbPres|C|();|SCH.1|FCTDIAGTRBPRES|1|PTS_DOC_5198884||||0|0|0|0|Evènement de reset de la fonction AirPres.|
AirPres_EveRst_InMnfPresAcq|F|();|SCH.1|INMNFPRESACQ|1|PTS_DOC_6525158||||0|0|0|0|Fonction d'accroche moniteur à l'evenement Reset du calculateur|
AirPres_EveRst_InMnfPresDiag|E|();|SCH.1|INMNFPRESDIAG|1|PTS_DOC_6539920||||0|0|0|0|Evénement reset du calculateur
AirPres_EveRst_RelBrkAsiAcq|B|();|SCH.1|RELBRKASIACQ|1|PTS_DOC_6547160||||0|0|0|0|Reset event for AirPres function
AirPres_EveRst_SpgPresAcq|E|();|SCH.1|SPGPRESACQ|1|PTS_DOC_6851381||||0|0|0|0|Evènement_reset|
AirPres_EveRst_SpgPresAcqif|D|();|SCH1.10|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Evènement_reset|
AirPres_EveRst_SpgPresSp|A|();|SCH.1|SPGPRESSP|1|V02 NT 09 08194||||0|0|0|0|Event Reset|
AirPres_SdlFast_AirExtPresAcq|D|();|SCH.2|AIREXTPRESACQ|1|PTS_DOC_6525166||||0|0|0|0|Fast monitor for AirExtPresAcq|
AirPres_SdlFast_AirExtPresAcqAdc|A|();|SCH2.6|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Monitoring rapide de la fonction AirPres
AirPres_SdlFast_AirExtPresAcqIf|C|();|SCH19.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Monitoring rapide de la fonction AirPres.|
AirPres_SdlFast_BrkAsiAcq|D|();|SCH.2|BRKASIACQ|1|PTS_DOC_6525171||||0|0|0|0|Fonction d'accroche au moniteur rapide de la fonction AirPres|
AirPres_SdlFast_BrkAsiAcqAdc|A|();|SCH2.7|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Monitoring rapide de la fonction AirPres
AirPres_SdlFast_InMnfPresDiag|E|();|SCH.4|INMNFPRESDIAG|1|PTS_DOC_6539920||||0|0|0|0|Moniteur rapide
AirPres_SdlFast_InMnfPresDiagAdc|A|();|SCH2.8|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur rapide
AirPres_SdlFast_MonBrkAsi|B|();|SCH.2|BRKASIFONCDIAG|1|V02 NT 09 04714||||0|0|0|0|Moniteur rapide de la fonction AirPres|
AirPres_SdlFast_RelBrkAsiAcq|B|();|SCH.2|RELBRKASIACQ|1|PTS_DOC_6547160||||0|0|0|0|Fast monitor for AirPres function
AirPres_SdlFast_RelBrkAsiAcqAdc|A|();|SCH2.9|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur rapide de la fonction AirPres
AirPres_SdlMid_AcqAdc|A|();|SCH.3|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|Middle scheduler of AirPres function|
AirPres_SdlMid_AirExtPresAcq|B|();|SCH.4|AIREXTPRESACQ|1|PTS_DOC_6525166||||0|0|0|0|Mid monitor for AirExtPresAcq|
AirPres_SdlMid_FctDiagTrbPres|C|();|SCH.2|FCTDIAGTRBPRES|1|PTS_DOC_5198884||||0|0|0|0|Moniteur moyen pour la fonction AirPres.|
AirPres_SdlMid_InMnfPresAcq|H|();|SCH.3|INMNFPRESACQ|1|PTS_DOC_6525158||||0|0|0|0|Fonction d'accroche moniteur à l'evenement Moniteur moyen|
AirPres_SdlMid_InMnfPresAcqAdc|A|();|SCH2.4|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur moyen
AirPres_SdlMid_InMnfPresDiag|G|();|SCH.2|INMNFPRESDIAG|1|PTS_DOC_6539920||||0|0|0|0|Moniteur moyen de la fonction diagnostic de la boucle d'air
AirPres_SdlMid_SpgPresAcq|E|();|SCH.2|SPGPRESACQ|1|PTS_DOC_6851381||||0|0|0|0|Moniteur moyen pour la fonction AirPres|
AirPres_SdlMid_SpgPresAcqif|D|();|SCH1.9|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Moniteur moyen pour la fonction AirPres|
AirPres_SdlMid_SpgPresSp|A|();|SCH.2|SPGPRESSP|1|V02 NT 09 08194||||0|0|0|0|Middle scheduler of the Airpres function|
AirPres_SdlSfty_BrkAsiAcq|C|();|SCH.3|BRKASIACQ|1|PTS_DOC_6525171||||0|0|0|0|Evènement de calcul des fonctions safety de niveau 2|
AirPres_SdlSfty_RelBrkAsiAcq|B|();|SCH.3|RELBRKASIACQ|1|PTS_DOC_6547160||||0|0|0|0|Calculation event of safety level 2 functions
AirPres_SdlSlow_AirExtPresAcq|D|();|SCH.3|AIREXTPRESACQ|1|PTS_DOC_6525166||||0|0|0|0|Slow monitor for AirExtPresAcq|
AirPres_SdlSlow_AirExtPresAcqAdc|A|();|SCH2.5|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur lent
AirPres_SdlSlow_AirExtPresAcqIf|C|();|SCH19.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur lent.|
AirPres_SdlSlow_DiagAirExtPres|A|();|SCH.3|DIAGAIREXTPRES|1|V02 NT 11 03594||||0|0|0|0|Moniteur lent|
AirSys_EveIni_AirTqEff|B|();|SCH.1|AIRTQEFF|1|V02 NT 10 07791||||0|0|0|0|Evenement reset du calculateur|
AirSys_EveRst_InAirflowDiag|C|();|SCH.1|INAIRFLOWDIAG|1|PTS_DOC_5198333||||0|0|0|0|Evènement de reset de la fonction AirSys|
AirSys_SdlFast_AirTqEff|B|();|SCH.2|AIRTQEFF|1|V02 NT 10 07791||||0|0|0|0|Scheduler rapide de la fonction AirTqEff|
AirSys_SdlFast_InterfAirSysSC|E|();|SCH.2|INTERFACAGE_BA_SC|1|V02 NT 10 07792||||0|0|0|0|Scheduleur rapide de l'interfaçage du module AirSys|
AirSys_SdlFast_nEngGrdIf|B|();|SCH2.1|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Scheduleur rapide de l'interfaçage du module AirSys.|
AirSys_SdlMid_InAirflowDiag|C|();|SCH.2|INAIRFLOWDIAG|1|PTS_DOC_5198333||||0|0|0|0|Moniteur moyen de la fonction diagnostic de la boucle d'air|
AirT_EveCrTR_AcqAirT|C|();|SCH.3|ACQAIRT|1|PTS_DOC_6535285||||0|0|0|0|Evénement CRANKING vers RUNNING|
AirT_EveRst_AcqAirT|F|();|SCH.1|ACQAIRT|1|PTS_DOC_6535285||||0|0|0|0|fonction d'accroche moniteur a l'evenement   AirT_EveRst_AcqAirT.|
AirT_EveRst_AcqAirTAdc|A|();|SCH3.6|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Evènement reset
AirT_EveRst_AcqAirTIf|B|();|SCH1.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset ECU du module d'interface|
AirT_EveRst_AcqAirTIfAir|D|();|SCH1.11|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Evènement Reset|
AirT_SdlMid_AcqAirT|F|();|SCH.2|ACQAIRT|1|PTS_DOC_6535285||||0|0|0|0|Fonction d'accroche moniteur a l'evenement  AirT_SdlMid_AcqAirT|
AirT_SdlMid_AcqAirTAdc|A|();|SCH3.7|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur moyen
AirT_SdlMid_AcqAirTIf|E|();|SCH6.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur moyen du module d'interface|
AirT_SdlMid_AcqAirTIfAir|D|();|SCH1.12|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Moniteur de module d'interface.|
AirT_SdlMid_MonAirT|B|();|SCH.2|AIRTFONCDIAG|1|PTS_DOC_5070969||||0|0|0|0|Moniteur moyen de la fonction AirT|
AIRTFONCDIAG_vidBeforeStartCoh|C|();|FCT1.2|AIRTFONCDIAG|0|PTS_DOC_5070969||||0|0|0|0|Le test de cohérence avec la température d’eau avant démarrage est activé seulement si : 1) Le moteur est arrêté depuis suffisamment longtemps (via l’information reçu du calculateur EMF), 2) Le diagnostic n’est pas inhibé par le GAR.|
AIRTFONCDIAG_vidCohActivDtct|C|();|FCT1.3|AIRTFONCDIAG|0|PTS_DOC_5070969||||0|0|0|0|La détection du défaut revient à constater un écart entre la température d’air et la température d’eau suffisamment important.|
AIRTFONCDIAG_vidEntryInit|B|();|SCH.1|AIRTFONCDIAG|1|PTS_DOC_5070969||||0|0|0|0|Evènement Reset du module AIRTFONCDIAG.|
AIRTFONCDIAG_vidInitOutput|C|();|FCT1.1|AIRTFONCDIAG|0|PTS_DOC_5070969||||0|0|0|0|Fonction d'initialisation des variables internes de la spec.|
AIRTFONCDIAG_vidNegOfsActivDtct|C|();|FCT1.9|AIRTFONCDIAG|0|PTS_DOC_5070969||||0|0|0|0|La détection du défaut revient à tester si la valeur mesurée est en dessous du seuil minimum (calibrable) que doit normalement atteindre l’air dans les conditions d’activation du diagnostic.|
AIRTFONCDIAG_vidNegOfsDtct|D|();|FCT1.8|AIRTFONCDIAG|0|PTS_DOC_5070969||||0|0|0|0|Fonction qui décrit les conditions d'activation du test de l’offset négatif de la température d’admission d’air ( moteur démarré, vitesse véhicule faible, température d’eau élevée, moteur au ralenti, Le diagnostic n’est pas inhibé par le GAR.)|
AIRTFONCDIAG_vidOutRngActivDtct|B|();|FCT1.5|AIRTFONCDIAG|0|PTS_DOC_5070969||||0|0|0|0|La détection du défaut revient à tester avec 2 seuils calibrables (seuil Mini et seuil Maxi) si la valeur mesurée se trouve hors de la zone de fonctionnement normale.|
AIRTFONCDIAG_vidOutRngDtct|C|();|FCT1.4|AIRTFONCDIAG|0|PTS_DOC_5070969||||0|0|0|0|Le test de la valeur hors zone de la température d’admission d’air est activé seulement si le diagnostic n’est pas inhibé par le GAR.|
AIRTFONCDIAG_vidPosOfsActivDtct|B|();|FCT1.7|AIRTFONCDIAG|0|PTS_DOC_5070969||||0|0|0|0|La détection du défaut revient à tester si la valeur mesurée dépasse le seuil maximum (calibrable) que peut normalement atteindre l’air dans les conditions d’activation du diagnostic.|
AIRTFONCDIAG_vidPosOfsDtct|E|();|FCT1.6|AIRTFONCDIAG|0|PTS_DOC_5070969||||0|0|0|0|Le test de l’offset positif de la température d’admission d’air est activé seulement si : La vitesse véhicule est suffisamment élevée depuis un certain délai, le débit d’air massique d’air pompé par le moteur est suffisant, le diagnostic n’est pas inhibé.|
AIRTHRARCRKSP_vidCalcTqLoss|H|();|FCT1.6|AIRTHRARCRKSP|0|PTS_DOC_5074571||||0|0|0|0|Les pertes de couple suivantes sont transformés en surface papillon et prises en compte en structure couple débouclée : pertes accessoires, Pertes BVA, réserve de couple, adaptatif frottement.|
AIRTHRARCRKSP_vidCompAirDenGain|G|();|FCT1.2|AIRTHRARCRKSP|0|PTS_DOC_5074571||||0|0|0|0|En fonction de la température d’air et de la pression atmosphérique, on calcule une correction à apporter sur la section papillon en mode débouclé.|
AIRTHRARCRKSP_vidCompDtcFiCraOff|F|();|FCT1.3|AIRTHRARCRKSP|0|PTS_DOC_5074571||||0|0|0|0|Pour obtenir un profil de démarrage correct, on applique un offset de section Dtc_first_crank_offset.|
AIRTHRARCRKSP_vidCompDtcSection|G|();|FCT1.8|AIRTHRARCRKSP|0|PTS_DOC_5074571||||0|0|0|0|En fonction de la position pédale et de la température d’eau et d’huile et des différents consommateurs, une section efficace hors structure couple est calculée.|
AIRTHRARCRKSP_vidCompDtcTrCoSurf|C|();|FCT1.7|AIRTHRARCRKSP|0|PTS_DOC_5074571||||0|0|0|0|La cartographie Dtc_trans_couple_surf_map doit être calibrée précisément afin d’obtenir une régulation de ralenti correcte en mode recopie pédale.|
AIRTHRARCRKSP_vidEntryInit|D|();|SCH.1|AIRTHRARCRKSP|1|PTS_DOC_5074571||||0|0|0|0|Evènement reset|
AIRTHRARCRKSP_vidInitDelay|E|();|FCT1.4|AIRTHRARCRKSP|0|PTS_DOC_5074571||||0|0|0|0|initialisation.|
AIRTHRARCRKSP_vidInitOutput|D|();|FCT1.1|AIRTHRARCRKSP|0|PTS_DOC_5074571||||0|0|0|0|fonction d'initialisation des sorties|
AIRTHRARCRKSP_vidTimer|C|();|FCT1.5|AIRTHRARCRKSP|0|PTS_DOC_5074571||||0|0|0|0|decrementer la de delai du crank offset|
AIRTQEFF_vidCalc_afr_efficiency|B|();|FCT2.7|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Le rendement de richesse est issu d’une cartographie fonction de la richesse.|
AIRTQEFF_vidCalc_egr_efficiency|D|();|FCT2.9|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Le rendement d’EGR est issu d’une cartographie fonction du taux d’EGR|
AIRTQEFF_vidCalc_rendement|B|();|FCT1.6|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|La fonction est constituée de 3 blocs où sont calculées les valeurs des différents rendements|
AIRTQEFF_vidCalc_rendement_Afr|B|();|FCT1.8|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet de calculer la valeur du rendement de richesse|
AIRTQEFF_vidCalc_rendement_cyc|B|();|FCT1.7|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|La fonction est constituée de 6 blocs permettant de calculer le rendement de cycle|
AIRTQEFF_vidCalc_rendement_EGR|B|();|FCT1.9|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet de calculer la valeur initiale du rendement d’EGR|
AIRTQEFF_vidCalibration_1|B|();|FCT3.2|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_10|B|();|FCT4.1|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_11|B|();|FCT4.2|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_12|B|();|FCT4.3|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_13|B|();|FCT4.4|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_14|B|();|FCT4.5|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_2|B|();|FCT3.3|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_3|B|();|FCT3.4|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_4|B|();|FCT3.5|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_5|B|();|FCT3.6|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_6|B|();|FCT3.7|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_7|B|();|FCT3.8|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_8|B|();|FCT3.9|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibration_9|B|();|FCT3.10|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
AIRTQEFF_vidCalibrations|B|();|FCT2.3|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc regroupe les différentes calibrations de la fonction|
AIRTQEFF_vidCoordination_1|E|();|FCT2.6|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|La fonction permet de prendre en compte le mélange entre un carburant classique et du « Flex Fuel » ou du gaz. La fonction permet entre autre la gestion des différents modes de combustion par application d’un décalage/recalage (offset).|
AIRTQEFF_vidCoordination_2|D|();|FCT2.8|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet de coordonner les valeurs de rendement dans des cas de multi-carburation.|
AIRTQEFF_vidCoordination_3|E|();|FCT2.10|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet de coordonner les valeurs de rendement dans les cas de multi-carburation.|
AIRTQEFF_vidInit_afr_efficicency|B|();|FCT1.4|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet de calculer la valeur initiale du rendement de richesse|
AIRTQEFF_vidinit_egr_efficicency|C|();|FCT1.5|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet de calculer la valeur initiale du rendement d’EGR|
AIRTQEFF_vidInit_rendement|B|();|FCT1.2|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|La fonction est constituée de 3 blocs où sont calculés les valeurs initiales des différents rendements|
AIRTQEFF_vidInit_rendement_cycle|C|();|FCT1.3|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet de calculer la valeur initiale du rendement de cycle|
AIRTQEFF_vidInitOutput|D|();|FCT1.1|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Fonction d'initialisation des sorties des blocs dynamiques au reset|
AIRTQEFF_vidInterpolation|D|();|FCT2.5|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc calcul le rendement de cycle final à partir des 4 rendements de cycle correspondants à différents modes. Le calcul se fait à l’aide de 3 barycentres pilotés par des facteurs issus du gestionnaire de modes de combustion.|
AIRTQEFF_vidMode_Mask|B|();|FCT2.2|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet de sélectionner le numéro des cartographies utiles|
AIRTQEFF_vidSelect_Modes|C|();|FCT2.4|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet d’imposer les rendements de cycle en indexant les vecteurs des rendements de cycle au mode de fonctionnement appliqué.|
AIRTQEFF_vidUnvectorize_Mode|B|();|FCT2.1|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet de sélectionner les informations provenant du gestionnaire de modes de fonctionnements|
AIRTQEFF_vidUnvectorz_Activ_Bool|B|();|FCT3.1|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet de démultiplexer le flux de sélection des cartographies utiles|
AIRTQEFF_vidVectorz_Calibrations|C|();|FCT4.6|AIRTQEFF|0|V02 NT 10 07791||||0|0|0|0|Ce bloc permet de calculer le rendement de cycle à partir du couple calculé.|
AIRTQSTRUCTMNGT_StructState|I|();|FCT1.8|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|Le stateflow gère l’ensemble des passages entre le mode bouclé et débouclé.
AIRTQSTRUCTMNGT_vidCalcSecCrOffs|B|();|FCT1.2|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|cette fonction fait appel à AIRTQSTRUCTMGT_vidInitSecCrOffset et AIRTQSTRUCTMGT_vidCompDtcSecOffDel
AIRTQSTRUCTMNGT_vidCalObjPres|C|();|FCT1.6|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|Ce module calcule l’objectif de ratio de la pression collecteur ainsi q’un seuil à partir duquel on déboucle.
AIRTQSTRUCTMNGT_vidDtcSecOffDel|B|();|FCT1.4|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|décrementer la valeur de Dtc_second_crank_offset_delay.
AIRTQSTRUCTMNGT_vidFcDeTranToCyc|C|();|FCT2.2|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|calculer le coeficient Coef_de_transition_air dans l'état de bouclage.
AIRTQSTRUCTMNGT_vidFcSurfStart|F|();|FCT2.1|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|initialiser la valeur de Coef_de_transition_air au demarrage
AIRTQSTRUCTMNGT_vidFcTransToCycl|F|();|FCT2.3|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|On souhaite converger vers la structure couple, on calcule donc des coefficients qui permettent de filtrer les consignes.
AIRTQSTRUCTMNGT_vidFcTransToStop|A|();|FCT2.5|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|Lors d’une séquence d’arrêt, le coefficient de transition d’air prend une valeur calibrable spécifique à un arrêt STT.
AIRTQSTRUCTMNGT_vidFcTranToDecyc|B|();|FCT2.4|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|On calcule un coefficient de filtrage sur les consignes d’air et d’avance débouclées. Le booléen Manu_inh_dtc_filtrage_air permet de l’inhiber.
AIRTQSTRUCTMNGT_vidInitOutput|G|();|FCT1.1|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|initialisation des sorties
AIRTQSTRUCTMNGT_vidInitSecCrOffs|C|();|FCT1.3|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|cette fonction permet de calculer Dtc_second_crank_offset_delay à partir de la valeur de Temperature_eau.
AIRTQSTRUCTMNGT_vidManager|B|();|FCT1.5|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|2 sections effectives sont calculées suivant que l’on soit en ou hors structure couple.. Le passage filtré de l’une vers l’autre et géré par un stateflow (Manager) à l’aide de coefficients sur l’air et sur l’avance.
AIRTQSTRUCTMNGT_vidStructInit|D|();|FCT1.7|AIRTQSTRUCTMNGT|0|PTS DOC 5015877||||0|0|0|0|initialisation de l'état de la structure
ALDALTCOR_vidAlticor|A|();|FCT1.2|ALDALTCOR|0|V02 NT 11 02165||||0|0|0|0|Fonction de correction altimétrique de la charge en air.|
ALDALTCOR_vidEntryInit|A|();|SCH.1|ALDALTCOR|1|V02 NT 11 02165||||0|0|0|0|Evénement Reset|
ALDALTCOR_vidInitOutput|A|();|FCT1.1|ALDALTCOR|0|V02 NT 11 02165||||0|0|0|0|Fonction d'initialisation des sorties.|
ANGSCHED_vidDisable|A|(uint8 u8AngschedAlarm);|0x02|ANGSCHED|1|V03 NT 10 08984||||0|0|0|0||
ANGSCHED_vidEnable|A|(uint8 u8AngschedAlarm);|0x01|ANGSCHED|1|V03 NT 10 08984||||0|0|0|0||
ANGSCHED_vidInit|A|();|0x00|ANGSCHED|1|V03 NT 10 08984||||0|0|0|0||
ASIC_EveRst_diagasicgdi|C|();|SCH.1|DIAGASICGDI|1|PTS_DOC_6930924||||0|0|0|0|Evenement Reset pour le diagnostic de l'Asic Gdi|
ASIC_SdlFast_diagasicgdi|C|();|SCH.2|DIAGASICGDI|1|PTS_DOC_6930924||||0|0|0|0|Moniteur rapide pour le diagnostic ASIC GDI|
ASIC_SdlFast_diagasicgdiDiag|A|();|SCH.3|ACQDGOHAL_DT|1|PTS_DOC_6854092||||0|0|0|0|Fast scheduler for the ASIC GDI diagnosis|
AUTHSTRTSTT_vidCallMng|C|();|FCT1.2|AUTHSTRTSTT|0|PTS_DOC_6525148||||0|0|0|0|cette fonction sert a déclencher les evenement sous conditions|
AUTHSTRTSTT_vidDiagnostic|C|();|FCT1.5|AUTHSTRTSTT|0|PTS_DOC_6525148||||0|0|0|0|cette fonction spécifie L'état de la commande Ext_bInhCrkAltHw pour autoriser le diagnostic|
AUTHSTRTSTT_vidInhCrkAlt|B|();|FCT1.3|AUTHSTRTSTT|0|PTS_DOC_6525148||||0|0|0|0|On copie la demande d’inhibition du driver de démarrage par la safety, dans une variable interne à la fonction qui servira à construire la variable de pilotage du driver de redémarrage STT.|
AUTHSTRTSTT_vidInhCrkAltHw|C|();|FCT1.4|AUTHSTRTSTT|0|PTS_DOC_6525148||||0|0|0|0|cette fonction permet de Piloter l'actionneur d'autorisation de redémarrage STT|
AUTHSTRTSTT_vidInitialisation|C|();|FCT1.1|AUTHSTRTSTT|0|PTS_DOC_6525148||||0|0|0|0|L’état ouvert de la commande « autorisation redémarrage STT » correspond à la valeur 1|
AVRMISFCNT_vidCntMisfPerCycleCyl|B|();|FCT1.5|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0|In this function, for a duration of a driving cycle, the number of occurred misfires corresponding to each cylinder is calculated.|
AVRMISFCNT_vidEWMA_MisfireCalc|B|();|FCT2.2|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0| In this part, an exponential weighting moving average of misfires occurring is calculated for each cylinder for the last driving cycles.|
AVRMISFCNT_vidInitCntMisf|A|();|FCT1.2|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0|Before starting the engine (ECU On but engine stalled), the counter is set to the value saved in EEPROM.|
AVRMISFCNT_vidInitOutput|B|();|FCT1.1|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0|Fonction d'initialisation des variables de sorties.|
AVRMISFCNT_vidMisfCntCyl_1|B|();|FCT1.7|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0|The number of occurred misfires during the current driving cycle is calculated for the cylinder 1.|
AVRMISFCNT_vidMisfCntCyl_2|B|();|FCT1.8|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0|The number of occurred misfires during the current driving cycle is calculated for the cylinder 2.|
AVRMISFCNT_vidMisfCntCyl_3|B|();|FCT1.9|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0|The number of occurred misfires during the current driving cycle is calculated for the cylinder 3.|
AVRMISFCNT_vidMisfCntCyl_4|B|();|FCT1.10|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0|The number of occurred misfires during the current driving cycle is calculated for the cylinder 4.|
AVRMISFCNT_vidMisfDetectPerCyl|B|();|FCT1.6|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0|This function insures assignment of  detected misfire to the corresponding cylinder in order to increment the misfire counters.|
AVRMISFCNT_vidNumMisfirePerCycle|B|();|FCT2.1|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0|The total number of detected misfires during the current cycle is refreshed every misfire.|
AVRMISFCNT_vidReinit_Cnt_Misf|A|();|FCT1.4|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0| When a new driving cycle starts (CRANK To Run), the counter is set to zero.|
AVRMISFCNT_vidRstEWMAMisfireMod4|A|();|FCT1.3|AVRMISFCNT|0|V02 NT 11 05583||||0|0|0|0| Default erase by “mode 04” sets the EWMA to 0.|
BATTVOLTACQ_vidBattAcqOn2ms|C|();|FCT1.10|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Acquisition de la tension batterie toute les 2ms, sous condition d’activation de la stratégie : Pwr_bEnaEve2ms_C = 1. En sortie, on retrouve les 5 derniers échantillons.
BATTVOLTACQ_vidBattAcqOnEveInj|C|();|FCT1.9|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Acquisition de la tension batterie sur événement d’injection, sous condition d’activation de la stratégie :  Pwr_bEnaEveInj_C = 1.
BATTVOLTACQ_vidBattAcqReset|C|();|FCT1.2|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Acquisition de la tension batterie au Reset.
BATTVOLTACQ_vidBattDiag|D|();|FCT1.3|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Diagnostic défaut haut et bas de la tension batterie
BATTVOLTACQ_vidBattFil|E|();|FCT1.7|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Calcul de la tension batterie précédente
BATTVOLTACQ_vidBattFilt|C|();|FCT1.8|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Tension_batterie_filt est créé à partir d’un filtrage du premier ordre sur Tension_batterie.
BATTVOLTACQ_vidbattFiltMng|C|();|FCT2.1|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Avant chaque injection, une requête de boost est envoyée à la batterie. Ces emandes entraînent des chutes de tension.
BATTVOLTACQ_vidBattIni|D|();|FCT1.4|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Initialisation de la tension batterie.
BATTVOLTACQ_vidFilClcnAcv|D|();|FCT1.5|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Fonction du filtre anti-progression
BATTVOLTACQ_vidFilClcnVal|D|();|FCT1.6|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Calcul de la tension batterie filtrée
BATTVOLTACQ_vidInitOutput|D|();|FCT1.1|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Fonction d'initialisation
BATTVOLTACQ_vidWeightedAvr|C|();|FCT2.2|BATTVOLTACQ|0|PTS_DOC_6547150||||0|0|0|0|Moyenne pondérée  glissante sur 5 échantillons, avec une pondération calibrable. Les pondérations doivent être comprises entre 0 et 1et la somme des pondération doit être obligatoirement égale à 1.
BATTVOLTREQ_vidBattVltRqstLowVlt|A|();|FCT1.3|BATTVOLTREQ|0|V02 NT 11 04680||||0|0|0|0|This block describes the battery voltage boost request due to low battery voltage: BoostReq_bBattVoltReq|
BATTVOLTREQ_vidBattVoltRqstCond|A|();|FCT1.5|BATTVOLTREQ|0|V02 NT 11 04680||||0|0|0|0|This block describes conditions of battery voltage boost request due to low battery voltage.|
BATTVOLTREQ_vidInit|A|();|FCT1.2|BATTVOLTREQ|0|V02 NT 11 04680||||0|0|0|0|This block describes the initialization of the battery voltage boost request.|
BATTVOLTREQ_vidInitOutput|A|();|FCT1.1|BATTVOLTREQ|0|V02 NT 11 04680||||0|0|0|0|This block describes the initialization of the battery voltage boost request.|
BATTVOLTREQ_vidWasteMaxClsdCond|A|();|FCT1.4|BATTVOLTREQ|0|V02 NT 11 04680||||0|0|0|0|This block describes the boolean of the wastegate maximaly closed condition: BoostAct_bAcvTrbActMax|
BICD_vidDftStaCmdAcq|B|();|FCT1.4|BICD|0|PTS_DOC_6529336||||0|0|0|0|permet l'acquisition, la linéarisation et le filtration de l’information Etat BICD
BICD_vidDftStaCmdDiag|A|();|FCT1.5|BICD|0|PTS_DOC_6529336||||0|0|0|0|Autorisation des diagnostics et diagnostics de l’information Etat BICD
BICD_vidDftStaCmdInit|C|();|FCT1.1|BICD|0|PTS_DOC_6529336||||0|0|0|0|permet l'initialisation de la sortie.
BICD_vidDftStaCmdSelection|B|();|FCT1.8|BICD|0|PTS_DOC_6529336||||0|0|0|0|Consolidation de l’information Etat BICD
BICD_vidDiagInvalide|A|();|FCT1.7|BICD|0|PTS_DOC_6529336||||0|0|0|0|Autorisation des Diagnostics de l’information Etat BICD
BICD_vidDiagScpScp|B|();|FCT1.6|BICD|0|PTS_DOC_6529336||||0|0|0|0|Diagnostics de l’information Etat BICD
BICD_vidFastFunCall|A|();|FCT1.3|BICD|0|PTS_DOC_6529336||||0|0|0|0|Activation et Rafraîchissement de l’information Etat BICD.
BICD_vidInitOutput|C|();|FCT1.2|BICD|0|PTS_DOC_6529336||||0|0|0|0|initialisation des variables internes.
BLOWBYCMD_vidBlowBy1Cmd|C|();|FCT1.3|BLOWBYCMD|0|PTS_DOC_6563717||||0|0|0|0|Driver of BlowBy heater 1|
BLOWBYCMD_vidBlowBy2Cmd|B|();|FCT1.4|BLOWBYCMD|0|PTS_DOC_6563717||||0|0|0|0|Driver of BlowBy heater 2|
BLOWBYCMD_vidDiagBlowBy1|A|();|FCT1.5|BLOWBYCMD|0|PTS_DOC_6563717||||0|0|0|0|DGOHAL service generates signals defaults detected during the command of the BlowBy heater nbr 1|
BLOWBYCMD_vidDiagBlowBy2|A|();|FCT1.6|BLOWBYCMD|0|PTS_DOC_6563717||||0|0|0|0|DGOHAL service generates signals defaults detected during the command of the BlowBy heater nbr 2.|
BLOWBYCMD_vidHeaterCmd|A|();|FCT1.2|BLOWBYCMD|0|PTS_DOC_6563717||||0|0|0|0|This state machine generate the variable control of the heater BlowBy BlowByHw_bReq|
BLOWBYCMD_vidInit|B|();|FCT1.1|BLOWBYCMD|0|PTS_DOC_6563717||||0|0|0|0|The outputs variables are initialized on event reset|
BoostReq_EveIni_BattVoltReq|A|();|SCH.1|BATTVOLTREQ|1|V02 NT 11 04680||||0|0|0|0|Evénnement du Reset|
BoostReq_SdlFast_BattVoltReq|A|();|SCH.2|BATTVOLTREQ|1|V02 NT 11 04680||||0|0|0|0|Evènement 10 ms.|
Brk_EveRst_DiagBrkPed|D|();|SCH.1|DIAGBRKPED|1|PTS_DOC_6526884||||0|0|0|0|Fonction d'accroche à l'evenement Reset|
Brk_EveRst_DiagBrkPedNoBVH2p|A|();|SCH.1|DIAGBRKPEDNOBVH2P|1|V02 NT 10 02593||||0|0|0|0|Evènement reset du calculateur|
Brk_EveRst_MngBrkPed|C|();|SCH.1|MNGBRKPED|1|V02 NT 11 03796||||0|0|0|0|Evènement reset du calculateur|
Brk_SdlMid_BrkPedBVH2p|B|();|SCH.2|BRKPEDBVH2P|1|V02 NT 10 02615||||0|0|0|0|Moniteur moyen du diagnostic acquisition frein.|
Brk_SdlMid_DiagBrkPed|E|();|SCH.2|DIAGBRKPED|1|PTS_DOC_6526884||||0|0|0|0|Moniteur du diagnostic acquisition frein|
Brk_SdlMid_DiagBrkPedDio|A|();|SCH3.6|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Moniteur du diagnostic acquisition frein.
Brk_SdlMid_DiagBrkPedNoBVH2p|A|();|SCH.2|DIAGBRKPEDNOBVH2P|1|V02 NT 10 02593||||0|0|0|0|Moniteur du diagnostic acquisition frein|
Brk_SdlMid_MngBrkPed|C|();|SCH.2|MNGBRKPED|1|V02 NT 11 03796||||0|0|0|0|Moniteur du diagnostic acquisition frein|
Brk_SdlSfty_BrkPed|A|();|SCH.3|DIAGBRKPEDNOBVH2P|1|V02 NT 10 02593||||0|0|0|0|Evenement de lancement de diagnostic de défaut niveau 2.|
Brk_SdlSfty_BrkPedBVH2p|A|();|SCH.3|BRKPEDBVH2P|1|V02 NT 10 02615||||0|0|0|0|Moniteur du diagnostic niveau 2 acquisition frein.|
BRKASIACQ_vidBrkAsiAcq|E|();|FCT1.8|BRKASIACQ|0|PTS_DOC_6525171||||0|0|0|0|Fonction qui permet qu'en cas de défaut détecté (court-circuit à la masse ou au plus du capteur Mastervac) la valeur de la pression sera figée à sa dernière valeur calculée et prendra une valeur de refuge en cas de confirmation du défaut.|
BRKASIACQ_vidBrkAsiAcqBrut|E|();|FCT1.4|BRKASIACQ|0|PTS_DOC_6525171||||0|0|0|0|Fonction de transfert Tension Pression|
BRKASIACQ_vidCallMng|E|();|FCT1.3|BRKASIACQ|0|PTS_DOC_6525171||||0|0|0|0|Fonction d'appel conditionné pour le module BrkAsiAcq.|
BRKASIACQ_vidGrdDiagnostic|C|();|FCT1.7|BRKASIACQ|0|PTS_DOC_6525171||||0|0|0|0|Fonction qui énumère les différents court-circuits qui engendre un défaut sur le capteur Mastervac.|
BRKASIACQ_vidInitialization|E|();|FCT1.2|BRKASIACQ|0|PTS_DOC_6525171||||0|0|0|0|Initialisation au réveil calculateur de la valeur de pression d’air dans le mastervac.|
BRKASIACQ_vidInitOutput|D|();|FCT1.1|BRKASIACQ|0|PTS_DOC_6525171||||0|0|0|0|Fonction d'initialisation|
BRKASIACQ_vidMstrVacSensorDiag|D|();|FCT1.5|BRKASIACQ|0|PTS_DOC_6525171||||0|0|0|0|Cette fonction énumère les différents court-circuits (à la masse et au plus) qui engendre un défaut sur le capteur Mastervac|
BRKASIACQ_vidScDiagnostic|C|();|FCT1.6|BRKASIACQ|0|PTS_DOC_6525171||||0|0|0|0|Fonction qui énumère les différents court-circuits qui engendre un défaut sur le capteur Mastervac.|
BRKASIACQ_vidSftLvl2|B|();|FCT1.9|BRKASIACQ|0|PTS_DOC_6525171||||0|0|0|0|Ce bloc permet de répondre aux exigences de safety niveau 2 concernant le diagnostics électriques du capteur de pression mastervac|
BRKASIACT_vidActiv_Cond_Couple|B|();|FCT1.3|BRKASIACT|0|V02 NT 10 03258||||0|0|0|0|On utilise  ici des mesures de pression plénum en  fonction du couple moteur pour activer une assistance de  freinage.|
BRKASIACT_vidActiv_Cond_Veh|C|();|FCT1.2|BRKASIACT|0|V02 NT 10 03258||||0|0|0|0|On détermine ici les différentes conditions de roulage pour activer une assistance de freinage.|
BRKASIACT_vidAssistAC_ON|B|();|FCT2.3|BRKASIACT|0|V02 NT 10 03258||||0|0|0|0|sous etat Assistance_AC_ON du superviseur|
BRKASIACT_vidAssistALT_AC_ON|B|();|FCT2.4|BRKASIACT|0|V02 NT 10 03258||||0|0|0|0|sous etat Assistance_ALT_AC_ON du superviseur|
BRKASIACT_vidAssistALT_OFF_AC_ON|B|();|FCT2.5|BRKASIACT|0|V02 NT 10 03258||||0|0|0|0|sous etat Assistance_ALT_OFF_AC_ON du superviseur|
BRKASIACT_vidAssistALT_ON|B|();|FCT2.2|BRKASIACT|0|V02 NT 10 03258||||0|0|0|0|sous etat Assistance_ALT_ON du superviseur|
BRKASIACT_vidAssistALT_ON_AC_OFF|B|();|FCT2.6|BRKASIACT|0|V02 NT 10 03258||||0|0|0|0|sous etat Assistance_ALT_ON_AC_OFF du superviseur|
BRKASIACT_vidAssistOFF|B|();|FCT2.1|BRKASIACT|0|V02 NT 10 03258||||0|0|0|0|Sous etat Assistance_OFF du superviseur|
BRKASIACT_vidEntryInit|B|();|SCH.1|BRKASIACT|1|V02 NT 10 03258||||0|0|0|0|evenement d'initialisation|
BRKASIACT_vidInitOutput|B|();|FCT1.1|BRKASIACT|0|V02 NT 10 03258||||0|0|0|0|initialisation des sorties|
BRKASIACT_vidSF_supervise_BrkAsi|B|();|FCT1.5|BRKASIACT|0|V02 NT 10 03258||||0|0|0|0|Le superviseur fait la priorité sur les actions en fonctions de la situation demandée. Les actions d’assistance vis-à-vis des accessoires sont maintenues pendant un temps fini calibrable.|
BRKASIACT_vidSuperviseur|B|();|FCT1.4|BRKASIACT|0|V02 NT 10 03258||||0|0|0|0|Le superviseur fait la priorité sur les actions en fonctions de la situation demandée. Les actions d’assistance vis-à-vis des accessoires sont maintenues pendant un temps fini calibrable.|
BRKASIFONCDIAG_vidActivateDetect|C|();|FCT1.3|BRKASIFONCDIAG|0|V02 NT 09 04714||||0|0|0|0|La détection du défaut revient à constater une dépression Mastervac trop importante.|
BRKASIFONCDIAG_vidEntryInit|B|();|SCH.1|BRKASIFONCDIAG|1|V02 NT 09 04714||||0|0|0|0|Fonction d'accroche au reset.|
BRKASIFONCDIAG_vidInitOutput|A|();|FCT1.1|BRKASIFONCDIAG|0|V02 NT 09 04714||||0|0|0|0|Fonction d'initialisation des parametres produits.|
BRKASIFONCDIAG_vidRun|C|();|FCT1.2|BRKASIFONCDIAG|0|V02 NT 09 04714||||0|0|0|0|Le test de cohérence du capteur de dépression Mastervac est activé seulement si: Moteur tournant autonome, Le frein est en position appuyé (avec une pression collecteur raisonnable) depuis un certain temps, Le diagnostic n’est pas inhibé par le GAR.|
BRKPEDBVH2P_vidClutchPedalEdge|A|();|FCT1.5|BRKPEDBVH2P|0|V02 NT 10 02615||||0|0|0|0|Ce bloc permet d’initialiser le passage de Ext_bCluPedPrss de « pédale embrayage appuyée » à « pédale embrayage relachée »|
BRKPEDBVH2P_vidCounter|B|();|FCT1.3|BRKPEDBVH2P|0|V02 NT 10 02615||||0|0|0|0|Temporisation sur changement de rapport|
BRKPEDBVH2P_vidDiagnostic|C|();|FCT1.6|BRKPEDBVH2P|0|V02 NT 10 02615||||0|0|0|0|Ce bloc spécifie les défauts incohérence BVH2’ en accélération et en décélération|
BRKPEDBVH2P_vidDiagnostic_niv2|A|();|FCT1.7|BRKPEDBVH2P|0|V02 NT 10 02615||||0|0|0|0|Ce diagnostic niveau est crée à partir d’un défaut detecté par le niveau 2|
BRKPEDBVH2P_vidEntryInit|B|();|SCH.1|BRKPEDBVH2P|1|V02 NT 10 02615||||0|0|0|0|Evenement reset du calculateur.|
BRKPEDBVH2P_vidEventGeneration|A|();|FCT1.2|BRKPEDBVH2P|0|V02 NT 10 02615||||0|0|0|0|La fonction diagnostic BVH2’ est inhibée par flux de contrôle ou quand on est en phase de vie Réveil principal mode intégration électronique.|
BRKPEDBVH2P_vidGearRatioChgEdge|B|();|FCT1.4|BRKPEDBVH2P|0|V02 NT 10 02615||||0|0|0|0|Ce bloc permet d’initialiser le passage de Tra_bSIP de « changement en cours » à « pas de changement en cours »|
BRKPEDBVH2P_vidInitOutput|C|();|FCT1.1|BRKPEDBVH2P|0|V02 NT 10 02615||||0|0|0|0|initialisation des sorties|
BswM_Dcm_RequestResetMode|I|(argin Dcm_ResetModeType RequestedMode);|Dcm.2|BSWM_DCM|1|PTS_DOC_5074345||||0|0|0|0|Function called by DCM to request a reset of the ECU.|
BswM_Dcm_RequestSessionMode|J|(argin Dcm_SesCtrlType RequestedMode);|Dcm.1|BSWM_DCM|1|PTS_DOC_5074345||||0|0|0|0|Function called by DCM to request diagnostic modes.|
BufNEs_EveCgt_BufNEs|A|();|SCH.2|BUFNES|1|V02 NT 11 01163||||0|0|0|0|Moniteur du module BUFNES|
BUFNES_vidActivateCalcBufRecord|A|();|FCT1.3|BUFNES|0|V02 NT 11 01163||||0|0|0|0|This block disables the function calculation, if the engine speed is higher than a threshold|
BufNEs_vidEntryInit|A|();|SCH.1|BUFNES|1|V02 NT 11 01163||||0|0|0|0|Evenement Reset|
BUFNES_vidGlobal_View|A|();|FCT1.2|BUFNES|0|V02 NT 11 01163||||0|0|0|0|This block records the crankshaft tooth duration in a buffer|
BUFNES_vidInitOutput|A|();|FCT1.1|BUFNES|0|V02 NT 11 01163||||0|0|0|0|Initialisation des sorties|
BUFNES_vidRcrdCrankshafToothDrt|A|();|FCT1.4|BUFNES|0|V02 NT 11 01163||||0|0|0|0|This block creates several variables:  A buffer of the crankshaft teeth, A number of the valid elements recorde, The index of the last recorded element|
BUFNES_vidRplceOutptIfCalcDisabl|A|();|FCT1.5|BUFNES|0|V02 NT 11 01163||||0|0|0|0|This block disables the valid elements recorded in the buffer, if the engine speed is higher than a threshold|
CAMHAL_udtEnableDetection|A|func_CAMHAL_udtEnableDetection|0x0F|HEADER|1|NONE||||0|0|0|0|
CAMHAL_udtEnableSynchronisation|A|func_CAMHAL_udtEnableSynchron|2|HEADER|1|NONE||||0|0|0|0|
CAMHAL_udtReadEventPosition|A|func_CAMHAL_udtReadEventPos|0x10|HEADER|1|NONE||||0|0|0|0|
CAMHAL_udtReadSignalLevel|A|func_CAMHAL_udtReadSignalLevel|0x13|HEADER|1|NONE||||0|0|0|0|
CAMHAL_udtReadStatus|A|func_CAMHAL_udtReadStatus|0x07|HEADER|1|NONE||||0|0|0|0|
CAMHAL_udtReadToothPeriod|A|func_CAMHAL_udtReadToothPeriod|0x12|HEADER|1|NONE||||0|0|0|0|
CAMHAL_vidInit|A|();|0x00|HEADER|1|NONE||||0|0|0|0||
CAMHAL_vidSetMode|A|(argin CAMHAL_tudtChannel udtChannelName, argin CAMHAL_tenuMode enuMode);|0x06|HEADER|1|NONE||||0|0|0|0|
CAMHAL_vidSetTrueEdgePos|A|(argin CAMHAL_tudtChannel udtChannelName, argio uint16 *pau16CamEdgePositionTable);|5|HEADER|1|NONE||||0|0|0|0||
Can_DisableControllerInterrupts|A|(argin uint8 CAN_Channel);|16|HEADER|1|NONE||||0|0|0|0|
Can_EveRst_CanTxMixMod|A|();|SCH.1|CANTXMIXMOD|1|PTS_DOC_5708641||||0|0|0|0|Evénement reset du calculateur.
Can_EveRst_DftLiMsgMgt|A|();|SCH.1|DFTLIMSGMGT|1|V02 NT 11 02272||||0|0|0|0|Evénement reset du calculateur
Can_EveRst_FHCanF349_FlowMng|A|();|SCH2.6|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evènement reset de l'ECU|
Can_EveRst_FHCanF349If_2|C|();|SCH2.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reset de l'ECU.|
Can_EveRst_FHCanF34DIf|A|();|SCH.1|IFADV|1|V02 NT 11 07695||||0|0|0|0|Evénement reset du calculateur|
Can_EveRst_FHCanF3C9If|C|();|SCH10.10|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reset de l'ECU.|
Can_EveRst_FHCanF432If|E|();|SCH3.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement reset lie au CAN|
Can_EveRst_FHCanF495If|C|();|SCH3.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement reset lie au CAN.|
Can_EveRst_FHCanF50EIf2|B|();|SCH1.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reset de l'ECU|
Can_EveRst_FHCanF552_FlowMng|A|();|SCH2.7|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evénement reset de l'ECU|
Can_EveRst_FHCanF592If|F|();|SCH3.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement reset lié au CAN|
Can_EveRst_FHCanF612If|C|();|SCH3.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Event reset lie au CAN|
Can_EveRxn0E0_IsCan|A|();|1|HEADER|1|NONE||||0|0|0|0|
Can_EveRxn30D_FHCanF30DIf|E|();|SCH13.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evnement de rception de la trame 30D|
Can_EveRxn349_FHCanF349_FlowMng|B|();|SCH1.9|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement de reception de la trame 349.|
Can_EveRxn349_FHCanF349If_2|C|();|SCH2.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement de reception de la trame 349.|
Can_EveRxn34D_FHCanF34DAVIf|C|();|SCH17.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement d'interface (réception de trame 34Dh).|
Can_EveRxn34D_FHCanF34DIf|A|();|SCH.2|IFADV|1|V02 NT 11 07695||||0|0|0|0|Evénement d'interface (réception de trame 34Dh).|
Can_EveRxn34D_FHCanF34DIf2|B|();|SCH4.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement de réception de trame 34Dh|
Can_EveRxn34D_IsCan|A|();|1|HEADER|1|NONE||||0|0|0|0|
Can_EveRxn38D_FHCanF38DIf|E|();|SCH13.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement de réception de la trame 38Dh|
Can_EveRxn3C9_FHCanF3C9If|C|();|SCH12.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement de réception de la trame 3C9|
Can_EveRxn412_CohCan|B|();|SCH.5|COHCAN|1|V02 NT 12 00919||||0|0|0|0|Evnement de rception de la trame 412|
Can_EveRxn432_FHCanF432If|D|();|SCH16.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement de réception de trame CAN|
Can_EveRxn489_FHCanF489_FlowMng|B|();|SCH2.1|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement de reception de la trame 489.|
Can_EveRxn495_FHCanF495If|D|();|SCH17.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement de réception de la trame 495h.|
Can_EveRxn4F2_FHCanF4F2AVIf|C|();|SCH3.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evnement de rception de la trame 4F2|
Can_EveRxn50E_CohCan|B|();|SCH.6|COHCAN|1|V02 NT 12 00919||||0|0|0|0|Evnement de rception de la trame 50E|
Can_EveRxn50E_FHCanF50EIf2|B|();|SCH6.9|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evnement de rception de la trame 50E|
Can_EveRxn552_FHCanF552_FlowMng|B|();|SCH2.4|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement de reception de la trame 552.|
Can_EveRxn572_CohCan|B|();|SCH.4|COHCAN|1|V02 NT 12 00919||||0|0|0|0|Evénement de réception de la trame 572h|
Can_EveRxn592_FHCanF592If|E|();|SCH15.9|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement de réception de trames CAN|
Can_EveRxn5B2_CohCan|B|();|SCH.3|COHCAN|1|V02 NT 12 00919||||0|0|0|0|Evénement de réception de la trame 5B2h|
Can_EveRxn5B2_TiEngStop|A|();|SCH.9|TIENGSTOP|1|PTS_DOC_5329313||||0|0|0|0|Evènement de réception de la trame CAN 5B2.|
Can_EveRxn612_FHCanF612If|B|();|SCH14.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evnement de rception de la trame 612.|
Can_EveRxn7F2_CohCan|B|();|SCH.2|COHCAN|1|V02 NT 12 00919||||0|0|0|0|Evénement de réception de la trame 7F2h|
Can_EveRxn7F2_FHCanF7F2_FlowMng|B|();|SCH2.5|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement de reception de la trame 7F2.|
Can_EveRxn7F2_FHCanF7F2AVIf|C|();|SCH17.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement de réception de la trame 7F2h.|
Can_EveRxn7F2_TiEngStop|A|();|SCH.10|TIENGSTOP|1|PTS_DOC_5329313||||0|0|0|0|Evènement de réceprion de la trame CAN 7F2.|
Can_EveSaimmo_TxFrame072|A|();|HD_6|HEADER|1|HEADER||||0|0|0|0||
Can_EveSaimmo_TxFrame0E8|A|();|HD_5|HEADER|1|HEADER||||0|0|0|0||
Can_EveTxn1E8_CanTxMixMod|A|();|2|HEADER|1|PTS_DOC_5708641||||0|0|0|0|Demande d'envoi de la trame 1E8h.
Can_EveTxn468_CanTxMixMod|A|();|1|HEADER|1|NONE||||0|0|0|0|Demande d'envoi de la trame 468h.
Can_Init|A|(argin const Lin_ConfigType * Config);|1|HEADER|1|NONE||||0|0|0|0|
Can_MainFunction_BusOff|A|();|23|HEADER|1|NONE||||0|0|0|0|
Can_MainFunction_Read|A|();|22|HEADER|1|NONE||||0|0|0|0|
Can_MainFunction_Write|A|();|21|HEADER|1|NONE||||0|0|0|0|
Can_SdlFast_CanTxMixMod|A|();|SCH.2|CANTXMIXMOD|1|PTS_DOC_5708641||||0|0|0|0|Moniteur rapide.
Can_SdlFast_FHCanF34DIf|A|();|SCH.3|IFADV|1|V02 NT 11 07695||||0|0|0|0|Moniteur rapide de la fonction FHCANF34D|
Can_SdlMid_DftLiMsgMgt|A|();|SCH.2|DFTLIMSGMGT|1|V02 NT 11 02272||||0|0|0|0|Moniteur moyen de la fonction
Can_SdlSlow_CanTxMixMod|A|();|SCH.3|CANTXMIXMOD|1|PTS_DOC_5708641||||0|0|0|0|Moniteur lent.
Can_SdlSlow_FHCanF349_FlowMng|B|();|SCH2.3|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Moniteur lent pour la fonction FH CAN F349h.|
Can_SdlSlow_FHCanF349If_2|C|();|SCH3.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur lent pour la fonction FH CAN F349h.|
Can_SdlSlow_FHCanF38DIf|C|();|SCH2.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur lent pour la fonction FH CAN F38Dh|
Can_SdlSlow_FHCanF3C9If|C|();|SCH12.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur lent pour la fonction FH CAN F3C9h|
Can_SdlSlow_FHCanF432If|D|();|SCH16.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement slow lié au CAN|
Can_SdlSlow_FHCanF495If|B|();|SCH18.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur lent pour la fonction FH CAN F495h .|
Can_SdlSlow_FHCanF592If|D|();|SCH12.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur lent pour la fonction FH CAN F592h.|
Can_SdlSlow_FHCanF612If|B|();|SCH14.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur lent pour la fonction FH CAN F612h .|
CanIf_Init|A|(uint16 *pu16Aks);|3|HEADER|1|NONE||||0|0|0|0|
CanSecuCalcChecksum|A|(argin uint8 CHKini, argin const uint8 DataFrame[], argin uint8 Size, argout uint8 *Result);|1.2|CANSECUCHKDATA|1|V02 NT 09 05149||||0|0|0|0|Cette fonction calcule la valeur que doit prendre le quartet du checksum dans la trame.
CanSecuChkData|A|(argin uint8 CHKini, argin const uint8 DataFrame[], argin uint8 Size, argout uint8 *Result, argout boolean *Chk_ok);|1.1|CANSECUCHKDATA|1|V02 NT 09 05149||||0|0|0|0|Cette fonction calcul la somme des quartets d’une trame plus une constante d’initialisation modulo 16. Une trame vérifiant cette cohérence rendra toujours un résultat de Fh.
CanSM_Init|A|(uint16 *pu16Can);|5|HEADER|1|NONE||||0|0|0|0|
CanSM_MainFunction|A|();|27|HEADER|1|NONE||||0|0|0|0|
CanTp_Init|A|(argin const CanTp_ConfigType *CfgPtr);|17|HEADER|1|NONE||||0|0|0|0|
CanTp_MainFunction|A|();|28|HEADER|1|NONE||||0|0|0|0|
CANTXMIXMOD_vidFastCheck|A|();|FCT1.2|CANTXMIXMOD|0|PTS_DOC_5708641||||0|0|0|0|Après rafraichissement des flux CoOptmEl_stElEProv, CoPtUH_bRStrtAnt et CoEmSTT_stTypEmPredRstrt récurrence 10ms,  cette fonction permet de déclencher une émission de la trame  468h et/ou 1E8h.
CANTXMIXMOD_vidInitOutput|A|();|FCT1.1|CANTXMIXMOD|0|PTS_DOC_5708641||||0|0|0|0|Cette fonction permet l'initialisation des variables CANTXMIXMOD_bCoPtUHbRStrtAntPrev, CANTXMIXMOD_u8CoOptmElstElEPrev et CANTXMIXMOD_bThMgtbPosnFSFPrev.
CANTXMIXMOD_vidSlowCheck|A|();|FCT1.3|CANTXMIXMOD|0|PTS_DOC_5708641||||0|0|0|0|Après rafraichissement du flux ThMgt_bPosnFSF  à récurrence 1000ms,  cette fonction permet de déclencher une émission de de la trame 1E8h.
CATAGIESTIM_vidAgiCata|C|();|FCT1.2|CATAGIESTIM|0|V02 NT 08 07305||||0|0|0|0|Optimisation des fonctions régulation de richesse et double boucle en fonction du vieillissement catalyseur
CATAGIESTIM_vidEntryInit|C|();|SCH.1|CATAGIESTIM|1|V02 NT 08 07305||||0|0|0|0|Initalisation des outputs
CATAGIESTIM_vidInitOutput|C|();|FCT1.1|CATAGIESTIM|0|V02 NT 08 07305||||0|0|0|0|Initialisation des outputs
CatMdl_SdlSlow_EstimAgi|C|();|SCH.2|CATAGIESTIM|1|V02 NT 08 07305||||0|0|0|0|Moniteur lent de la fonction estimation vieillissement cata
CatMon_EveRst_CatAcvDiagIf|B|();|SCH1.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset du calculateur.|
CatMon_EveRst_CatMonIf|B|();|SCH.1|CATMONIF|1|V02 NT 12 04035||||0|0|0|0|Evenement reset|
CatMon_SdlFast_CatAcvDiagIf|B|();|SCH18.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide de la fonction CatMon.|
CatMon_SdlFast_CatAcvDiagIf2|A|();|SCH.4|IFFAR|1|V02 NT 12 01358||||0|0|0|0|Moniteur du module d'interface en aval du CatMon|
CatMon_SdlMid_CatMonIf|B|();|SCH.2|CATMONIF|1|V02 NT 12 04035||||0|0|0|0|Moniteur moyen de la fonction CatMonIf|
CATMONIF_vidCatMonIf|C|();|FCT1.2|CATMONIF|0|V02 NT 12 04035||||0|0|0|0|cette fonction réaliser pour des variables d’entrée du diagnostic catalyseur passif et actif|
CATMONIF_vidInit|C|();|FCT1.1|CATMONIF|0|V02 NT 12 04035||||0|0|0|0|Fonction initialise les sorties du module.|
Cf_EvePwrl_FlowMng|E|();|SCH1.6|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Fonction d'accroche à l'événement power latch|
Cf_EveRst_AirTFlowMng|B|();|SCH1.2|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Reset event of the external temprature.|
Cf_EveRst_CtrlCfg|D|();|SCH.1|CTRLCFG|1|PTS_DOC_5068500||||0|0|0|0|Event reset|
Cf_EveRst_CtrlCfgIf|B|();|SCH6.10|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset|
Cf_EveRst_FlowMngAlt|A|();|SCH2.8|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement reset pour l'alternateur|
Cf_EveRst_FlowMngBatt|A|();|SCH2.9|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement reset pour la tension batterie|
Cf_EveRst_FlowMngBrk|A|();|SCH3.1|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement reset pour la pedale de frein|
Cf_EveRst_FlowMngBrkAsi|A|();|SCH3.2|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement reset pour le mastervac|
Cf_EveRst_FlowMngClu_1|A|();|SCH3.3|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement de reset de la pedale d'embrayage|
Cf_EveRst_FlowMngClu_2|A|();|SCH3.4|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement de reset de la pedale d'embrayage|
Cf_EveRst_FlowMngDayCt|A|();|SCH3.5|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement reset pour le compteur|
Cf_EveRst_FlowMngGear|A|();|SCH3.6|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement reset de la fonction gear|
Cf_EveRst_FlowMngGmv|A|();|SCH3.7|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement reset pour la sous fonction GMV|
Cf_EveRst_FlowMngIf|C|();|SCH1.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset du calculateur .|
Cf_EveRst_FlowMngOilPres|A|();|SCH3.8|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement reset pour la fonction pression huile|
Cf_EveRst_FlowMngPedPrss|A|();|SCH3.9|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement reset de la pedale de frein|
Cf_EveRst_FlowMngPwt|A|();|SCH4.1|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement reset de la fonction powertrain|
Cf_EveRst_FlowMngTqSel|A|();|SCH4.2|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement de reset de la fonction couple|
Cf_EveRst_FuPmp|A|();|SCH5.1|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evenement reset pour la fonction FuPmp|
Cf_EveRst_NoProd|A|();|SCH.1|NOPROD|1|V02 NT 10 01758||||0|0|0|0|Evénement RESET pour l' initialisation des  variables non produites
Cf_EveRst_TunCfg|E|();|SCH.1|TUNCFG|1|PTS_DOC_5304544||||0|1|0|0|Evénement reset du calculateur|
Cf_EveRxn552_FlowMng|C|();|SCH1.7|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evénement de réception de la trame 552.|
Cf_EveRxn552bis_FlowMng|B|();|SCH1.8|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evénement de réception de la trame 552bis|
Cf_EveTele_TunCfg|B|();|SCH.2|TUNCFG|1|PTS_DOC_5304544||||0|1|0|0|Evénement télécodage|
Cf_EveTele_TunCfg_FlowMng|B|();|SCH2.2|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evénement télécodage.|
Cf_EveTele_TunCfgIf|B|();|SCH6.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement télécodage|
Cf_FuPmp_EveKOn_Mng|A|();|SCH5.2|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON|
Cf_FuPmp_EveStTR_Mng|A|();|SCH5.3|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant|
Cf_SdlFast_CtrlCfg|D|();|SCH.2|CTRLCFG|1|PTS_DOC_5068500||||0|0|0|0|Fast monitoring|
Cf_SdlFast_CtrlCfgIf|B|();|SCH7.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide|
Cf_SdlFast_FlowMngAlt|A|();|SCH4.3|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Scheduler rapide pour l'alternateur|
Cf_SdlFast_FlowMngBatt|A|();|SCH4.4|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Scheduler rapide pour la tension batterie|
Cf_SdlFast_FlowMngBrk|A|();|SCH4.5|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Scheduler rapide pour la pedale de frein|
Cf_SdlFast_FlowMngBrkAsi|A|();|SCH4.6|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Scheduler rapide pour le mastervac|
Cf_SdlFast_FlowMngClu_1|A|();|SCH4.7|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Fast clutch monitoring|
Cf_SdlFast_FlowMngClu_2|A|();|SCH4.8|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Fast clutch monitoring|
Cf_SdlFast_FlowMngGear|A|();|SCH4.9|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Scheduler rapide de la fonction gear|
Cf_SdlFast_FlowMngIf|B|();|SCH16.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Scheduler rapide da la fonction FlowMng.|
Cf_SdlFast_FlowMngOilPres|A|();|SCH1.3|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Scheduler rapide pour la fonction pression huile|
Cf_SdlFast_FlowMngPedPrss|A|();|SCH4.10|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Scheduler rapide de la pedale de frein|
Cf_SdlFast_FlowMngPwt|A|();|SCH1.4|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Scheduler rapide de la fonction powertrain|
Cf_SdlFast_FuPmp|A|();|SCH5.4|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Moniteur rapide de la fonction pompe à essence|
Cf_SdlMid_FlowMngGmv|A|();|SCH1.10|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Scheduler moyen pour la sous fonction GMV|
Cf_SdlMid_FlowMngIf|B|();|SCH11.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Scheduler moyen da la fonction FlowMng .|
Cf_SdlMid_FlowMngTAir|A|();|SCH2.10|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Scheduler moyen pour la sous fonction TAie|
Cf_SdlMid_FlowMngTOil|A|();|SCH3.10|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Scheduler moyen pour la sous fonction TOil|
Cf_SdlSlow_FlowMng|D|();|SCH1.5|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Slow monitor of the FlowMng function|
Cf_SdlSlow_IfAirSys|A|();|SCH2.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur lent pour la fonction|
Cf_SdlSlow_NoProd|A|();|SCH.2|NOPROD|1|V02 NT 10 01758||||0|0|0|0|Evénement lent de mise à jour des variables non produites .
Cf_SdlSlow_TunCfg|B|();|SCH.3|TUNCFG|1|PTS_DOC_5304544||||0|1|0|0|Moniteur lent pour la fonction configuration moteur|
CHAADVMINUNLIM_vidASRReg|D|();|FCT1.8|CHAADVMINUNLIM|0|V02 NT 11 05440||||0|0|0|0|Cette fonction élabore la demande d’activation ASR sécuritaire lors de l’activation de l’ASR moteur.
CHAADVMINUNLIM_vidASRSecuReq|A|();|FCT1.6|CHAADVMINUNLIM|0|V02 NT 11 05440||||0|0|0|0|Fonction de demande d'activation d'ASR sécuritaire .
CHAADVMINUNLIM_vidESPReg|A|();|FCT1.7|CHAADVMINUNLIM|0|V02 NT 11 05440||||0|0|0|0|Demande d’activation d’ASR sécuritaire en contrôle de lacet
CHAADVMINUNLIM_vidEventMs|B|();|FCT1.3|CHAADVMINUNLIM|0|V02 NT 11 05440||||0|0|0|0|L’automate « EventSelc » permet de créer un événement à 10ms à partir d’un événement à 5ms.
CHAADVMINUNLIM_vidInit|A|();|FCT1.4|CHAADVMINUNLIM|0|V02 NT 11 05440||||0|0|0|0|Initialisation des sorties.
CHAADVMINUNLIM_vidInitOutput|B|();|FCT1.1|CHAADVMINUNLIM|0|V02 NT 11 05440||||0|0|0|0|Initialisation du timer.
CHAADVMINUNLIM_vidRearWheelSpeed|A|();|FCT1.5|CHAADVMINUNLIM|0|V02 NT 11 05440||||0|0|0|0|Cette fonction permet la production de la moyenne des vitesses des roues arrières, issues du CAN.
CHAADVMINUNLIM_vidRstSelc|A|();|FCT1.2|CHAADVMINUNLIM|0|V02 NT 11 05440||||0|0|0|0|Fonction reset EventSelc
CHATQAIRCORD_vidCalcConsigRegASR|F|();|FCT1.2|CHATQAIRCORD|0|PTS_DOC_5139605||||0|0|0|0|Cette fonction calcule la consigne de couple AIR lors de la régulation ASR et le nombre de cylindre autorisé à couper|
CHATQAIRCORD_vidEntryInit|F|();|SCH.1|CHATQAIRCORD|1|PTS_DOC_5139605||||0|0|0|0|Fonction d'accroche au Reset.|
CHATQAIRCORD_vidInitOutput|E|();|FCT1.1|CHATQAIRCORD|0|PTS_DOC_5139605||||0|0|0|0|Initialisation des variables de sortie.|
CKMNGIF_vidAcqui_duree_dent|A|();|FCT1.6|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|La durée dent est utilisée pour le calcul des angles de phasage des injections. Elle est calculée sur événement PMH, moteur  calé vers moteur tournant ou sur moteur synchro.
CKMNGIF_vidBdcTreatment|B|();|FCT3.5|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Fonction qui déclenche le  calcul du régime moteur au PMB .
CKMNGIF_vidCalcBdcEngSpd|D|();|FCT3.6|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Fonction de calcul du régime moteur au PMB
CKMNGIF_vidCountPmh|C|();|FCT2.3|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Le compteur_de_pmh est incrémenté à chaque événement PMH.
CKMNGIF_vidDiagEngFail|E|();|FCT3.1|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Fonction de diagnostic de deux pannes sur le régime moteur : Panne Régime trop haut et Panne  Accélération  trop  forte
CKMNGIF_vidEnginePeriodFind|H|();|FCT2.5|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Le LdB fournit au LdA le compteur de PMH phasé et modulo le nombre de cylindres
CKMNGIF_vidEnginePeriodMeasure|F|();|FCT2.4|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Le LdA récupère du LdB la valeur de la période moteur tous les événements PMH. dans le cas du 1er PMH, le LdB évalue la période moteur à partir de la durée dent.
CKMNGIF_vidEngineRotDetection|B|();|FCT1.4|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Mettre la variable Sync_bRotDetEng à 1
CKMNGIF_vidEngineRotNoDetection|B|();|FCT1.5|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Mettre la variable Sync_bRotDetEng à 0
CKMNGIF_vidEngineSpeedCalc|H|();|FCT2.7|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|A chaque point mort haut combustion, l'applicatif réceptionne la période moteur qui est  convertie ensuite en régime moteur.
CKMNGIF_vidEngineSpeedDerivCalc|B|();|FCT2.9|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Cette fonction permet de calculer Engine_speed_derivate et Ext_aEng
CKMNGIF_vidFiltEngineSpeedCalc|C|();|FCT2.8|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Fonction qui produit le régime moteur filtré
CKMNGIF_vidInitOutput|I|();|FCT1.1|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|La recherche de la singularité de la roue dentée par le composant LDB CRKHAL doit être activée au reset
CKMNGIF_vidNoExCyl|G|();|FCT3.4|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Ce bloc permet de produire, à récurrence temporelle et moteur synchronisé, les informations « numéro du cylindre en phase d’échappement » et « numéro du prochain cylindre en phase d’échappement ».
CKMNGIF_vidPeriodeCyl|F|();|FCT2.6|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Fonction qui permet de fournir le numéro du cylindre en phase de compression et admission
CKMNGIF_vidPhaseCylEch|C|();|FCT3.2|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Fonction permettant  d'obtenir la position angulaire du vilebrequin
CKMNGIF_vidRunToStall|F|();|FCT1.2|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Initialisation des sorties sur passage de l'etat tournant cale
CKMNGIF_vidStallToRun|D|();|FCT1.3|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Initialisation des sorties sur passage de l'etat cale tournant
CKMNGIF_vidSynchroFound|G|();|FCT2.1|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Fonction qui permet la reconnaissance  tardive  d'un  calage moteur  par  la  clé
CKMNGIF_vidTDCTreatment|D|();|FCT2.2|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Fonction de traitement PMH
CKMNGIF_vidToothCylEch|F|();|FCT3.3|CKMNGIF|0|PTS_DOC_6884590||||0|0|0|0|Une fois le moteur synchronisé, le LdA fait un appel au LdB via l’API CRKHAL pour obtenir la position angulaire du vilebrequin dont la référence (0 °Vil) est pour  rappel à l’événement PMH du cylindre 1
CLCNFISAGAIN_vidAllowedWrite|E|();|FCT1.3|CLCNFISAGAIN|0|V02 NT 08 04650||||0|0|0|0|La valeur de FISA_facAdp est stockée en mémoire non volatile au powerlatch si l'autorisation de sauvegarde est donnée par le superviseur (FISA_bAuthSave à 1
CLCNFISAGAIN_vidCalculCoeff|D|();|FCT1.2|CLCNFISAGAIN|0|V02 NT 08 04650||||0|0|0|0|Cette fonction permet le calcul des corrections strictement nécessaires aux réglages de bases d’enrichissements au démarrage, post démarrage et réchauffage moteur à partir de la valeur du coefficient de qualité carburant calculé au sein de FISA.
CLCNFISAGAIN_vidEntryInit|A|();|SCH.1|CLCNFISAGAIN|1|V02 NT 08 04650||||0|0|0|0|Evennement d'initialisation.
CLCNFISAGAIN_vidInitOutput|D|();|FCT1.1|CLCNFISAGAIN|0|V02 NT 08 04650||||0|0|0|0|Initialisation des sorrties.
Clu_EveCrTR_CluSwtDiag|A|();|SCH.3|CLUSWTDIAG|1|V02 NT 08 04680||||0|0|0|0|Evènement Crank To Run|
Clu_EveKOn_CluSwtDiag|A|();|SCH.2|CLUSWTDIAG|1|V02 NT 08 04680||||0|0|0|0|Evénement associé au passge de clef OFF à clef ON|
Clu_EveRst_CluPed|F|();|SCH.1|ACQCLUPED|1|PTS_DOC_6509293||||0|0|0|0|Evénement reset du calculateur|
Clu_EveRst_CluPedFreqAcq|E|();|SCH.1|CLUPEDFREQACQ|1|PTS_DOC_6562175||||0|0|0|0|Evénement reset du calculateur
Clu_EveRst_CluPedFreqAcqPwd|A|();|SCH.2|ACQPWD|1|PTS_DOC_6717056||||0|0|0|0|Evénement reset.
Clu_EveRst_CluSwtDiag|A|();|SCH.1|CLUSWTDIAG|1|V02 NT 08 04680||||0|0|0|0|Evénement reset du calculateur|
Clu_SdlFast_AcqnCluPed|E|();|SCH.2|ACQCLUPED|1|PTS_DOC_6509293||||0|0|0|0|Moniteur d'acquisition de l'embrayage|
Clu_SdlFast_AcqnCluPedDio|A|();|SCH3.3|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Moniteur d'acquisition de l'embrayage.
Clu_SdlFast_CluPedFreqAcq|D|();|SCH.2|CLUPEDFREQACQ|1|PTS_DOC_6562175||||0|0|0|0|Fonction d'accroche moniteur Clu_SdlFast_CluPedFreqAcq
Clu_SdlFast_CluPedFreqAcqPwd|A|();|SCH.3|ACQPWD|1|PTS_DOC_6717056||||0|0|0|0|Moniteur rapide.
Clu_SdlMid_CluSwtDiag|A|();|SCH.4|CLUSWTDIAG|1|V02 NT 08 04680||||0|0|0|0|Moniteur moyen du diagnostic switch embrayage|
Clu_SdlSfty_rCluPedPrssMes|C|();|SCH.3|CLUPEDFREQACQ|1|PTS_DOC_6562175||||0|0|0|0|Fonction d'accrochage moniteur Clu_SdlSfty_rCluPedPrssMes.
Clu_SdlSlow_CluSwtDiag|B|();|SCH.5|CLUSWTDIAG|1|V02 NT 08 04680||||0|0|0|0|Moniteur lent du diagnostic switch embrayage|
CLUPEDFREQACQ_vidAcvCall|C|();|FCT1.5|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|Fonction  qui fait appel aux fonctions dont l'occurrence est Clu_SdlMid_CluPedFreqAcq et actives quand FlowMng_bCluPropSnsrEna = 1.
CLUPEDFREQACQ_vidCluPedAcq|E|();|FCT1.2|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|L’acquisition du signal est réalisée de façon temporelle, conformément à l’exigence cliente et débutera dès le réveil du calculateur.
CLUPEDFREQACQ_vidCluPedDiag|B|();|FCT1.3|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|Ce bloc énumère les différents court circuits ( à la masse, au plus) et les gradients qui engendrent un défaut sur le capteur d’embrayage. Les critères de diagnostics ne sont pas évalués si les conditions de diagnostics ne sont pas présentes.
CLUPEDFREQACQ_vidCluPedLnr|B|();|FCT2.3|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|Linéarisation et saturation de l'information pédale d'embrayage proportionnelle
CLUPEDFREQACQ_vidCluPedSel|B|();|FCT1.4|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|Ce bloc permet de mesurer l'enfoncement pédale d'embrayage acquis par le CMM.
CLUPEDFREQACQ_vidDiagFreq|B|();|FCT1.7|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|Ce bloc énumère les différents court circuits ( à la masse, au plus) et les gradients qui engendrent un défaut sur le capteur d’embrayage.
CLUPEDFREQACQ_vidDiagGrad|B|();|FCT1.8|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|Ce bloc énumère les différents court circuits ( à la masse, au plus) et les gradients qui engendrent un défaut sur le capteur d’embrayage.
CLUPEDFREQACQ_vidDiagnosticniv2|C|();|FCT2.2|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|Les diagnostics de niveau 2 sont ajoutés pour sécuriser le diagnostic
CLUPEDFREQACQ_vidGDUFreq|C|();|FCT1.9|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|Ce bloc définit les appels au GDU pour les défauts de type court circuit
CLUPEDFREQACQ_vidGDUGrad|C|();|FCT2.1|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|Ce bloc définit les appels au GDU pour les défauts de type gradient
CLUPEDFREQACQ_vidInit|E|();|FCT1.1|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|Ce bloc permet d’initialiser la position embrayage au key-on quand le capteur n’est pas encore fonctionnel.
CLUPEDFREQACQ_vidOSCallAcv|C|();|FCT1.6|CLUPEDFREQACQ|0|PTS_DOC_6562175||||0|0|0|0|Fonction  qui fait appel aux fonctions dont l'occurrence est Clu_SdlMid_CluPedFreqAcq
CLUPEDPOSNDIAG_vidActiv_diag|B|();|FCT1.2|CLUPEDPOSNDIAG|0|PTS_DOC_5050499||||0|0|0|0|Cette fonction permet de déterminer si la surveillance de l’embrayage doit être active ou non.|
CLUPEDPOSNDIAG_vidCompteur|D|();|FCT1.7|CLUPEDPOSNDIAG|0|PTS_DOC_5050499||||0|0|0|0|Lorsqu’un dysfonctionnement est détecté, un compteur est incrémenté  Le pas d’incrémentation est  différent selon le dysfonctionnement  activé.La décrémentation est effectuée si le compteur reste inchangé pendant un cycle de test.|
CLUPEDPOSNDIAG_vidCondIncDecCnt|D|();|FCT1.6|CLUPEDPOSNDIAG|0|PTS_DOC_5050499||||0|0|0|0|cette fonction permet la commutation entre l'incrémentation et la décrémentation du compteur: incrémentation lors de la détéction d'un dysfonctionnment et décrémentation si le compteur reste inchangé pendant tout un cycle de conduite.|
CLUPEDPOSNDIAG_vidCycle_de_tests|D|();|FCT1.3|CLUPEDPOSNDIAG|0|PTS_DOC_5050499||||0|0|0|0|La  fonction  cycle_de_tests  détermine  si  l’utilisateur  a  fait  un  cycle  de  conduite  suffisament  complet afin de pouvoir effectuer certaines vérifications.|
CLUPEDPOSNDIAG_vidDetect_dysfcts|F|();|FCT1.4|CLUPEDPOSNDIAG|0|PTS_DOC_5050499||||0|0|0|0|La fonction detection_dysfonctionnements effectue la surveillance proprement dite  de  la position embrayage.|
CLUPEDPOSNDIAG_vidDetectionMvt|F|();|FCT1.5|CLUPEDPOSNDIAG|0|PTS_DOC_5050499||||0|0|0|0|Cette fonction permet la détection d' un dysfonctionnement du capteur continu d'embrayage suite à une absence de mouvement de la pédale d'embrayage pendant un cycle de conduite|
CLUPEDPOSNDIAG_vidEntry_100ms|F|();|SCH.2|CLUPEDPOSNDIAG|1|PTS_DOC_5050499||||0|0|0|0|Scheduler 100 ms|
CLUPEDPOSNDIAG_vidEntryInit|B|();|SCH.1|CLUPEDPOSNDIAG|1|PTS_DOC_5050499||||0|0|0|0|Scheduler Reset|
CLUPEDPOSNDIAG_vidInitOutput|B|();|FCT1.1|CLUPEDPOSNDIAG|0|PTS_DOC_5050499||||0|0|0|0|Fonction qui fait l'initialisation des sorties|
CLUSWTDIAG_vidCounter|A|();|FCT1.7|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|L’autorisation de diagnostic monte sur un pas de temps, le compteur de défaut est donc incrémenté une seule fois à la fin de chaque diagnostic NOK.|
CLUSWTDIAG_vidCps_switch_mal_cpt|A|();|FCT2.2|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Le calcul réalisé ici est l’incrémentation du compteur de défaut "Cps_switch_mal_utilise_cpt".|
CLUSWTDIAG_vidDgoCoh_CluSt|C|();|FCT2.1|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Cette fonction gère la detection d'une panne du capteur d'embrayage|
CLUSWTDIAG_vidDiagCoh|A|();|FCT1.6|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Cette fonction gère d’une part la génération des variables Ext_bDgoCoh_CluSt et Ext_bMonRunCoh_CluSt et d’autre part le compteur d’embrayage mal utilisé.|
CLUSWTDIAG_vidDiagCohMonitoring|B|();|FCT1.4|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Le stateflow permet de gérer les phases du diagnostic de cohérence d’état, notamment le déclenchement des temporisations à l’initialisation et lorsque le diagnostic est activé.|
CLUSWTDIAG_vidDiagStuck|A|();|FCT1.8|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Cette fonction gère gère la génération des variables Ext_bDgoStuck_CluSt et Ext_bMonRunStuck_CluSt.|
CLUSWTDIAG_vidDiagStuck_CluSt|C|();|FCT2.3|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Cette fonction gère la génération des variables Ext_bDgoStuck_CluSt et Ext_bMonRunStuck_CluSt.|
CLUSWTDIAG_vidDiagStuckAcvn|A|();|FCT2.6|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Fonction de production de Clu_bDiagStuckCtrAcvn|
CLUSWTDIAG_vidDiagStuckDft|A|();|FCT2.8|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Fonction de production de Clu_bDgoStuck_CluSt.|
CLUSWTDIAG_vidDiagStuckInitTempo|A|();|FCT2.7|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Fonction d'initialisation de Cps_emb_tempo.|
CLUSWTDIAG_vidEventFlagOn|A|();|FCT1.3|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Cette fonction est appelée aux évenememnts Clu_EveKOn_CluSwtDiag Clu_EveCrTR_CluSwtDiag, elle sert à mettre la variable CLUSWTDIAG_bAllowCohRunnigToInit à 1 pour autoriser la transaction de l'automate.|
CLUSWTDIAG_vidInit|A|();|FCT1.1|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Initialisation des variables au reset de l’ECU (Clu_EveRst_CluSwtDiag).|
CLUSWTDIAG_vidInitDiagStuck|A|();|FCT1.5|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Cette fonction gère l’initialisation des variables après un Key OFF/ON.|
CLUSWTDIAG_vidInitOutput|A|();|FCT1.2|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Initialisation des variables internes.|
CLUSWTDIAG_vidStateCluInit|A|();|FCT1.10|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Fonction de transition à l'état CLU_INIT de l'automate.|
CLUSWTDIAG_vidTempo|A|();|FCT1.9|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Cette fonction gère la temporisation d’autorisation du diagnostic du capteur embrayage, appelée à récurrence temporelle lente|
CLUSWTDIAG_vidTempoCoh|A|();|FCT2.4|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Calcul de la temporisation du diagnostic de cohérence, lorsque l’indicateur télécodé de présence du capteur d’embrayage est à la valeur 1.|
CLUSWTDIAG_vidTempoStuck|A|();|FCT2.5|CLUSWTDIAG|0|V02 NT 08 04680||||0|0|0|0|Calcul de la temporisation du diagnostic de plausibilité temporel, lorsque l’indicateur télécodé de présence du capteur d’embrayage est à la valeur 1.|
CMDDIO_DT_vidCmdDio_CTP1|A|();|FCT1.1|CMDDIO_DT|0|PTS_DOC_6913275||||0|0|0|0|The activation command of the CTP1 additional heater is sent to the the basic layer using a DIOHAL API.|
CMDDIO_DT_vidCmdDio_CTP2|A|();|FCT1.2|CMDDIO_DT|0|PTS_DOC_6913275||||0|0|0|0|The activation command of the CTP2 additional heater is sent to the the basic layer using a DIOHAL API.|
CMDPWM_vidCmd_tpac|A|();|FCT1.9|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Function reponsable de la commande du throttle.
CMDPWM_vidCmdPwmCoFan|A|();|FCT1.7|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Valeur récupérée de la fréquence ainsi que la valeur d'init de la commande CMD_GMV1 envoyé au BSW.
CMDPWM_vidCmdPwmCstr|A|();|FCT1.1|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Fréquence du signal pwm ainsi que la consigne RCO de commande de l'électrovanne de la purge canister envoyé au BSW.
CMDPWM_vidCmdPwmECTCmd|A|();|FCT1.8|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Fréquence du signal RCO de commande du thermostat envoyé au BSW.
CMDPWM_vidCmdPwmPropFuPmp|A|();|FCT1.2|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Signal de commande de la pompe proportionnelle envoyé au BSW.
CMDPWM_vidCmdPwmVlvActEx|A|();|FCT1.3|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Acquisition de la valeur du signal RCO appliqué à la commande VVT échappement et envoyé au BSW.
CMDPWM_vidCmdPwmVlvActIn|A|();|FCT1.4|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Valeur du signal RCO appliqué à la commande VVT admission et envoyé au BSW.
CMDPWM_vidDriverInh|A|();|FCT2.1|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Ce bloc décrit l’activation et la désactivation par le LDA du composant LDB qui pilote le Hbridge HBHAL.
CMDPWM_vidF00_Init_CmdPwmECTCmd|A|();|FCT2.2|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Initialisation de la valeur de la fréquence du signal RCO de commande du thermostat envoyé au BSW.
CMDPWM_vidF00_Init_CmdPwmThrCmd|A|();|FCT2.3|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Initialisation du throttle.
CMDPWM_vidF00_Init_CmdPwmVlvAct|A|();|FCT1.6|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Fréquence du signal RCO de commande VVT admission et échappement envoyé au BSW.
CMDPWM_vidF00InitCmdPwmPropFuPmP|A|();|FCT1.5|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Valeur récupérée de la fréquence ainsi que la valeur d'init de la commande de la pompe proportionnelle envoyé au BSW.
CMDPWM_vidInitOutput|A|();|FCT2.4|CMDPWM|0|PTS_DOC_6669891||||0|0|0|0|Initialisation des variables internes
CMDPWMACT_DT_vidCmdPwmCtlPmpReq|A|();|FCT1.4|CMDPWMACT_DT|0|PTS_DOC_6913248||||0|0|0|0|The oil pump solenoid valve load commands (PWM frequency and duty cycle) are transmitted through the basic layer via the PWDHAL service|
CMDPWMACT_DT_vidCmdPwmDmpVlvCmd|A|();|FCT1.2|CMDPWMACT_DT|0|PTS_DOC_6913248||||0|0|0|0|The Dump-Valve commands  (PWM frequency and duty cycle) are  transmitted through the basic layer via the PWDHAL service|
CMDPWMACT_DT_vidCmdPwmTrbWaPmp|A|();|FCT1.1|CMDPWMACT_DT|0|PTS_DOC_6913248||||0|0|0|0|The water pump commands (PWM frequency and duty cycle) are transmitted through the basic layer via the PWDHAL service|
CMDPWMACT_DT_vidCmdPwmWgcCmd|A|();|FCT1.3|CMDPWMACT_DT|0|PTS_DOC_6913248||||0|0|0|0|The waste gate signal commands (PWM frequency and duty cycle) are transmitted through the basic layer via the PWDHAL service|
CoEs_SdlFast_STTEs|C|();|SCH.2|COES|1|PTS_DOC_5660023||||0|0|0|0|Scheduler rapide de la fonction de gestion de l'arrêt STT.|
COES_vidCutOffSequenceInterrupt|A|();|FCT2.3|COES|0|PTS_DOC_5660023||||0|0|0|0|cette fonction détermine si le prochain redémarrage doit être normal  ou des séquences d'interruption .|
COES_vidDetecterInterrupSeqArret|D|();|FCT2.2|COES|0|PTS_DOC_5660023||||0|0|0|0|Cette fonction détermine si la phase d’arrêt est interrompue alors que le moteur est encore tournant et que l’on est en phase 2 (ou plus) de la séquence d’arrêt.|
COES_vidEntryInit|B|();|SCH.1|COES|1|PTS_DOC_5660023||||0|0|0|0|Evenement Reset du calculateur.|
COES_vidFiltrerRegimeDentADent|B|();|FCT2.6|COES|0|PTS_DOC_5660023||||0|0|0|0|Cette fonction filtre via un passe bas du 1er ordre le régime vilebrequin calculé dent à dent.|
COES_vidImposeDelaiActivCanister|B|();|FCT2.5|COES|0|PTS_DOC_5660023||||0|0|0|0|Cette fonction applique un délai calibrable durant  laquelle on maintient la vanne canister fermée lors d’une interruption de la séquence d’arrêt.|
COES_vidImposerDelaiActivVanos|B|();|FCT2.4|COES|0|PTS_DOC_5660023||||0|0|0|0|Cette fonction applique un délai calibrable durant  laquelle on maintient les vanos sur leur position décroisé de verrouillage lors d’une interruption de la séquence d’arrêt.|
COES_vidInitOutput|C|();|FCT1.1|COES|0|PTS_DOC_5660023||||0|0|0|0|Cette fonction permet l'initialisation des sorties.|
COES_vidInterdirInterrupSeqArret|B|();|FCT1.2|COES|0|PTS_DOC_5660023||||0|0|0|0|Cette fonction maintient la demande d’arrêt STT à sa dernière valeur prise si l’on est dans les conditions moteur tournant et régime inférieur à un seuil calibrable.|
COES_vidObserverVanneCanisFermee|B|();|FCT1.4|COES|0|PTS_DOC_5660023||||0|0|0|0|Cette fonction détermine si la vanne du canister est suffisamment proche de sa position fermée depuis au moins une temporisation calibrable.|
COES_vidObserverVanosPositionRef|B|();|FCT1.3|COES|0|PTS_DOC_5660023||||0|0|0|0|Cette fonction permet de déterminer si les vanos admission et échappement sont tous deux sur leur position décroisée de verrouillage.|
COES_vidSelectionnerCommandArret|B|();|FCT2.1|COES|0|PTS_DOC_5660023||||0|0|0|0|Cette fonction détermine l’application des commandes de l’automate de gestion de la séquence d’arrêt.|
COES_vidSequencerPhaseArretSTT|C|();|FCT1.5|COES|0|PTS_DOC_5660023||||0|0|0|0|Cette fonction détermine l’état de la séquence d’arrêt. Si la demande d’arrêt n’est plus émise, les commandes de la séquence d’arrêt sont imposées à 0. Cette fonction est calculée à chaque événement PMH.|
CoFan_EveRst_ActrTstGMV|C|();|SCH.1|COFANACTEST|1|V02 NT 09 00774||||0|0|0|0|Evénement reset du calculateur
CoFan_EveRst_CmdDiagCoFan|A|();|SCH.1|COFANCMDDIAG|1|PTS_DOC_6722439||||0|0|0|0|Fonction d'accroche au moniteur CoFan_EveRst_CmdDiagCoFan
CoFan_EveRst_CmdDiagCoFanAcqPwd|A|();|SCH.8|ACQPWD|1|PTS_DOC_6717056||||0|0|0|0|Evénement reset
CoFan_EveRst_CmdDiagCoFanIf|B|();|SCH5.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement de reset de la fonction CoFan|
CoFan_EveRst_ECTReq|B|();|SCH.1|ECTREQ|1|PTS_DOC_6886129||||0|0|0|0|Evénement Reset de l'ECU.|
CoFan_EveRstDft_CmdDiagCoFan|B|();|SCH.2|COFANCMDDIAG|1|PTS_DOC_6722439||||0|0|0|0|Fonction d'accroche au moniteur CoFan_EveRstDft_CmdDiagCoFan
CoFan_SdlMid_AcqCmdCoFan|A|();|SCH3.8|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Moniteur moyen de la fonction CoFan.
CoFan_SdlMid_ActrTstGMV|C|();|SCH.2|COFANACTEST|1|V02 NT 09 00774||||0|0|0|0|Moniteur moyen de la fonction commande des GMV
CoFan_SdlMid_CmdDiagCoFan|C|();|SCH.3|COFANCMDDIAG|1|PTS_DOC_6722439||||0|0|0|0|Fonction d'accroche au moniteur CoFan_SdlMid_CmdDiagCoFan
CoFan_SdlMid_CmdDiagCoFanAcqPwd|A|();|SCH.9|ACQPWD|1|PTS_DOC_6717056||||0|0|0|0|Moniteur moyen
CoFan_SdlMid_CmdDiagCoFanIf|B|();|SCH8.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur moyen de la fonction CoFan|
CoFan_SdlMid_CmdDiagGMV1GMV2|A|();|SCH2.5|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Moniteur moyen de la fonction CoFan.
CoFan_SdlMid_CmdPwmCoFan|A|();|SCH.11|CMDPWM|1|PTS_DOC_6669891||||0|0|0|0|Moniteur moyen de la fonction CoFan
CoFan_SdlSlow_CmdDiagECTReq|A|();|SCH2.6|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Moniteur lent de la fonction CoFan.
CoFan_SdlSlow_CmdPmwECTCmd|A|();|SCH.10|CMDPWM|1|PTS_DOC_6669891||||0|0|0|0|Moniteur lent de la fonction CoFan
CoFan_SdlSlow_ECTReq|B|();|SCH.2|ECTREQ|1|PTS_DOC_6886129||||0|0|0|0|Control flow for the ECT|
COFANACTEST_vidBAcTstTransToEnd|A|();|FCT1.5|COFANACTEST|0|V02 NT 09 00774||||0|0|0|0|Execution de l'Entry lors de la transition à l'état COFAN_BACTRTST_END
COFANACTEST_vidBAcTstTransToIdle|A|();|FCT1.6|COFANACTEST|0|V02 NT 09 00774||||0|0|0|0|Execution de l'Entry lors de la transition à l'état COFAN_BACTRTST_IDLE
COFANACTEST_vidCAcTstTransToIdle|B|();|FCT1.7|COFANACTEST|0|V02 NT 09 00774||||0|0|0|0|Execution de l'Entry lors de la transition à l'état COFAN_CACTRTST_IDLE
COFANACTEST_vidGMVTstB|D|();|FCT1.3|COFANACTEST|0|V02 NT 09 00774||||0|0|0|0|Pour les tests de GMV type B1 ou B2 (petite et grande vitesse), l’état de repos est une commande des 2 GMV à 1
COFANACTEST_vidGMVTstC|D|();|FCT1.4|COFANACTEST|0|V02 NT 09 00774|VEMS V02 ECU#045395|||0|0|0|0|Pour le test de GMV type C, l’état de repos est une commande GMV2 à 0 et GMV1 à 0.Pendant le test, on active le GMV2 pendant tous le temps du test et on fait varier la commande du GMV1.
COFANACTEST_vidGMVTstRun|C|();|FCT1.2|COFANACTEST|0|V02 NT 09 00774||||0|0|0|0|La stratégie se décompose en 2 sous-fonctions :  Procédure de test actionneur pour des GMV de type B1 ou B2 et Procédure de test actionneur pour des GMV de type C
COFANACTEST_vidInitOutput|A|();|FCT1.1|COFANACTEST|0|V02 NT 09 00774||||0|0|0|0|Initialisations des sorties
COFANCMDDIAG_vidCoFan1Cmd|A|();|FCT6.8|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction envoie les commandes CMD_GMV1 et CMD_GMV2 au LdB selon l’équipement (B1 ou B2).
COFANCMDDIAG_vidCoFan1CmdFricC|A|();|FCT6.9|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction envoie les commandes CMD_GMV1 et CMD_GMV2 au LdB selon l’équipement (C)
COFANCMDDIAG_vidCofanB2_DEFAUT|B|();|FCT4.5|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Focntion de transition de l'étape COFANB2_DEFAULT
COFANCMDDIAG_vidCofanB2_GVTran|D|();|FCT4.4|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de transition de l'état COFANB2_GV
COFANCMDDIAG_vidCofanB2_PVTran|B|();|FCT4.3|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de la transition de l'état COFANB2_PV
COFANCMDDIAG_vidCofanB2VNullTran|B|();|FCT4.1|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|fonction de transition de l'état COFANB2_VNULLE
COFANCMDDIAG_vidCofanB2WaitTran|D|();|FCT4.2|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de transition de l'état COFANB2_ATTENTE
COFANCMDDIAG_vidCofanc_Default_T|C|();|FCT2.6|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de transition de l'état COFANC_DEFAULT
COFANCMDDIAG_vidCofanc_Gmvp_T|D|();|FCT4.8|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de transition de l'état COFANC_GMVP
COFANCMDDIAG_vidCofanc_Init_T|B|();|FCT2.5|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|fonction de transition de l'état COFANC_INIT
COFANCMDDIAG_vidCofanc_Rf_T|E|();|FCT4.10|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de transition de l'état COFANC_RF
COFANCMDDIAG_vidCofanc_Rfao_T|E|();|FCT4.7|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de transition de l'état COFANC_RFAO
COFANCMDDIAG_vidCofanc_Rfgmvp_T|E|();|FCT4.9|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de transition de l'état COFANC_RFGMVP
COFANCMDDIAG_vidCofanc_Ro_T|D|();|FCT4.6|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de transition de l'état COFANC_RO
COFANCMDDIAG_vidCoFanCmd|D|();|FCT2.7|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction envoie les commandes CMD_GMV1 et CMD_GMV2 au LdB selon l’équipement et leur type.
COFANCMDDIAG_vidCoFanCmdB1|B|();|FCT2.8|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction se charge d’envoyer les commandes CMD_GMV1.
COFANCMDDIAG_vidCoFanCmdB2|B|();|FCT2.9|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction se charge d’envoyer les commandes  CMD_GMV2.
COFANCMDDIAG_vidCoFanCmdC|B|();|FCT2.10|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction envoie les commandes CMD_GMV1 et CMD_GMV2 au LdB selon l’équipement (C).
COFANCMDDIAG_vidCoFanCtlMng|B|();|FCT2.1|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction définie les états des commandes CMD_GMV1 et CMD_GMV2 en fonction de la vitesse GMV et de la vitesse de consigne filtrée (C).
COFANCMDDIAG_vidCoFanCtlMngB1|E|();|FCT2.2|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction définie les états des commandes CMD_GMV1 en fonction de la vitesse GMVprédite (B1).
COFANCMDDIAG_vidCoFanCtlMngB2|B|();|FCT2.3|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction définie les états des commandes CMD_GMV1 en fonction de la vitesse GMV prédite (B2).
COFANCMDDIAG_vidCoFanCtlMngC|B|();|FCT2.4|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction définie les états des commandes CMD_GMV1 et CMD_GMV2 en fonction de la vitesse de consigne filtrée (C).
COFANCMDDIAG_vidCoFanSpdMng|B|();|FCT1.7|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de calcule des vitesses prédites à partir de la consigne de vitesse GMV.
COFANCMDDIAG_vidCritScCnt|A|();|FCT5.9|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction gère la stratégie spécifique de comptage de panne défaut CCA sur 1 DC global
COFANCMDDIAG_vidCritScRlyElDgo|A|();|FCT6.6|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction gére le diagnostic Défaut électrique sur ETAT_GMV
COFANCMDDIAG_vidDgClsdRlyCoFanB2|A|();|FCT5.6|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Relais CCA collé fermé
COFANCMDDIAG_vidDgCohCoFB2NoSpd|A|();|FCT3.7|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|ette fonction réalise la Cohérence petite vitesse, grande vitesse et absence de commande en Fric B2.
COFANCMDDIAG_vidDgoCoFanB1|C|();|FCT3.3|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|ette fonction réalise l’acquisition d’ETAT_GMV et des diagnostics électriques de la commande CMD_GMV1 provenant du LdB en équipement B1.
COFANCMDDIAG_vidDgoCoFanB2|B|();|FCT3.5|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction réalise l’acquisition d’ETAT_GMV et des diagnostics électriques des commandes CMD_GMV1 et CMD_GMV2 provenant du LdB en équipement B2.
COFANCMDDIAG_vidDgoCoFanC|B|();|FCT5.4|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction réalise l’acquisition d’ETAT_GMV provenant du LdB en équipement C.
COFANCMDDIAG_vidDgoCohB2|C|();|FCT3.6|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction calcule les résultats des diagnostics de cohérence pour les 3 états Petite Vitesse, Grande Vitesse et Vitesse nulle en équipement B2.
COFANCMDDIAG_vidDgoCohCoFanB1|B|();|FCT3.4|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fionction réalise la Cohérence vitesse ou ETAT_GMVX en défaut électrique en Fric B1.
COFANCMDDIAG_vidDgoCohCoFanB2|A|();|FCT5.7|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction qui permet de calculer CoFan_bDgoEl_StFanC.
COFANCMDDIAG_vidDgoHalFanC|B|();|FCT5.5|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|cette fonction permet de calcluler CoFan_bDgoClsdRly_StFanC et CoFan_bDgoEl_StFanC.
COFANCMDDIAG_vidDiagBMonRun|B|();|FCT5.10|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction gère l’ensemble des diagnostics GMV pour les 3 équipements.
COFANCMDDIAG_vidDiagCoFan|B|();|FCT3.1|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction gère l’ensemble des diagnostics GMV pour les 3 équipements.
COFANCMDDIAG_vidDiagCoFanEna|B|();|FCT3.2|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction réalise les diagnostics électriques sur les commandes.
COFANCMDDIAG_vidECIDgo|A|();|FCT5.8|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction gére le diagnostic ECI de la commande GMV.
COFANCMDDIAG_vidInit|A|();|FCT1.2|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction se charge de récupérer les variables enregistrées en EEPROM au Réveil Partiel de l’ECU. Il s’agit des données liées à la stratégie de confirmation d’un défaut CCA en FRIC C’ qui est définie sur un DC.
COFANCMDDIAG_vidInitFricC|E|();|FCT1.3|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|il est nécessaire également d’activer l’entrée ETAT_GMV en mode RCO (API PWDHAL) et de switcher sur la CMD_GMV1 de type RCO (API PFCHAL).
COFANCMDDIAG_vidInitOutput|D|();|FCT1.1|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction d'intialisation
COFANCMDDIAG_vidMngTimer|A|();|FCT3.8|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction qui permet de calculer les cinq valeurs du compteur.
COFANCMDDIAG_vidRstCoFanCtlMng|A|();|FCT1.4|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction d'initialisation du manager
COFANCMDDIAG_vidRstDft|B|();|FCT1.5|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de réinitialisation des variables liées à la stratégie de confirmation d’un défaut CCA en FRIC C.
COFANCMDDIAG_vidRstDftFricC|B|();|FCT1.6|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Réinitialisation des variables liées à la stratégie de confirmation d’un défaut CCA en FRIC C.
COFANCMDDIAG_vidSpdFanB1Mng|C|();|FCT5.1|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de calcule, pour un équipement de type B1 la vitesse prédite à partir de la consigne de vitesse GMV.
COFANCMDDIAG_vidSpdFanB2Mng|C|();|FCT5.2|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Cette fonction calcule, pour un équipement de type B2 la vitesse prédite à partir de la consigne de vitesse GMV.
COFANCMDDIAG_vidSpdFanCMng|D|();|FCT5.3|COFANCMDDIAG|0|PTS_DOC_6722439||||0|0|0|0|Fonction de calcul pour un équipement de type C de la vitesse prédite à partir de la consigne de vitesse GMV après l’avoir filtrée à l’aide d’un limiteur de pente.
COHCAN_vidDiagBattSys|A|();|FCT1.5|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Cette fonction, appelée sur réception de la trame 572, spécifie les conditions d’activation ainsi que l’activation elle-même, du diagnostic de cohérence.|
COHCAN_vidDiagChkBattSys|A|();|FCT1.7|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Cette sous fonction réalise le diagnostic de la batterie|
COHCAN_vidDiagCluAC|B|();|FCT2.4|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Cette sous fonction réalise le diagnostic de la Clim|
COHCAN_vidDiagFuLvlDft|A|();|FCT2.1|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Cette sous fonction réalise le diagnostic fuel low|
COHCAN_vidDiagModSpd_FuLvl|A|();|FCT1.8|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Cette fonction, appelée sur réception de la trame 412, spécifie les conditions d’activation ainsi que l’activation elle-même, du diagnostic de cohérence.|
COHCAN_vidDiagModSptReq|B|();|FCT1.10|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Cette sous fonction réalise le diagnostic de la fonction d’activation|
COHCAN_vidDiagOBD1|A|();|FCT1.2|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Cette fonction, appelée sur réception de la trame 5B2 et 7F2, spécifie les conditions d’activation ainsi que l’activation elle-même, du diagnostic de cohérence|
COHCAN_vidDiagOBD2|A|();|FCT1.4|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Cette sous fonction réalise le diagnostic OBD|
COHCAN_vidDiagStCluAC|A|();|FCT2.2|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Cette fonction, appelée sur réception de la trame 50E, spécifie les conditions d’activation ainsi que l’activation elle-même, du diagnostic de cohérence.|
COHCAN_vidEntryInit|B|();|SCH.1|COHCAN|1|V02 NT 12 00919||||0|0|0|0|Evénement reset du calculateur|
COHCAN_vidInitOutput|B|();|FCT1.1|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Initialisation des variables|
COHCAN_vidWindowChkBattSys|A|();|FCT1.6|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Le moniteur de diagnostic de la batterie|
COHCAN_vidWindowCluAC|A|();|FCT2.3|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Le moniteur de diagnostic de la Clim|
COHCAN_vidWindowModSpt_FuLvl|A|();|FCT1.9|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Le moniteur de diagnostic fuel low et de la fonction d’activation|
COHCAN_vidWindowOBD|A|();|FCT1.3|COHCAN|0|V02 NT 12 00919||||0|0|0|0|Le moniteur de diagnostic OBD|
Com_ClearIpduGroupVector|A|(uint16 u16PduGroup);|18|HEADER|1|NONE||||0|0|0|0|
Com_Init|A|(uint16 *pu16Com);|6|HEADER|1|NONE||||0|0|0|0|
Com_IpduGroupControl|A|(uint16 u16PduGroupVector, boolean bTest);|10|HEADER|1|NONE||||0|0|0|0|
Com_MainFunctionRouteSignals|A|();|24|HEADER|1|NONE||||0|0|0|0|
Com_MainFunctionRx|A|();|25|HEADER|1|NONE||||0|0|0|0|
Com_MainFunctionTx|A|();|26|HEADER|1|NONE||||0|0|0|0|
Com_ReceptionDMControl|A|(uint16 u16PduGroup);|19|HEADER|1|NONE||||0|0|0|0|
Com_SetIpduGroup|A|(uint16 u16PduGroup, uint8 u8ComIP, boolean bEnable);|9|HEADER|1|NONE||||0|0|0|0|
ComM_CommunicationAllowed|A|(uint8 u8ComMChannel, boolean bEna);|7|HEADER|1|NONE||||0|0|0|0|
ComM_GetCurrentComMode|A|(uint8 u8ComMUser, uint8 *ComMode);|12|HEADER|1|NONE||||0|0|0|0|
ComM_Init|A|();|2|HEADER|1|NONE||||0|0|0|0|
ComM_MainFunction_000|A|();|29|HEADER|1|NONE||||0|0|0|0|
ComM_MainFunction_001|A|();|30|HEADER|1|NONE||||0|0|0|0|
ComM_RequestComMode|A|(uint8 u8ComMUser, uint8 u8FullCom);|8|HEADER|1|NONE||||0|0|0|0|
ComStMng_EveRst|A|();|SCH.1|COMSTMNG|1|PTS_DOC_6832731||||0|0|0|0|Evènement de reset logiciel.
ComStMng_EveSdlFast|A|();|SCH.2|COMSTMNG|1|PTS_DOC_6832731||||0|0|0|0|Evènement tâche temporelle rapide.
COMSTMNG_vidCanIsLifeCyclePhases|A|();|FCT1.4|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Afin de gérer la communication CAN pendant la phase d’intégration électronique et de power-latch, il suffit de positionner les PduGroup des trames qui ne doivent plus être émises à 0.
COMSTMNG_vidInitOutput|A|();|FCT1.10|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Initialisation des internes et des sorties
COMSTMNG_vidIntegraElectronique|A|();|FCT1.2|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Fontion permettant la circulation d'un ensemble de trames prédéfini sur le bus pendant la phase d’intégration électronique.
COMSTMNG_vidLinLifeCyclePhases|A|();|FCT2.1|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0| L’automate détermine dans quel état se trouve le réseau LIN. Au réveil RCD et afin de réveiller le réseau LIN, il est nécessaire d’envoyer une trame de réveil. De même à la coupure du contact clef, il est nécessaire d’envoyer une trame de mise en veille.
COMSTMNG_vidLinStatusInit|A|();|FCT2.2|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Transition de l'état ISLIN_INIT.
COMSTMNG_vidLinStatusNormal|A|();|FCT2.4|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Transition de l'état ISLIN_NORMAL.
COMSTMNG_vidLinStatusShut|A|();|FCT2.5|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Transition de l'état ISLIN_SHUTDOWN.
COMSTMNG_vidLinStatusWakeUp|A|();|FCT2.3|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|transition de l'état ISLIN_WAKEUP.
COMSTMNG_vidPowerlatch|A|();|FCT1.3|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Fontion permettant la circulation d'un ensemble de trames prédéfini sur le bus pendant la phase de Power-latch.
COMSTMNG_vidReset|A|();|FCT1.1|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Fonction d'initialisation des différentes couches de la COM stack pour l’activation de la  communication via le réseau CAN IS
COMSTMNG_vidShutDown|A|();|FCT1.6|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Quand l’automate est à l’état SHUTDOWN, on demande le passage du réseau LIN en mode NO_COM.
COMSTMNG_vidWakeUp|A|();|FCT1.5|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Quand l’automate est à l’état WAKEUP, on demande le passage du réseau LIN en mode FULL_COM.
CONFIGLIN_vidDiagAltAbsent|A|();|FCT1.5|CONFIGLIN|0|V02 NT 09 04644||||0|0|0|0|This function does the diagnostic of the default ECU ALT Absent.
CONFIGLIN_vidDiagFrame|A|(argin uint8 u8NodeIndex, argin uint16 u16DefaultIndex);|FCT1.6|CONFIGLIN|0|V02 NT 09 04644||||0|0|0|0|Fonction gérant les défauts d'absences des trames de réceptions
CONFIGLIN_vidDiagLinBlocked|A|();|FCT1.4|CONFIGLIN|0|V02 NT 09 04644||||0|0|0|0|This function does the diagnostic of the default BUS LIN BLOCKED.
CONFIGLIN_vidInit|A|();|FCT1.1|CONFIGLIN|0|V02 NT 09 04644||||0|0|0|0|This function initializes internal variables, outputs and the NM for the LIN
CONFIGLIN_vidLinScheduler|A|();|FCT1.3|CONFIGLIN|0|V02 NT 09 04644||||0|0|0|0|This function manages the NM of the LIN and schedules the transmission and the reception of messages.
CONFIGLIN_vidMngEveRst|A|();|SCH.1|CONFIGLIN|1|V02 NT 09 04644||||0|0|0|0|Fonction appelée à l'init
CONFIGLIN_vidMngSch_100MS|A|();|SCH.3|CONFIGLIN|1|V02 NT 09 04644||||0|0|0|0|Fonction appelée toutes les 100ms
CONFIGLIN_vidMngSch_10MS|A|();|SCH.2|CONFIGLIN|1|V02 NT 09 04644||||0|0|0|0|Fonction appelée toutes les 10ms
CONFIGLIN_vidMngSch_1S|A|();|SCH.4|CONFIGLIN|1|V02 NT 09 04644||||0|0|0|0|Fonction appelée toutes les 1s
CONFIGLIN_vidReInitCondCheck|A|();|FCT1.2|CONFIGLIN|0|V02 NT 09 04644||||0|0|0|0|his function checks the variable Diag_on to enable or disable the LIN NM.
CoPt_Sdl10ms_ProtDftlClc|A|();|SCH.2|PROTDFTLCLC|1|V02 NT 11 04686||||0|0|0|0|Fonction d'accroche au moniteur 10ms|
CoPTSt_SdlFast_RStrtSTT|A|();|SCH.2|COPTST|1|V02 NT 09 05959||||0|0|0|0|Scheduler rapide|
COPTST_vidBoolEtatRedemarrageSTT|B|();|FCT1.3|COPTST|0|V02 NT 09 05959||||0|0|0|0|Ce booléen détermine l’état du redémarrage STT. Il doit être stocké en mémoire protégée.|
COPTST_vidCalcTempEauDemarrage|B|();|FCT1.7|COPTST|0|V02 NT 09 05959||||0|0|0|0|On stocke la valeur de température d’eau courante dans la variable de température d’eau au démarrage ou redémarrage.|
COPTST_vidCalcTempEauRedemarrage|C|();|FCT1.5|COPTST|0|V02 NT 09 05959||||0|0|0|0|On  stocke  la  valeur  de  température  d’eau  courante  dans  la  variable  de  température  d’eau  au redémarrage STT.|
COPTST_vidDefinitionVariables|B|();|FCT1.2|COPTST|0|V02 NT 09 05959||||0|0|0|0|Cette fonction détermine les variables spécifiques au redémarrage Stop&Start : le booléen d’état de redémarrage STT et la température d’eau moteur lors des redémarrages STT|
COPTST_vidEntryInit|A|();|SCH.1|COPTST|1|V02 NT 09 05959||||0|0|0|0|initialisation des sorties.|
COPTST_vidInitOutput|C|();|FCT1.1|COPTST|0|V02 NT 09 05959||||0|0|0|0|initialisation des sorties du module|
COPTST_vidTempEauDemarrage|B|();|FCT1.6|COPTST|0|V02 NT 09 05959||||0|0|0|0|On actualise la mémorisation de la température d’eau moteur au démarrage lors des phases de démarrages ou redémarrage uniquement.|
COPTST_vidTempEauRedemarrageSTT|B|();|FCT1.4|COPTST|0|V02 NT 09 05959||||0|0|0|0|On  actualise  la  mémorisation  de  la  température  d’eau  moteur  au  redémarrage  Stop&Start  lors  des phases de redémarrages STT.|
COSYNC_vidActvCalcDetectionArret|A|();|FCT2.2|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet d’activer ou pas le calcul d’information de détection d’arrêt moteur.
COSYNC_vidActvCalcDiagPosArret|A|();|FCT3.5|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet d’activer ou pas le calcul de diagnostic sur la position d’arrêt moteur. Le calcul se déroule à bas régime et si une défaillance est possible sur le signal vilebrequin (car l’information Ext_nEng n’est plus fiable).
COSYNC_vidActvCalcRisqGrippgeVil|A|();|FCT1.4|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc fournit 2 informations : 1. L’information de machine électrique active, 2. L’information d’activation de la machine électrique. Il permet également d’activer le calcul de prévention du risque de moteur bloqué.
COSYNC_vidBouchSortiesDetecArret|A|();|FCT2.8|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de bouchonner les variables de la fonction « Détecter et gérer l’arrêt moteur » si le calcul de la fonction n’est pas activé.
COSYNC_vidBouchSortiesDgPosArret|A|();|FCT3.7|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de bouchonner les variables de la fonction « Informer du risque de calcul erroné de la position d arrêt moteur » si le calcul de la fonction n’est pas activé.
COSYNC_vidBouchSortiesGrippgeVil|A|();|FCT2.1|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de bouchonner les variables de la fonction « Prévenir du risque de blocage vilebrequin » si le calcul de la fonction n’est pas activé.
COSYNC_vidCalcAbsenceFrontsAAC|A|();|FCT3.4|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de détecter l’absence de front AAC admission ou échappement. La temporisation est variable si l’initialisation du compteur s’est faite sur l’activation de la machine électrique ou sur un front vilebrequin.
COSYNC_vidCalcAbsenceFrontsVil|A|();|FCT3.3|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de détecter l’absence de front vilebrequin. La temporisation est variable si l’initialisation précédente du compteur s’est faite sur l’activation de la machine électrique ou sur un front vilebrequin.
COSYNC_vidCalculerComptrPMHa10ms|A|();|FCT2.7|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de reseter la valeur du compteur de PMH à chaque détection de régime nul.
COSYNC_vidCnfrmValidSignAACOuVil|A|();|FCT1.9|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de maintenir l’état « DEFAILLANCE_VIL » (respectivement l’état « DEFAILLANCE_AAC ») durant une certaine durée le temps de confirmation de l’exploitation possible du signal AAC (respectivement vilebrequin).
COSYNC_vidConnaitreEtatMoteur|A|();|FCT1.8|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc contient la machine d’état qui est utilisé pour définir la stratégie de synchronisation à activer.
COSYNC_vidCreerInfoArretMoteur|A|();|FCT2.6|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de choisir l'information de régime à retenir. En cas de défaillance sur le signal vilebrequin, on retient l’information construite par le signal vilebrequin. La détection de régime nul est retardée pour bien confirmer l'arrêt du moteur.
COSYNC_vidDetectArretAvcBckupVil|A|();|FCT2.4|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de créer une information de détection d’arrêt moteur à partir du signal AAC.
COSYNC_vidDetectArretSnsBckupVil|A|();|FCT2.5|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de créer une information de détection d’arrêt moteur à partir du signal vilebrequin. Pour cela, il faut ne pas avoir vu de fronts sur le signal vilebrequin pendant un certain temps, temps calibrable en fonction de certains paramètres.
COSYNC_vidDetecterGererArretMotr|A|();|FCT2.3|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de fournir plusieurs informations : 1. La détection d’un régime nul (le moteur est effectivement à l’arrêt), 2. Le fait qu’une détection d’arrêt vient d’avoir lieu, 3. Un compteur de nombre de PMH resté lors de la détection d’arrêt moteur.
COSYNC_vidEntry_10ms|A|();|SCH.2|COSYNC|1|V02 NT 10 02290||||0|0|0|0|Moniteur 10ms d'appel de la fonction.
COSYNC_vidEntryInit|A|();|SCH.1|COSYNC|1|V02 NT 10 02290||||0|0|0|0|Fonction de Reset Calculateur.
COSYNC_vidEvalAbsnceSignVilEtAAC|A|();|FCT1.6|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de détecter l’absence de passage de dents vilebrequin, de fronts AAC admission et de fronts AAC échappement pendant un temps calibrable.
COSYNC_vidEvalDefailSignAACEtVil|A|();|FCT1.7|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet de définir : 1. l’exploitation possible du signal vilebrequin (présence de fronts, pas de remontée de diagnostic), 2. l’exploitation possible d’un signal AAC (existence, présence, pas de remontée de diagnostic sur au moins un signal AAC).
COSYNC_vidEvalSignalAACAUtiliser|A|();|FCT1.3|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc définit quel signal AAC est à utiliser par la fonction de synchronisation fournisseur. La méthode est de retenir le signal existant et valide. Pour des applications possédant 2 signaux AAC valides, une priorité est définie sur l’un des signaux.
COSYNC_vidGenererSortiesFonction|A|();|FCT1.10|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc exploite l’état de la machine d’état et convertit en informations : 1. Risque machine électrique bloquée et active, 2. Demande de désynchronisation moteur (Pour les cas ou il y a un risque de moteur bloqué).
COSYNC_vidInfrmRsqClcErrPosArret|A|();|FCT3.6|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc permet d’informer du risque que la position d’arrêt moteur calculée est erronée ou pas. Actuellement cette fonction n’est pas développée.
COSYNC_vidInitOutput|A|();|FCT1.1|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Cette fonction initialise les sorties et autres variables intermédiaires du module.
COSYNC_vidPrevenirRisqGrippgeVil|A|();|FCT1.5|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc informe et de prévient du risque d’un blocage vilebrequin via : 1. L’information de risque moteur bloqué et machine électrique active, 2. L’information demandant de forcer la désynchronisation, afin de prévenir l’injection.
COSYNC_vidSuperviseurFctSynchro|A|();|FCT1.2|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Cette fonction crée plusieurs informations : 1. Le signal AAC à utiliser pour la synchronisation, 2. Le risque de blocage vilebrequin, 3. La détection d’arrêt moteur et la position associées, 4. Une demande de recommencement du cycle de synchronisation.
COSYNC_vidTraitInfoCmptFrontsAAC|A|();|FCT3.2|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc renvoie l'information de passage ou non de front AAC pour le signal AAC admission et échappement. Il permet aussi de détecter le passage du 1er front AAC admission et échappement après l’activation de la machine électrique.
COSYNC_vidTraitInfoCmptFrontsVil|A|();|FCT3.1|COSYNC|0|V02 NT 10 02290||||0|0|0|0|Ce bloc renvoie une information pour savoir s‘il y a eu ou pas un passage de front descendant du signal vilebrequin. Il permet également de détecter le passage du 1er front descendant du signal vilebrequin après l’activation de la machine électrique.
CoT_EveCrTR_AcqCoT|B|();|SCH.3|ACQCOT|1|PTS_DOC_6529851||||0|0|0|0|Evènement cranking vers running.
CoT_EveCrTR_FctDiagCoT|A|();|SCH.3|COTDIAG|1|V02 NT 09 00859||||0|0|0|0|Evènement Crank To Run.
CoT_EvePwrl_AcqCoT|A|();|SCH.6|ACQCOT|1|PTS_DOC_6529851||||0|0|0|0|Evènement Powerlatch pour la fonction CoT
CoT_EveRst_AcqCoT|D|();|SCH.1|ACQCOT|1|PTS_DOC_6529851||||0|0|0|0|Evènement reset.
CoT_EveRst_AcqCoTAdc|A|();|SCH3.5|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Evènement reset
CoT_EveRst_FctDiagCoT|A|();|SCH.2|COTDIAG|1|V02 NT 09 00859||||0|0|0|0|Evènement reset de l'ECU
CoT_EveRst_TrbWaPmp|D|();|SCH.1|TRBWAPMP|1|PTS_DOC_6851428||||0|0|0|0|Evénement Reset de l'ECU.|
CoT_EveStTR_AcqCoT|B|();|SCH.4|ACQCOT|1|PTS_DOC_6529851||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant.
CoT_EveStTR_AcqCoTAdc|A|();|SCH3.4|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant
CoT_SdlMid_AcqCoT|C|();|SCH.2|ACQCOT|1|PTS_DOC_6529851||||0|0|0|0|Moniteur moyen pour la fonction acquisition température d'eau.
CoT_SdlMid_AcqCoTAdc|A|();|SCH3.3|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur moyen
CoT_SdlSlow_AcqCoT|B|();|SCH.5|ACQCOT|1|PTS_DOC_6529851||||0|0|0|0|Moniteur lent
CoT_SdlSlow_CmdPwmAct|A|();|SCH.5|CMDPWMACT_DT|1|PTS_DOC_6913248||||0|0|0|0|Slow scheduler|
CoT_SdlSlow_FctDiagCoT|A|();|SCH.4|COTDIAG|1|V02 NT 09 00859||||0|0|0|0|Moniteur lent
CoT_SdlSlow_TrbWaPmp|D|();|SCH.2|TRBWAPMP|1|PTS_DOC_6851428||||0|0|0|0|Evénement de reception de la trame.|
CoT_SdlSlow_TrbWaPmpDiag|A|();|SCH.4|ACQDGOHAL_DT|1|PTS_DOC_6854092||||0|0|0|0|Slow scheduler|
COTDIAG_vidCalcDgoIndicator|C|();|FCT1.8|COTDIAG|0|V02 NT 09 00859||||0|0|0|0|Fonction qui calcule CoT_bDgoWup_tCoMes et CoT_bDgoTrck_tCoMes.
COTDIAG_vidCalcMonRunIndicator|C|();|FCT1.7|COTDIAG|0|V02 NT 09 00859||||0|0|0|0|Fonction qui calcule CoT_bMonRunWup_tCoMes et CoT_bMonRunTrck_tCoMes.
COTDIAG_vidEntryInit|A|();|SCH.1|COTDIAG|1|V02 NT 09 00859||||0|0|0|0|Fonction d'accroche au moniteur RESET.
COTDIAG_vidFunctDiagCoTemp|A|();|FCT1.3|COTDIAG|0|V02 NT 09 00859||||0|0|0|0|Cette fonction spécifie les diagnostics fonctionnels de la température d’eau moteur. Les calculs sont réalisés à récurrence temporelle lente.
COTDIAG_vidFunctDiagCoTempInit|E|();|FCT1.2|COTDIAG|0|V02 NT 09 00859||||0|0|0|0|Cette fonction permet d’initialiser les variables au reset de l’ECU (CoT_EveRst_FctDiagCoT) et sur événement démarrage moteur (CoT_EveCrTR_FctDiagCoT).
COTDIAG_vidInitOutput|A|();|FCT1.1|COTDIAG|0|V02 NT 09 00859||||0|0|0|0|Fonction d'initialisation des variables produites dans le module.
COTDIAG_vidInjCutoffTimeCalc|A|();|FCT1.4|COTDIAG|0|V02 NT 09 00859||||0|0|0|0|Cette fonction calcule le temps cumulé de fonctionnement en mode coupure d’injection (Injector_cut_off_counter) et active un booléen (Flag_delay_injection) lorsque le compteur dépasse un seuil.
COTDIAG_vidTrackerCoTempCalc|B|();|FCT1.5|COTDIAG|0|V02 NT 09 00859||||0|0|0|0|Cette fonction calcule  la  variable  suiveur  de  température  d’eau (Temperature_eau_tracker_value).
COTDIAG_vidWarmUpTestEnd|A|();|FCT1.6|COTDIAG|0|V02 NT 09 00859||||0|0|0|0|Cette fonction Active le booléen (Warmup_test_complete)  indiquant que  le Diagnostic  de la cohérence température d’eau au démarrage est terminé.
CRC_bCheck|A|func_CRC_bCheck|API1.2|CRC|1|V02 NT 09 03344||||0|0|0|0|Check the CRC of the frame
CRC_vidCalcCrc|A|(argin const uint8 * DataPtr, argin uint32 DataLength, argio uint16 * ComputedCrc );|FCT2.1|CRC|0|V02 NT 09 03344||||0|0|0|0|Calculates the CRC of the frame
CRC_vidComputation|A|(argin uint8 * DataPtr, argin uint32 DataLength, argio uint16 * ComputedCrc);|API1.1|CRC|1|V02 NT 09 03344||||0|0|0|0|Calculates the CRC of the frame
CRKHAL_u16GetEngineAngle|A|func_CRKHAL_u16GetEngineAngle|0x14|HEADER|1|NONE||||0|0|0|0|
CRKHAL_udtDisableBwdRotation|A|()argret Std_ReturnType;|0x0A|HEADER|1|NONE||||0|0|0|0|
CRKHAL_udtDisableQuickSynchro|A|()argret Std_ReturnType;|0x11|HEADER|1|NONE||||0|0|0|0|
CRKHAL_udtDisableSynchronisation|A|func_CRKHAL_udtDisableSynchronis|3|HEADER|1|NONE||||0|0|0|0|
CRKHAL_udtEnableBwdRotation|A|()argret Std_ReturnType;|0x0B|HEADER|1|NONE||||0|0|0|0|
CRKHAL_udtEnableDetection|A|func_CRKHAL_udtEnableDetection|0x04|HEADER|1|NONE||||0|0|0|0|
CRKHAL_udtEnableQuickSynchro|A|()argret Std_ReturnType;|0x09|HEADER|1|NONE||||0|0|0|0|
CRKHAL_udtEnableSynchronisation|A|func_CRKHAL_udtEnableSynchronis|1|HEADER|1|NONE||||0|0|0|0|
CRKHAL_udtGetEngStopPosition|A|(argin uint8 u8EngStopPositionType, argio uint16 *pu16EngStopPosition)argret Std_ReturnType;|0x0D|HEADER|1|NONE||||0|0|0|0|
CRKHAL_udtGetToothInfo|A|(argin uint8 u8MaxTableSize, argio uint32 *pau32ToothInfoTable)argret Std_ReturnType;|0x0C|HEADER|1|NONE||||0|0|0|0|
CRKHAL_udtReadLastToothDuration|A|func_CRKHAL_udtRLTD|0x01|HEADER|1|NONE||||0|0|0|0|
CRKHAL_udtReadMode|A|func_CRKHAL_udtReadMode|6|HEADER|1|NONE||||0|0|0|0||
CRKHAL_udtReadStatus|A|func_CRKHAL_udtReadStatus|4|HEADER|1|NONE||||0|0|0|0||
CRKHAL_udtWriteEnaToothTskRpmThd|A|(argin uint16 u16EngineSpeedThd)argret Std_ReturnType;|0x08|HEADER|1|NONE||||0|0|0|0|
CRKHAL_vidSetMode|A|(argin CRKHAL_tenuMode enuMode);|3|HEADER|1|NONE||||0|0|0|0||
CrkMgt_EveRst_AirTqStructMngt|C|();|SCH.1|AIRTQSTRUCTMNGT|1|PTS DOC 5015877||||0|0|0|0|évenement reset
CrkMgt_EveRst_AirTqStructMngtIf|C|();|SCH2.4|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|evènement Reset.|
CrkMgt_SdlFast_AirThrArCrkSp|D|();|SCH.3|AIRTHRARCRKSP|1|PTS_DOC_5074571||||0|0|0|0|moniteur rapide pour le calcul  de la consigne d'air papillon.|
CrkMgt_SdlFast_AirTqStructMngt|C|();|SCH.3|AIRTQSTRUCTMNGT|1|PTS DOC 5015877||||0|0|0|0|moniteur rapide
CrkMgt_SdlFast_IfTqSysIf|B|();|SCH15.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur de module d'interface.|
Crkmgt_sdlFast_tqStructMngtIf|C|();|SCH2.5|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Moniteur de module d'interface.|
Crkmgt_sdlFast_tqStructMngtIf2|C|();|SCH1.3|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Moniteur de module d'interface.|
CrkMgt_SdlMid_AirThrArCrkSp|D|();|SCH.2|AIRTHRARCRKSP|1|PTS_DOC_5074571||||0|0|0|0|moniteur moyen pour le calcul  de la condigne d'air papillon.|
CrkMgt_SdlMid_AirTqStructMngt|C|();|SCH.2|AIRTQSTRUCTMNGT|1|PTS DOC 5015877||||0|0|0|0|moniteur moyen
CrsCtl_EveRst_CrsCtlBsiTreat|E|();|SCH.1|CRSCTLBSITREAT|1|PTS_DOC_5206188||||0|0|0|0|Evènement reset de l'ECU|
CrsCtl_EveRst_CrsCtlInTreatIf|B|();|SCH.1|CRSCTLINTREATIF|1|V02 NT 11 06065||||0|0|0|0|Evenement reset.|
CrsCtl_EveRst_CrsCtlOutTreat|C|();|SCH.1|CRSCTLOUTTREAT|1|V02 NT 12 01019||||0|0|0|0|Fonction d'accroche à l'evenement Reset|
CrsCtl_EveRxn50E_CrsCtlBsiTreat|E|();|SCH.2|CRSCTLBSITREAT|1|PTS_DOC_5206188||||0|0|0|0|Evènement de réception de la trame 50E|
CrsCtl_SdlFast_CrsCtlInTreatIf|B|();|SCH.2|CRSCTLINTREATIF|1|V02 NT 11 06065||||0|0|0|0|Evenement moniteur rapide|
CrsCtl_SdlFast_CrsCtlOutTreat|B|();|SCH.2|CRSCTLOUTTREAT|1|V02 NT 12 01019||||0|0|0|0|Moniteur rapide pour la fonction xVV|
CrsCtl_SdlFast_CrsCtlOutTreatIf|E|();|SCH11.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide pour la fonction xVV|
CrsCtl_SdlSlow_CrsCtlBsiTreat|B|();|SCH.3|CRSCTLBSITREAT|1|PTS_DOC_5206188||||0|0|0|0|Moniteur lent pour la fonction xVV|
CrsCtl_SdlSlow_CrsCtlInTreatIf|A|();|SCH.3|CRSCTLINTREATIF|1|V02 NT 11 06065||||0|0|0|0|Evenement SdlSlow|
CRSCTLBSITREAT_vidBsiFraCnt|B|();|FCT1.5|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Focntion de diagnontis de cohérence du compteur de trame BSI|
CRSCTLBSITREAT_vidBsiFraFil|B|();|FCT1.8|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Cette fonction permet de filtrer les informations BSI en fonction des valeurs reçues du compteur de trame BSI avant qu’elles soient traitées pour les besoins de la fonction XVV|
CRSCTLBSITREAT_vidCksCoh|B|();|FCT2.2|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Cette fonction réalise la cohérence des cheksums en comparant le checksum interne (recalculé par l’ECU) à celui reçu par la trame de la BSI|
CRSCTLBSITREAT_vidCptTraBsiInc|B|();|FCT1.7|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Cette fonction réalise le diagnostic sur la valeur de l’incrément du compteur de trame BSI|
CRSCTLBSITREAT_vidCptTrBsiNtZero|B|();|FCT1.6|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Cette fonction réalise les diagnostics du compteur de trame BSI dans le cas où les valeurs  reçues sont différentes de zéro.|
CRSCTLBSITREAT_vidDiag_1|B|();|FCT1.3|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Fonction qui réalise les diagnostics des cohérences des informations BSI à chaque réception de la trame 50Eh et si la LVV ou RVV est détectée présente.|
CRSCTLBSITREAT_vidDiag_2|B|();|FCT2.3|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Fonction de diagnostic sur cohérence des informations de BVVP|
CRSCTLBSITREAT_vidDiagEna|B|();|FCT1.4|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Focntion qui décrit 5 stratégies de diagnostics de cohérence.|
CRSCTLBSITREAT_vidInfoBsiCoh|B|();|FCT1.9|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Cette fonction s’assure de la cohérence des informations envoyées par la BSI.|
CRSCTLBSITREAT_vidInfoTreat|B|();|FCT2.5|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Fonction qui traite les différentes informations.|
CRSCTLBSITREAT_vidInit|D|();|FCT1.1|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Fonction d'initialisation des variables produites.|
CRSCTLBSITREAT_vidInitOutput|E|();|FCT1.2|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Fonction d'initialisation.|
CRSCTLBSITREAT_vidLimSpdSpCoh|C|();|FCT1.10|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Cette fonction teste la cohérence de la consigne de vitesse envoyée par la BSI dans le cas où la LVV est active et à condition que l’ensemble des informations envoyées soient cohérentes entre-elles|
CRSCTLBSITREAT_vidNVRAMmanagemnt|B|();|FCT2.4|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Fonction qui gère l’écriture en RAM non volatile de la consigne de vitesse RVV.|
CRSCTLBSITREAT_vidOutAcvRgVSCtRq|B|();|FCT2.8|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Fonction qui détermine le type de Régulation longitudinale du Véhicule demandée.|
CRSCTLBSITREAT_vidOutspdVehLimRq|B|();|FCT2.6|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Production de la consigne de limitation de vitesse LVV.|
CRSCTLBSITREAT_vidRegSpdSpCoh|C|();|FCT2.1|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Cette fonction teste la cohérence de la consigne de vitesse envoyée par la BSI dans le cas où la RVV est sélectionnée et à condition que l’ensemble des informations envoyées soient cohérentes entre-elles|
CRSCTLBSITREAT_vidspdVehVSRegReq|B|();|FCT2.7|CRSCTLBSITREAT|0|PTS_DOC_5206188||||0|0|0|0|Fonction qui produit la consigne vitesse RVV.|
CRSCTLINTREATIF_vid3ADTreatIf|A|();|FCT1.5|CRSCTLINTREATIF|0|V02 NT 11 06065||||0|0|0|0|Fonction qui permet le calcul de Freinage dynamique en cours (0 = Pas en cours / Faux 1 = En cours / Vrai)|
CRSCTLINTREATIF_vid44DTreatIf|E|();|FCT1.6|CRSCTLINTREATIF|0|V02 NT 11 06065||||0|0|0|0|Cette fonction génère la variable Régime moyen roues avant par recopie du paramètre P354 provenant du CAN.|
CRSCTLINTREATIF_vid50DTreatIf|B|();|FCT1.4|CRSCTLINTREATIF|0|V02 NT 11 06065||||0|0|0|0|Cette fonction génère la variable Régulation ABS par recopie du paramètre P351 provenant du CAN.|
CRSCTLINTREATIF_vidAuth_clc|C|();|FCT1.8|CRSCTLINTREATIF|0|V02 NT 11 06065||||0|0|0|0|Cette fonction permet de calculer le flag d’initialisation «ECU_bAuthVSCtlIni ».|
CRSCTLINTREATIF_vidCrsctl|C|();|FCT1.9|CRSCTLINTREATIF|0|V02 NT 11 06065||||0|0|0|0|Cette fonction génère la consigne de vitesse BVV|
CRSCTLINTREATIF_vidCrsCtl_Can|A|();|FCT1.3|CRSCTLINTREATIF|0|V02 NT 11 06065||||0|0|0|0|Fonction qui permet l’initialisation  du flag ECU_bAuthVSCtlIni .|
CRSCTLINTREATIF_vidInit|A|();|FCT1.1|CRSCTLINTREATIF|0|V02 NT 11 06065||||0|0|0|0|Fonction qui permet l'initialisation des sorties.|
CRSCTLINTREATIF_vidInitOutput|A|();|FCT1.2|CRSCTLINTREATIF|0|V02 NT 11 06065||||0|0|0|0|Fonction qui permet l'initalisation des variables.|
CRSCTLINTREATIF_vidOutClunGearEg|D|();|FCT1.7|CRSCTLINTREATIF|0|V02 NT 11 06065||||0|0|0|0|cette fonction génére la detection débrayage et le rapport engagé.|
CRSCTLOUTTREAT_vidFctTreatProc|C|();|FCT1.9|CRSCTLOUTTREAT|0|V02 NT 12 01019||||0|0|0|0|Cette fonction sert d’interface entre la fonction xVV et le reste des fonctions internes calculateur.|
CRSCTLOUTTREAT_vidInitOutput|C|();|FCT1.2|CRSCTLOUTTREAT|0|V02 NT 12 01019||||0|0|0|0|Fonction d'initialisation des sorties|
CRSCTLOUTTREAT_vidSubSystem|C|();|FCT1.7|CRSCTLOUTTREAT|0|V02 NT 12 01019||||0|0|0|0|calcul de Cc_defaut_rvv_lvv_mux et de CrsCtl_bDgoCrsCtlDft|
CRSCTLOUTTREAT_vidxVV_init|B|();|FCT1.1|CRSCTLOUTTREAT|0|V02 NT 12 01019||||0|0|0|0|Ce bloc gère l’initialisation des variables sur évènement reset du calculateur.|
CRSCTLOUTTREAT_vidxVVFail|C|();|FCT1.6|CRSCTLOUTTREAT|0|V02 NT 12 01019||||0|0|0|0|Appel de la fonction CRSCTLOUTTREAT_vidSubSystem si Ext_bKeyOff = 0 et Diag_on = 1|
CRSCTLOUTTREAT_vidxVVFailCond|C|();|FCT1.5|CRSCTLOUTTREAT|0|V02 NT 12 01019||||0|0|0|0|Appel de la fonction CRSCTLOUTTREAT_vidxVVFail si Ext_bVSRegCf = 1 ou Ext_bVSLimCf = 1|
CRSCTLOUTTREAT_vidxVVInFctTreat|C|();|FCT1.8|CRSCTLOUTTREAT|0|V02 NT 12 01019||||0|0|0|0|Cette fonction active l'interface entre la fonction xVV et le reste des fonctions internes calculateur.|
CRSCTLOUTTREAT_vidxVVStateIndic|C|();|FCT1.4|CRSCTLOUTTREAT|0|V02 NT 12 01019||||0|0|0|0|Calcul de Cc_rvv_lvv_manager_state_mux|
CRSCTLOUTTREAT_vidxVVStIndiCond|C|();|FCT1.3|CRSCTLOUTTREAT|0|V02 NT 12 01019||||0|0|0|0|Appel de la fonction CRSCTLOUTTREAT_vidxVVStateIndic si Ext_bVSRegCf = 1 ou Ext_bVSLimCf = 1|
Cstr_EveCrTR_CstrEfcRed|A|();|SCH.3|CSTREFCRED|1|V02 NT 09 01759||||0|0|0|0|Fonction d'accroche au moniteur Cstr_EveCrTR_CstrEfcRed
Cstr_EveCrTR_FuConcEstim|E|();|SCH.1|CSTRFUCONCESTIM|1|PTS_DOC_5066966||||0|0|0|0|Evénement CRANKING vers RUNNING|
Cstr_EveKOf_CstrMgr|B|();|SCH.2|CSTRMGR|1|V02 NT 09 01858||||0|0|0|0|Evénement associé au passage de clef ON à clef OFF|
Cstr_EveRst_ActrTstCstr|A|();|SCH.1|CSTRACTEST|1|V02 NT 09 00924||||0|0|0|0|Evénement reset du calculateur.
Cstr_EveRst_CmdPwmCstr|A|();|SCH.4|CMDPWM|1|PTS_DOC_6669891||||0|0|0|0|Evènement reset du calculateur.
Cstr_EveRst_CstrCmd|D|();|SCH.1|CSTRCMD|1|PTS_DOC_6562479||||0|0|0|0|Evénement reset du calculateur
Cstr_EveRst_CstrDynLim|C|();|SCH.1|CSTRDYNLIM|1|PTS_DOC_5205503||||0|0|0|0|Evénement reset du calculateur|
Cstr_EveRst_CstrEfcRed|A|();|SCH.1|CSTREFCRED|1|V02 NT 09 01759||||0|0|0|0|Fonction d'accroche à l'evenement  Cstr_EveRst_CstrEfcRed
Cstr_EveRst_CstrMgr|B|();|SCH.1|CSTRMGR|1|V02 NT 09 01858||||0|0|0|0|Evénement reset du calculateur|
Cstr_EveRst_FuConcEstim|E|();|SCH.2|CSTRFUCONCESTIM|1|PTS_DOC_5066966||||0|0|0|0|Evénement reset du calculateur|
Cstr_SdlFast_CmdDiagCstr|A|();|SCH1.9|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Moniteur rapide pour la fonction purge canister.
Cstr_SdlFast_CstrCmd|D|();|SCH.3|CSTRCMD|1|PTS_DOC_6562479||||0|0|0|0|Moniteur rapide pour la fonction purge canister
Cstr_SdlFast_CstrEfcRed|A|();|SCH.2|CSTREFCRED|1|V02 NT 09 01759||||0|0|0|0|Fonction d'accroche au moniteur Cstr_SdlFast_CstrEfcRed
Cstr_SdlFast_FuConcEstim|E|();|SCH.3|CSTRFUCONCESTIM|1|PTS_DOC_5066966||||0|0|0|0|Moniteur rapide|
Cstr_SdlMid_ActrTstCstr|A|();|SCH.2|CSTRACTEST|1|V02 NT 09 00924||||0|0|0|0|Moniteur moyen de la fonction commande purge canister
Cstr_SdlMid_CmdPwmCstr|A|();|SCH.5|CMDPWM|1|PTS_DOC_6669891||||0|0|0|0|Evènement moniteur moyen pour la fonction purge canister.
Cstr_SdlMid_CstrCmd|D|();|SCH.2|CSTRCMD|1|PTS_DOC_6562479||||0|0|0|0|Moniteur moyen pour la fonction purge canister
Cstr_SdlMid_CstrDynLim|C|();|SCH.2|CSTRDYNLIM|1|PTS_DOC_5205503||||0|0|0|0|Moniteur moyen|
Cstr_SdlMid_CstrMgr|B|();|SCH.3|CSTRMGR|1|V02 NT 09 01858||||0|0|0|0|Moniteur moyen|
Cstr_SdlSlow_CstrEfcRed|A|();|SCH.4|CSTREFCRED|1|V02 NT 09 01759||||0|0|0|0|Fonction d'accroche au moniteur Cstr_SdlSlow_CstrEfcRed
Cstr_SdlSlow_FuConcEstim|E|();|SCH.4|CSTRFUCONCESTIM|1|PTS_DOC_5066966||||0|0|0|0|Moniteur lent|
CSTRACTEST_vidCmdState|C|();|FCT1.2|CSTRACTEST|0|V02 NT 09 00924||||0|0|0|0|Fonction decrivant le déroulement des tests actionneurs de purge canister.
CSTRACTEST_vidInitOutput|B|();|FCT1.1|CSTRACTEST|0|V02 NT 09 00924||||0|0|0|0|Initialisation des tests actionneurs  de purge canister
CSTRCMD_vidCmd|A|();|FCT1.2|CSTRCMD|0|PTS_DOC_6562479||||0|0|0|0|Le rapport cyclique d’ouverture de la purge canister pilote  la sortie purge canister de ECU.
CSTRCMD_vidDiag|A|();|FCT1.3|CSTRCMD|0|PTS_DOC_6562479||||0|0|0|0|Diagnostic circuit ouvert, circuit lié à la masse et alimentation.
CSTRCMD_vidInitOutput|A|();|FCT1.1|CSTRCMD|0|PTS_DOC_6562479||||0|0|0|0|Initialisation des variables produites.
CSTRDYNLIM_vidAirMaxCta|B|();|FCT1.6|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|Pour  ne  pas  avoir  de  surrégime  sur  lâcher  de  pied,  on  veut  limiter  la  contribution  de  la  purge à Cpc_max_amfr_thresh du débit d'air entrant dans le papillon.|
CSTRDYNLIM_vidCurPurgeRat|B|();|FCT1.3|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|Le taux de purge courant est calculé en fonction du débit papillon et du débit gaz de la purge.|
CSTRDYNLIM_vidCurRat|B|();|FCT1.9|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|calcul de la variable Cpc_max_purge_ratio|
CSTRDYNLIM_vidDynLimClc|C|();|FCT1.2|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|Tous les calculs se font au réveil ECU (Cstr_EveRst_CstrDynLim) et à la récurrence du moniteur moyen (Cstr_SdlMid_CstrDynLim).|
CSTRDYNLIM_vidFuMaxCta|C|();|FCT1.4|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|Afin  de  préserver  l’autorité  de  la  régulation  de  richesse,  tout  en  purgeant  au maximum  le  canister,  on  veut limiter la contribution en essence de la purge à Cpc_fuel_constraint_max .|
CSTRDYNLIM_vidInitOutput|B|();|FCT1.1|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|Initialisation des sorties|
CSTRDYNLIM_vidInjMinCta|D|();|FCT1.5|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|Le débit maximal pour permettre un temps d'injection Tmin|
CSTRDYNLIM_vidLsclCta|C|();|FCT1.7|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|L'objectif de ce processus est de calculer 'au mieux' l'évolution du taux de purge|
CSTRDYNLIM_vidNullRat|B|();|FCT1.8|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|calcul de la variable Cpc_max_purge_ratio|
CSTRDYNLIM_vidPrgDecRat|C|();|FCT2.1|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|calcul de la variable Cpc_max_purge_ratio|
CSTRDYNLIM_vidPrgIncRat|B|();|FCT1.10|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|calcul de la variable Cpc_max_purge_ratio|
CSTRDYNLIM_vidPurgeGblCta|C|();|FCT2.2|CSTRDYNLIM|0|PTS_DOC_5205503||||0|0|0|0|Ce processus utilise les contraintes spécifiques pour générer la contrainte globale en débit qui est ensuite  convertie en taux de purge.|
CSTREFCRED_vidClcn|A|();|FCT1.7|CSTREFCRED|0|V02 NT 09 01759||||0|0|0|0|Le booléen de demande de ralenti pour purger le canister est à ON
CSTREFCRED_vidClcnIdlReq|A|();|FCT1.6|CSTREFCRED|0|V02 NT 09 01759||||0|0|0|0|Cette stratégie est applicable à l’ensemble des moteurs essence pourvus de la fonctionnalité STOP & START.Le calcul du booléen est donc conditionné par Ext_bSTTCf = ON.
CSTREFCRED_vidEfcRedClcn|A|();|FCT1.3|CSTREFCRED|0|V02 NT 09 01759||||0|0|0|0|Fonction de production de la consigne de dégradation de rendement par l'avance pour la purge.
CSTREFCRED_vidInhApplySlewRate|A|();|FCT1.4|CSTREFCRED|0|V02 NT 09 01759||||0|0|0|0|Fonction ded égradation du rendement par l'avance pour la purge.
CSTREFCRED_vidIni|A|();|FCT1.1|CSTREFCRED|0|V02 NT 09 01759||||0|0|0|0|Initialisation des variables produites du module
CSTREFCRED_vidIniIdlReq|A|();|FCT1.5|CSTREFCRED|0|V02 NT 09 01759||||0|0|0|0|Au réveil calculateur, à chaque démarrage ou chaque redémarrage, le booléen de demande de ralenti pour réaliser la purge du canister doit être remis à zéro.
CSTREFCRED_vidTarClcn|A|();|FCT1.2|CSTREFCRED|0|V02 NT 09 01759||||0|0|0|0|Fonction de dégradation du rendement par l'avance pour la purge avant slew rate
CSTRFUCONCESTIM_NVMSRV_vidInit|B|();|FCT1.8|CSTRFUCONCESTIM|1|PTS_DOC_5066966||||0|0|0|0|Initialisation des variables Eeprom.|
CSTRFUCONCESTIM_vidCllConc|C|();|FCT2.1|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction d'estimation  de  la  proportion  de  vapeurs  d'essence  dans  le mélange  gazeux issu de la purge canister et de détermination du pas d’incrémentation  de la concentration.|
CSTRFUCONCESTIM_vidCllConcEstim|C|();|FCT2.2|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction de régultion de la richesse.|
CSTRFUCONCESTIM_vidConcFuErr|G|();|FCT2.3|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction de calcul de l'erreur commise sur l'estimateur de concentration de vapeur  d'essence dans le canister en boucle fermée.|
CSTRFUCONCESTIM_vidConcFuEstim|C|();|FCT2.4|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction d' estimation  de  la  proportion  de  vapeurs  d'essence  dans  le mélange  gazeux issu de la purge canister.|
CSTRFUCONCESTIM_vidCrk2RunIni|C|();|FCT1.3|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction d'affectation des valeurs du calculateur lors d'un calage.|
CSTRFUCONCESTIM_vidEstimMng|I|();|FCT1.4|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction de supervision du calcul de l'estimateur.|
CSTRFUCONCESTIM_vidFuEstim|D|();|FCT1.5|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction de calcul de la concentartion en vapeur d'essence et du débit courant issus de la purge.|
CSTRFUCONCESTIM_vidInitialization|E|();|FCT1.1|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction d'initialisation au reset.|
CSTRFUCONCESTIM_vidOplConc|C|();|FCT1.6|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction de réinitialisation des estimations de le concentration en vapeurs d'essence dans le canister et de l'erreur sur la concentration en vapeurs d'essence dans le canister.|
CSTRFUCONCESTIM_vidOplConcEstim|C|();|FCT1.7|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction d'incrémentation à un pas calibrable de l'estimateur lors de la fermeture de la purge ou au débouclage du lambda feedback.|
CSTRFUCONCESTIM_vidOutIf|E|();|FCT2.5|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction de centralisation des renommages des variables de sortie.|
CSTRFUCONCESTIM_vidStallTi|C|();|FCT1.2|CSTRFUCONCESTIM|0|PTS_DOC_5066966||||0|0|0|0|Fonction agissant sur le compteur Cpc_init_after_stall_count selon l'état de VS.|
CSTRMGR_vidCalcRcoDemandPurge|A|();|FCT1.5|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de calcul du RCO de commande d'ouverture de la purge en mode controlé.|
CSTRMGR_vidCalcRcoPurgeApplique|A|();|FCT1.8|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de calcul de la requête de RCO effectivement transmise au driver|
CSTRMGR_vidConsolidation|A|();|FCT1.7|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de consolidation de la commande de la purge|
CSTRMGR_vidFullLoadTrans|A|();|FCT2.4|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de transition de l'etat FULL_LOAD|
CSTRMGR_vidGsmPurgeClosingTrans|C|();|FCT2.8|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de transition de l'etat GSM_PURGE_CLOSING|
CSTRMGR_vidInit|A|();|FCT1.2|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction d'initialisation au Reset|
CSTRMGR_vidInitOutput|A|();|FCT1.1|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction d'initialisation.|
CSTRMGR_vidLambdaPurgeClosTrans|B|();|FCT2.7|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de transition de l'etat LAMBDA_PURGE_CLOSING|
CSTRMGR_vidMgr|A|();|FCT1.3|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction du manager de la gestion de la purge|
CSTRMGR_vidNormalBoundingTrans|B|();|FCT2.5|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de transition de l'etat NORMAL_BOUNDING|
CSTRMGR_vidOutputInterface|A|();|FCT1.9|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de production de l'indicateur de demande de fermeture de la purge|
CSTRMGR_vidPurgeBenchMod|A|();|FCT1.6|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de la gestion de la purge en mode banc|
CSTRMGR_vidPurgeClosedTrans|C|();|FCT2.2|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de transition de l'etat PURGE_CLOSED|
CSTRMGR_vidPurgeControlState|A|();|FCT2.1|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de l'automate de gestion de la purge|
CSTRMGR_vidPurgeHoldingTrans|C|();|FCT2.6|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de transition de l'etat PURGE_HOLDING|
CSTRMGR_vidPurgeMinTrans|B|();|FCT2.3|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de transition de l'etat PURGE_MIN|
CSTRMGR_vidPurgeNormalMod|A|();|FCT1.4|CSTRMGR|0|V02 NT 09 01858||||0|0|0|0|Fonction de gestion de la purge en mode normal|
CTLPMPREQ_vidCmd|B|();|FCT1.4|CTLPMPREQ|0|PTS_DOC_6851410||||0|0|0|0|Controlling the solenoid valve consists of: 1. Absolute value of the setpoint and filtering the battery voltage, 2. Correction of the duty cycle and limitation between 0 and 100pc, 3.Sending the duty cycle to BSW, 4. Filtering the current in the solenoid.|
CTLPMPREQ_vidCmdAbs|C|();|FCT1.5|CTLPMPREQ|0|PTS_DOC_6851410||||0|0|0|0|The main function of this block is obtaining the absolute value of application setpoint and filtering the battery voltage.|
CTLPMPREQ_vidCmdAndDiagEnable|C|();|FCT1.3|CTLPMPREQ|0|PTS_DOC_6851410||||0|0|0|0|The stategy consists of the two major functions: 1. Calculation of the oil pump solenoid valve controlling, 2. Oil pump solenoid diagnosis. Command and diagnosis could be inhibited using the boolean "Ctrl_bOilPmpCmd".|
CTLPMPREQ_vidCmdApp|E|();|FCT1.7|CTLPMPREQ|0|PTS_DOC_6851410||||0|0|0|0|The oil pump solenoid valve load (PWM frequency and duty cycle) is transmitted through the basic layer via the PWDHAL service.|
CTLPMPREQ_vidCmdCor|D|();|FCT1.6|CTLPMPREQ|0|PTS_DOC_6851410||||0|0|0|0|The duty cycle of oil pump solenoid valve is corrected and bounded between 0 and 100 per cent.|
CTLPMPREQ_vidDiag|C|();|FCT1.9|CTLPMPREQ|0|PTS_DOC_6851410||||0|0|0|0|The input Boolean Ctrl_bOilPmpCmd activates the diagnosis of solenoid strategy.|
CTLPMPREQ_vidDrvCur|B|();|FCT1.8|CTLPMPREQ|0|PTS_DOC_6851410||||0|0|0|0|The acquisition sends information to the current application Ext_iMesOilPmp by using  low pass first order filter of  Ext_iBrutMesOilPmp.|
CTLPMPREQ_vidInit|B|();|FCT1.1|CTLPMPREQ|0|PTS_DOC_6851410||||0|0|0|0|The outputs variables are initialized on ECU reset.|
CTLPMPREQ_vidInitOutput|C|();|FCT1.2|CTLPMPREQ|0|PTS_DOC_6851410||||0|0|0|0|This function initializes the internal data of the module.|
CTP_EveRst_ActrTstCTP|A|();|SCH.1|ACTRTSTCTP|1|V02 NT 12 05323||||0|0|0|0|Fonction d'accroche à l'event CTP_EveRst_ActrTstCTP|
CTP_SdlMid_ActrTstCTP|A|();|SCH.2|ACTRTSTCTP|1|V02 NT 12 05323||||0|0|0|0|Fonction d'accroche à l'event CTP_SdlMid_ActrTstCTP|
CTRLCFG_vidBrkUCFrame|G|();|FCT1.6|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|Each frame sent or received by the Brake control unit are activated by a control flow, according the vehicle configuration.|
CTRLCFG_vidBrkUCFrame2|F|();|FCT1.7|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|Each frame sent or received by the Brake control unit are activated by a control flow, according the vehicle configuration.|
CTRLCFG_vidBSIFrame|F|();|FCT1.9|CTRLCFG|0|PTS_DOC_5068500||||0|1|0|0|According to the variant coding of the vehicle, the frames sent or received by the BSI are activated or not.|
CTRLCFG_vidBSIFrame2|E|();|FCT1.10|CTRLCFG|0|PTS_DOC_5068500||||0|1|0|0|According to the variant coding of the vehicle, the frames sent or received by the BSI are activated or not.|
CTRLCFG_vidBSIFrame3|F|();|FCT2.1|CTRLCFG|0|PTS_DOC_5068500||||0|1|0|0|According to the variant coding of the vehicle, the frames sent or received by the BSI are activated or not.|
CTRLCFG_vidBSIFrame4|B|();|FCT2.2|CTRLCFG|0|PTS_DOC_5068500||||0|1|0|0|According to the variant coding of the vehicle, the frames sent or received by the BSI are activated or not.|
CTRLCFG_vidBSIFrame5|C|();|FCT2.3|CTRLCFG|0|PTS_DOC_5068500||||0|1|0|0|According to the variant coding of the vehicle, the frames sent or received by the BSI are activated or not.|
CTRLCFG_vidCluFrames|C|();|FCT2.9|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|According to the variant coding of the vehicle, the frames sent or received by the power steering are activated or not.|
CTRLCFG_vidCtrlCfg|I|();|FCT1.1|CTRLCFG|0|PTS_DOC_5068500||||0|1|0|0|All the activation flows are fixed to 1.|
CTRLCFG_vidCtrlCfg2|D|();|FCT1.2|CTRLCFG|0|PTS_DOC_5068500||||0|1|0|0|All the activation flows are fixed to 1.|
CTRLCFG_vidECUFrames|F|();|FCT2.4|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|According to the variant coding of the vehicle, the frames sent or received by the ECU are activated or not.|
CTRLCFG_vidECUFrames2|G|();|FCT2.5|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|According to the variant coding of the vehicle, the frames sent or received by the ECU are activated or not.|
CTRLCFG_vidECUFrames3|F|();|FCT2.6|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|According to the variant coding of the vehicle, the frames sent or received by the ECU are activated or not.|
CTRLCFG_vidFrameCfg|C|();|FCT1.3|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|According the variant coding of the vehicle, the CAN frames will be activated (their control flow will be equal to 1). We authorize the transmission or the reception of each frame.|
CTRLCFG_vidFrameCfg2|C|();|FCT1.4|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|According the variant coding of the vehicle, the CAN frames will be activated (their control flow will be equal to 1). We authorize the transmission or the reception of each frame.|
CTRLCFG_vidFrameCfg3|C|();|FCT1.5|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|According the variant coding of the vehicle, the CAN frames will be activated (their control flow will be equal to 1). We authorize the transmission or the reception of each frame.|
CTRLCFG_vidGearBoxFrame|F|();|FCT1.8|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|According to the variant coding of the vehicle, the Gear Box frames are activated or not.|
CTRLCFG_vidOther_Frames_Param|D|();|FCT2.8|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|Other frames or parameters are always activated.|
CTRLCFG_vidPSFrames|D|();|FCT2.7|CTRLCFG|0|PTS_DOC_5068500||||0|0|0|0|According to the variant coding of the vehicle, the frames sent or received by the power steering are activated or not.|
DC_RstDC|B|();|SCH.8|DC|1|V02 NT 10 04662||||0|0|0|0|Restart module DC by calling ReInit function|
DC_RstDftCal|B|();|SCH.4|DC|1|V02 NT 10 04662||||0|0|0|0|Demande d'effacement Manuel des défauts|
DC_vidExitEveGlbStrt|A|();|8|HEADER|1|HEADER||||0|0|0|0|fonction du WUC|
DC_vidF01_Autorise|B|();|FCT1.3|DC|0|V02 NT 10 04662||||0|0|0|0|Global DC Start autorize during the next starting|
DC_vidF01_NonAutorise|B|();|FCT1.2|DC|0|V02 NT 10 04662||||0|0|0|0|Global DC Start not autorize during the next starting|
DC_vidF02_F01_ValDC|C|(argin uint16 u16IdxDft);|FCT1.6|DC|0|V02 NT 10 04662||||0|0|0|0|This data set to TRUE the parameter DC_B<typeCc_NameVar> of the default indicated by its index.|
DC_vidF02_GlbDCStrtEve|C|();|FCT1.4|DC|0|V02 NT 10 04662||||0|0|0|0|Function which indicate to the rest of the module that an Global DC has started.|
DC_vidF03_DC_Reinit|B|();|FCT1.7|DC|0|V02 NT 10 04662||||0|0|0|0|A chaque début d’un nouveau DC global, les DC Appliqués sont réinitialisés à l’état « Non Réalisé ».|
DC_vidF03_F01_NotRelzd|C|();|FCT1.5|DC|0|V02 NT 10 04662||||0|0|0|0|set to false the data DC_bSynGlbDC to indicate that the DC is in the state not realized.|
DC_vidInit|C|();|FCT1.1|DC|0|V02 NT 10 04662||||0|0|0|0|Intialized the DC parameter.|
DC_vidMngEveCDThd|C|(argin uint16 u16IdxDft);|API.1|DC|1|V02 NT 10 04662||||0|0|0|0|API called on the event EveCDTh generated by the module GDU.This API calls after the DC functions linked to this event.|
DC_vidMngEveCDThd_opt|A|(argin sint32 s32IdxDft,argin uint32 u32IdxDft);|1|HEADER|1|HEADER||||0|0|0|0|header|
DC_vidMngEveCrTR|B|();|SCH.2|DC|1|V02 NT 10 04662||||0|0|0|0|Evenement Crank to run|
DC_vidMngEveCrTst|B|();|SCH.3|DC|1|V02 NT 10 04662||||0|0|0|0|Event CRANKING to STALL|
DC_vidMngEveKeyODB|C|();|API.2|DC|1|V02 NT 10 04662||||0|0|0|0|API which call the functions which must be executed on this event.|
DC_vidMngEveRst|C|();|SCH.1|DC|1|V02 NT 10 04662||||0|0|0|0|Evenement Reset du calculateur|
Dcm_ComM_FullComModeEntered|B|(argin uint8 NetworkId);|DCM.2|HEADER|1|NONE||||0|0|0|0||
DCM_CONFIG_Eve_5ms|B|();|SCH.2|DCM_CONFIG|1|PTS_DOC_5074345||||0|1|0|0|Moniteur schedule à 5ms du DCM|
DCM_CONFIG_EveRst|B|();|SCH.1|DCM_CONFIG|1|PTS_DOC_5074345||||0|1|0|0|Evène Reset du DCM|
DCM_CONFIG_sdlFast_DiagSrv|A|();|SCH.4|DCM_CONFIG|1|PTS_DOC_5074345||||0|1|0|0|Moniteur rapide de la fonction Srv|
DCM_CONFIG_SdlMid_RcRst|B|();|SCH.3|DCM_CONFIG|1|PTS_DOC_5074345||||0|1|0|0|Moniteur moyen du DCM|
Dcm_Confirmation|G|(argin Dcm_IdContextType idContext, argin PduIdType dcmRxPduId, argin Dcm_ConfirmationStatusType status);|DCM_CALLOUTS.5|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|This function confirms thesuccessful transmission or a transmission error of a diagnostic service. The idContext and the dcmRxPduId are required to identify the message which was processed.|
Dcm_DefaultSessionModeEntry|G|();|0x02|DCM_CFG|1|NONE||||0|0|0|1||
Dcm_ExtendedDiagnosticSessionModeEntry|J|();|0x01|SCHM_DCM|1|NONE||||0|0|0|1||
Dcm_GetSesCtrlType|B|func_OBDMODE9_Inftyp_08|78|HEADER|1|NONE||||0|0|0|0||
Dcm_Init|B|func_Dcm_Init|DCM.2|HEADER|1|NONE||||0|0|0|0||
Dcm_MainFunction|B|();|DCM.1|HEADER|1|NONE||||0|0|0|0||
DCM_MANU_AccP_EveRstPed|B|();|78|HEADER|1|NONE||||0|0|0|0||
DCM_MANU_ActTstResAnalyse|B|func_DCM_MANU_ActTstResAnalyse|ACTUATOR_TST_MNG.9|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction analysant le résultat des la machine d'état.|
DCM_MANU_ActTstStateMachineTransition|B|();|ACTUATOR_TST_MNG.7|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Evènement pilotant la machine d'état des tests actionneurs côté com.|
DCM_MANU_ActuatorTestCheckCond|B|func_DCM_MANU_ActuatorTestCheckCond|ACTUATOR_TST_MNG.8|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Cette fonction effectue le test des conditions applicatives avant de lancer un test actionneur.|
DCM_MANU_ActuatorTestCheckCond_Farsp|B|func_ActuatorTestCheckCond_Farsp|ACTUATOR_TST_FCT.1|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction traitant les conditions d'exécution de la routine FASP|
DCM_MANU_CALL_CheckRcCdn_RstAFAMgtT|B|func_rte_call_CheckRcCdn|FCT2.3|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction testant les conditions de terminaison de la routine reset AFAMgtT data service THR/INJ/VVT|
DCM_MANU_CALL_CheckRcCdn_RstCylHdDmgCnt|B|func_rte_call_CheckRcCdn|FCT2.5|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction testant les conditions de terminaison de la routine reset the damage counter of the cylinder head|
DCM_MANU_CALL_CheckRcCdn_RstCylHdDmgCplmCnt|B|func_rte_call_CheckRcCdn|FCT2.11|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction testant les conditions de terminaison de la rouine reset the damage counter of the cylinder head complementary|
DCM_MANU_CALL_CheckRcCdn_RstMnfDmgCnt|B|func_rte_call_CheckRcCdn|FCT2.7|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction testant les conditions de terminaison de la routine reset the damage counter of the exhaust manifold|
DCM_MANU_CALL_CheckRcCdn_RstTrbActSys|B|func_rte_call_CheckRcCdn|FCT2.13|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction testant les conditions de terminaison de la routine reset TrbActSys data service Waste Gate|
DCM_MANU_CALL_CheckRcCdn_RstTrbDmgCnt|B|func_rte_call_CheckRcCdn|FCT2.9|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction testant les conditions de terminaison de la routine reset the damage counter of the turbo housing|
DCM_MANU_CALL_RcAcv_RstAFAMgtT|B|func_rte_call_RcAcv|FCT2.2|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction exécutant le fonctionnel de la routine reset AFAMgtT data service THR/INJ/VVT|
DCM_MANU_CALL_RcAcv_RstCylHdDmgCnt|B|func_rte_call_RcAcv|FCT2.4|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction exécutant le fonctionnel de la routine reset the damage counter of the cylinder head|
DCM_MANU_CALL_RcAcv_RstCylHdDmgCplmCnt|B|func_rte_call_RcAcv|FCT2.10|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction exécutant le fonctionnel de la routine reset the damage counter of the cylinder head complementary|
DCM_MANU_CALL_RcAcv_RstMnfDmgCnt|B|func_rte_call_RcAcv|FCT2.6|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction exécutant le fonctionnel de la routine reset the damage counter of the exhaust manifold|
DCM_MANU_CALL_RcAcv_RstTrbActSys|B|func_rte_call_RcAcv|FCT2.12|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction exécutant le fonctionnel de la routine reset TrbActSys data service Waste Gate|
DCM_MANU_CALL_RcAcv_RstTrbDmgCnt|B|func_rte_call_RcAcv|FCT2.8|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction exécutant le fonctionnel de la routine reset the damage counter of the turbo housing|
DCM_MANU_CaracInjWriteReqInit|C|();|CARACINJ.1|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Fonction appelée pour initialiser les données liées à l'écriture de la caractérisation des injecteurs.|
DCM_MANU_CheckADCCondition|C|func_DCM_MANU_CheckADCCondition|AllChecked.2|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Check condition "ADC"|
DCM_MANU_CheckChangeSessionSWCcondition|B|func_rte_call_changeSessionSWC|FCT2.1|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Fonction testant les conditions de changement de session relatives aux SWC PSA|
DCM_MANU_CheckCond4AcvUnloadRail|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.3|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée à la décharge de pression rail.|
DCM_MANU_CheckCond4BattChg|B|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.18|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about battery changing|
DCM_MANU_CheckCond4InhBoostGDI|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.77|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée aux condiftions d'exécution de la routine DFA2|
DCM_MANU_CheckCond4IniRealTiTroCnt|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.2|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée à je ne sais plus quoi.|
DCM_MANU_CheckCond4MkdPwrl|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.1|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée à l'init du marqueur power latch.|
DCM_MANU_CheckCond4ModeSTTAftsReq|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.61|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to performe the conditions to authorize or not the Routine about STT after sales forced stop mode|
DCM_MANU_CheckCond4ModeSTTBatt|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.64|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to performe the conditions to authorize or not the Routine about STT after sales battery removal mode|
DCM_MANU_CheckCond4ModeSTTFactReq|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.58|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to performe the conditions to authorize or not the Routine about STT factory stop mode|
DCM_MANU_CheckCond4ProdTest|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.4|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée au saut dans les tests en prod.|
DCM_MANU_CheckCond4RstAFAMgtT|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.39|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to performe the conditions to authorize or not the Routine about reset AFAMgtT data service THR/INJ/VVT|
DCM_MANU_CheckCond4RstCluDftCnt|B|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.31|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset clutch default AFTS counter|
DCM_MANU_CheckCond4RstCoReqRStrt|B|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.24|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset for learned value in function re-start|
DCM_MANU_CheckCond4RstCurRdB|B|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.21|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset learning RdB current|
DCM_MANU_CheckCond4RstCylHdDmgCnt|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.46|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to performe the conditions to authorize or not the Routine about reset the damage counter of the cylinder head|
DCM_MANU_CheckCond4RstCylHdDmgCplmCnt|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.55|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to performe the conditions to authorize or not the Routine about reset the damage counter of the cylinder head complementary|
DCM_MANU_CheckCond4RstDfwChg|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.37|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to performe the conditions to authorize or not the Routine about engine flywheel (DWA) exchange service|
DCM_MANU_CheckCond4RstESLim|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.43|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to performe the conditions to authorize or not the Routine about reset TrbActSys data service ESLim|
DCM_MANU_CheckCond4RstLrn_Misf|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.2|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée aux condiftions d'exécution de la routine DF37|
DCM_MANU_CheckCond4RstMnfDmgCnt|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.49|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to performe the conditions to authorize or not the Routine about reset the damage counter of the exhaust manifold|
DCM_MANU_CheckCond4RstPed|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.70|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée aux condiftions d'exécution de la routine DF33|
DCM_MANU_CheckCond4RstReqStcBatt|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.2|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée aux condiftions d'exécution de la routine DF36|
DCM_MANU_CheckCond4RstStaCnt|B|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.28|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset starter activation counter|
DCM_MANU_CheckCond4RstTrbActSys|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.67|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to performe the conditions to authorize or not the Routine about reset TrbActSys data service Waste Gate|
DCM_MANU_CheckCond4RstTrbDmgCnt|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.52|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to performe the conditions to authorize or not the Routine about reset the damage counter of the turbo housing|
DCM_MANU_CheckCond4SftyLvl2|D|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.5|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée au Safety Niveau 2|
DCM_MANU_CheckCond4ThrInh|B|func_DCM_MANU_CheckCond4Xxx|ROUTINE_CNTRL_FCT.16|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about throttle inhibition|
DCM_MANU_CheckFunctionalAvailability|B|func_DCM_MANU_CheckFunctionalAvailability|Mng_API.6|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Cette fonction permet de déterminer si la requête reçue est bien autorisée en adressage fonctionnelle.|
DCM_MANU_Checking_Result_Analyse|B|func_XXX_ADC_Result_Analyse|ROUTINE_CNTRL_MNG.12|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction permettant d'analyser le résultat de la requete Checking ADC|
DCM_MANU_CheckRcCdn_BattChg|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.19|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about battery changing|
DCM_MANU_CheckRcCdn_MkdPwrl|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.10|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée au marqeur de powerlatch|
DCM_MANU_CheckRcCdn_ModeSTTAftsReq|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.62|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to indicate that the Routine about STT after sales forced stop mode is finished OK or NOK|
DCM_MANU_CheckRcCdn_ModeSTTBatt|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.65|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to indicate that the Routine about STT after sales battery removal mode is finished OK or NOK|
DCM_MANU_CheckRcCdn_ModeSTTFactReq|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.59|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to indicate that the Routine about STT factory stop mode is finished OK or NOK|
DCM_MANU_CheckRcCdn_RstAFAMgtT|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.41|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to indicate that the Routine about reset AFAMgtT data service THR/INJ/VVT is finished OK or NOK|
DCM_MANU_CheckRcCdn_RstCluDftCnt|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.32|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset clutch default AFTS counter|
DCM_MANU_CheckRcCdn_RstCoReqRStrt|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.25|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset for learned value in function re-start|
DCM_MANU_CheckRcCdn_RstCurRdB|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.22|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset learning RdB current|
DCM_MANU_CheckRcCdn_RstCylHdDmgCnt|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.47|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to indicate that the Routine about reset the damage counter of the cylinder head is finished OK or NOK|
DCM_MANU_CheckRcCdn_RstCylHdDmgCplmCnt|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.56|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to indicate that the Routine about reset the damage counter of the cylinder head complementary is finished OK or NOK|
DCM_MANU_CheckRcCdn_RstDfwChg|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.36|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to indicate that the Routine about engine flywheel (DWA) exchange service is finished OK or NOK|
DCM_MANU_CheckRcCdn_RstESLim|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.44|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to indicate that the Routine about reset TrbActSys data service ESLim is finished OK or NOK|
DCM_MANU_CheckRcCdn_RstMnfDmgCnt|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.50|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to indicate that the Routine about reset the damage counter of the exhaust manifold is finished OK or NOK|
DCM_MANU_CheckRcCdn_RstStaCnt|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.29|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset starter activation counter|
DCM_MANU_CheckRcCdn_RstTrbActSys|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.68|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to indicate that the Routine about reset TrbActSys data service Waste Gate is finished OK or NOK|
DCM_MANU_CheckRcCdn_RstTrbDmgCnt|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.53|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to indicate that the Routine about reset the damage counter of the turbo housing is finished OK or NOK|
DCM_MANU_CheckRcCdn_tiRcRstEnd|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.26|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about timer tiRcRstEnd|
DCM_MANU_CheckVehicleCondition|D|func_DCM_MANU_CheckVehicleCondition|AllChecked.1|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Check condition "Véhicule non roulant / Moteurarrêté "|
DCM_MANU_CompareKey_SecLevel_2|E|func_dcm_compareKey|Sa_API.2|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Function appelée dans le DCM sur l'événement SA $27 $04|
DCM_MANU_EveAckActrTstDmd|A|();|ACTUATOR_TST_MNG.2|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction appelée par Srv_EveAckActrTstDmd_ActrTstMn.|
DCM_MANU_EveAcvBoostGDI_SrvRc|B|();|106|HEADER|1|NONE||||0|0|0|0||
DCM_MANU_EveErrPostEquWr|B|();|78|HEADER|1|NONE||||0|0|0|0||
DCM_MANU_EveErrTeleWr|B|();|89|HEADER|1|NONE||||0|0|0|0||
DCM_MANU_EveInhBoostGDI_SrvRc|B|();|108|HEADER|1|NONE||||0|0|0|0||
DCM_MANU_EveRC_SdlMid|B|();|FCT1.13|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|The Boost GDI inhibition Boolean behaviour generates two events that will enable or disable the boost GDI|
DCM_MANU_EveRcRst1|B|();|FCT1.1|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about timer_adaptative|
DCM_MANU_EveRcRst2|B|();|FCT1.4|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about timer_adaptative|
DCM_MANU_EveRcRst4|B|();|FCT1.3|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about timer_adaptative|
DCM_MANU_EveRcStt|B|();|FCT1.2|DCM_MANU|1|PTS_DOC_5074350||||0|0|0|0|Function about timer_adaptative|
DCM_MANU_EveRst_ActrTstRc|B|();|ACTUATOR_TST_MNG.1|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Evènement reset pour les tests actionneur.|
DCM_MANU_EveRst_RC|D|();|ROUTINE_CNTRL_MNG.1|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Evènement appelé par le reset.|
DCM_MANU_EveRstLrn_MisfDftLrn|B|();|2|HEADER|1|NONE||||0|0|0|0||
DCM_MANU_EveRstThr_SrvRc|B|();|89|HEADER|1|NON||||0|0|0|0||
DCM_MANU_EveRstVVT_SrvRc|B|();|105|HEADER|1|NONE||||0|0|0|0||
DCM_MANU_EveSessChg|B|();|SCH.2|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Evènement appelé lorsque le DCM change de session. (Evènement interne au DCM_MANU)|
DCM_MANU_EveSessChg_ActrTstRc|B|();|ACTUATOR_TST_MNG.3|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Evènement informant les tests actionneurs que la session a changé?|
DCM_MANU_EveSessChg_RC|D|();|ROUTINE_CNTRL_MNG.2|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction appelée sur changement de session.|
DCM_MANU_GetDTRValue_OBDMID01_TID01|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.1|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID01_TID02|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.2|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID01_TID03|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.3|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID01_TID04|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.4|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID01_TID07|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.5|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID01_TID08|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.6|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID01_TID0A|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.7|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID01_TIDA0|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.8|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID01_TIDA1|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.9|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID02_TID01|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.10|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID02_TID02|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.11|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID02_TID03|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.12|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID02_TID04|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.13|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID02_TID07|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.14|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID02_TID08|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.15|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID02_TIDC0|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.16|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID02_TIDC1|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.17|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID02_TIDC2|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.18|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID21_TID81|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.19|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID41_TIDD0|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.29|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMID42_TIDDA|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.20|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMIDA2_TID0B|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.21|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMIDA2_TID0C|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.22|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMIDA3_TID0B|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.23|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMIDA3_TID0C|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.24|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMIDA4_TID0B|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.25|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMIDA4_TID0C|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.26|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMIDA5_TID0B|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.27|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetDTRValue_OBDMIDA5_TID0C|A|func_GetDTRValue_OBDMIDXX_TIDXX|OBDMode06_API1.28|DCM_MANU|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD MIDXX TIDYY is received.|
DCM_MANU_GetSeed_SecLevel_2|E|func_Dcm_getSeed|Sa_API.1|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Fonction appelée dans le DCM sur événement SA $27 $03|
DCM_MANU_IuprResponseConcat|D|func_DCM_MANU_IuprResponseConcat|ROUTINE_CNTRL_MNG.9|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Concaténation de la réponse aux requêtes IUPR.|
DCM_MANU_IuprResponseCreate|D|();|ROUTINE_CNTRL_MNG.8|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Creation des différentes tables IUPR.|
DCM_MANU_ManufacturerIndication|I|func_DCM_MANU_ManufacturerIndication|Mng_API.4|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|The interface ServiceRequestManufacturerIndication indicates to the Manufacturer Application that a service is about to be executed and allows the Manufacturer Application to reject the execution of the service request.|
DCM_MANU_ManufSupplIndication|F|func_DCM_MANU_ManufacturerIndication|Mng_API.5|DCM_MANU|1|PTS_DOC_5074345|V02 NT 11 06099|||0|0|0|0|The interface ServiceRequestManufSupplIndication indicates to the Manufacturer Application that a service is about to be executed and allows the Manufacturer          Application to reject the execution of the service request|
DCM_MANU_Matching_Result_Analyse|B|func_XXX_ADC_Result_Analyse|ROUTINE_CNTRL_MNG.10|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction permettant d'analyser le résultat de la requete Matching ADC|
DCM_MANU_PostEquipementWriteReqInit|C|();|POSTEQUIPEMENT.1|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Fonction initialisant le Post Equipement|
DCM_MANU_Programming_Result_Analyse|B|func_XXX_ADC_Result_Analyse|ROUTINE_CNTRL_MNG.11|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction permeettant d'analyse le résultat de la requete Programming ADC|
DCM_MANU_RcAcv_AcvUnloadRail|D|();|ROUTINE_CNTRL_FCT.7|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée à la décharge de pression rail.|
DCM_MANU_RcAcv_BattChg|B|();|ROUTINE_CNTRL_FCT.17|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about battery changing|
DCM_MANU_RcAcv_InhBoostGDI|D|();|ROUTINE_CNTRL_FCT.78|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée au fonctionnel de la routine DFA2|
DCM_MANU_RcAcv_IniRealTiTroCnt|D|();|ROUTINE_CNTRL_FCT.6|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée à je ne sais plus quoi.|
DCM_MANU_RcAcv_MkdPwrl|D|();|ROUTINE_CNTRL_FCT.8|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée à l'initialisation du marqueur Power Latch.|
DCM_MANU_RcAcv_ModeSTTAftsReq|D|();|ROUTINE_CNTRL_FCT.60|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to realize for the Routine about STT after sales forced stop mode|
DCM_MANU_RcAcv_ModeSTTBatt|D|();|ROUTINE_CNTRL_FCT.63|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to realize for the Routine about STT after sales battery removal mode|
DCM_MANU_RcAcv_ModeSTTFactReq|D|();|ROUTINE_CNTRL_FCT.57|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to realize for the Routine about STT factory stop mode|
DCM_MANU_RcAcv_ProdTest|D|();|ROUTINE_CNTRL_FCT.9|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée au tests en prod.|
DCM_MANU_RcAcv_RstAFAMgtT|D|();|ROUTINE_CNTRL_FCT.38|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to realize for the Routine about reset AFAMgtT data service THR/INJ/VVT|
DCM_MANU_RcAcv_RstCluDftCnt|B|();|ROUTINE_CNTRL_FCT.30|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset clutch default AFTS counter|
DCM_MANU_RcAcv_RstCoReqRStrt|B|();|ROUTINE_CNTRL_FCT.23|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset for learned value in function re-start|
DCM_MANU_RcAcv_RstCurRdB|B|();|ROUTINE_CNTRL_FCT.20|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset learning RdB current|
DCM_MANU_RcAcv_RstCylHdDmgCnt|D|();|ROUTINE_CNTRL_FCT.45|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to realize for the Routine about reset the damage counter of the cylinder head|
DCM_MANU_RcAcv_RstCylHdDmgCplmCnt|D|();|ROUTINE_CNTRL_FCT.54|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to realize for the Routine about reset the damage counter of the cylinder head complementary|
DCM_MANU_RcAcv_RstDfwChg|D|();|ROUTINE_CNTRL_FCT.35|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to realize for the Routine about engine flywheel (DWA) exchange service|
DCM_MANU_RcAcv_RstESLim|D|();|ROUTINE_CNTRL_FCT.42|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to realize for the Routine about reset TrbActSys data service ESLim|
DCM_MANU_RcAcv_RstLrn_Misf|D|();|ROUTINE_CNTRL_FCT.6|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée au fonctionnel de la routine DF37|
DCM_MANU_RcAcv_RstMnfDmgCnt|D|();|ROUTINE_CNTRL_FCT.48|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to realize for the Routine about reset the damage counter of the exhaust manifold|
DCM_MANU_RcAcv_RstPed|D|();|ROUTINE_CNTRL_FCT.69|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée au fonctionnel de la routine DF33|
DCM_MANU_RcAcv_RstReqStcBatt|D|();|ROUTINE_CNTRL_FCT.6|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée au fonctionnel de la routine DF36|
DCM_MANU_RcAcv_RstStaCnt|B|();|ROUTINE_CNTRL_FCT.27|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about reset starter activation counter|
DCM_MANU_RcAcv_RstTrbActSys|D|();|ROUTINE_CNTRL_FCT.66|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to realize for the Routine about reset TrbActSys data service Waste Gate|
DCM_MANU_RcAcv_RstTrbDmgCnt|D|();|ROUTINE_CNTRL_FCT.51|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Action to realize for the Routine about reset the damage counter of the turbo housing|
DCM_MANU_RcAcv_SftyLvl2|B|();|ROUTINE_CNTRL_FCT.34|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée à la routine Safety Niveau 2|
DCM_MANU_RcAcv_ThrInh|B|();|ROUTINE_CNTRL_FCT.15|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about throttle inhibition|
DCM_MANU_RcCdn_4AcvUnloadRail|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.12|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about Diminution of pressure in rail|
DCM_MANU_RcCdn_InhBoostGDI|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.79|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée aux conditions de terminaison de la routine DFA2|
DCM_MANU_RcCdn_IniRealTiTroCnt|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.11|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|function about Reset of realtime trouble counter|
DCM_MANU_RcCdn_ProdTest|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.13|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about Tests in production of the ECU|
DCM_MANU_RcCdn_RstLrn_Misf|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.11|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée aux conditions de terminaison de la routine DF37|
DCM_MANU_RcCdn_RstPed|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.71|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée aux conditions de terminaison de la routine DF33|
DCM_MANU_RcCdn_RstReqStcBatt|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.11|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction liée aux conditions de terminaison de la routine DF36|
DCM_MANU_RcCdn_SftyLvl2|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.14|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about safety level 2|
DCM_MANU_RcCdn_ThrInh|B|func_DCM_MANU_CheckRcCdn_Xxx|ROUTINE_CNTRL_FCT.33|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about throttle inhibition|
DCM_MANU_ReqResActuatorTst|B|func_DCM_MANU_xxxActuatorTst|ACTUATOR_TST_MNG.6|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction appelée lors de la réception d'une sous fonction Request Result.|
DCM_MANU_RequestResult_Rc_Acttest_Factor_Mngmt|A|func_DCM_MANU_RequestResult_Rc_Acttest_Factor_Mngmt|ACTUATOR_TST_MNG.11|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Focntion appelée sur réception de requête Request Result pour les tests actionneurs uniquement.|
DCM_MANU_Reset|D|();|SCH.1|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Evènement Reset|
DCM_MANU_ResetInit|A|();|Reset.1|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Intialisation de la variable lié à la requête de reset|
DCM_MANU_RoutineResAnalyse|D|func_DCM_MANU_RoutineResAnalyse|ROUTINE_CNTRL_MNG.6|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Analyse des résultat de la routine.|
DCM_MANU_SecurityAcessReqInit|C|();|Sa_API.3|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Fonction gérant l'initialisationdu SA|
DCM_MANU_SrvEvePostEquWrt|B|();|14|HEADER|1|NONE||||0|0|0|0||
DCM_MANU_SrvEveSa|B|();|99|HEADER|1|NONE||||0|0|0|0||
DCM_MANU_SrvEveTele|B|();|15|HEADER|1|NONE||||0|0|0|0|Evénement télécodage|
DCM_MANU_Start_Rc_Acttest_Factor_Mngmt|A|func_DCM_MANU_Start_Rc_Acttest_Factor_Mngmt|ACTUATOR_TST_MNG.10|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction appelée sur réception de requête de type Start Routine pour les tests actionneurs.|
DCM_MANU_StartActuatorTst|D|func_DCM_MANU_xxxActuatorTst|ACTUATOR_TST_MNG.4|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Evenement interne pour avertir le manager qu'une demande de démarrage d'un test donné a éé reçu.|
DCM_MANU_StartProtocol|I|func_DCM_MANU_StartProtocol|Mng_API.1|DCM_MANU|1|PTS_DOC_5074345|V02 NT 11 06099|||0|0|0|0|Indication of protocol start. Application is able to reject further processing of requested protocol due to failed conditions.|
DCM_MANU_Stop_Rc_Acttest_Factor_Mngmt|A|func_DCM_MANU_Stop_Rc_Acttest_Factor_Mngmt|ACTUATOR_TST_MNG.12|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction appelée sur réception de requête Stop Routine. Uniquement pour les tests actionneurs…|
DCM_MANU_StopActuatorTst|B|func_DCM_MANU_xxxActuatorTst|ACTUATOR_TST_MNG.5|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Fonction appelée lors de la réception de la sous fonction stop routine|
DCM_MANU_StopProtocol|H|func_DCM_MANU_StopProtocol|Mng_API.2|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Indication of protocol stop. If a running diagnostic requested is preempted by a higher prior request (of an other protocol, e.g. OBD), application is requested to abort further processing of running request ProtocolID.|
DCM_MANU_SupplierIndication|I|func_DCM_MANU_SupplierIndication|Mng_API.3|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|The interface ServiceRequestSupplierIndication indicates to the Supplier Application that a service is about to be executed and allows the Supplier Application to reject the execution of the service request.|
DCM_MANU_TelecodageWriteReqInit|C|();|TELECODAGE.1|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Fonction initialisant le Télécodage|
DCM_MANU_vidChgSesType|B|();|FCT1.11|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Fonction liée au changement de session|
DCM_MANU_vidEveRst|B|();|FCT1.7|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Fonction liée au Reset du DCM|
DCM_MANU_vidEveRst_SrvDiagConst|B|();|FCT1.8|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Evenement Reset|
DCM_MANU_vidPwrl_SrvRc|B|();|FCT1.12|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Fonction liée au PowerLatch|
DCM_MANU_VidReinitAftsVariables|B|();|FCT1.5|DCM_MANU|0|PTS_DOC_5074350||||0|0|0|0|Function about timer_adaptative|
DCM_MANU_vidSdlFast|B|();|FCT1.6|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Fonction liée au fast du DCM|
DCM_MANU_vidSdlFast_DiagSrvSA|B|();|FCT1.10|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Fonction Fast liée au SA du DCM|
DCM_MANU_vidSdlMid_SrvDiagConst|B|();|FCT1.9|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Scheduler Mid|
DCM_MANU_vidSetAftsVariables|A|(argin boolean aftsValue);|FCT1.14|DCM_MANU|0|PTS_DOC_5074345||||0|1|0|0|Function modifying AfterSales Datas|
DCM_MANU_WriteCaracInj|C|func_DCM_MANUWriteDataLengthNotFixed|CARACINJ.2|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Fonction appelée sur réception de la requête d'écriture de la caractérisation des injecteurs.|
DCM_MANU_WritePostEquipementMngt|C|func_DCM_MANUWriteDataLengthNotFixed|POSTEQUIPEMENT.2|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Fonction gérant l'écriture du Post Equipement|
DCM_MANU_WriteTelecodageMngt|C|func_DCM_MANUWriteDataLengthNotFixed|TELECODAGE.2|DCM_MANU|0|PTS_DOC_5074345||||0|0|0|0|Fonction gérant l'écriture du Télécodage|
Dcm_NoResetModeEntry|G|();|0x03|SCHM_DCM|1|NONE||||0|0|0|0||
Dcm_ReadMemory|G|func_Dcm_ReadMemory|Dcm_Callouts.1|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_ReadMemory callout is used to request memory data identified by the parameter memoryAddress and memorySize. This service is needed for the implementation of UDS services: ReadMemoryByAdress, RequestUpload, ReadDataByIdentifier.|
Dcm_SsBootloaderResetModeEntry|F|();|0x04|SCHM_DCM|1|NONE||||0|0|0|0||
Dcm_vidStopAllRoutines|G|();|DCM_CALLOUTS.6|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Called by Dcm upon going into the default session. The integrator should implement this callout in order to stop the running routines.|
Dcm_WriteMemory|G|func_Dcm_WriteMemory|Dcm_WriteMemory.2|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteMemory callout is used to write memory data identified by the parameter memoryAddress and memorySize. This service is needed for the mplementation of UDS services: WriteMemoryByAdress, RequestDownload, WriteDataByIdentifier.|
Dem_ClearDTC|B|func_GDEI_ClearDTC|API1.7|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Clears single DTCs as well as groups of DTCs. This API can only be used  through the RTE, and therefore no declaration is exported via Dem.h.|
Dem_DcmCancelOperation|C|();|API2.10|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Fonction vode créée pour le besoin du DCM|
Dem_DcmReadDataOfPID01|B|(argin uint8* u8PID01value)Std_ReturnType;|API2.8|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Service to report the value of PID $01 computed by the Dem.|
Dem_DisableDTCRecordUpdate|B|func_DisableDTCRecordUpdate|API1.5|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Disables the DTC record update.|
Dem_DisableDTCSetting|B|func_GDEI_DisableDTCSetting|API1.3|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Disables the DTC setting for a DTC group.|
Dem_EnableDTCRecordUpdate|B|func_EnableDTCRecordUpdate|API1.6|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Enables the DTC record update.|
Dem_EnableDTCSetting|B|func_GDEI_DisableDTCSetting|API1.4|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Enables the DTC setting for a DTC group.|
Dem_GetDTCOfOBDFreezeFrame|B|func_Dem_GetDTCOfOBDFreezeFrame|API2.6|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Gets DTC by freeze frame record number.|
Dem_GetDTCStatusAvailabilityMask|B|func_GDEI_GetDTCStatusAvailabilityMask|API2.4|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Gets the DTC Status availability mask.|
Dem_GetEventStatus|C|func_GDEI_GetEventStatus|API1.2|GDExtInt|1|PTS_DOC_5075312||||0|0|0|0|Gets the current extended event status of an event|
Dem_GetFreezeFrameDataByDTC|C|func_GetFreezeFrameDataByDTC|API2.3|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Gets freeze frame data by DTC. The function stores the data in the provided  DestBuffer.|
Dem_GetNextFilteredDTC|B|func_GDEI_GetNextFilteredDTC|API1.10|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Gets the next filtered DTC.|
Dem_GetNumberOfFilteredDTC|B|func_GDEI_GetNumberOfFilteredDTC|API1.9|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Gets the number of a filtered DTC.|
Dem_GetSizeOfFreezeFrameByDTC|B|func_GetSizeOfFreezeFrameByDTC|API2.2|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Gets the size of freeze frame data by DTC.|
Dem_GetStatusOfDTC|B|func_GDEI_GetStatusOfDTC|API2.1|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Gets the status of a DTC.|
Dem_GetTranslationType|B|func_GDEI_GetTranslationType|API2.5|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Gets the supported DTC formats of the ECU. The supported formats are  configured via DemTypeOfDTCSupported.|
Dem_Init|F|();|SCH.1|GDExtInt|1|PTS_DOC_5075312||||0|0|0|0|Initializes or re-initializes the GD|
Dem_ReadDataOfOBDFreezeFrame|B|(argin uint8 u8PID,argin uint8 u8DataElementIndexOfPID,argin uint8* u8DestBuffer, argin uint8* u8BufSize)Std_ReturnType;|API2.7|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Gets data element per PID and index of the most important freeze frame being selected for the output of service $02. The function stores the data in the provided  DestBuffer.|
Dem_SetDTCFilter|B|func_GDEI_SetDTCFilter|API1.8|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|The server shall perform a bit-wise logical AND-ing operation between the mask  specified in the client's request and the actual status associated with each DTC supported by the server.|
Dem_SetEventStatus|C|func_GDEI_SetEventStatus|API1.1|GDExtInt|1|PTS_DOC_5075312||||0|0|0|0|Set the status of an Event|
Det_ReportError|E|(argin uint16 u16ModuleId, argin uint8 u8InstanceId, argin uint8 u8ApiId, argin uint8 u8ErrorId);|DET.1|DET|1|PTS_DOC_5074345||||0|0|0|0|The Development Error Tracer module is just help for BSW development and integration. It must not be contained inside the production code. The API is defined, but the functionality can be chosen and implemented according to the development needs|
DEVHAL_bCheckEmulCard|A|func_DEVHAL_bCheckEmulCard|14|HEADER|1|NONE||||0|0|0|0||
DFTLIMSGMGT_vidCMM_Dft|A|();|FCT1.3|DFTLIMSGMGT|0|V02 NT 11 02272||||0|0|0|0|Cette fonction gère l’élaboration des messages CAN pour les allumages des voyants non réglementaires en configuration « Mode d’alerte G3-G4 »
DFTLIMSGMGT_vidInit|A|();|FCT1.1|DFTLIMSGMGT|0|V02 NT 11 02272||||0|0|0|0|Cette fonction donne les valeurs d'initialisation des sorties.
DFTLIMSGMGT_vidSfty_Dft|A|();|FCT1.4|DFTLIMSGMGT|0|V02 NT 11 02272||||0|0|0|0|Cett fonction gère l’élaboration des messages CAN pour les allumages des voyants non réglementaires en configuration « Mode d’alerte Safety »
DFTLIMSGMGT_vidTimeTreatment|A|();|FCT1.2|DFTLIMSGMGT|0|V02 NT 11 02272||||0|0|0|0|Les flux de sortie ne sont pas élaborés de la même manière selon qu’on soit en configuration « Mode d’alerte G3 – G4 » ou bien « Mode d’alerte Safety ».
DFTMGT_vidEntryInit|C|();|SCH.1|DFTMGT|1|PTS_DOC_5402500||||0|0|0|0|Evenement reset calculateur|
DFTMGT_vidInitOutput|D|();|FCT1.1|DFTMGT|0|PTS_DOC_5402500||||0|0|0|0|initialisation des sorties|
DFTMGT_vidInterfaceDftSftyMgt|D|();|FCT1.2|DFTMGT|0|PTS_DOC_5402500||||0|0|0|0|Interface Defauts SafetyManager|
DFTMGT_vidIntrfDftSftyMgtDftECU|D|();|FCT1.3|DFTMGT|0|PTS_DOC_5402500||||0|0|0|0|fonction de concaténation des défauts TMS pour safety manager|
DFTMGT_vidIntrfDftSftyMgtPrmDft|D|();|FCT1.4|DFTMGT|0|PTS_DOC_5402500||||0|0|0|0|fonction de concaténation des défauts (25 bits)|
DGOHAL_akpfvidCallback|A|();|5|DGOHAL|0|PTS_DOC_5395989||||0|0|0|1|It is a callback array of pointers to functions
DGOHAL_bfRead|A|func_DGOHAL_bfRead|0x01|DGOHAL|1|PTS_DOC_5395989||||0|0|0|0|Return the bfStatus of the udtChannel
DGOHAL_vidClearConfirmedFailure|B|(argin DGOHAL_tudtChannel udtChannel,argin DGOHAL_tbfStatus bfFaultIds );|0x07|DGOHAL|1|PTS_DOC_5395989||||0|0|0|1|force the fault state to be no failure
DGOHAL_vidDisableNotification|B|(argin DGOHAL_tudtChannel udtChannel);|0x04|DGOHAL|1|PTS_DOC_5395989||||0|0|0|1|Disable the notifications Callbacks
DGOHAL_vidEnableNotification|B|(argin DGOHAL_tudtChannel udtChannel);|0x03|DGOHAL|1|PTS_DOC_5395989||||0|0|0|1|Enable the notifications Callbacks
DGOHAL_vidInit|A|();|0x00|DGOHAL|1|PTS_DOC_5395989||||0|0|0|0|Initialize all internal variables
DGOHAL_vidSetConfirmedFailure|B|(argin DGOHAL_tudtChannel udtChannel, argin DGOHAL_tbfStatus bfFaultIds);|0x06|DGOHAL|1|PTS_DOC_5395989||||0|0|0|1|force the fault state to be confirmed failure
DGOHAL_vidWrite|A|(argin DGOHAL_tudtChannel udtChannel, argin DGOHAL_tbfStatus bfDiagDone, argin DGOHAL_tbfStatus bfFailResult);|0x02|DGOHAL|1|PTS_DOC_5395989||||0|0|0|0|Update the diagnostic bfStatus identified by bfDiagDone with the new diagnostic result received by bfFailResult
DGOHALACQINJ_vidInjector1Diag|A|();|FCT1.2|DGOHALACQINJ|0|PTS_DOC_6913684||||0|0|0|0|Le driver Injection est capable de différencier un court circuit à la masse d’un circuit ouvert. Il permet aussi de détecter un Overload sur l’injecteur.  Le LDB remontera 4 flags de défaut (Scg, Scp, Oc, Ovld)|
DGOHALACQINJ_vidInjector2Diag|A|();|FCT1.3|DGOHALACQINJ|0|PTS_DOC_6913684||||0|0|0|0|Le driver Injection est capable de différencier un court circuit à la masse d’un circuit ouvert. Il permet aussi de détecter un Overload sur l’injecteur.  Le LDB remontera 4 flags de défaut (Scg, Scp, Oc, Ovld)|
DGOHALACQINJ_vidInjector3Diag|A|();|FCT1.4|DGOHALACQINJ|0|PTS_DOC_6913684||||0|0|0|0|Le driver Injection est capable de différencier un court circuit à la masse d’un circuit ouvert. Il permet aussi de détecter un Overload sur l’injecteur.  Le LDB remontera 4 flags de défaut (Scg, Scp, Oc, Ovld)|
DGOHALACQINJ_vidInjector4Diag|A|();|FCT1.5|DGOHALACQINJ|0|PTS_DOC_6913684||||0|0|0|0|La spécification est compatible pour des moteurs 3 ou 4 cylindres. Pour un moteur 3 cylindres, le bloc Diagnostic_injecteur_4 n’est jamais appelé|
DGOHALACQINJ_vidInjectorsDiag|A|();|FCT1.1|DGOHALACQINJ|0|PTS_DOC_6913684||||0|0|0|0|Le diagnostic fournit une information de panne présente, utilisée par la gestion des défauts unitaire pour générer les éventuelles  demande de reconfiguration et définir les modes dégradés associés.|
DGOTEST_vidSdlSlow|A|();|SCH01|DGOTEST|1|V02 NT 08 07048||||0|0|0|0|Slow task of the OS
DIAGAIREXTPRES_vidCdnAirPresOld|A|();|FCT1.10|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Conditions d’activation du diagnostic de détection d'une pression  atmosphérique incohérente par rapport au roulage précédent|
DIAGAIREXTPRES_vidCdnChgAirPres|A|();|FCT1.7|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Conditions d’activation du diagnostic de détection de la variation de la pression  atmosphérique incohérente|
DIAGAIREXTPRES_vidCdnCohAirPres|A|();|FCT1.5|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Cette fonction spécifie les conditions d’activation du diagnostic de détection d'une pression atmosphérique incohérente|
DIAGAIREXTPRES_vidChgCohAirPres|A|();|FCT1.9|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Détection de la variation de la pression atmosphérique incohérente|
DIAGAIREXTPRES_vidClcGrdAirPres|A|();|FCT1.8|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Détection de la variation de la pression atmosphérique incohérente|
DIAGAIREXTPRES_vidCohAirExtPres|A|();|FCT1.6|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Cette fonction permet la détection d'une pression atmosphérique incohérente|
DIAGAIREXTPRES_vidCohAirPresOld|A|();|FCT2.1|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Détection d'une pression atmosphérique incohérente par rapport au roulage  précédent|
DIAGAIREXTPRES_vidDiaAirExtPrsIn|A|();|FCT1.2|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Cette fonction gère l’initialisation des variables au reset de l’ECU|
DIAGAIREXTPRES_vidDiagAirExtPres|A|();|FCT1.4|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Cette fonction gère  l'appel des macros diagnostic|
DIAGAIREXTPRES_vidInitOutput|A|();|FCT1.1|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Initialisation des sorties|
DIAGAIREXTPRES_vidMemAirExtPres|A|();|FCT1.3|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Cette fonction gère la mémorisation  de la pression atmosphérique au Key-On, sous condition de présence du capteur.|
DIAGAIREXTPRES_vidMemBeforeWr|B|();|FCT2.2|DIAGAIREXTPRES|0|V02 NT 11 03594||||0|0|0|0|Le système doit mémoriser la pression atmosphérique mesurée au key-off|
DIAGASICGDI_vidDiag_ASICGDI|C|();|FCT1.1|DIAGASICGDI|0|PTS_DOC_6930924||||0|0|0|0|Fonction bouchon|
DIAGBRKPED_vidFilterAcqui|D|();|FCT1.4|DIAGBRKPED|0|PTS_DOC_6526884||||0|0|0|0|L’information frein secondaire doit être filtrée à l'aide d'un filtre anti rebond afin d'éviter battement hautes fréquences|
DIAGBRKPED_vidIni|C|();|FCT1.2|DIAGBRKPED|0|PTS_DOC_6526884||||0|0|0|0|Initialisation du signal frein secondaire|
DIAGBRKPED_vidInitOutput|B|();|FCT1.1|DIAGBRKPED|0|PTS_DOC_6526884||||0|0|0|0|Fonction d'initialisation des sorties|
DIAGBRKPED_vidLogicAcqui|C|();|FCT1.3|DIAGBRKPED|0|PTS_DOC_6526884||||0|0|0|0|Acquisition de l'information concernant la pédale de frein|
DIAGBRKPEDNOBVH2P_vidDiagBrkPMng|B|();|FCT1.3|DIAGBRKPEDNOBVH2P|0|V02 NT 10 02593||||0|0|0|0|Le diagnostic de cohérence de l’information frein consiste en une interprétation de l’info CAN frein HS et un  test entre  l’information provenant du CAN et celle par le contrôle moteur.|
DIAGBRKPEDNOBVH2P_vidDiagManager|B|();|FCT1.4|DIAGBRKPEDNOBVH2P|0|V02 NT 10 02593||||0|0|0|0|Diagnostique du frein|
DIAGBRKPEDNOBVH2P_vidFnctionCall|A|();|FCT1.2|DIAGBRKPEDNOBVH2P|0|V02 NT 10 02593||||0|0|0|0|Le diagnostic de la cohérence de la pédale de frein est inhibé en mode intégration électronique.|
DIAGBRKPEDNOBVH2P_vidInitOutput|B|();|FCT1.1|DIAGBRKPEDNOBVH2P|0|V02 NT 10 02593||||0|0|0|0|Fontion d'initialisation des sorties au reset|
DIAGBRKPEDNOBVH2P_vidSftyNiv2|A|();|FCT1.5|DIAGBRKPEDNOBVH2P|0|V02 NT 10 02593||||0|0|0|0|Fonction de diagnostic niveau à partir d’un défaut detecté par le niveau 2|
DIAGCAN_Eve50ms|A|();|SCH.2|ELECITGRMOD|1|PTS_DOC_6873723||||0|0|0|0|Evénement toutes les 50ms du Diagnostic Can
DIAGCAN_EveRst|A|();|SCH.1|ELECITGRMOD|1|PTS_DOC_6873723||||0|0|0|0|Fonction d'accroche pour l'événement EveRst
DIAGCAN_EveRst_If|C|();|SCH3.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reset.|
DIAGCAN_EveRxn092_If|B|();|SCH5.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement de réception de la trame 092.|
DIAGCAN_EveRxn092IntElec|D|();|SCH.3|ELECITGRMOD|1|PTS_DOC_6873723||||0|0|0|0|Fonction appelée sur réception de la trame CAN 0x092
DIAGMEMECU_vidEcuStEepromEna|A|();|FCT1.1|DIAGMEMECU|0|V02 NT 10 02966||||0|0|0|0|Fonction d'in itialisation du enable pour le diagnostic de EEPROM
DIAGMEMECU_vidEcuStEepromOK|A|();|FCT1.2|DIAGMEMECU|0|V02 NT 10 02966||||0|0|0|0|Fonction d'activiation du diagnostic de l'eeprom
DIAGMEMECU_vidEcuStFlashChk|A|();|FCT1.4|DIAGMEMECU|0|V02 NT 10 02966||||0|0|0|0|Lorsqu’il y a un défaut sur la mémoire Flash (calibration ou Checksum), le booléen EcuSt_bDgoFlashChk passe à 1.
DIAGMEMECU_vidEepromOK|A|();|FCT1.3|DIAGMEMECU|0|V02 NT 10 02966||||0|0|0|0|EcuSt_bDgoDftEeprom indique (quand il est VRAI) un défaut EEPROM (absence, endommagement physique ou pas accessible (problème de communication SPI)) pour un calculateur non vierge.
DIAGSFTYLVL2_vidAccPDiag|B|();|FCT2.10|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit les diagnostiques pour le Safety niveau 2 pour la pédale d'accélération.|
DIAGSFTYLVL2_vidAccPDiagSftyLvl2|B|();|FCT2.9|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction effectue les diagnostiques du niveau 2 pour la pédale accélération, qui se font en 2 étapes :   diagnostique et sécurisation des défauts|
DIAGSFTYLVL2_vidAccPSecu|B|();|FCT3.1|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction  décrit la sécurisation des diagnostiques pour le Safety niveau 2 la pédale d'accélération|
DIAGSFTYLVL2_vidActDiagCanSftyL2|A|();|FCT5.1|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction permet d'activater le diagnostic CAN Safety level 2.|
DIAGSFTYLVL2_vidActDiagCanSftyNv|B|();|FCT5.2|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction permet d'activer le diagnostic CAN safety niveau 2.|
DIAGSFTYLVL2_vidBrkDiag|B|();|FCT3.3|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit le diagnostique pour le Safety niveau 2 pour la pédale de frein.|
DIAGSFTYLVL2_vidBrkDiagSftyLvl2|B|();|FCT3.2|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction effectue les diagnostiques du niveau 2 pour la pédale frein, qui se font en 2 étapes :   diagnostique et sécurisation des défauts|
DIAGSFTYLVL2_vidBrkSecu|B|();|FCT3.4|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit la sécurisation des diagnostiques pour le Safety niveau 2 la pédale de frien|
DIAGSFTYLVL2_vidCalculcounter|B|();|FCT4.9|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction permet de reconverger les entrées vitesse roues vers des valeurs cohérentes.|
DIAGSFTYLVL2_vidCluDiag|B|();|FCT4.2|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit les diagnostiques pour le Safety niveau 2 pour la pédale d’embrayage|
DIAGSFTYLVL2_vidCluDiagSftyLvl2|B|();|FCT4.1|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction effectue les diagnostiques du niveau 2 pour la pédale d’embrayage, qui se font en 2 étapes :diagnostique et sécurisation des défauts|
DIAGSFTYLVL2_vidCluSecu|B|();|FCT4.3|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit la sécurisation des diagnostiques pour le Safety niveau 2 la pédale d’embrayage.|
DIAGSFTYLVL2_vidF329_ProcCnt|B|();|FCT1.4|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Ce bloc décrit les diagnostiques d’un défaut compteur du processus pour la trame 329.|
DIAGSFTYLVL2_vidF329Diag|B|();|FCT1.3|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit les diagnostiques pour le Safety niveau 2 pour la Trame 329 .|
DIAGSFTYLVL2_vidF329Secu|B|();|FCT1.5|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Ce bloc décrit la sécurisation des diagnostiques pour le Safety niveau 2 de la Trame 329|
DIAGSFTYLVL2_vidF329SftyLevel2|B|();|FCT1.2|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction fait les diagnostiques du niveau 2 pour la Trame 329, qui se font en 2 étapes : Diagnostique et Sécurisation des défauts|
DIAGSFTYLVL2_vidF349_ProcCnt|B|();|FCT1.8|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit les diagnostiques d’un défaut compteur du processus pour la trame 349|
DIAGSFTYLVL2_vidF349Diag|B|();|FCT1.7|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit les diagnostiques pour le Safety niveau 2 pour la Trame 349|
DIAGSFTYLVL2_vidF349Secu|B|();|FCT1.9|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit la sécurisation des diagnostiques pour le Safety niveau 2 de la Trame 349.|
DIAGSFTYLVL2_vidF349SftyLevel2|B|();|FCT1.6|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction fait les diagnostiques du niveau 2 pour la Trame 349, qui se font en 2 étapes : Diagnostique et Sécurisation des défauts|
DIAGSFTYLVL2_vidF34D_ProcCnt|C|();|FCT2.2|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit les diagnostiques d’un défaut compteur du processus pour la trame 34D|
DIAGSFTYLVL2_vidF34DDiag|C|();|FCT2.1|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Ce bloc décrit les diagnostiques pour le Safety niveau 2 pour la Trame 34D|
DIAGSFTYLVL2_vidF34DSecu|C|();|FCT2.3|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit la sécurisation des diagnostiques pour le Safety niveau 2 de la Trame 34D.|
DIAGSFTYLVL2_vidF34DSftyLevel2|B|();|FCT1.10|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction fait les diagnostiques du niveau 2 pour la Trame 34D, qui se font en 2 étapes : Diagnostique et Sécurisation des défauts|
DIAGSFTYLVL2_vidF34DTqCoh|C|();|FCT4.7|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Le diagnostic de cohérence entre les paramètres teste les configurations:ISCAN_u8N8F34DP047, ISCAN_u8N8F34DP043, ISCAN_u8N8F34DP044 et ISCAN_u8N8F34DP045.|
DIAGSFTYLVL2_vidF38D_ProcCnt|B|();|FCT2.6|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit les diagnostiques d’un défaut compteur du processus pour la trame 38D|
DIAGSFTYLVL2_vidF38DDiag|B|();|FCT2.5|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonctiondécrit les diagnostiques pour le Safety niveau 2 pour la Trame 38D.|
DIAGSFTYLVL2_vidF38DSecu|B|();|FCT2.7|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit la sécurisation des diagnostiques pour le Safety niveau 2 de la Trame 38D|
DIAGSFTYLVL2_vidF38DSftyLevel2|B|();|FCT2.4|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction fait les diagnostiques du niveau 2 pour la Trame 38D, qui se font en 2 étapes : Diagnostique et Sécurisation des défauts|
DIAGSFTYLVL2_vidInit|A|();|FCT4.10|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction permet d'initialiser les différents compteurs temporels.|
DIAGSFTYLVL2_vidInitOutput|D|();|FCT1.1|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Initialisation des variables.|
DIAGSFTYLVL2_vidNeutPosDiagSftyLvl2|B|();|FCT4.4|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction effectue les diagnostiques du niveau 2 pour la position point mort, qui se font en 2 étapes :diagnostique et sécurisation des défauts|
DIAGSFTYLVL2_vidNeutPosnDiag|B|();|FCT4.5|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit les diagnostiques pour le Safety niveau 2 pour la position point mort|
DIAGSFTYLVL2_vidNeutPosnSecu|B|();|FCT4.6|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit la sécurisation des diagnostiques pour le Safety niveau 2 la position point mort.|
DIAGSFTYLVL2_vidReinitCounter|A|();|FCT4.8|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction permet de reinitialiser la valeur du compteur SftyMgt_tiCohSpdVehLvl2 à la valeur du calibration SftyMgt_tiSpdVehInit_C.|
DIAGSFTYLVL2_vidReinitCounter1|A|();|FCT5.3|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction permet de reinitialiser le compteur SftyMgt_counterWkuMain.|
DIAGSFTYLVL2_vidReinitCounter2|A|();|FCT5.4|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction permet de reinitialiser le compteur SftyMgt_counterEngStrtReq.|
DIAGSFTYLVL2_vidReinitCounter3|A|();|FCT5.5|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction permet de reinitialiser le compteur SftyMgt_counterBattMes.|
DIAGSFTYLVL2_vidSensDiagSftyLvl2|B|();|FCT2.8|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit les diagnostiques pour le Safety niveau 2 pour les capteurs Pédale d'accélération, Pédale de frein, Vitesse Véhicule, Papillon, Pédale d'embrayage et Position Point Mort.|
DIAGSFTYLVL2_vidThrDiag|B|();|FCT3.9|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit les diagnostiques pour le Safety niveau 2 pour la papillon|
DIAGSFTYLVL2_vidThrDiagSftyLvl2|B|();|FCT3.8|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction effectue les diagnostiques du niveau 2 pour la papillon, qui se font en 2 étapes :   diagnostique et sécurisation des défauts|
DIAGSFTYLVL2_vidThrSecu|B|();|FCT3.10|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit la sécurisation des diagnostiques pour le Safety niveau 2 la papillon|
DIAGSFTYLVL2_vidVehSpdDiag|E|();|FCT3.6|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit les diagnostiques et la sécurisation de la vitesse à partir quatre roues pour le Safety niveau 2 pour la vitesse véhicule.|
DIAGSFTYLVL2_vidVehSpdDiagSftyLvl2|B|();|FCT3.5|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction effectue les diagnostiques du niveau 2 pour la vitesse véhicule, qui se font en 2 étapes :   diagnostique et sécurisation des défauts|
DIAGSFTYLVL2_vidVehSpdSecu|B|();|FCT3.7|DIAGSFTYLVL2|0|PTS_DOC_5147426||||0|0|0|0|Cette fonction décrit la sécurisation des diagnostiques pour le Safety niveau 2 la vitesse véhicule|
DIAGTAB_vidFillingFailuresBuffer|B|();|FCT1.2|DIAGTAB|0|V02 NT 11 00293||||0|0|0|0|Cette fonction assure le remplissage des tables des pannes.|
DIAGTAB_vidInitFailuresBuffer|B|();|FCT1.1|DIAGTAB|0|V02 NT 11 00293||||0|0|0|0|Fonction d'initialisation du module DIAGTAB.|
DIOHAL_bRead|A|func_DIOHAL_bRead|2|DIOHAL|1|PTS_DOC_5206415||||0|1|0|0|Returns the input after a s/w low pass filter; but if the  uChannel is o/p, it returns the raw value (no filter).  State of the ECU input/output; or STD_OFF in case of invalid ch.
DIOHAL_bReadRaw|A|func_DIOHAL_bReadRaw|3|DIOHAL|1|PTS_DOC_5206415||||0|1|0|0|Returns the actual state without filtering. State of the ECU input/output; or STD_OFF in case of invalid ch.
DIOHAL_vidFilterInit|A|();|1.3|DIOHAL|0|PTS_DOC_5206415||||0|1|0|0|Initializes the Filter module.
DIOHAL_vidInit|A|();|0|DIOHAL|0|PTS_DOC_5206415||||0|1|0|0|Initializes all internal DIOHAL variables.
DIOHAL_vidMainFunction|A|();|1.4|DIOHAL|1|PTS_DOC_5206415||||0|1|0|0|Updates both low and high frequency filter tables.
DIOHAL_vidUpdateHighFreqTable|A|();|1.1|DIOHAL|0|PTS_DOC_5206415||||0|1|0|0|Updates high frequency filter's table
DIOHAL_vidUpdateLowFreqTable|A|();|1.2|DIOHAL|0|PTS_DOC_5206415||||0|1|0|0|Updates low frequency filter's table.
DIOHAL_vidWrite|A|(argin uint8 u8Channel, argin boolean bVal);|1|DIOHAL|1|	PTS_DOC_5206415||||0|1|0|0|
DLT_ConditionCheckRead_0100|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.29|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_0D01|A|func_DLT_ConditionCheckRead_XXXX|ReadDataMANU_API8.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_0E00|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_2100|D|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API1.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_2101|D|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API1.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_2102|D|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API6.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_C001|B|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API1.16|DLT|0|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D400|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.27|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D402|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.31|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D403|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.29|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D404|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.21|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D405|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D406|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.25|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D407|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.23|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D408|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.41|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D409|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.37|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D40A|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.35|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D40C|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.27|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D40D|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D40E|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.39|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D40F|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API8.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D410|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API8.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D411|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D412|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D414|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D41A|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D41B|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D41C|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D41D|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D41E|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.21|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D420|D|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API7.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D421|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D422|H|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.35|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D423|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.37|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D424|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.39|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D425|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.41|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D426|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D428|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D429|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D42D|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.41|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D42E|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.39|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D42F|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.37|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D435|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API13.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D438|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D43A|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.43|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D43C|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D43D|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D43E|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D445|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.25|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D446|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.27|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D459|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API4.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D460|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.27|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D462|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.33|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D463|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.35|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D464|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.29|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D465|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.31|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D466|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D467|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D468|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D469|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D470|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.27|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D471|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.31|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D472|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.37|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D474|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D475|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.21|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D476|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.23|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D477|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D478|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D47E|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D47F|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D481|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.45|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D482|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.39|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D483|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.43|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D484|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.33|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D485|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.35|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D486|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API8.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D489|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D48A|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D48D|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D48E|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D491|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.43|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D492|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.41|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D496|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.47|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D497|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D498|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.49|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D499|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.29|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D49C|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.21|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D49D|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API2.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D49E|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API2.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D49F|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API2.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4A0|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4A1|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API2.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4A2|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API2.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4A3|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API2.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4A5|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4A6|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4AB|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.23|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4AF|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.21|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4B0|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4B8|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.33|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4B9|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.31|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4BA|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.35|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4BB|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4C0|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4C3|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4C5|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4CA|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.23|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4CB|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API2.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4CC|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API2.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4CD|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API2.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4D2|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4D3|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4D5|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4D8|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.21|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4D9|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4DA|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.37|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4DC|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.21|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4DE|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4DF|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4E0|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4E2|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4E3|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4E4|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API8.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4E5|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API8.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4E6|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4FD|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API13.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D4FE|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.23|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D500|B|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API1.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D600|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D602|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.33|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D603|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.39|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D604|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.25|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D605|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.27|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D606|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.29|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D60A|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.45|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D60B|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D60C|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API3.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D611|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D612|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D613|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.25|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D614|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.23|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D615|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D618|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.33|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D619|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API2.31|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D61A|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.25|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D61B|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.27|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D61C|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.29|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D61D|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.31|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D61F|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.33|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D621|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D623|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D624|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API2.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D625|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API1.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D626|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API4.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D62A|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D62B|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D62C|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D62D|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D62E|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D630|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D631|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D632|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D633|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D635|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.21|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D636|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D637|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D638|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D639|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D63A|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D63C|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D63D|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API6.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D63E|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API6.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D63F|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API6.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D641|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API8.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D642|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API8.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D661|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API4.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D662|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API4.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D663|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API4.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D665|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API4.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D666|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API4.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D667|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API4.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D669|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API4.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D700|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D701|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D702|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D703|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D704|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D705|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.29|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D706|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.35|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D708|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API6.25|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D709|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D70A|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D70B|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D70C|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.21|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D70D|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D70F|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.23|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D710|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.25|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D71E|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.37|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D71F|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.23|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D723|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D724|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D725|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API4.39|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D726|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D727|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D728|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API5.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D729|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D72A|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API7.23|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D736|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D737|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D73D|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D73E|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D73F|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D740|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D741|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D742|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D743|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D744|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D745|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D74A|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D74B|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API10.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D74C|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D74D|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D74E|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D750|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D751|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D752|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D753|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D754|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D757|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D760|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D761|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D762|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D763|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D764|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D765|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API11.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D766|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API12.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D767|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API12.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D780|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API12.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D782|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API12.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D783|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API12.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D784|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API12.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D785|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API12.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D786|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API12.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_D78A|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAUTO_API12.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_DADC|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API3.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_DADD|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API5.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E00D|A|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API2.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E013|B|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API1.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E014|B|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API1.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E017|B|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API1.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E018|B|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API1.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E019|A|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API1.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E01B|A|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API2.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E031|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAuto_API9.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E032|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAuto_API9.25|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E033|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAuto_API9.22|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E034|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAuto_API9.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E035|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAuto_API9.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E036|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAuto_API9.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E037|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAuto_API9.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E038|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAuto_API9.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E039|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAuto_API9.28|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E03A|A|func_DLT_ConditionCheckRead_XXXX|ReadDataAuto_API9.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E03C|A|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API2.19|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E03D|A|func_DLT_ConditionCheckRead_XXXX|RDATAAUTO_API8.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E040|A|func_DLT_ConditionCheckRead_XXXX|ReadDataMANU_API8.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E041|A|func_DLT_ConditionCheckRead_XXXX|ReadDataMANU_API8.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E042|A|func_DLT_ConditionCheckRead_XXXX|ReadDataMANU_API8.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E043|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API7.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E044|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API7.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E045|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API7.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E050|A|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API2.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E051|A|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API2.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E052|A|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API2.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_E053|A|func_DLT_ConditionCheckRead_XXXX|RDATAADPT_API2.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_F080|D|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API1.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_F0FE|D|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API1.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_F18B|B|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API1.14|DLT|0|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_F18C|A|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API7.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ConditionCheckRead_F196|D|func_DLT_ConditionCheckRead_XXXX|RDATAMANU_API1.22|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_GetInfotypeValueData_02|B|func_DLT_GetInfotypeValueData_XX|OBDMode09_API1.4|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 09 request is received.|
DLT_GetInfotypeValueData_04|A|func_DLT_GetInfotypeValueData_XX|OBDMode09_API1.1|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 09 request is received.|
DLT_GetInfotypeValueData_08|A|func_DLT_GetInfotypeValueData_XX|OBDMode09_API1.2|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 09 request is received.|
DLT_GetInfotypeValueData_Stub|A|func_DLT_GetInfotypeValueData_XX|OBDMode09_API1.3|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 09 request is received.|
DLT_OBDMode01_PID01|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.1|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID03|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.2|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID04|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.3|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID05|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.4|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID06|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.5|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID07|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.6|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID0B|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.7|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID0C|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.8|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID0D|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.9|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID0E|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.10|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID0F|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.11|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID11|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.12|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID13|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.13|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID14|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.14|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID15|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.15|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID1C|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.16|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID1F|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.17|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID21|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.18|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID23|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.19|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID2E|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.20|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID30|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.21|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID31|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.22|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID33|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.23|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID3C|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.24|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID42|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.25|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID44|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.26|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID47|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.27|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID49|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.28|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID4A|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.29|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID4C|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.30|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID4D|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.31|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID4E|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.32|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID4F|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.33|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID50|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.34|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID72_Data1|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.35|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_OBDMode01_PID72_Data2|A|func_DLT_OBDMode01_PIDXX|OBDMode01_API1.36|DLT|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD mode 01 request is received.|
DLT_ReadData_0100|A|func_DLT_Read_XXXX|RDATAAUTO_API3.30|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_0D01|A|func_DLT_Read_XXXX|ReadDataMANU_API8.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_0E00|A|func_DLT_Read_XXXX|RDATAAUTO_API5.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_2100|D|func_DLT_Read_XXXX|RDATAMANU_API1.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_2101|D|func_DLT_Read_XXXX|RDATAMANU_API1.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_2102|D|func_DLT_Read_XXXX|RDATAMANU_API6.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_C001|B|func_DLT_Read_XXXX|RDATAMANU_API1.17|DLT|0|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ReadData_D400|A|func_DLT_Read_XXXX|RDATAAUTO_API5.28|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D402|A|func_DLT_Read_XXXX|RDATAAUTO_API5.32|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D403|A|func_DLT_Read_XXXX|RDATAAUTO_API5.30|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D404|A|func_DLT_Read_XXXX|RDATAAUTO_API5.22|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D405|A|func_DLT_Read_XXXX|RDATAAUTO_API5.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D406|A|func_DLT_Read_XXXX|RDATAAUTO_API5.26|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D407|A|func_DLT_Read_XXXX|RDATAAUTO_API5.24|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D408|A|func_DLT_Read_XXXX|RDATAAUTO_API5.42|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D409|A|func_DLT_Read_XXXX|RDATAAUTO_API5.38|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D40A|A|func_DLT_Read_XXXX|RDATAAUTO_API2.36|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D40C|A|func_DLT_Read_XXXX|RDATAAUTO_API2.28|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D40D|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D40E|A|func_DLT_Read_XXXX|RDATAAUTO_API2.40|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D40F|A|func_DLT_Read_XXXX|RDATAAUTO_API8.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D410|A|func_DLT_Read_XXXX|RDATAAUTO_API8.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D411|A|func_DLT_Read_XXXX|RDATAAUTO_API7.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D412|A|func_DLT_Read_XXXX|RDATAAUTO_API3.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D414|A|func_DLT_Read_XXXX|RDATAAUTO_API3.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D41A|A|func_DLT_Read_XXXX|RDATAAUTO_API1.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D41B|A|func_DLT_Read_XXXX|RDATAAUTO_API1.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D41C|A|func_DLT_Read_XXXX|RDATAAUTO_API1.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D41D|A|func_DLT_Read_XXXX|RDATAAUTO_API1.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D41E|A|func_DLT_Read_XXXX|RDATAAUTO_API1.22|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D420|D|func_DLT_Read_XXXX|RDATAMANU_API7.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D421|A|func_DLT_Read_XXXX|RDATAAUTO_API1.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D422|D|func_DLT_Read_XXXX|RDATAAUTO_API1.36|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D423|A|func_DLT_Read_XXXX|RDATAAUTO_API1.38|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D424|A|func_DLT_Read_XXXX|RDATAAUTO_API1.40|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D425|A|func_DLT_Read_XXXX|RDATAAUTO_API1.42|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D426|A|func_DLT_Read_XXXX|RDATAAUTO_API2.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D428|A|func_DLT_Read_XXXX|RDATAAUTO_API2.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D429|A|func_DLT_Read_XXXX|RDATAAUTO_API2.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D42D|A|func_DLT_Read_XXXX|RDATAAUTO_API3.42|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D42E|A|func_DLT_Read_XXXX|RDATAAUTO_API3.40|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D42F|A|func_DLT_Read_XXXX|RDATAAUTO_API3.38|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D435|A|func_DLT_Read_XXXX|ReadDataAUTO_API13.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D438|A|func_DLT_Read_XXXX|RDATAAUTO_API4.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D43A|A|func_DLT_Read_XXXX|RDATAAUTO_API3.44|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D43C|A|func_DLT_Read_XXXX|RDATAAUTO_API3.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D43D|A|func_DLT_Read_XXXX|RDATAAUTO_API3.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D43E|A|func_DLT_Read_XXXX|RDATAAUTO_API3.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D445|A|func_DLT_Read_XXXX|RDATAAUTO_API3.26|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D446|A|func_DLT_Read_XXXX|RDATAAUTO_API3.28|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D459|A|func_DLT_Read_XXXX|RDATAMANU_API4.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D460|A|func_DLT_Read_XXXX|RDATAAUTO_API4.28|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D462|A|func_DLT_Read_XXXX|RDATAAUTO_API4.34|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D463|A|func_DLT_Read_XXXX|RDATAAUTO_API4.36|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D464|A|func_DLT_Read_XXXX|RDATAAUTO_API4.30|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D465|A|func_DLT_Read_XXXX|RDATAAUTO_API4.32|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D466|A|func_DLT_Read_XXXX|RDATAAUTO_API4.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D467|A|func_DLT_Read_XXXX|RDATAAUTO_API4.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D468|A|func_DLT_Read_XXXX|RDATAAUTO_API4.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D469|A|func_DLT_Read_XXXX|RDATAAUTO_API4.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D470|A|func_DLT_Read_XXXX|RDATAAUTO_API6.28|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D471|A|func_DLT_Read_XXXX|RDATAAUTO_API6.32|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D472|A|func_DLT_Read_XXXX|RDATAAUTO_API6.38|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D474|A|func_DLT_Read_XXXX|RDATAAUTO_API6.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D475|A|func_DLT_Read_XXXX|RDATAAUTO_API6.22|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D476|A|func_DLT_Read_XXXX|RDATAAUTO_API6.24|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D477|A|func_DLT_Read_XXXX|RDATAAUTO_API6.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D478|A|func_DLT_Read_XXXX|RDATAMANU_API3.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D47E|A|func_DLT_Read_XXXX|RDATAAUTO_API6.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D47F|A|func_DLT_Read_XXXX|RDATAAUTO_API6.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D481|A|func_DLT_Read_XXXX|RDATAAUTO_API5.46|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D482|A|func_DLT_Read_XXXX|RDATAAUTO_API5.40|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D483|A|func_DLT_Read_XXXX|RDATAAUTO_API5.44|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D484|A|func_DLT_Read_XXXX|RDATAAUTO_API5.34|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D485|A|func_DLT_Read_XXXX|RDATAAUTO_API5.36|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D486|A|func_DLT_Read_XXXX|RDATAAUTO_API8.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D489|A|func_DLT_Read_XXXX|RDATAAUTO_API5.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D48A|A|func_DLT_Read_XXXX|RDATAAUTO_API7.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D48D|A|func_DLT_Read_XXXX|RDATAAUTO_API5.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D48E|A|func_DLT_Read_XXXX|RDATAAUTO_API5.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D491|A|func_DLT_Read_XXXX|RDATAAUTO_API2.44|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D492|A|func_DLT_Read_XXXX|RDATAAUTO_API2.42|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D496|A|func_DLT_Read_XXXX|RDATAAUTO_API2.48|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D497|A|func_DLT_Read_XXXX|RDATAAUTO_API3.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D498|A|func_DLT_Read_XXXX|RDATAAUTO_API2.50|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D499|A|func_DLT_Read_XXXX|RDATAAUTO_API2.30|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D49C|A|func_DLT_Read_XXXX|RDATAMANU_API3.22|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D49D|A|func_DLT_Read_XXXX|RDATAMANU_API2.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D49E|A|func_DLT_Read_XXXX|RDATAMANU_API2.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D49F|A|func_DLT_Read_XXXX|RDATAMANU_API2.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4A0|A|func_DLT_Read_XXXX|RDATAMANU_API5.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4A1|A|func_DLT_Read_XXXX|RDATAMANU_API2.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4A2|A|func_DLT_Read_XXXX|RDATAMANU_API2.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4A3|A|func_DLT_Read_XXXX|RDATAMANU_API2.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4A5|A|func_DLT_Read_XXXX|RDATAAUTO_API3.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4A6|A|func_DLT_Read_XXXX|RDATAAUTO_API3.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4AB|A|func_DLT_Read_XXXX|RDATAAUTO_API3.24|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4AF|A|func_DLT_Read_XXXX|RDATAAUTO_API3.22|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4B0|A|func_DLT_Read_XXXX|RDATAMANU_API5.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4B8|A|func_DLT_Read_XXXX|RDATAAUTO_API3.34|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4B9|A|func_DLT_Read_XXXX|RDATAAUTO_API3.32|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4BA|A|func_DLT_Read_XXXX|RDATAAUTO_API3.36|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4BB|A|func_DLT_Read_XXXX|RDATAAUTO_API4.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4C0|A|func_DLT_Read_XXXX|RDATAMANU_API5.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4C3|A|func_DLT_Read_XXXX|RDATAAUTO_API1.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4C5|A|func_DLT_Read_XXXX|RDATAAUTO_API1.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4CA|A|func_DLT_Read_XXXX|RDATAAUTO_API1.24|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4CB|A|func_DLT_Read_XXXX|RDATAMANU_API2.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4CC|A|func_DLT_Read_XXXX|RDATAMANU_API2.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4CD|A|func_DLT_Read_XXXX|RDATAMANU_API2.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4D2|A|func_DLT_Read_XXXX|RDATAAUTO_API2.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4D3|A|func_DLT_Read_XXXX|RDATAAUTO_API2.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4D5|A|func_DLT_Read_XXXX|RDATAAUTO_API2.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4D8|A|func_DLT_Read_XXXX|RDATAAUTO_API2.22|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4D9|A|func_DLT_Read_XXXX|RDATAAUTO_API2.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4DA|A|func_DLT_Read_XXXX|RDATAAUTO_API2.38|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4DC|A|func_DLT_Read_XXXX|RDATAMANU_API5.22|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4DE|A|func_DLT_Read_XXXX|RDATAAUTO_API7.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4DF|A|func_DLT_Read_XXXX|RDATAAUTO_API7.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4E0|A|func_DLT_Read_XXXX|RDATAAUTO_API7.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4E2|A|func_DLT_Read_XXXX|RDATAAUTO_API7.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4E3|A|func_DLT_Read_XXXX|RDATAAUTO_API7.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4E4|A|func_DLT_Read_XXXX|RDATAAUTO_API8.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4E5|A|func_DLT_Read_XXXX|RDATAAUTO_API8.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4E6|A|func_DLT_Read_XXXX|RDATAAUTO_API7.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4FD|A|func_DLT_Read_XXXX|ReadDataAUTO_API13.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D4FE|A|func_DLT_Read_XXXX|RDATAMANU_API5.24|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D500|B|func_DLT_Read_XXXX|RDATAMANU_API1.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ReadData_D600|A|func_DLT_Read_XXXX|RDATAAUTO_API6.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D602|A|func_DLT_Read_XXXX|RDATAAUTO_API6.34|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D603|A|func_DLT_Read_XXXX|RDATAAUTO_API6.40|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D604|A|func_DLT_Read_XXXX|RDATAMANU_API3.26|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D605|A|func_DLT_Read_XXXX|RDATAMANU_API3.28|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D606|A|func_DLT_Read_XXXX|RDATAMANU_API3.30|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D60A|A|func_DLT_Read_XXXX|RDATAAUTO_API2.46|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D60B|A|func_DLT_Read_XXXX|RDATAAUTO_API3.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D60C|A|func_DLT_Read_XXXX|RDATAAUTO_API3.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D611|A|func_DLT_Read_XXXX|RDATAAUTO_API2.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D612|A|func_DLT_Read_XXXX|RDATAAUTO_API2.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D613|A|func_DLT_Read_XXXX|RDATAAUTO_API2.26|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D614|A|func_DLT_Read_XXXX|RDATAAUTO_API2.24|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D615|A|func_DLT_Read_XXXX|RDATAAUTO_API2.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D618|A|func_DLT_Read_XXXX|RDATAAUTO_API2.34|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D619|A|func_DLT_Read_XXXX|RDATAAUTO_API2.32|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D61A|A|func_DLT_Read_XXXX|RDATAAUTO_API1.26|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D61B|A|func_DLT_Read_XXXX|RDATAAUTO_API1.28|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D61C|A|func_DLT_Read_XXXX|RDATAAUTO_API1.30|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D61D|A|func_DLT_Read_XXXX|RDATAAUTO_API1.32|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D61F|A|func_DLT_Read_XXXX|RDATAAUTO_API1.34|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D621|A|func_DLT_Read_XXXX|RDATAAUTO_API1.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D623|A|func_DLT_Read_XXXX|RDATAAUTO_API1.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D624|A|func_DLT_Read_XXXX|RDATAMANU_API2.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D625|A|func_DLT_Read_XXXX|RDATAAUTO_API1.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D626|A|func_DLT_Read_XXXX|RDATAMANU_API4.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D62A|A|func_DLT_Read_XXXX|RDATAAUTO_API4.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D62B|A|func_DLT_Read_XXXX|RDATAMANU_API3.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D62C|A|func_DLT_Read_XXXX|RDATAMANU_API3.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D62D|A|func_DLT_Read_XXXX|RDATAMANU_API3.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D62E|A|func_DLT_Read_XXXX|RDATAMANU_API3.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D630|A|func_DLT_Read_XXXX|RDATAMANU_API3.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D631|A|func_DLT_Read_XXXX|RDATAMANU_API3.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D632|A|func_DLT_Read_XXXX|RDATAMANU_API3.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D633|A|func_DLT_Read_XXXX|RDATAMANU_API3.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D635|A|func_DLT_Read_XXXX|RDATAAUTO_API7.22|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D636|A|func_DLT_Read_XXXX|RDATAAUTO_API7.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D637|A|func_DLT_Read_XXXX|RDATAAUTO_API7.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D638|A|func_DLT_Read_XXXX|RDATAMANU_API5.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D639|A|func_DLT_Read_XXXX|RDATAMANU_API5.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D63A|A|func_DLT_Read_XXXX|RDATAMANU_API5.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D63C|A|func_DLT_Read_XXXX|RDATAMANU_API5.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D63D|A|func_DLT_Read_XXXX|RDATAMANU_API6.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D63E|A|func_DLT_Read_XXXX|RDATAMANU_API6.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D63F|A|func_DLT_Read_XXXX|RDATAMANU_API6.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D641|A|func_DLT_Read_XXXX|RDATAAUTO_API8.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D642|A|func_DLT_Read_XXXX|RDATAAUTO_API8.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D661|A|func_DLT_Read_XXXX|RDATAMANU_API4.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D662|A|func_DLT_Read_XXXX|RDATAMANU_API4.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D663|A|func_DLT_Read_XXXX|RDATAMANU_API4.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D665|A|func_DLT_Read_XXXX|RDATAMANU_API4.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D666|A|func_DLT_Read_XXXX|RDATAMANU_API4.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D667|A|func_DLT_Read_XXXX|RDATAMANU_API4.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D669|A|func_DLT_Read_XXXX|RDATAMANU_API4.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D700|A|func_DLT_Read_XXXX|RDATAAUTO_API6.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D701|A|func_DLT_Read_XXXX|RDATAAUTO_API6.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D702|A|func_DLT_Read_XXXX|RDATAAUTO_API6.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D703|A|func_DLT_Read_XXXX|RDATAAUTO_API6.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D704|A|func_DLT_Read_XXXX|RDATAAUTO_API6.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D705|A|func_DLT_Read_XXXX|RDATAAUTO_API6.30|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D706|A|func_DLT_Read_XXXX|RDATAAUTO_API6.36|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D708|A|func_DLT_Read_XXXX|RDATAAUTO_API6.26|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D709|A|func_DLT_Read_XXXX|RDATAMANU_API5.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D70A|A|func_DLT_Read_XXXX|RDATAAUTO_API4.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D70B|A|func_DLT_Read_XXXX|RDATAAUTO_API4.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D70C|A|func_DLT_Read_XXXX|RDATAAUTO_API4.22|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D70D|A|func_DLT_Read_XXXX|RDATAAUTO_API4.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D70F|A|func_DLT_Read_XXXX|RDATAAUTO_API4.24|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D710|A|func_DLT_Read_XXXX|RDATAAUTO_API4.26|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D71E|A|func_DLT_Read_XXXX|RDATAAUTO_API4.38|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D71F|A|func_DLT_Read_XXXX|RDATAMANU_API3.24|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D723|A|func_DLT_Read_XXXX|RDATAAUTO_API5.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D724|A|func_DLT_Read_XXXX|RDATAAUTO_API5.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D725|A|func_DLT_Read_XXXX|RDATAAUTO_API4.40|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D726|A|func_DLT_Read_XXXX|RDATAAUTO_API5.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D727|A|func_DLT_Read_XXXX|RDATAAUTO_API5.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D728|A|func_DLT_Read_XXXX|RDATAAUTO_API5.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D729|A|func_DLT_Read_XXXX|RDATAMANU_API5.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D72A|A|func_DLT_Read_XXXX|RDATAAUTO_API7.24|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D736|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D737|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D73D|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D73E|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D73F|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D740|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D741|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D742|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D743|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D744|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D745|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D74A|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D74B|A|func_DLT_Read_XXXX|ReadDataAUTO_API10.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D74C|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D74D|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D74E|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D750|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D751|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D752|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D753|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D754|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D757|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D760|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D761|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D762|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D763|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D764|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D765|A|func_DLT_Read_XXXX|ReadDataAUTO_API11.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D766|A|func_DLT_Read_XXXX|ReadDataAUTO_API12.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D767|A|func_DLT_Read_XXXX|ReadDataAUTO_API12.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D780|A|func_DLT_Read_XXXX|ReadDataAUTO_API12.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D782|A|func_DLT_Read_XXXX|ReadDataAUTO_API12.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D783|A|func_DLT_Read_XXXX|ReadDataAUTO_API12.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D784|A|func_DLT_Read_XXXX|ReadDataAUTO_API12.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D785|A|func_DLT_Read_XXXX|ReadDataAUTO_API12.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D786|A|func_DLT_Read_XXXX|ReadDataAUTO_API12.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_D78A|A|func_DLT_Read_XXXX|ReadDataAUTO_API12.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_DADC|A|func_DLT_Read_XXXX|RDATAMANU_API3.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_DADD|A|func_DLT_Read_XXXX|RDATAMANU_API5.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E00D|A|func_DLT_Read_XXXX|RDATAADPT_API2.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E013|B|func_DLT_Read_XXXX|RDATAADPT_API1.15|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E014|B|func_DLT_Read_XXXX|RDATAADPT_API1.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E018|B|func_DLT_Read_XXXX|RDATAADPT_API1.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E019|B|func_DLT_Read_XXXX|RDATAADPT_API1.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E01B|A|func_DLT_Read_XXXX|RDATAADPT_API2.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E031|A|func_DLT_Read_XXXX|ReadDataAuto_API9.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E032|A|func_DLT_Read_XXXX|ReadDataAuto_API9.27|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E033|A|func_DLT_Read_XXXX|ReadDataAuto_API9.24|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E034|A|func_DLT_Read_XXXX|ReadDataAuto_API9.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E035|A|func_DLT_Read_XXXX|ReadDataAuto_API9.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E036|A|func_DLT_Read_XXXX|ReadDataAuto_API9.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E037|A|func_DLT_Read_XXXX|ReadDataAuto_API9.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E038|A|func_DLT_Read_XXXX|ReadDataAuto_API9.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E039|A|func_DLT_Read_XXXX|ReadDataAuto_API9.30|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E03A|A|func_DLT_Read_XXXX|ReadDataAuto_API9.21|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E03C|A|func_DLT_Read_XXXX|RDATAADPT_API2.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E03D|A|func_DLT_Read_XXXX|RDATAAUTO_API8.16|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E040|A|func_DLT_Read_XXXX|ReadDataMANU_API8.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E041|A|func_DLT_Read_XXXX|ReadDataMANU_API8.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E042|A|func_DLT_Read_XXXX|ReadDataMANU_API8.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E043|A|func_DLT_Read_XXXX|RDATAMANU_API7.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E044|A|func_DLT_Read_XXXX|RDATAMANU_API7.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E045|A|func_DLT_Read_XXXX|RDATAMANU_API7.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E050|A|func_DLT_Read_XXXX|RDATAADPT_API2.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E051|A|func_DLT_Read_XXXX|RDATAADPT_API2.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E052|A|func_DLT_Read_XXXX|RDATAADPT_API2.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_E053|A|func_DLT_Read_XXXX|RDATAADPT_API2.15|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_F080|D|func_DLT_Read_XXXX|RDATAMANU_API1.9|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_F0FE|D|func_DLT_Read_XXXX|RDATAMANU_API1.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_F18B|B|func_DLT_Read_XXXX|RDATAMANU_API1.15|DLT|0|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ReadData_F18C|A|func_DLT_Read_XXXX|RDATAMANU_API7.12|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadData_F196|D|func_DLT_Read_XXXX|RDATAMANU_API1.23|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called.|
DLT_ReadDataLength_0D01|A|func_Dlt_ReadDataLength_XXXX|ReadDataMANU_API8.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_2100|D|func_Dlt_ReadDataLength_XXXX|RDATAMANU_API1.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_2101|D|func_Dlt_ReadDataLength_XXXX|RDATAMANU_API1.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_2102|D|func_Dlt_ReadDataLength_XXXX|RDATAMANU_API6.7|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_D500|B|func_Dlt_ReadDataLength_XXXX|RDATAMANU_API1.18|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called to see if Dlt_ReadData can be called.|
DLT_ReadDataLength_E00D|A|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API2.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E013|B|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API1.14|DLT|1|PTS_DOC_5074345||||0|0|0|0||
DLT_ReadDataLength_E014|B|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API1.11|DLT|1|PTS_DOC_5074345||||0|0|0|0||
DLT_ReadDataLength_E017|B|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API1.8|DLT|1|PTS_DOC_5074345||||0|0|0|0||
DLT_ReadDataLength_E018|B|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API1.5|DLT|1|PTS_DOC_5074345||||0|0|0|0||
DLT_ReadDataLength_E019|B|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API1.2|DLT|1|PTS_DOC_5074345||||0|0|0|0||
DLT_ReadDataLength_E01B|A|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API2.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E031|A|func_Dlt_ReadDataLength_XXXX|ReadDataAuto_API9.17|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E032|A|func_Dlt_ReadDataLength_XXXX|ReadDataAuto_API9.26|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E033|A|func_Dlt_ReadDataLength_XXXX|ReadDataAuto_API9.23|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E034|A|func_Dlt_ReadDataLength_XXXX|ReadDataAuto_API9.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E035|A|func_Dlt_ReadDataLength_XXXX|ReadDataAuto_API9.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E036|A|func_Dlt_ReadDataLength_XXXX|ReadDataAuto_API9.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E037|A|func_Dlt_ReadDataLength_XXXX|ReadDataAuto_API9.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E038|A|func_Dlt_ReadDataLength_XXXX|ReadDataAuto_API9.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E039|A|func_Dlt_ReadDataLength_XXXX|ReadDataAuto_API9.29|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E03A|A|func_Dlt_ReadDataLength_XXXX|ReadDataAuto_API9.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E03C|A|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API2.20|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E040|A|func_Dlt_ReadDataLength_XXXX|ReadDataMANU_API8.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E041|A|func_Dlt_ReadDataLength_XXXX|ReadDataMANU_API8.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E042|A|func_Dlt_ReadDataLength_XXXX|ReadDataMANU_API8.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E043|A|func_Dlt_ReadDataLength_XXXX|RDATAMANU_API7.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E044|A|func_Dlt_ReadDataLength_XXXX|RDATAMANU_API7.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E045|A|func_Dlt_ReadDataLength_XXXX|RDATAMANU_API7.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E050|A|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API2.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E051|A|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API2.8|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E052|A|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API2.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_E053|A|func_Dlt_ReadDataLength_XXXX|RDATAADPT_API2.14|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_F0FE|A|func_Dlt_ReadDataLength_XXXX|RDATAMANU_API1.10|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_F18B|A|func_Dlt_ReadDataLength_XXXX|RDATAMANU_API1.13|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_F18C|A|func_Dlt_ReadDataLength_XXXX|RDATAMANU_API7.11|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_ReadDataLength_F196|A|func_Dlt_ReadDataLength_XXXX|RDATAMANU_API1.21|DLT|1|PTS_DOC_5074345||||0|0|0|0|Is called from Dcm when UDS service ReadDataByIdendifer for Dlt DID is called, to check data length|
DLT_RequestResult_0302|B|func_DLT_RequestResult_0302|RC_API4.4|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID 0302 service sub function 03 is received.|
DLT_RequestResult_0400|A|func_DLT_RequestResult_DF2D|RC_API4.14|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID 0400 service sub function 03 is received.|
DLT_RequestResult_DF08|A|func_DLT_RequestResult_DF08|RC_API6.9|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF08 service sub function 03 is received.|
DLT_RequestResult_DF0D|A|func_DLT_RequestResult_DF0D|RC_API6.5|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF0D service sub function 03 is received.|
DLT_RequestResult_DF10|A|func_DLT_RequestResult_DF10|RC_API6.11|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF10 service sub function 03 is received.|
DLT_RequestResult_DF11|A|func_DLT_RequestResult_DF11|RC_API6.13|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF11 service sub function 03 is received.|
DLT_RequestResult_DF15|A|func_DLT_RequestResult_DF15|RC_API6.1|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF15 service sub function 03 is received.|
DLT_RequestResult_DF1C|A|func_DLT_RequestResult_DF1C|RC_API6.3|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF1C service sub function 03 is received.|
DLT_RequestResult_DF20|B|func_DLT_RequestResult_DF20|RC_API5.7|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF20 service sub function 03 is received.|
DLT_RequestResult_DF22|B|func_DLT_RequestResult_DF22|RC_API5.1|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF22 service sub function 03 is received.|
DLT_RequestResult_DF28|A|func_DLT_RequestResult_DF28|RC_API5.9|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF28 service sub function 03 is received.|
DLT_RequestResult_DF2A|A|func_DLT_RequestResult_DF2A|RC_API5.11|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF2A service sub function 03 is received.|
DLT_RequestResult_DF2C|A|func_DLT_RequestResult_DF2C|RC_API5.13|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF2C service sub function 03 is received.|
DLT_RequestResult_DF2D|A|func_DLT_RequestResult_DF2D|RC_API5.15|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF2D service sub function 03 is received.|
DLT_RequestResult_DF33|B|DLT_RequestResult_DF33|RC_API9.2|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID service sub function 03 is received.|
DLT_RequestResult_DF34|A|func_DLT_RequestResult_DF34|RC_API6.7|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF34 service sub function 03 is received.|
DLT_RequestResult_DF35|A|func_DLT_RequestResult_DF35|RC_API6.15|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF35 service sub function 03 is received.|
DLT_RequestResult_DF36|B|DLT_RequestResult_DF36|RC_API10.2|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID service sub function 03 is received.|
DLT_RequestResult_DF37|B|DLT_RequestResult_DF37|RC_API10.4|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID service sub function 03 is received.|
DLT_RequestResult_DFAD|B|func_DLT_RequestResult_DFAD|RC_API4.6|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFAD service sub function 03 is received.|
DLT_RequestResult_DFC7|B|func_DLT_RequestResult_DFC7|RC_API6.17|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFC7 service sub function 03 is received.|
DLT_RequestResult_DFC8|A|func_DLT_RequestResult_DFC8|RC_API6.19|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFC8 service sub function 03 is received.|
DLT_RequestResult_DFCA|B|func_DLT_RequestResult_DFCA|RC_API5.17|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFCA service sub function 03 is received.|
DLT_RequestResult_DFCC|A|func_DLT_RequestResult_DFCC|RC_API7.3|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFCC service sub function 03 is received.|
DLT_RequestResult_DFD2|B|func_DLT_RequestResult_DFD2|RC_API1.1|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFD2 service sub function 03 is received.|
DLT_RequestResult_DFDA|A|func_DLT_RequestResult_DFDA|RC_API7.12|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDA service sub function 03 is received.|
DLT_RequestResult_DFDB|A|func_DLT_RequestResult_DFDB|RC_API7.9|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDB service sub function 03 is received.|
DLT_RequestResult_DFDC|A|func_DLT_RequestResult_DFDC|RC_API5.19|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDC service sub function 03 is received.|
DLT_RequestResult_DFDD|B|func_DLT_RequestResult_DFDD|RC_API4.8|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDD service sub function 03 is received.|
DLT_RequestResult_DFDE|B|func_DLT_RequestResult_DFDE|RC_API1.4|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDE service sub function 03 is received.|
DLT_RequestResult_DFDF|B|func_DLT_RequestResult_DFDF|RC_API1.7|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDF service sub function 03 is received.|
DLT_RequestResult_DFE1|B|func_DLT_RequestResult_DFE1|RC_API1.10|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE1 service sub function 03 is received.|
DLT_RequestResult_DFE2|A|func_DLT_RequestResult_DFE2|RC_API5.22|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE2 service sub function 03 is received.|
DLT_RequestResult_DFE6|B|func_DLT_RequestResult_DFE6|RC_API2.1|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE6 service sub function 03 is received.|
DLT_RequestResult_DFE7|B|func_DLT_RequestResult_DFE7|RC_API2.4|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE7 service sub function 03 is received.|
DLT_RequestResult_DFE8|B|func_DLT_RequestResult_DFE8|RC_API2.7|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE8 service sub function 03 is received.|
DLT_RequestResult_DFE9|B|func_DLT_RequestResult_DFE9|RC_API2.10|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE9 service sub function 03 is received.|
DLT_RequestResult_DFEA|B|func_DLT_RequestResult_DFEA|RC_API3.1|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEA service sub function 03 is received.|
DLT_RequestResult_DFEB|A|func_DLT_RequestResult_DFEB|RC_API7.6|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEB service sub function 03 is received.|
DLT_RequestResult_DFEC|B|func_DLT_RequestResult_DFEC|RC_API3.4|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEC service sub function 03 is received.|
DLT_RequestResult_DFED|B|func_DLT_RequestResult_DFED|RC_API3.7|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFED service sub function 03 is received.|
DLT_RequestResult_DFEE|B|func_DLT_RequestResult_DFEE|RC_API3.10|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEE service sub function 03 is received.|
DLT_RequestResult_DFEF|B|func_DLT_RequestResult_DFEF|RC_API4.1|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEF service sub function 03 is received.|
DLT_StartRoutine_0302|B|func_DLT_StartRoutine_0302|RC_API4.5|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID 0302 service sub function 01 is received.|
DLT_StartRoutine_0400|B|func_DLT_StartRoutine_0400|RC_API4.11|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID 0400 service sub function 01 is received.|
DLT_StartRoutine_DF08|A|func_DLT_StartRoutine_DF08|RC_API6.10|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF08 service sub function 01 is received.|
DLT_StartRoutine_DF0D|A|func_DLT_StartRoutine_DF0D|RC_API6.6|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF0D service sub function 01 is received.|
DLT_StartRoutine_DF10|A|func_DLT_StartRoutine_DF10|RC_API6.12|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF10 service sub function 01 is received.|
DLT_StartRoutine_DF11|A|func_DLT_StartRoutine_DF11|RC_API6.14|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF11 service sub function 01 is received.|
DLT_StartRoutine_DF15|A|func_DLT_StartRoutine_DF15|RC_API6.2|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF15 service sub function 01 is received.|
DLT_StartRoutine_DF1C|A|func_DLT_StartRoutine_DF1C|RC_API6.4|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF1C service sub function 01 is received.|
DLT_StartRoutine_DF20|B|func_DLT_StartRoutine_DF20|RC_API5.6|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF20 service sub function 01 is received.|
DLT_StartRoutine_DF22|B|func_DLT_StartRoutine_DF22|RC_API5.2|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF22 service sub function 01 is received.|
DLT_StartRoutine_DF28|A|func_DLT_StartRoutine_DF28|RC_API5.8|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF28 service sub function 01 is received.|
DLT_StartRoutine_DF2A|A|func_DLT_StartRoutine_DF2A|RC_API5.10|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF2A service sub function 01 is received.|
DLT_StartRoutine_DF2C|A|func_DLT_StartRoutine_DF2C|RC_API5.12|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF2C service sub function 01 is received.|
DLT_StartRoutine_DF2D|A|func_DLT_StartRoutine_DF2D|RC_API5.14|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF2D service sub function 01 is received.|
DLT_StartRoutine_DF33|A|DLT_StartRoutine_DF33|RC_API9.1|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID service sub function 01 is received.|
DLT_StartRoutine_DF34|A|func_DLT_StartRoutine_DF34|RC_API6.8|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF34 service sub function 01 is received.|
DLT_StartRoutine_DF35|A|func_DLT_StartRoutine_DF35|RC_API6.16|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF35 service sub function 01 is received.|
DLT_StartRoutine_DF36|A|DLT_StartRoutine_DF36|RC_API10.1|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID service sub function 01 is received.|
DLT_StartRoutine_DF37|A|DLT_StartRoutine_DF37|RC_API10.3|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID service sub function 01 is received.|
DLT_StartRoutine_DFA0|B|func_DLT_StartRoutine_DFA0|RC_API4.12|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFA0 service sub function 01 is received.|
DLT_StartRoutine_DFA1|A|func_DLT_StartRoutine_DFA1|RC_API5.5|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFA1 service sub function 01 is received.|
DLT_StartRoutine_DFA2|A|DLT_StartRoutine_DFA2|RC_API9.5|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID service sub function 01 is received.|
DLT_StartRoutine_DFAC|B|func_DLT_StartRoutine_DFAC|RC_API4.13|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFAC service sub function 01 is received.|
DLT_StartRoutine_DFAD|B|func_DLT_StartRoutine_DFAD|RC_API4.7|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFAD service sub function 01 is received.|
DLT_StartRoutine_DFAE|B|func_DLT_StartRoutine_DFAE|RC_API5.24|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFAE service sub function 01 is received.|
DLT_StartRoutine_DFC7|B|func_DLT_StartRoutine_DFC7|RC_API6.18|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFC7 service sub function 01 is received.|
DLT_StartRoutine_DFC8|A|func_DLT_StartRoutine_DFC8|RC_API6.20|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFC8 service sub function 01 is received.|
DLT_StartRoutine_DFCA|B|func_DLT_StartRoutine_DFCA|RC_API5.16|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFCA service sub function 01 is received.|
DLT_StartRoutine_DFCC|A|func_DLT_StartRoutine_DFCC|RC_API7.1|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFCC service sub function 01 is received.|
DLT_StartRoutine_DFD2|B|func_DLT_StartRoutine_DFD2|RC_API1.2|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFD2 service sub function 01 is received.|
DLT_StartRoutine_DFDA|A|func_DLT_StartRoutine_DFDA|RC_API7.10|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDA service sub function 01 is received.|
DLT_StartRoutine_DFDB|A|func_DLT_StartRoutine_DFDB|RC_API7.7|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDB service sub function 01 is received.|
DLT_StartRoutine_DFDC|A|func_DLT_StartRoutine_DFDC|RC_API5.18|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDC service sub function 01 is received.|
DLT_StartRoutine_DFDD|B|func_DLT_StartRoutine_DFDD|RC_API4.9|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDD service sub function 01 is received.|
DLT_StartRoutine_DFDE|B|func_DLT_StartRoutine_DFDE|RC_API1.5|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDE service sub function 01 is received.|
DLT_StartRoutine_DFDF|B|func_DLT_StartRoutine_DFDF|RC_API1.8|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDF service sub function 01 is received.|
DLT_StartRoutine_DFE1|B|func_DLT_StartRoutine_DFE1|RC_API1.11|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE1 service sub function 01 is received.|
DLT_StartRoutine_DFE2|A|func_DLT_StartRoutine_DFE2|RC_API5.21|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE2 service sub function 01 is received.|
DLT_StartRoutine_DFE6|B|func_DLT_StartRoutine_DFE6|RC_API2.2|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE6 service sub function 01 is received.|
DLT_StartRoutine_DFE7|B|func_DLT_StartRoutine_DFE7|RC_API2.5|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE7 service sub function 01 is received.|
DLT_StartRoutine_DFE8|B|func_DLT_StartRoutine_DFE8|RC_API2.8|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE8 service sub function 01 is received.|
DLT_StartRoutine_DFE9|B|func_DLT_StartRoutine_DFE9|RC_API2.11|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE9 service sub function 01 is received.|
DLT_StartRoutine_DFEA|B|func_DLT_StartRoutine_DFEA|RC_API3.2|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEA service sub function 01 is received.|
DLT_StartRoutine_DFEB|A|func_DLT_StartRoutine_DFEB|RC_API7.4|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEB service sub function 01 is received.|
DLT_StartRoutine_DFEC|B|func_DLT_StartRoutine_DFEC|RC_API3.5|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEC service sub function 01 is received.|
DLT_StartRoutine_DFED|B|func_DLT_StartRoutine_DFED|RC_API3.8|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFED service sub function 01 is received.|
DLT_StartRoutine_DFEE|B|func_DLT_StartRoutine_DFEE|RC_API3.11|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEE service sub function 01 is received.|
DLT_StartRoutine_DFEF|B|func_DLT_StartRoutine_DFEF|RC_API4.2|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEF service sub function 01 is received.|
DLT_StartRoutine_F000|B|func_DLT_StartRoutine_F000|RC_API5.4|DLT|1|PTS_DOC_5074350||||0|0|0|0|Fonction appelée sur réception de la requête de saut en test en prod.|
DLT_StopRoutine_DF22|B|func_DLT_StopRoutine_DF22|RC_API5.3|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DF22 service sub function 02 is received.|
DLT_StopRoutine_DFCC|A|func_DLT_StopRoutine_DFCC|RC_API7.2|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFCC service sub function 02 is received.|
DLT_StopRoutine_DFD2|B|func_DLT_StopRoutine_DFD2|RC_API1.3|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFD2 service sub function 02 is received.|
DLT_StopRoutine_DFDA|A|func_DLT_StopRoutine_DFDA|RC_API7.11|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDA service sub function 02 is received.|
DLT_StopRoutine_DFDB|A|func_DLT_StopRoutine_DFDB|RC_API7.8|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDB service sub function 02 is received.|
DLT_StopRoutine_DFDC|A|func_DLT_StopRoutine_DFDC|RC_API5.20|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDC service sub function 02 is received.|
DLT_StopRoutine_DFDD|B|func_DLT_StopRoutine_DFDD|RC_API4.10|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDD service sub function 02 is received.|
DLT_StopRoutine_DFDE|B|func_DLT_StopRoutine_DFDE|RC_API1.6|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDE service sub function 02 is received.|
DLT_StopRoutine_DFDF|B|func_DLT_StopRoutine_DFDF|RC_API1.9|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFDF service sub function 02 is received.|
DLT_StopRoutine_DFE1|B|func_DLT_StopRoutine_DFE1|RC_API1.12|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE1 service sub function 02 is received.|
DLT_StopRoutine_DFE2|A|func_DLT_StopRoutine_DFE2|RC_API5.23|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE2 service sub function 02 is received.|
DLT_StopRoutine_DFE6|B|func_DLT_StopRoutine_DFE6|RC_API2.3|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE6 service sub function 02 is received.|
DLT_StopRoutine_DFE7|B|func_DLT_StopRoutine_DFE7|RC_API2.6|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE7 service sub function 02 is received.|
DLT_StopRoutine_DFE8|B|func_DLT_StopRoutine_DFE8|RC_API2.9|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE8 service sub function 02 is received.|
DLT_StopRoutine_DFE9|B|func_DLT_StopRoutine_DFE9|RC_API2.12|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFE9 service sub function 02 is received.|
DLT_StopRoutine_DFEA|B|func_DLT_StopRoutine_DFEA|RC_API3.3|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEA service sub function 02 is received.|
DLT_StopRoutine_DFEB|A|func_DLT_StopRoutine_DFEB|RC_API7.5|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEB service sub function 02 is received.|
DLT_StopRoutine_DFEC|B|func_DLT_StopRoutine_DFEC|RC_API3.6|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEC service sub function 02 is received.|
DLT_StopRoutine_DFED|B|func_DLT_StopRoutine_DFED|RC_API3.9|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFED service sub function 02 is received.|
DLT_StopRoutine_DFEE|B|func_DLT_StopRoutine_DFEE|RC_API3.12|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEE service sub function 02 is received.|
DLT_StopRoutine_DFEF|B|func_DLT_StopRoutine_DFEF|RC_API4.3|DLT|1|PTS_DOC_5074350||||0|0|0|0|Is called from Dcm when RID DFEF service sub function 02 is received.|
DLT_writeData_2101|E|func_Dcm_WriteData_2101|WDATAMANU_API1.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_2101 callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_writeData_2102|B|func_Dcm_WriteData_2101|WDATAMANU_API1.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_2102 callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_D420|B|func_writeDataFixed|WDATAMANU_API1.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_D500|B|func_writeData|WDATAMANU_API1.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|The DLT_WriteData_D500 callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E00D|C|func_Dcm_WriteData_XXXX|WDATAADPT_API2.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E013|C|func_Dcm_WriteData_XXXX|WDATAADPT_API1.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E014|C|func_Dcm_WriteData_XXXX|WDATAADPT_API1.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E017|C|func_Dcm_WriteData_XXXX|WDATAADPT_API1.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E018|C|func_Dcm_WriteData_XXXX|WDATAADPT_API1.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E019|C|func_Dcm_WriteData_XXXX|WDATAADPT_API1.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E03C|C|func_Dcm_WriteData_XXXX|WDATAADPT_API2.6|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E03D|C|func_Dcm_WriteData_XXXX|WDATAAUTO_API1.1|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E050|C|func_Dcm_WriteData_XXXX|WDATAADPT_API2.2|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E051|C|func_Dcm_WriteData_XXXX|WDATAADPT_API2.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E052|C|func_Dcm_WriteData_XXXX|WDATAADPT_API2.4|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_E053|C|func_Dcm_WriteData_XXXX|WDATAADPT_API2.5|DLT|1|PTS_DOC_5074345||||0|0|0|0|The Dcm_WriteData_XXXX callout is used to write data identified by the parameter memoryAddress and memorySize.|
DLT_WriteData_F196|B|func_writeData|WDATAMANU_API1.3|DLT|1|PTS_DOC_5074345||||0|0|0|0|The DLT_WriteData_F196 callout is used to write data identified by the parameter memoryAddress and memorySize.|
DmpVlv_Eve14TDC_FctDiagDmpVlv|B|();|SCH.2|FCTDIAGDMPVLV|1|PTS_DOC_5068534||||0|0|0|0|A Quarter TDC crankshaft angular based event|
DmpVlv_EveRst_ActrTstDV|A|();|SCH.1|ACTRTSTDV|1|V02 NT 11 02175||||0|0|0|0|Fonction d'accroche à l'event DmpVlv_EveRst_ActrTstDV|
DmpVlv_EveRst_DmpVlvCmdSpArb|A|();|SCH.1|DMPVLVCMDSPARB|1|V02 NT 12 02202||||0|0|0|0|Event reset|
DmpVlv_EveRst_FctDiagDmpVlv|B|();|SCH.1|FCTDIAGDMPVLV|1|PTS_DOC_5068534||||0|0|0|0|Reset event for the ECU|
DmpVlv_SdlFast_ActrTstDV|A|();|SCH.2|ACTRTSTDV|1|V02 NT 11 02175||||0|0|0|0|Fonction d'accroche à l'event DmpVlv_SdlFast_ActrTstDV|
DmpVlv_SdlFast_DmpVlvCmdSpArb|A|();|SCH.2|DMPVLVCMDSPARB|1|V02 NT 12 02202||||0|0|0|0|Fast scheduler for the dump-valve function|
DmpVlvAct_EveRst_CmdPwmAct|A|();|SCH.2|CMDPWMACT_DT|1|PTS_DOC_6913248||||0|0|0|0|Reset event|
DmpVlvAct_EveRst_DmpVlvCmd|D|();|SCH.1|DMPVLVCMD|1|PTS_DOC_6851423||||0|0|0|0|Evénement reset du calculateur|
DmpVlvAct_EveRst_DmpVlvOplCmd|A|();|SCH.1|DMPVLVOPLCMD|1|V02 NT 10 01292||||0|0|0|0|Event reset  (Outputs initializations)
DmpVlvAct_SdlFast_CmdPwmAct|A|();|SCH.3|CMDPWMACT_DT|1|PTS_DOC_6913248||||0|0|0|0|Fast monitor for the DmpVlvAct function|
DmpVlvAct_SdlFast_DmpVlvCmd|C|();|SCH.2|DMPVLVCMD|1|PTS_DOC_6851423||||0|0|0|0|Moniteur rapide pour la fonction DmpVlvAct|
DmpVlvAct_SdlFast_DmpVlvCmdDiag|A|();|SCH.5|ACQDGOHAL_DT|1|PTS_DOC_6854092||||0|0|0|0|Fast monitor for the DmpVlvAct function|
DmpVlvAct_SdlMid_DmpVlvOplCmd|A|();|SCH.2|DMPVLVOPLCMD|1|V02 NT 10 01292||||0|0|0|0|Middle scheduler of the Airpres function DmpVlvAct
DmpVlvCmd_vidDiagnostic|D|();|FCT1.3|DMPVLVCMD|0|PTS_DOC_6851423||||0|0|0|0|Dump Valve Diagnosis|
DmpVlvCmd_vidDmpVlvCmdAplication|C|();|FCT1.2|DMPVLVCMD|0|PTS_DOC_6851423||||0|0|0|0|The Dump-Valve PWM frequency calibration is transmitted to the basic layer. Frequency is updated before PWM command signal as the PWM command is dependent upon frequency.|
DmpVlvCmd_vidInitEveRst|B|();|FCT1.1|DMPVLVCMD|0|PTS_DOC_6851423||||0|0|0|0|Initialisation des variables au reset|
DMPVLVCMDSPARB_vidDmpVlvArb|C|();|FCT1.1|DMPVLVCMDSPARB|0|V02 NT 12 02202||||0|0|0|0|describes the Dump-Valve command arbitration between different setpoints. It selects the bench mode and the nominal mode with the help of DmpVlvAct_bDmpVlvOplCmdEna.|
DmpVlvOplCmd_vidCalcCmdBModeBenchMod|B|();|FCT1.2|DMPVLVOPLCMD|0|V02 NT 10 01292||||0|0|0|0|The computation of the Dump valve open loop command bench mode setpoint can be inhibited by an enable.
DmpVlvOplCmd_vidDmpVlvOplCmdBenchMod|B|();|FCT1.3|DMPVLVOPLCMD|0|V02 NT 10 01292||||0|0|0|0|The method to command setpoint in bench mode is based on the error observed (Pa) and engine speed.
DmpVlvOplCmd_vidInitOutput|B|();|FCT1.1|DMPVLVOPLCMD|0|V02 NT 10 01292||||0|0|0|0|The Dump valve open loop command setpoint is initialised by a calibration at reset.
DRVRSENO2DS_vidDiag|B|();|FCT1.4|DRVRSENO2DS|0|PTS_DOC_6545446||||0|0|0|0|Fonction du traitement diagnostic.
DRVRSENO2DS_vidDiagEna|B|();|FCT1.5|DRVRSENO2DS|0|PTS_DOC_6545446||||0|0|0|0|Le diagnostic ne sera autorisé que si la variable « Lshd_down_lbda_s_heat_diag_inh » est à 0 et la tension batterie est comprise entre « Lshd_min_voltage_diag_thresh » et « Lshd_max_voltage_diag_thresh ».
DRVRSENO2DS_vidDiagTest|C|();|FCT1.6|DRVRSENO2DS|0|PTS_DOC_6545446||||0|0|0|0|Nous utilisons directement les informations de détection de pannes électriques fournies par le bloc masqué « DGO_OUTPUT » (Bloc d’interface entre la détection des défauts sous la responsabilité du LdB et le comptage panne sous la responsabilité du LdA).
DRVRSENO2DS_vidEntryInit|A|();|SCH.1|DRVRSENO2DS|1|PTS_DOC_6545446||||0|0|0|0|Evénement reset du calculateur.
DRVRSENO2DS_vidHeatSenO2DsCmd|A|();|FCT1.2|DRVRSENO2DS|0|PTS_DOC_6545446||||0|0|0|0|Le booléen chauf_o2_aval_demande_on est directement envoyé au LdB.
DRVRSENO2DS_vidInitOutput|B|();|FCT1.1|DRVRSENO2DS|0|PTS_DOC_6545446||||0|0|0|0|Initialisation des sorties
DRVRSENO2DS_vidSdlDiag|A|();|FCT1.3|DRVRSENO2DS|0|PTS_DOC_6545446||||0|0|0|0|On génère un nouveau function call (SdlDiag_DrvrSenO2Ds) basé sur SdlFast. Ce nouveau function call ne sera émis qu’un SdlFast sur 2
DRVRSENO2DS_vidUAcqn|I|();|FCT1.7|DRVRSENO2DS|0|PTS_DOC_6545446||||0|0|0|0|La tension du chauffage sonde est acquise pour des besoins de diagnostic fonctionnel.
DRVRSENO2US_vidDiag|B|();|FCT1.4|DRVRSENO2US|0|PTS_DOC_6559003||||0|0|0|0|Fonction du traitement diagnostic.
DRVRSENO2US_vidDiagEna|B|();|FCT1.5|DRVRSENO2US|0|PTS_DOC_6559003||||0|0|0|0|Le diagnostic ne sera autorisé que si la variable « FRM_bInhHeatSenO2Us » est à 0 et la tension batterie est comprise entre « Lshd_min_voltage_diag_thresh » et « Lshd_max_voltage_diag_thresh ».
DRVRSENO2US_vidDiagTest|D|();|FCT1.6|DRVRSENO2US|0|PTS_DOC_6559003||||0|0|0|0|Nous utilisons directement les informations de détection de pannes électriques fournies par le bloc masqué « DGO_OUTPUT » (Bloc d’interface entre la détection des défauts sous la responsabilité du LdB et le comptage panne sous la responsabilité du LdA).
DRVRSENO2US_vidEntryInit|A|();|SCH.1|DRVRSENO2US|0|PTS_DOC_6559003||||0|0|0|0|Evénement reset du calculateur.
DRVRSENO2US_vidHeatSenO2DsCmd|A|();|FCT1.2|DRVRSENO2US|0|PTS_DOC_6559003||||0|0|0|0|Le booléen Chauf_o2_amont_demande_on est directement envoyé au LdB.
DRVRSENO2US_vidInitOutput|D|();|FCT1.1|DRVRSENO2US|0|PTS_DOC_6559003||||0|0|0|0|Initialisation des sorties
DRVRSENO2US_vidSdlDiag|A|();|FCT1.3|DRVRSENO2US|0|PTS_DOC_6559003||||0|0|0|0|On génère un nouveau function call (SdlDiag_DrvrSenO2Us) basé sur SdlFast. Ce nouveau function call ne sera émis qu’un SdlFast sur 2
DRVRSENO2US_vidUAcqn|I|();|FCT1.7|DRVRSENO2US|0|PTS_DOC_6559003||||0|0|0|0|La tension du chauffage sonde est acquise pour des besoins de diagnostic fonctionnel.
DSO2SEN_vidAnalogMeasurement|A|();|FCT2.10|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Mesure analoguique de la sonde aval.|
DSO2SEN_vidBenchModeDownStream|A|();|FCT3.2|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Fonction de simulation du comportement d’une sonde viellie permettant la calibration du diagnostic dérivée de la sonde aval.|
DSO2SEN_vidCalDownStreamSO2|C|();|FCT1.5|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Calcul de la tension sonde aval|
DSO2SEN_vidDefaultOCSO2|A|();|FCT3.1|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Ce bloc permet de détecter l’absence de sonde aval ou la mauvaise connexion.|
DSO2SEN_vidDiagCCSO2|C|();|FCT1.4|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Gestion tension sonde aval en daig CC|
DSO2SEN_vidDiagOCSO2|D|();|FCT2.2|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Ce diagnostic permet de détecter la présence anormalement longue de la tension sonde dans une bande morte centrée autour du point de polarisation, ce qui induit l’absence de sonde aval ou une mauvaise connexion.|
DSO2SEN_vidDiagSCGSO2|D|();|FCT2.5|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Ce bloc permet de détecter un court-circuit à la masse sur la sonde aval. Le principe de cette détection repose sur le fait que lors d'un CC masse, le signal sonde vaut environ 0V.|
DSO2SEN_vidFreezeDownStreamSO2|B|();|FCT1.8|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Blocage de la sonde aval|
DSO2SEN_vidInitCptrAuthorizeFail|A|();|FCT2.9|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Initialisation du compteur qui  autorise la panne|
DSO2SEN_vidInitDeadZoneCount|B|();|FCT2.1|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Initialisation du compteur de la zone morte|
DSO2SEN_vidInitOutput|C|();|FCT1.1|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Initialisation des sorties au Reset ECU|
DSO2SEN_vidInitTempoDestock|A|();|FCT2.7|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Initialisation de tempo de destockage|
DSO2SEN_vidManageTempoDestock|A|();|FCT2.6|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Ce bloc permet de détecter un court-circuit à la masse sur la sonde aval. Le principe de cette détection repose sur le fait que lors d'un CC masse, le signal sonde vaut environ 0V.|
DSO2SEN_vidMngDownStreamSO2|D|();|FCT1.2|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Fonction permettant l’acquisition de la tension de la sonde aval et la simulation du comportement d’une sonde viellie.|
DSO2SEN_vidMngVoltSO2Extrema|C|();|FCT2.3|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Gestion de la tension sonde extreme|
DSO2SEN_vidRunClefOff|B|();|FCT2.4|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Commande du clé off|
DSO2SEN_vidSO2LeanToRich|B|();|FCT1.6|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Sonde  pauvre au riche|
DSO2SEN_vidSO2RichToLean|B|();|FCT1.7|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Sonde riche ou pauvre|
DSO2SEN_vidTempoBeforeFailure|A|();|FCT2.8|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Tempo avant autorisation panne|
DSO2SEN_vidVoltSO2WithoutDefect|D|();|FCT1.3|DSO2SEN|0|PTS_DOC_6563982||||0|0|0|0|Fonction calculant la tension différentielle de la sonde aval avant le mode banc.|
ECTREQ_vidCmdRCO_Cor|B|();|FCT1.5|ECTREQ|0|PTS_DOC_6886129||||0|0|0|0|In this block the ECT command is first corrected with the value of the filtered battery voltage and then saturated  between two values.|
ECTREQ_vidDiagnosis|A|();|FCT1.7|ECTREQ|0|PTS_DOC_6886129||||0|0|0|0|In this block we make the electrical diagnosis of the ECT command.|
ECTREQ_vidDrvCmd|A|();|FCT1.6|ECTREQ|0|PTS_DOC_6886129||||0|0|0|0|Here we make a conversion of the corrected and saturated ECT command and we send this final value to the  LDB.  The PWM request can be inverted using the calibration ECTReq_bInvDuCy_C if it is required.|
ECTREQ_vidFiltBatt|A|();|FCT1.4|ECTREQ|0|PTS_DOC_6886129||||0|0|0|0|Here we make an average on the two last values of battery voltage to use it for the correction.|
ECTREQ_vidInitialization|A|();|FCT1.2|ECTREQ|0|PTS_DOC_6886129||||0|0|0|0|In this block the initialization of the output command is done and the PWM frequency is communicated to the  LDB.|
ECTREQ_vidInitOutput|A|();|FCT1.1|ECTREQ|0|PTS_DOC_6886129||||0|0|0|0|Fonction qui initialise les sorties des blocs dynamique et les sorties non initlialisée.|
ECTREQ_vidTreatment|A|();|FCT1.3|ECTREQ|0|PTS_DOC_6886129||||0|0|0|0|In this block we make a treatment on the ECT command in order to send to the hardware driver a corrected and  saturated value.|
ECUMNG_NVMSRV_vidInit|B|();|FCT2.9|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|La variable EcuSt_ctHotRst_Count est initialisée à la réinitialisation  de l' EEPROM avec la calibrationEcuSt_ctHotRst_Count_Init.|
ECUMNG_vidAPCConfig|B|();|FCT2.8|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|cette fonction permet d'assurer le calcul de l'état UCE_stSt selon la configuration APC.|
ECUMNG_vidbisAcvDiagHotRst|A|();|FCT3.1|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|When a hot reset is detected (hot reset = software reset or hardware reset) the EcuSt_bDgoHotRst flag is  validated.|
ECUMNG_vidbRstSrvRstEepromCount|B|();|FCT2.10|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|In case of a software reset Boolean (Srv_bRstSw_DiagSrv ) rising edge,the counter of maximum delay required to write in EEPROM Rcd_wait_wr_in_eeprom_count is reset to calibration Rcd_wait_wr_in_eeprom_delay.|
ECUMNG_vidEcuMng_Init|C|();|FCT1.1|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|Init function|
ECUMNG_vidFctPrinDegrad|C|();|FCT1.5|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|This function, called in POWER_ON (EcuSt_SdlMid_EcuMng_3), produces a flag gathering the conditions to set the ECU in degraded main awakening.|
ECUMNG_vidInitOutput|B|();|FCT1.8|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|initialisation des sorties|
ECUMNG_vidInterneCmm|C|();|FCT2.6|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|This function is called after the main awakening to inform the BSI if the ECU is in partial awakening, in internal partial awakening, or simply transient.|
ECUMNG_vidManagePowerOn|C|();|FCT1.2|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|On Key on event, Power_conditions_state is set to POWER_ON state and the immobilizer event SAIMMO_Init is generated.|
ECUMNG_vidManager|I|();|FCT1.3|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|Manager d’état.|
ECUMNG_vidPowerOnTrans|G|();|FCT2.2|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|Fonction de gestion de transition de l'état POWER_ON|
ECUMNG_vidPwrLatchDelayTrans|L|();|FCT2.4|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|Fonction de gestion de transition de l'état Waiting_for_power_latch_delay|
ECUMNG_vidPwrlEndAuth|B|();|FCT1.6|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|On EcuSt_EvePwrlEnd_EcuMng, the Powerlatch end is authorized.|
ECUMNG_vidRCDConfig|B|();|FCT2.7|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|cette fonction permet d'assurer le calcul de l'état UCE_stSt selon la configuration RCD.|
ECUMNG_vidRcdStateSelection|C|();|FCT1.7|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|The Rcd state is selected between the state determinated by the Valeo strategy or by RCD software component.This selection is realized on reset event, Key On event, Key Of event and on middle timing event.|
ECUMNG_vidSleepingTrans|F|();|FCT2.5|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|Dans cet état le calculateur demande au LDB la coupure du relais principal. La demande de coupure du relais principal par l'API DIOHAL_vidWrite(MAIN_RELAY, STD_OFF) entraine l'arret de l'OS et de toutes les IT|
ECUMNG_vidSurveillance|B|();|FCT1.4|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|After RCD signal deactivating and awakening requests by the BSI, the ECU monitors their progress during a minimum period before going to SLEEPING state.|
ECUMNG_vidWaitAnticipationTrans|F|();|FCT2.1|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|Fonction de gestion de transition de l'état WAITING_FOR_ANTICIPATION|
ECUMNG_vidWaitRstrtDelayTrans|I|();|FCT2.3|ECUMNG|0|PTS_DOC_6642215||||0|0|0|0|Fonction de gestion de transition de l'état Waiting_for_restart_delay|
EcuSt_EveEcuSt_EcuMng|A|();|4|HEADER|1|NONE||||0|0|0|0|Fonction d'accroche à l'evenement de transmission de la trame 788|
EcuSt_EveFct_PwrlMrk|A|();|SCH.3|PWRLMRK|1|V02 NT 11 04404||||0|0|0|0|Event recurrence to launch the API: AllSaved that checks if all the  parameters have been saved in the Eeprom writings during the power latch state.|
EcuSt_EveFct_WaitForPwrl|A|();|7|HEADER|1|NONE||||0|0|0|0||
EcuSt_EveFrstKOn_Wku|A|();|4|HEADER|1|NONE||||0|0|0|0||
EcuSt_EveIni_Wku|A|();|SCH.6|WKU|1|PTS_DOC_6765172||||0|0|0|0|Reset pour déclenchement du premier Key ON|
EcuSt_EveKOf_EcuMng|F|();|SCH.5|ECUMNG|1|PTS_DOC_6642215||||0|0|0|0|Fonction d'accroche à l'event EcuSt_EveKOf_EcuMng|
EcuSt_EveKOn_EcuMng|F|();|SCH.4|ECUMNG|1|PTS_DOC_6642215||||0|0|0|0|Focntion d'accroche à l'event EcuSt_EveKOn_EcuMnG|
EcuSt_EvePtlWku_Wku|B|();|SCH.3|ECUMNG|1|PTS_DOC_6642215||||0|0|0|0|Focntion d'accroche à l'event EcuSt_EvePtlWku_Wku|
EcuSt_EvePwrlEnd_EcuMng|E|();|SCH.6|ECUMNG|1|PTS_DOC_6642215||||0|0|0|0|Evénement d'entrée dans la tâche d’écriture en EEPROM en fin de powerlatch|
EcuSt_EveRst_AcqWkuSig|D|();|SCH.1|ACQWKUSIG|1|PTS_DOC_6884549||||0|0|0|0|Evènement de reset calculateur|
EcuSt_EveRst_DiagMem|A|();|SCH.1|DIAGMEMECU|1|V02 NT 10 02966||||0|0|0|0|Reset du Calculateur
EcuSt_EveRst_EcuMng|G|();|SCH.1|ECUMNG|1|PTS_DOC_6642215||||0|0|0|0|Foonction d'accroche à l'event EcuSt_EveRst_EcuMng.|
EcuSt_EveRst_EcuMngIf|E|();|SCH1.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset ECU du module d'interface|
EcuSt_EveRst_Wku|G|();|SCH.1|WKU|1|PTS_DOC_6765172||||0|0|0|0|Fonction Reset|
EcuSt_EveRxn432_Wku|G|();|SCH.2|WKU|1|PTS_DOC_6765172||||0|0|0|0|Fonction ordonnanceur des taches actives sur evenement EcuSt_EveRxnFrame432_Wku|
EcuSt_SdlFast_AcqWkuSig|D|();|SCH.2|ACQWKUSIG|1|PTS_DOC_6884549||||0|0|0|0|Moniteur Rapide|
EcuSt_SdlFast_AcqWkuSigDio|A|();|SCH3.9|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Moniteur rapide de l'acquisition clé
EcuSt_SdlFast_Wku|H|();|SCH.4|WKU|1|PTS_DOC_6765172||||0|0|0|0|Englobe les fonctions appelées à la récurence de EcuSt_SdlFast_Wku|
EcuSt_SdlMid_DiagMem|A|();|SCH.2|DIAGMEMECU|1|V02 NT 10 02966||||0|0|0|0|Moniteur moyen du diagnostic des mémoires EEPROM
EcuSt_SdlMid_EcuMng|F|();|SCH.2|ECUMNG|1|PTS_DOC_6642215||||0|0|0|0|Fonction d'accroche à l'event EcuSt_SdlMid_EcuMng|
EcuSt_SdlMid_EcuMngIf|F|();|SCH7.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur moyen du module d'interface|
EcuSt_SdlMid_Wku|G|();|SCH.3|WKU|1|PTS_DOC_6765172||||0|0|0|0|Englobe les fonctions activés sur le moniteur fixe EcuSt_SdlMid_Wku|
EcuSt_SdlSlow_DiagMem|A|();|SCH.3|DIAGMEMECU|1|V02 NT 10 02966||||0|0|0|0|Moniteur lent du diagnostic des mémoires Flash
EcuSt_SdlSlow_Wku|F|();|SCH.5|WKU|1|PTS_DOC_6765172||||0|0|0|0|Moniteur lent de la fonction EcuSt|
EEPMNG_bF02_Conditions|A|func_EEPMNG_bF02_Conditions|API.1|EEPMNG|1|V02 NT 09 03285||||0|0|0|0|Vérifie si les conditions sont réunies pour une remise à zéro de l'eeprom. Appelé par le driver eeprom, cette fonction  retourne un booléen à TRUE si le RAZ de l'eeprom est necessaire.|
ELECITGRMOD_vidEntryIntElec|E|();|FCT1.4|ELECITGRMOD|0|PTS_DOC_6873723||||0|0|0|0|This function launch the Integration Electronic mode
ELECITGRMOD_vidExitIntElec|F|();|FCT1.5|ELECITGRMOD|0|PTS_DOC_6873723||||0|0|0|0|This function quits the Integration Electronic mode
ELECITGRMOD_vidIntegElectronic|D|();|FCT1.3|ELECITGRMOD|0|PTS_DOC_6873723||||0|0|0|0|This function checks data received by the frame 0x092
ELECITGRMOD_vidIntElecCondCheck|D|();|FCT1.2|ELECITGRMOD|0|PTS_DOC_6873723||||0|0|0|0|This function checks if conditions are corrects
ELECITGRMOD_vidIntElecInit|E|();|FCT1.1|ELECITGRMOD|0|PTS_DOC_6873723||||0|0|0|0|This function checks if conditions to be in Inegration  Electronic mode are correct at the init
Eng_EveIni_tOilEstim|E|();|SCH.1|TOILEST|1|PTS_DOC_5050596||||0|0|0|0|Fonction d'accroche au moniteur de Reset.|
Eng_EveIni_tOilEstimIf|B|();|SCH4.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement reset du calculateur.|
Eng_EvePwL_tOilEstim|C|();|SCH.3|TOILEST|1|PTS_DOC_5050596||||0|0|0|0|Evènement Power Latch.|
Eng_Sdl100ms_tOilEstim|E|();|SCH.2|TOILEST|1|PTS_DOC_5050596||||0|0|0|0|Fonction d'accroche au moniteur moyen.|
Eng_Sdl100ms_tOilEstimIf|B|();|SCH15.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur 100ms.|
ENGIDLEINTERFACE_vidBoucleStruct|A|(void);|FCT1.2|ENGIDLEINTERFACE|0|V02 NT 10 04614||||0|0|0|0|Ce bloc permet de générer le flux de bouclage de la structure couple à partir des informations de bouclage des branches avance et air.|
ENGIDLEINTERFACE_vidCalcCouples|B|(void);|FCT1.4|ENGIDLEINTERFACE|0|V02 NT 10 04614||||0|0|0|0|Ce bloc permet d’adapter les couples de saturation maximum et minimum à prendre en compte par le régulateur de ralenti.|
ENGIDLEINTERFACE_vidEntryInit|B|();|SCH.1|ENGIDLEINTERFACE|1|V02 NT 10 04614||||0|0|0|0|Evénement reset.|
ENGIDLEINTERFACE_vidInitOutput|A|(void);|FCT1.1|ENGIDLEINTERFACE|0|V02 NT 10 04614||||0|0|0|0|Fonction d'initialisation des sorties|
ENGIDLEINTERFACE_vidSelGainRegul|A|(void);|FCT1.3|ENGIDLEINTERFACE|0|V02 NT 10 04614||||0|0|0|0|Ce bloc permet d’adapter les gains du régulateur de ralenti en fonction du mode de combustion ou d’un défaut moteur imposant une régulation de régime spécifique.|
ENGLIMEFCCORD_vidCoord_Lim_CME|C|();|FCT1.2|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|La fonction de coordination des limitations GMP fournit les couples de limitation utilisés par l’agrément, la xVV, la boite, l’ESP pour créer des couples inter-systèmes.|
ENGLIMEFCCORD_vidEntryInit|D|();|SCH.1|ENGLIMEFCCORD|1|V02 NT 10 03267||||0|0|0|0|Fonction d'accroche moniteur Reset|
ENGLIMEFCCORD_vidInitOutput|G|();|FCT1.1|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|Initialise les variables produites par la spec|
ENGLIMEFCCORD_vidLim_BVAuto_1|D|(argin sint16 s16TqSys1, argin sint16 s16TqSys2, argin sint16 s16TqSys3);|FCT1.6|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|Réinitialisation du filtre de niveau 1 de la stratégie d’agrément curatif.|
ENGLIMEFCCORD_vidLim_BVAuto_1_2|D|(argin sint16 s16GbxBVAuto_1_2);|FCT2.2|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|Réinitialisation du filtre de niveau 1 de la stratégie d’agrément curatif.|
ENGLIMEFCCORD_vidLim_BVAuto_2|E|(argin sint16 s16TqSys1, argin sint16 s16TqSys2, argin sint16 s16TqSys3);|FCT1.7|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|La deuxième limitation pour la fonction BVA/BVMP est configurée en fonction de la valeur de EngLim_CoPtLimTyp2_C correspondant à la somme des valeurs couples de limitation à utiliser.|
ENGLIMEFCCORD_vidLim_BVAuto_2_2|D|(argin sint16 s16ATBVAuto_2_2);|FCT2.3|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|La deuxième limitation pour la fonction BVA/BVMP est configurée en fonction de la valeur de EngLim_CoPtLimTyp2_C correspondant à la somme des valeurs couples de limitation à utiliser.|
ENGLIMEFCCORD_vidLim_ESP|D|(argin sint16 s16TqSys1, argin sint16 s16TqSys2, argin sint16 s16TqSys3);|FCT1.8|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|La deuxième limitation pour la fonction ESP est configurée en fonction de la valeur de EngLim_ChaLim_C correspondant à la somme des valeurs couples de limitation à utiliser.|
ENGLIMEFCCORD_vidLim_ESP1|C|(argin sint16 s16tqEfcESP1);|FCT2.4|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|La deuxième limitation pour la fonction ESP est configurée en fonction de la valeur de EngLim_ChaLim_C correspondant à la somme des valeurs couples de limitation à utiliser.|
ENGLIMEFCCORD_vidLim_ModSpt|A|(argin sint16 s16TqSys1, argin sint16 s16TqSys2, argin sint16 s16TqSys3);|FCT1.9|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|La deuxième limitation pour la fonction superviseur du mode sport est configurée en fonction de la valeur de EngLim_idxModSptLim_C correspondant à la somme des valeurs couples de limitation à utiliser.|
ENGLIMEFCCORD_vidLim_ModSpt1|A|(argin sint16 s16tqEfcModSpt1);|FCT2.5|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|La deuxième limitation pour la fonction superviseur du mode sport est configurée en fonction de la valeur de EngLim_idxModSptLim_C correspondant à la somme des valeurs couples de limitation à utiliser.|
ENGLIMEFCCORD_vidLim_Preventif|E|();|FCT1.4|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|La limitation pour la fonction agrément est différente selon que l’on est en présence d’une boite auto, dans ce cas lors des SIP, elle prend en compte en plus le couple max envoyé par la boite.|
ENGLIMEFCCORD_vidLim_Stat_Air_Av|D|();|FCT1.3|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|Les limitations de protection boite (statique et dynamique) sont calculées dans ce bloc. On distingue les limitations sur la branche avance et sur la branche air. On ajoute une coordination en prenant en compte le type de carburant.|
ENGLIMEFCCORD_vidLimit_Divers|C|();|FCT1.10|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|D’autre limitations pour les fonctions divers (Clim, xVV et regulation de régime en aide décollage) sont calculées ici.|
ENGLIMEFCCORD_vidLimit_InterSys|C|();|FCT1.5|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|Chaque couple de limitation crée est configuré par une calibration. Cette calibration correspond à la somme des valeurs couples de limitation à utiliser.|
ENGLIMEFCCORD_vidLimitCpleAirDsl|B|();|FCT2.1|ENGLIMEFCCORD|0|V02 NT 10 03267||||0|0|0|0|Cette limitation est la limitation spécifique pour le couple consigne air en diesel|
EngLimTq_EveBDC_IgAdvTq3If|F|();|SCH9.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement PMB d'interface.|
EngM_SdlMid_InterfEngMSC|E|();|SCH.3|INTERFACAGE_BA_SC|1|V02 NT 10 07792||||0|0|0|0|Scheduleur moyen de l'interfaçage du module EngM|
EngM_SdlMid_InterfUsThrMSC|D|();|SCH.5|INTERFACAGE_BA_SC|1|V02 NT 10 07792||||0|0|0|0|Scheduleur moyen de l'interfaçage du module UsThrM|
EngM_SdlMid_intkLoaEstimnIf|E|();|SCH7.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur moyen du module d'interface|
EngReqH_SdlFast_EngReqH|B|();|SCH.3|ENGREQH|1|V02 NT 09 05960||||0|0|0|0|Fonction d'accroche au moniteur 10ms|
EngReqH_SdlMid_EngReqH|B|();|SCH.2|ENGREQH|1|V02 NT 09 05960||||0|0|0|0|Scheduler intermédiaire|
ENGREQH_vidAutorisMoteurSTOP|C|();|FCT3.6|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction fait la synthèse de toutes les demandes moteur autorisant le STOP. Chaque demande extérieure peut être désactivée par calibration.|
ENGREQH_vidChoixTemperatureAir|E|();|FCT2.2|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Ce sous système fait partie de l’autorisation de stop en fonction du couple température d’air / température d’eau.Il permet de sélectionner au choix une température d’air.|
ENGREQH_vidConditionRegimeMoteur|D|();|FCT3.8|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|La condition de redémarrage autonome lors d’une phase d’arrêt STT est autorisée si le régime moteur est supérieur à un seuil fonction de la température moteur et de la pression atmosphérique.|
ENGREQH_vidCondNombrePMHRestant|B|();|FCT3.9|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|La condition de redémarrage autonome lors d’une phase d’arrêt STT est autorisée si le nombre de PMH restant  avant l’atteinte du régime nul est supérieur ou égal à un seuil.|
ENGREQH_vidCondPresHuileAutoStop|C|();|FCT2.10|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction autorise le STOP au bout d’une temporisation débutant après un seuil de pression d’huile franchi suite à un démarrage/redémarrage.|
ENGREQH_vidCondRedemaAutonomeSTT|B|();|FCT3.7|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction calcule la condition de redémarrage autonome lors d’une phase d’arrêt STT.|
ENGREQH_vidCondRedemarrAutonome|C|();|FCT3.10|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|La condition de redémarrage autonome est calculée à partir des deux conditions calculées précédemment, ainsi  qu’en fonction de l’état de fonctionnement du moteur.|
ENGREQH_vidCondSeuilBasTempCatal|D|();|FCT2.6|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Ce sous système est la partie fonctionnelle d’autorisation du stop en fonction de la température du catalyseur.|
ENGREQH_vidCondSeuilHautTempCata|C|();|FCT2.7|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction surveille la température catalyseur par rapport à un seuil haut. La condition  peut être forcée à 1 par  calibration ou en cas de défaillance sur la température catalyseur.|
ENGREQH_vidCondSondLambdaAutStop|C|();|FCT1.9|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction autorise le STOP si les sondes à oxygène amont et aval du catalyseur sont prêtes depuis une temporisation calibrable.On peut désactiver, par calibration, la condition sur chacune des sondes.|
ENGREQH_vidCondTempCatalyAutStop|B|();|FCT2.5|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction autorise le STOP fonction de la température du catalyseur. Elle comprend une partie instaurant une limite basse, une autre une limite haute et une partie dysfonctionnelle.|
ENGREQH_vidCondTempEauAutoriStop|B|();|FCT1.2|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction autorise le STOP à partir de l’observation de la température eau moteur. Elle comprend une partie fonctionnelle et une dysfonctionnelle.|
ENGREQH_vidCondTemperAirAutoStop|C|();|FCT2.1|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction autorise du STOP en fonction de règles liées à la température d’air et de la température moteur. Cette fonction est composée de 3 sous systèmes: sélection de la température, partie fonctionnelle, partie dysfonc- tionnelle.|
ENGREQH_vidCondTempHuileAutoStop|B|();|FCT1.5|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction autorise le STOP en fonction de la température d’huile. Elle comprend une partie fonctionnelle et une dysfonctionnelle.|
ENGREQH_vidConTempCarTurbAutStop|D|();|FCT2.9|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Ce sous système calcule l’autorisation du stop en fonction de la température carter turbine. On autorise le stop si la température du carter turbine est inférieure à un seuil calibrable.|
ENGREQH_vidCriticPresAtmospheriq|B|();|FCT4.2|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction détecte une condition critique sur la pression atmosphérique pour le démarrage du moteur.|
ENGREQH_vidDemandeRedemarrage|B|();|FCT3.2|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction fait la synthèse de toutes les demandes de redémarrage STT.|
ENGREQH_vidEntryInit|C|();|SCH.1|ENGREQH|1|V02 NT 09 05960||||0|0|0|0|Fonction d'accroche Reset.|
ENGREQH_vidFiltreRegimeMoteur|B|();|FCT4.1|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Ce bloc permet de sélectionner le régime moteur utilisé pour le calcul de la condition de redémarrage autonome.|
ENGREQH_vidInitOutput|D|();|FCT1.1|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Initialisation des variables de sortie.|
ENGREQH_vidObserTempsMinimumStop|D|();|FCT3.5|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction interdit l’émission d’une demande de redémarrage STT tant que le système n’est pas resté un temps  minimum calibrable en phase de STOP.|
ENGREQH_vidPartieDisfoncTempAir|B|();|FCT2.4|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Ce sous système est la partie dysfonctionnelle d’autorisation du STOP en fonction du couple température d’air / température d’eau. Par calibration, elle offre plusieurs possibilités de reconfiguration.|
ENGREQH_vidPartieDisfoncTempCata|B|();|FCT2.8|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|partie_disfonctionnelle_seuil_bas_temperature_catalyseur .|
ENGREQH_vidPartieDisfoncTempEau|A|();|FCT1.4|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Ce sous système est la partie dysfonctionnelle d’autorisation de STOP en fonction de la température d’eau moteur. Elle est activée sur un booléen de reconfiguration en cas de défaillance sur la température d’eau.|
ENGREQH_vidPartieDisfonTempHuile|A|();|FCT1.7|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Ce sous système est la partie dysfonctionnelle d’autorisation de STOP en fonction de la température d’huile mo- teur. Elle est activée sur un booléen de reconfiguration en cas de défaillance sur la température d’huile.|
ENGREQH_vidPartieFonctionTempAir|A|();|FCT2.3|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Ce sous système est la partie fonctionnelle de la fonction d’autorisation du stop sur des conditions liées au couple  température d’air / température d’eau.|
ENGREQH_vidPartieFonctionTempEau|B|();|FCT1.3|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Ce sous système est la partie fonctionnelle d’autorisation du stop en fonction de la température d’eau moteur. On autorise le stop si la température moteur est comprise entre 2 seuils calibrables.|
ENGREQH_vidPartieFonctTempHuile|B|();|FCT1.6|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Ce sous système est la partie fonctionnelle de la fonction d’autorisation du stop en fonction de la température d’huile. Dans ce sous système, on autorise le stop si la température d’huile est comprise entre 2 seuils calibrables.|
ENGREQH_vidRedemBesoinThermCapot|B|();|FCT3.3|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction émet un besoin de redémarrage STT à  partir de l’information en provenance de la fonction de  gestion de la thermique sous capot.|
ENGREQH_vidRedemSeuilTempEssence|D|();|FCT3.4|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction surveille la température d’essence par rapport à un seuil haut. Si ce seuil est dépassé durant une  phase de STOP, un redémarrage STT est demandé.|
ENGREQH_vidSelectActivFonctions|B|();|FCT3.1|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction permet de désactiver par calibration chacune des conditions d’autorisation du STOP. Sur demande d’un outil test de fin d’assemblage, une sélection calibrable des conditions d’autorisation peut être réalisée.|
ENGREQH_vidTempoDemarrageAutStop|C|();|FCT1.8|ENGREQH|0|V02 NT 09 05960||||0|0|0|0|Cette fonction autorise le STOP au bout d’une temporisation débutant avec l’entrée en phase engine_running suite  à un démarrage/redémarrage.|
ENGRUNST_vidCutOffInputMngt|D|();|FCT1.6|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|La coupure d’injection est autorisée qu'au dessus d'un seuil de température après un délai suivant le démarrage et lorsqu’un un délai calibré est écoulé suite à une régulation ESP de type MSR lors d’une coupure d’injection pied levé.|
ENGRUNST_vidDelayTimeout|B|();|FCT1.5|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|A la transition de l’automate Vehicle_active_state de l’état CRANKING à RUNNING, on initialise le compteur Pl_fco_entry_delay_timeout.|
ENGRUNST_vidDiag|B|();|FCT2.1|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|Lorsque le compteur de temps cumulé passé en sur-régime est supérieur à un seuil calibrable et que l’on a switché sur la carto EngSt_EngSpdLimHiThdMecProt_M pour le calcul du régime seuil d’activation de la fonction sur-régime.|
ENGRUNST_vidEngrunst|K|();|FCT1.7|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|L'injection de carburant est coupée lors des décélérations et les prises de régime pédale en position pied levé avec pour objectifs.|
ENGRUNST_vidEngrunStInterface|C|();|FCT1.9|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|Cette fonction décrit l'interfaçage des variables Manage_isc_closed_loop et Ext_bIdlAcv avec le flag moteur sous contrôle du régulateur et consigne ralenti active, ainsi que l'interfaçage de Ext_stEngrun avec Engine_running_state|
ENGRUNST_vidFcoMainConditions|F|();|FCT1.3|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|Cette condition nécessaire à l'autorisation de la coupure injection (ERUN_ENGINE_OVERRUN_FCO) quelque soit l'état d'origine.|
ENGRUNST_vidFullLoadEntryDelay|D|();|FCT1.2|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|Le passage en FULL_LOAD est effectué sur des conditions évaluées en NORMAL_RUNNING ou en ENGINE_OVERSPEED_FCO, avec un délai d’entrée géré dans ce module.|
ENGRUNST_vidInit|C|();|FCT1.4|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|Le compteur Esp_cut_off_allowed_count est initialisé à zéro au reset.|
ENGRUNST_vidInitOutput|H|();|FCT1.1|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|Fonction d'initialisation des variables produites par la spec.|
ENGRUNST_vidKeyOnCalc|C|();|FCT1.10|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|Au Key-On on vient lire la valeur du compteur de temps cumulé passé en sur-régime et on vérifie si il est supérieur au seuil défini par calibration.|
ENGRUNST_vidOverpeedFcoCondEntry|G|();|FCT1.8|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|Le passage à VRAI de FRM_bEngSpdLimHiIntv entraine une limitation du régime moteur, calibrable en fonction du rapport de boite filtré. Le passage à VRAI de FRM_bEngSpdLimLoIntv entraine une limitation sévère du régime moteur.|
ENGRUNST_vidRstAcvTrqLim|B|();|FCT2.2|ENGRUNST|0|PTS_DOC_5489080||||0|0|0|0|Lorsque la limitation du sur-régime par la couple est effective, la demande d’activation par le couple doit être réinitialisée à 0, mais la stratégie doit rester activée tant que EngSt_bEntryOVERSPEED_FCO = 1.|
EngSt_EveCkOn_EngStrtStop|A|();|SCH.10|ENGSTRTSTOP|1|V02 NT 08 05182||||0|0|0|0|Evènement Détection rotation moteur
EngSt_EveCkSnOn_EngStrtStop|A|();|SCH.5|ENGSTRTSTOP|1|V02 NT 08 05182||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise.
EngSt_EveCrTR_EngrunSt|C|();|SCH.3|ENGRUNST|1|PTS_DOC_5489080||||0|0|0|0|Evénement CRANKING vers RUNNING.|
EngSt_EveCrTR_VehSt|A|();|3|HEADER|1|NONE||||0|0|0|0||
EngSt_EveCrTSt_VehSt|A|();|5|HEADER|1|NONE||||0|0|0|0||
EngSt_EveEORF_EngrunSt|A|();|5|HEADER|1|NONE||||0|0|0|0|Transition ERUN_ENGINE_OVERRUN_FCO vers ERUN_NORMAL_RUNNING|
EngSt_EveKOf_EngStrtStop|A|();|SCH.6|ENGSTRTSTOP|1|V02 NT 08 05182||||0|0|0|0|Evénement associé au passage de clef ON à clef OFF.
EngSt_EveKOn_EngrunSt|B|();|SCH.4|ENGRUNST|1|PTS_DOC_5489080||||0|0|0|0|Evénement clef Off_On|
EngSt_EveKOn_EngStrtStop|B|();|SCH.3|ENGSTRTSTOP|1|V02 NT 08 05182||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON
EngSt_EveKOn_VehSt|A|();|SCH.4|VEHST|1|PTS_DOC_5404370||||0|0|0|0|Evenement Key On|
EngSt_EveNTFL_EngrunSt|A|();|3|HEADER|1|NONE||||0|0|0|0|Fonction permettant le passage de l'état ERUN_NORMAL_RUNNING vers ERUN_FULL_LOAD|
EngSt_EvePwrl_TiEngStop|C|();|SCH.6|TIENGSTOP|1|PTS_DOC_5329313||||0|0|0|0|Evénement powerlatch|
EngSt_EveRst_AuthStrtSTT|C|();|SCH.1|AUTHSTRTSTT|1|PTS_DOC_6525148||||0|0|0|0|Evenement Reset|
EngSt_EveRst_AuthStrtSTTDio|A|();|SCH1.3|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evènement_reset.
EngSt_EveRst_DftStaCmd|A|();|SCH.1|BICD|1|PTS_DOC_6529336||||0|0|0|0|Evènement reset
EngSt_EveRst_EngrunSt|E|();|SCH.1|ENGRUNST|1|PTS_DOC_5489080||||0|0|0|0|évenement reset.|
EngSt_EveRst_EngrunStIfAir|B|();|SCH2.3|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Evénement reset du calculateur|
EngSt_EveRst_EngStab|A|();|SCH.1|ENGSTAB|1|V02 NT 09 03216||||0|0|0|0|Evénement reset du calculateur
EngSt_EveRst_EngStOutIdc|E|();|SCH.1|ENGSTOUTPIDC|1|PTS_DOC_6528229||||0|0|0|0|Fonction d'accroche à l'événement reset du calculateur
EngSt_EveRst_EngStOutIdcDio|A|();|SCH1.2|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evénement reset du calculateur.
EngSt_EveRst_EngStrtStop|A|();|SCH.1|ENGSTRTSTOP|1|V02 NT 08 05182||||0|0|0|0|Evènement RESET du calculateur
EngSt_EveRst_EngStrtStopIf|C|();|SCH3.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement reset du calculateur.|
EngSt_EveRst_OscDet|A|();|SCH.1|OSCDET|1|V02 NT 12 00679||||0|0|0|0|Evénement reset du calculateur
EngSt_EveRst_TiEngStop|C|();|SCH.1|TIENGSTOP|1|PTS_DOC_5329313||||0|0|0|0|Cette fonction permet l'initialisation des sorties au reset du calculateur.|
EngSt_EveRst_VehSt|B|();|SCH.1|VEHST|1|PTS_DOC_5404370||||0|0|0|0|Fonction d'accroche à l'événement Event_reset|
EngSt_EveRTCr_VehSt|A|();|4|HEADER|1|NONE||||0|0|0|0||
EngSt_EveRTSt_EngStrtStop|A|();|SCH.8|ENGSTRTSTOP|1|V02 NT 08 05182||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant.
EngSt_EveRTSt_TiEngStop|C|();|SCH.5|TIENGSTOP|1|PTS_DOC_5329313||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant.|
EngSt_EveRxn552_EngStrtStop|A|();|SCH.7|ENGSTRTSTOP|1|V02 NT 08 05182||||0|0|0|0|Evènement correspondent à la reception de la trame 552h .
EngSt_EveRxn552_TiEngStop|C|();|SCH.3|TIENGSTOP|1|PTS_DOC_5329313||||0|0|0|0|Evènement correspondent à la reception de la trame 552h.|
EngSt_EveRxn552bis_TiEngStop|C|();|SCH.7|TIENGSTOP|1|PTS_DOC_5329313||||0|0|0|0|Evènement correspondent à la reception de la trame 552bis|
EngSt_EveStTCr_VehSt|A|();|2|HEADER|1|NONE||||0|0|0|0||
EngSt_EveStTR_EngStrtStop|C|();|SCH.4|ENGSTRTSTOP|1|V02 NT 08 05182||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant
EngSt_EveStTR_VehSt|A|();|SCH.5|VEHST|1|PTS_DOC_5404370||||0|0|0|0|Evènement Stall-2-Rot|
EngSt_EveTOSR_EngrunSt|A|();|4|HEADER|1|NONE||||0|0|0|0|Fonction permettant l'entrée en ERUN_ENGINE_OVERRUN_FCO ou ERUN_ENGINE_OVERSPEED_FCO|
EngSt_SdlFast_AuthStrtSTT|C|();|SCH.2|AUTHSTRTSTT|1|PTS_DOC_6525148||||0|0|0|0|Moniteur rapide pour la fonction CallMng|
EngSt_SdlFast_AuthStrtSTTDio|A|();|SCH2.7|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Monitoring rapide de la fonction EngSt.
EngSt_SdlFast_CmdDiagAuthStrtSTT|A|();|SCH1.8|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Monitoring rapide de la fonction EngSt.
EngSt_SdlFast_CmdDiagEngStOutIdc|A|();|SCH1.10|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Moniteur rapide pour la fonction état moteur
EngSt_SdlFast_DftStaCmd|A|();|SCH.2|BICD|1|PTS_DOC_6529336||||0|0|0|0|Monitoring rapide
EngSt_SdlFast_DftStaCmdAdc|A|();|SCH2.10|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Monitoring rapide
EngSt_SdlFast_EngrunSt|F|();|SCH.2|ENGRUNST|1|PTS_DOC_5489080||||0|0|0|0|Moniteur Rapide de la fonction EngSt.|
EngSt_SdlFast_EngrunStIfAir|B|();|SCH2.2|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Moniteur Rapide de la fonction EngSt|
EngSt_SdlFast_EngStOutIdc|E|();|SCH.2|ENGSTOUTPIDC|1|PTS_DOC_6528229||||0|0|0|0|Fonction d'accroche à l'événement EngSt_SdlFast_EngStOutIdc
EngSt_SdlFast_EngStOutIdcDio|A|();|SCH2.6|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Moniteur rapide pour la fonction état moteur.
EngSt_SdlFast_EngStrtStop|A|();|SCH.2|ENGSTRTSTOP|1|V02 NT 08 05182||||0|0|0|0|Moniteur rapide pour la fonction EngSt
EngSt_SdlFast_OscDet|B|();|SCH.2|OSCDET|1|V02 NT 12 00679||||0|0|0|0|Moniteur rapide de la fonction démarreur
EngSt_SdlFast_TiEngStop|B|();|SCH.8|TIENGSTOP|1|PTS_DOC_5329313||||0|0|0|0|Moniteur rapide pour la fonction EngSt|
EngSt_SdlFast_VehSt|A|();|SCH.2|VEHST|1|PTS_DOC_5404370||||0|0|0|0|Focntion d'accroche au moniteur EngSt_SdlFast_VehSt|
EngSt_SdlMid_CmdDiagStrtr|A|();|SCH2.4|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Recurence du diagnostic électrique du DML.
EngSt_SdlMid_EngStab|A|();|SCH.2|ENGSTAB|1|V02 NT 09 03216||||0|0|0|0|Moniteur moyen de la fonction EngSt.
EngSt_SdlMid_TiEngStop|D|();|SCH.2|TIENGSTOP|1|PTS_DOC_5329313||||0|0|0|0|Moniteur moyen pour la fonction EngSt.|
EngSt_SdlMid_VehSt|B|();|SCH.3|VEHST|1|PTS_DOC_5404370||||0|0|0|0|Focntion d'accroche au moniteur EngSt_SdlMid_VehSt|
EngSt_SdlSlow_EngStrtStop|A|();|SCH.9|ENGSTRTSTOP|1|V02 NT 08 05182||||0|0|0|0|Moniteur lent pour la fonction EngSt.
EngSt_SdlSlow_EngStrtStopIf|C|();|SCH14.9|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur lent pour la fonction EngSt.|
EngSt_SdlSlow_TiEngStop|D|();|SCH.4|TIENGSTOP|1|PTS_DOC_5329313||||0|0|0|0|Moniteur lent pour la fonction EngSt|
ENGSTAB_vidCalcEngineStabilised|A|();|FCT1.2|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Fonction qui gère l’ensemble de la stratégie en fonction des conditions véhicule.
ENGSTAB_vidCheckEngineLoadStable|A|();|FCT1.5|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|La variable Engine_load_not_stable passe à 0 si au bout du temps Engine_load_e_s_window_c la variable Engine_load n’a pas dépassé la valeur précédente +- Engine_load_e_s_limit_c.
ENGSTAB_vidCheckGearEngagedStab|A|();|FCT1.8|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Fonction permettant la mise de la variable Gear_engaged_not_stable à 0 si au bout du temps Gear_engaged_e_s_window_c, la variable Gear_engaged n’a pas évolué.
ENGSTAB_vidEngCondTimer|A|();|FCT2.4|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Fonction renfermant un compteur décroissant. EngStab_SampleTiMid_SC représente la période d’appel de la tache.
ENGSTAB_vidEngCondTimerOut|A|();|FCT2.5|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Fonction de mise à 1 du booléen Engine_stabilised, si le délai Engine_stable_t_d_c est écoulé.
ENGSTAB_vidEngineConditions|B|();|FCT2.1|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Cette fonction détermine la stabitilité du moteur : Si une seule de ces conditions est validée alors cela signifie que le moteur n’est pas stable.
ENGSTAB_vidEngineCondNotStable|A|();|FCT2.2|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Fonction permettant la mise à 0 des conditions de stabilité du moteur et le rebouclage pour un fonctionnement autonome du test des conditions de stabilité.
ENGSTAB_vidEngineCondStable|A|();|FCT2.3|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Si au bout de la durée Engine_stable_delay_c les conditions de stabilité sont toujours validées, le booléen Engine_stabilised passe à 1.
ENGSTAB_vidEngLoadTimer|A|();|FCT1.6|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Cette fonction représente un compteur décroissant. EngStab_SampleTiMid_SC représente la période d’appel de la tache.
ENGSTAB_vidEngLoadTimerOut|A|();|FCT1.7|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Fonction qui permet la mise à 0 de la variable Engine_load_not_stable dans le cas où le compteur est nul et la variable Engine_load est comprise dans l’intervalle Engine_load_last +- Engine_load_e_s_limit_c.
ENGSTAB_vidGearEngagedTimer|A|();|FCT1.9|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Fonction représentant un compteur décroissant. EngStab_SampleTiMid_SC représente la période d’appel de la tache.
ENGSTAB_vidGearEngagedTimerOut|A|();|FCT1.10|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Fonction permettant la mise de booléen gear_engaged_not_stable à 0, si au bout du temps Gear_engaged_e_s_window_c la variable Gear_engaged n’a pas évolué.
ENGSTAB_vidInitEngineStabilised|A|();|FCT1.1|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Fonction qui permet la réinitialisation des variables internes la à chaque reset du calculateur.
ENGSTAB_vidVehicleNotRunning|A|();|FCT2.6|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Lorsque les conditions qui permettent de juger la stabilité du moteur ne sont pas remplies, on recopie les variables Engine_load et Gear_engaged dans des plages mémoire qui permettront ensuite de suivre leur évolution.
ENGSTAB_vidVehicleRunning|A|();|FCT1.4|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Les conditions de traitement de la variable Engine_stabilised sont remplies, les sous systèmes Check_gear_engaged_stable et Check_engine_load_stable traitent les informations issues des variables Gear_engaged et Engine_load.
ENGSTAB_vidVehicleRunningCond|A|();|FCT1.3|ENGSTAB|0|V02 NT 09 03216||||0|0|0|0|Fonction qui détermine l'état RUNNING du véhicule
ENGSTOUTPIDC_vidDiagOutput|B|();|FCT1.3|ENGSTOUTPIDC|0|PTS_DOC_6528229||||0|0|0|0|En cas de défaut sur la batterie, la détection des défauts électriques est inhibée ; dans le  cas d'un défaut sur les alimentations capteurs, la détection de défaut est inhibée sur le groupe de capteurs alimenté par l'alimentation en défaut.
ENGSTOUTPIDC_vidElectricDiag|B|();|FCT1.4|ENGSTOUTPIDC|0|PTS_DOC_6528229||||0|0|0|0|fonction de diagnostic électrique.
ENGSTOUTPIDC_vidEngineRunningInfo|B|();|FCT1.2|ENGSTOUTPIDC|0|PTS_DOC_6528229||||0|0|0|0|Moteur tournant : Info_MotTournant=1; Moteur à l'arrêt : Info_MotTournant=0
ENGSTOUTPIDC_vidInit|B|();|FCT1.1|ENGSTOUTPIDC|0|PTS_DOC_6528229||||0|0|0|0|Initialisation du variable Info_moteur_tournant
ENGSTRTSTOP_vidCmdCranking|E|();|FCT1.6|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|La commande démarreur est attribuée à la même fréquence d’appel que la fonction DAGMP.(StaCtl_bStaReq=0 : Interdiction de démarrer, StaCtl_bStaReq=1 : Autorisation de démarrer.)
ENGSTRTSTOP_vidComputeCrankRetry|D|();|FCT2.4|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonction qui indique le redémarrage (le moteur a déjà été entraîné).
ENGSTRTSTOP_vidControlAutoInj|D|();|FCT1.8|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Lorsqu'une demande d'arrêt moteur par la BSI est reçue, on doit lui renvoyer l'état du moteur égal à coupé ou calé, alors elle peut désactiver sa demande d'arrêt,
ENGSTRTSTOP_vidEnaTransitToCrank|B|();|FCT2.9|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonction qui permet de tourner le moteur
ENGSTRTSTOP_vidEngStateDmlCalc|E|();|FCT1.5|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonction qui définit un compteur d’incrémentation réalisé à chaque démarrage moteur.
ENGSTRTSTOP_vidEngStopCond|C|();|FCT1.3|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Cette fonction définit si l’arrêt moteur est dû à une coupure clef après un calage
ENGSTRTSTOP_vidEveStallRunning|G|();|FCT1.9|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonction qui permet de calculer Cranking_retry lors du passage de l'état stall vers running.
ENGSTRTSTOP_vidFirstCrank|B|();|FCT2.6|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonction qui fait appel à ENGSTRTSTOP_vidMajFirstCrank.
ENGSTRTSTOP_vidInitAutoInjStlCrk|C|();|FCT1.7|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|L'injection n'est autorisée qu'à la transition "cale_tournant" et jusqu'à une demande d'arrêt moteur ou une coupure du réveil principal.
ENGSTRTSTOP_vidInitialization|C|();|FCT1.1|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonctions d'nitialisation des sorties
ENGSTRTSTOP_vidInitOutput|E|();|FCT1.2|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Initialisation des sorties
ENGSTRTSTOP_vidKeyOffOn|B|();|FCT2.2|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonction qui indique le calage du moteur.
ENGSTRTSTOP_vidKeyOnOff|B|();|FCT2.8|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonction qui indique le calage du moteur.
ENGSTRTSTOP_vidKeyStopCond|C|();|FCT1.4|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Le booléen Arret_moteur_clef indique si l’arrêt moteur est dû à une demande d'arrêt moteur par la BSI (TRUE) ou bien à un calage (FALSE).
ENGSTRTSTOP_vidMajFirstCrank|B|();|FCT2.7|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonction qui indique le tout premier démarrage sauvegardé en eeprom.
ENGSTRTSTOP_vidMemrTransStEng|A|();|FCT2.10|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|fonction déterminant la valeur de mémorisation de la transition de CoPTSt_stEng vers Engine_Running
ENGSTRTSTOP_vidStallRunning|C|();|FCT2.5|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonction qui permet de passer à l'état running.
ENGSTRTSTOP_vidTransEngine|C|();|FCT2.1|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonction qui permet de redémarrer le moteur.
ENGSTRTSTOP_vidTransToCranking|C|();|FCT2.3|ENGSTRTSTOP|0|V02 NT 08 05182||||0|0|0|0|Fonction qui permet de tourner le moteur.
ExM_SdlFast_ExOfs|A|();|SCH.2|VVTSPLIMCORD|1|V02 NT 11 02903||||0|0|0|0|Fonction d'accroche au moniteur 10ms|
ExM_SdlFast_InterfExMSC|E|();|SCH.4|INTERFACAGE_BA_SC|1|V02 NT 10 07792||||0|0|0|0|Scheduleur rapide de l'interfaçage du module ExM|
Ext_EveRst_AcqAdc|A|();|SCH1.1|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Event reset
Ext_EveRst_AcqCmdDio|A|();|SCH1.6|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evènement d'initialisation.
Ext_EveRst_AcqDgoHaL|A|();|SCH.1|ACQDGOHAL_DT|1|PTS_DOC_6854092||||0|0|0|0|Event reset|
Ext_EveRst_AcqPwd|A|();|SCH.1|ACQPWD|1|PTS_DOC_6717056||||0|0|0|0|Evénement reset du calculateur.
Ext_EveRst_CmdPwm|A|();|SCH.6|CMDPWM|1|PTS_DOC_6669891||||0|0|0|0|Evénement reset de CmdPwm
Ext_EveRst_OutPutCmdDiag|A|();|SCH1.1|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Evènement Reset du calculateur
Ext_getBInhCdtSpdVehImmo|B|(argin boolean *Immo_bInhCdtSpdVehImmo);|FCT4.6|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Invalid vehicle speed information acquisition function sent by the GAR.|
Ext_getBInhConf|B|(argin boolean *Immo_bInhConf);|FCT1.15|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Function of inhibition of the procedure of confirmation.|
Ext_getBUnlockAutho|B|(argin boolean *Immo_bUnlockAutho);|FCT1.13|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Function of inhibition of the unlock procedure and the automatic pairring|
Ext_getBUnlockReq|B|(argin boolean *Immo_bUnlockReq, argin boolean *Immo_bMainECUWakeUp);|FCT1.12|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Immobiliser life situation acquisition function|
Ext_getImmoCodProg|C|(argin uint32 *Ext_noImmoCod, argin uint8 *Ext_stCANMatchOpt, argin uint16 *Ext_stProgImmo, argin uint8 *Ext_stReadImmo);|FCT1.8|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Function called by IMMO to get state of data stored in SA module.|
Ext_getNInputImmo|B|(argin uint16 *Immo_nInput);|FCT1.14|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Engine speed acquisition function.|
Ext_getRandomUInt32|B|(argin uint32 *Ext_noUInt32Random);|FCT1.9|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Get a random data on 4 bytes.|
Ext_getSpdVehImmo|B|(argin uint8 *Immo_spdVeh);|FCT1.11|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Vehicle speed acquisition function|
Ext_getStLockECU|B|(argin uint8 *Ext_stLockECU);|FCT1.4|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Function which allow module to get the value of the ECUlock state store in the SAIMMO. If the state is not "LOCK" or "UNLOCK", we return the "INVALID" state.|
Ext_sendBLockECUCANImmo|B|(argin boolean Immo_bLockECUCAN);|FCT2.3|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Request to send the ECU lock State on the CAN network.|
Ext_sendNegAnswImmo|B|(argin uint8 Immo_stNegAnswSrv, argin uint8 Immo_noNegAnswCod);|FCT3.7|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|interface function called by IMMO. Used to send a negative answer for a UDS request.|
Ext_sendNoSeedImmo|B|(argin uint32 Immo_noSeed, argin uint8 Immo_stCANEmiTyp);|FCT2.4|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Request to send the seed on the CAN Network. The type of  send could be : stop transmission, send one frame or send  periodical.|
Ext_sendPosAnswImmoReadSt|B|(argin uint8 Immo_stLockECUReadSt, argin uint8 Immo_stProgImmoReadSt, argin uint8 Immo_bfImmoReadStDft, argin uint8 Immo_stCANMatchOptReadSt);|FCT3.5|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0||
Ext_sendPosAnswRCImmo|B|(argin uint8 Immo_noRC, argin uint8 Immo_stRCSrv1, argin uint8 Immo_stRCSrv2);|FCT3.6|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0||
Ext_setBDgoImmoCodNotRead|B|(argin boolean bLocalImmo_bDgoImmoCodNotRead, argin boolean Immo_bMonRunImmoCodNotRead);|FCT4.5|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Demande d’envoi du défaut « Lecture du Code ADC impossible » au gestionnaire de diagnostic simplifié.|
Ext_setBDgoNoAnswCtlUnit|B|(argin boolean bLocalImmo_bDgoNoAnswCtlUnit, argin boolean Immo_bMonRunNoAnswCtlUnit);|FCT4.3|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Demande d’envoi du défaut « Absence de réponse UCx » au gestionnaire de diagnostic simplifié.|
Ext_setBDgoWrgAnswCtlUnit|B|(argin boolean bLocalImmo_bDgoWrgAnswCtlUnit, argin boolean Immo_bMonRunWrgAnswCtlUnit);|FCT4.4|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Demande d’envoi du défaut « Réponse UCx incorrecte » au gestionnaire de diagnostic simplifié|
Ext_setBECUAwakeImmoNeed|B|(argin boolean bEcuAwakeImmoNeed);|FCT1.10|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Function called by IMMO to alert the S.A. of the new power latch need for the ADC function.|
Ext_setImmoCod|B|(argin uint32 Immo_noImmoCodWr, argin uint8 Immo_stCANMatchOptWr);|FCT1.6|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Function called by module IMMO to write in SA the ADC type and code. The data are stored in EEPROM and the SA should return the writing status in EEPROM to IMMO with a perioical function.|
Ext_setImmoProg|C|(argin uint16 Immo_stProgImmoWr);|FCT1.7|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Function called by IMMO to update the Programmation state stored in SA (in no volatil memory).|
Ext_setStCANOptImmoEve|B|(argin uint8 Immo_stCANOptEve);|FCT4.1|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Indicate to the SA the new ADC CAN option.|
Ext_setStLockECU|B|(argin uint8 Immo_stLockECU);|FCT1.5|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|function used by the IMMO module to set the ECU lock state memorized in SAIMMO. The state is duplicate on 2 data.|
Ext_setStMatchProgImmoEve|B|();|FCT4.2|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Indicate to SA if the UCM is paired or not.|
Far_EveCrTR_FarSpMgr|A|();|SCH.3|FAR_FARSPMGRONOFF|1|V02 NT 08 05510||||0|0|0|0|Evénement CRANKING vers RUNNING.|
Far_EveNTFL_FarSpMgr|A|();|SCH.4|FAR_FARSPMGRONOFF|1|V02 NT 08 05510||||0|0|0|0|Transition ERUN_NORMAL_RUNNING vers ERUN_FULL_LOAD.|
Far_EveRst_IfFar|A|();|SCH.1|IFFAR|1|V02 NT 12 01358||||0|0|0|0|Evénement reset interfacage du Far|
Far_EveTOSR_FarSpMgr|A|();|SCH.5|FAR_FARSPMGRONOFF|1|V02 NT 08 05510||||0|0|0|0|Entrée en ERUN_ENGINE_OVERRUN_FCO ou ERUN_ENGINE_OVERSPEED_FCO.|
FAR_FARSPMGRONOFF_ChoixTypInj|A|();|FCT1.6|FAR_FARSPMGRONOFF|0|V02 NT 08 05510||||0|0|0|0| Dans le cas de moteur avec système d’injection directe de carburant, la consigne de richesse de combustion (à  réaliser dans les cylindres comme l’objectif de richesse pleine charge) est différentiée de la consigne de richesse.|
FAR_FARSPMGRONOFF_vidCalcObjRich|E|();|FCT1.3|FAR_FARSPMGRONOFF|0|V02 NT 08 05510||||0|0|0|0|fonction qui détermine :Objectif de richesse en régulation de richesse , Objectif de richesse global.|
FAR_FARSPMGRONOFF_vidCaObjREnReg|F|();|FCT1.5|FAR_FARSPMGRONOFF|0|V02 NT 08 05510||||0|0|0|0|Fonctio qui calcule Obj_rich_en_regulation_richesse.|
FAR_FARSPMGRONOFF_vidEntryInit|A|();|SCH.1|FAR_FARSPMGRONOFF|1|V02 NT 08 05510||||0|0|0|0|Fonction d'accroche au moniteur Reset.|
FAR_FARSPMGRONOFF_vidInitOutput|B|();|FCT1.1|FAR_FARSPMGRONOFF|0|V02 NT 08 05510||||0|0|0|0|Fonction f'initialisation des sorties.|
FAR_FARSPMGRONOFF_vidObjRchGlBrt|A|();|FCT1.4|FAR_FARSPMGRONOFF|0|V02 NT 08 05510||||0|0|0|0|L’enrichissement au réattelage est positif. Il est  donc impératif de cartographier  Afr_target_reinst_aps_corr_map, Afr_target_reinst_init_corr_map et Afr_target_reinst_init_a_s_map en positif,  pour pouvoir enrichir.|
FAR_FARSPMGRONOFF_vidObjRiGlobal|B|();|FCT1.2|FAR_FARSPMGRONOFF|0|V02 NT 08 05510||||0|0|0|0|Fonction qui gére les appels des autres.|
Far_SdlFast_FarSpMgr|A|();|SCH.2|FAR_FARSPMGRONOFF|1|V02 NT 08 05510||||0|0|0|0|Moniteur rapide de la fonction objectif de richesse pour le groupe injection.|
FarSp_EveRst_ActrTstFarSp|D|();|SCH.1|ACTRTSTFARSP|1|PTS_DOC_5066987||||0|0|0|0|Evenement reset du calculateur|
FarSp_SdlFast_ActrTstFarSp|D|();|SCH.2|ACTRTSTFARSP|1|PTS_DOC_5066987||||0|0|0|0|Moniteur rapide de la fonction objectif de richesse pour le test actionneur|
FARSTRAMON_vidAuthdiagEGR|C|();|FCT1.3|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Fonction qui permet de calibrer Gsm_egr_relative_pos_hi_thresh et Gsm_egr_relative_pos_low_thresh afin que l'ouverture résiduelle tolérée de l'EGR ait un effet négligeable sur les différents diagnostics.|
FARSTRAMON_vidEGREffect|C|();|FCT1.10|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|La vanne EGR doit être fermée : pendant que l’IAE est active ou pendant une demande d’autorisation du diagnostic de surveillance de lambda feedback|
FARSTRAMON_vidEnableManagement|F|();|FCT2.1|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Fonction qui gere les Les requêtes des diagnostics  et d’adaptation d’air/essence. Il sont gérées par priorité à condition qu’il n’y ait plus d’effets issus  de la purge canister, d’EGR ou d’apprentissage de taux d’alcool( FlexFuel)..|
FARSTRAMON_vidFiltration|C|();|FCT1.2|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Pour éviter une bagotage dans les  inhibitions du aux ratés de combustion, le booléen Mf_emiss_det_fail_uavb0 , qui indique la détection des ratés de combustion OBD, est filtré par un filtre anti-rebond  sur les rebonds de 1 à 0.|
FARSTRAMON_vidInhCstrTranGasMod|B|();|FCT1.6|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Cette fonction spécifie la demande d’inhibition de la purge canister sur les transitions Gaz-Essence.|
FARSTRAMON_vidIninTmrEnaPurgEng|C|();|FCT2.2|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Cette fonction initialise le delai d'autorisation de la purge canister sur démarrage/redémarrage.|
FARSTRAMON_vidInitOutput|E|();|FCT1.1|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Fonction d'initialisation des variables de sorties et des d'états d'automates.|
FARSTRAMON_vidMngClsPurge|F|();|FCT1.9|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Cette fonction gère la fermeture de la vanne purge.|
FARSTRAMON_vidPurgCloseNoTurbMod|B|();|FCT1.8|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Cette fonction spécifie les requêtes de fermeture immédiate et progressive de la purge canister d’un moteur atmosphérique.|
FARSTRAMON_vidPurgeCloseTurbMod|B|();|FCT1.7|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Cette fonction spécifie les requêtes de fermeture immédiate et progressive de la purge canister d’un moteur suralimenté.|
FARSTRAMON_vidPurgeTurbGasMod|B|();|FCT1.5|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Cette fonction identifie le mode de demande de fermeture de la purge.|
FARSTRAMON_vidReqClsPurg|B|();|FCT1.4|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Cette fonction est le manager de stratégie demande la fermeture de la purge au gestionnaire.|
FARSTRAMON_vidTmrEnaPurgEng|C|();|FCT2.3|FARSTRAMON|0|PTS_DOC_5147156||||0|0|0|0|Cette fonction calcule le delai d'autorisation de la purge canister sur démarrage/redémarrage|
FCTDIAGDMPVLV_vidCntDiagStuckCls|B|();|FCT1.9|FCTDIAGDMPVLV|0|PTS_DOC_5068534||||0|0|0|0|This function allows the counter to increase by one at every oscillation detection flag’s rising edge.|
FCTDIAGDMPVLV_vidCondStuckCls|B|();|FCT1.7|FCTDIAGDMPVLV|0|PTS_DOC_5068534||||0|0|0|0|This function calculates  the stuck closed Dump Valve diagnosis activation flag.|
FCTDIAGDMPVLV_vidCondStuckOp|C|();|FCT1.4|FCTDIAGDMPVLV|0|PTS_DOC_5068534||||0|0|0|0|This function calculates  the stuck open Dump Valve diagnosis activation flag.|
FCTDIAGDMPVLV_vidDetOscStuckCls|B|();|FCT1.8|FCTDIAGDMPVLV|0|PTS_DOC_5068534||||0|0|0|0|This function detects and counts the super charging pressure oscillations while the stuck closed Dump Valve.|
FCTDIAGDMPVLV_vidDiagStuckOp|D|();|FCT1.5|FCTDIAGDMPVLV|0|PTS_DOC_5068534||||0|0|0|0|This function calculates the stuck open Dump Valve diagnosis result.|
FCTDIAGDMPVLV_vidDmpVlv_Op|C|();|FCT1.3|FCTDIAGDMPVLV|0|PTS_DOC_5068534||||0|0|0|0|This function allows the calculation of the stuck open Dump Valve diagnosis activation flag and the calculation of the stuck open Dump Valve diagnosis result.|
FCTDIAGDMPVLV_vidDmpVlvCls|B|();|FCT1.6|FCTDIAGDMPVLV|0|PTS_DOC_5068534||||0|0|0|0|This function allows the calculation of theStuck closed Dump Valve diagnosis  activation flag and the calculation of the stuck closed Dump Valve diagnosis result.|
FCTDIAGDMPVLV_vidInit|B|();|FCT1.2|FCTDIAGDMPVLV|0|PTS_DOC_5068534||||0|0|0|0|The diagnosis outputs are initialized at the ECU reset event.|
FCTDIAGDMPVLV_vidInitOutput|B|();|FCT1.1|FCTDIAGDMPVLV|0|PTS_DOC_5068534||||0|0|0|0|Output initialization function.|
FCTDIAGTRBPRES_vidCdEnaHiTrbPre|C|();|FCT1.4|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Conditions d’activation du diagnostic de détection d’une pression de  suralimentation excessive de X mBar .|
FCTDIAGTRBPRES_vidCdnCohTrbPrId|D|();|FCT1.8|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Conditions d’activation du diagnostic de pression de suralimentation  incohérente au ralenti.|
FCTDIAGTRBPRES_vidCdnEnaLoTrbPre|F|();|FCT1.6|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Conditions d’activation du diagnostic de détection d’une pression de  suralimentation trop faible de X mBar .|
FCTDIAGTRBPRES_vidCdnNegTrbPres|D|();|FCT2.2|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Conditions d’activation du diagnostic dérive positive du capteur de pression de  suralimentation.|
FCTDIAGTRBPRES_vidCdnPosTrbPres|C|();|FCT2.4|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Conditions d’activation du diagnostic dérive négative du capteur de pression  de suralimentation|
FCTDIAGTRBPRES_vidCohTrbPresBst|C|();|FCT2.1|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Détection de la pression de suralimentation incohérente en zone sural.|
FCTDIAGTRBPRES_vidCohTrbPresIdl|C|();|FCT1.9|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Détection de la pression de suralimentation incohérente au ralenti .|
FCTDIAGTRBPRES_vidDgCntTrbSenAcv|A|();|FCT2.7|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Cette fonction permet de déterminer le défaut pression sural maxi|
FCTDIAGTRBPRES_vidDiagCntTrbPres|A|();|FCT2.6|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Détection de la pression de suralimentation maxi|
FCTDIAGTRBPRES_vidDiagTrbPres|C|();|FCT1.3|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Diagnostic fonctionnel de la pression de suralimentation|
FCTDIAGTRBPRES_vidDiagTrbPrsinit|C|();|FCT1.2|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|initialisation des variables internes.|
FCTDIAGTRBPRES_vidEnaCohTrbPsBst|E|();|FCT1.10|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Conditions d’activation du diagnostic de pression de suralimentation  incohérente en zone sural.|
FCTDIAGTRBPRES_vidHiTrbPres|C|();|FCT1.5|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Détection de la pression de suralimentation excessive.|
FCTDIAGTRBPRES_vidInitOutput|D|();|FCT1.1|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Initialisation des outputs|
FCTDIAGTRBPRES_vidLoTrbPres|C|();|FCT1.7|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Détection de la pression de suralimentation trop faible.|
FCTDIAGTRBPRES_vidNegTrbPres|C|();|FCT2.3|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Détection d'une dérive positive du capteur de pression de suralimentation .|
FCTDIAGTRBPRES_vidPosTrbPres|C|();|FCT2.5|FCTDIAGTRBPRES|0|PTS_DOC_5198884||||0|0|0|0|Détection d'une dérive négative du capteur de pression de suralimentation|
FCTDIAGWG_vidAcvActStuckCls|B|();|FCT1.5|FCTDIAGWG|0|PTS_DOC_5070705||||0|0|0|0|The stuck closed Waste gate suspicion test|
FCTDIAGWG_vidAcvActStuckOp|C|();|FCT1.8|FCTDIAGWG|0|PTS_DOC_5070705||||0|0|0|0|The stuck open Waste gate suspicion test is continuous on piece|
FCTDIAGWG_vidClcpUsThrNat|C|();|FCT1.9|FCTDIAGWG|0|PTS_DOC_5070705||||0|0|0|0|Calculation of the natural boost pressure|
FCTDIAGWG_vidCls_pTrbAct|C|();|FCT1.3|FCTDIAGWG|0|PTS_DOC_5070705||||0|0|0|0|The stuck closed Waste gate suspicion test is continuous on piece.|
FCTDIAGWG_vidInit|C|();|FCT1.2|FCTDIAGWG|0|PTS_DOC_5070705||||0|0|0|0|This function is in charge of the initialization of the variables on the ECU reset (Wg_EveRst_FctDiagWg)|
FCTDIAGWG_vidInitOutput|C|();|FCT1.1|FCTDIAGWG|0|PTS_DOC_5070705||||0|0|0|0|Initialisation des sorties|
FCTDIAGWG_vidOp_pTrbAct|C|();|FCT1.6|FCTDIAGWG|0|PTS_DOC_5070705||||0|0|0|0|The stuck open Waste gate suspicion test|
FCTDIAGWG_vidPTrb_ActStuckOp|C|();|FCT1.7|FCTDIAGWG|0|PTS_DOC_5070705||||0|0|0|0|This function is in charge of the Diagnosis result fot the stuck open Waste Gate suspicion.|
FCTDIAGWG_vidStuckCls_pTrbAct|C|();|FCT1.4|FCTDIAGWG|0|PTS_DOC_5070705||||0|0|0|0|this function is in charge of the diagnosis result for the stuck closed Waste Gate suspicion.|
FFGEN_vidConstructionFrf|B|();|FCT1.2|FFGEN|0|V02 NT 10 01258||||0|0|0|0|La fonction de construction du freeze frame.|
FFGEN_vidEntryInit|B|();|SCH.1|FFGEN|1|V02 NT 10 01258||||0|0|0|0|L'évènement d'initialisation du module FFGEN.|
FFGEN_vidInitOutput|A|();|FCT1.1|FFGEN|0|V02 NT 10 01258||||0|0|0|0|La fonction d' initialisation des entrées.|
Fim_DemInit|A|();|API.3|FRM|1|PTS_DOC_5447824|PTS_DOC_5447829|||0|0|0|0|This service re-initializes the GAR.
Fim_DemTriggerOnEventStatus|B|(argin uint16 u16DftIdx, argin uint8 u8StatusOld, argin uint8 u8Status);|API.3|FRM|1|PTS_DOC_5447829|PTS_DOC_5447824|||0|0|0|0|Update the GAR upon changes of the event status
Fim_DemTriggerOnEventStatus_opt|A|(argin uint16 u16DftIdx, argin uint8 u8StatusOld, argin uint8 u8Status);|23|HEADER|1|NONE||||0|0|0|0||
Fim_GetFunctionPermission|B|func_GetFunctionPermission|API.4|FRM|1|PTS_DOC_5447829|PTS_DOC_5447824|||0|0|0|0|This function reports the permission state to the functionality
Fim_Init|C|();|SCH.1|FRM|1|PTS_DOC_5447829|PTS_DOC_5447824|||0|0|0|0|
Fin_DemInit|A|();|20|HEADER|1|NONE||||0|0|0|0||
Fisa_EveInit|A|();|SCH.1|FISARFUDET|1|V02 NT 08 07467||||0|0|0|0|Evénement init
Fisa_EveKOn_FisaRFuDet|C|();|SCH.2|FISARFUDET|1|V02 NT 08 07467||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON
Fisa_EvePwrl_ClcnFisaGain|D|();|SCH.4|CLCNFISAGAIN|1|V02 NT 08 04650||||0|0|0|0|Evènement power latch
Fisa_EveRTSt_FisaRFuDet|C|();|SCH.1|FISARFUDET|1|V02 NT 08 07467||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant
Fisa_EveStTR_ClcnFisaGain|C|();|SCH.2|CLCNFISAGAIN|1|V02 NT 08 04650||||0|0|0|0|Evénement correspondant au passage à 1 de la  variable Moteur_tournant
Fisa_EveTDC_ClcnFisaGain|C|();|SCH.3|CLCNFISAGAIN|1|V02 NT 08 04650||||0|0|0|0|Evènement interruption PMH
Fisa_EveTDC_FisaInhMgr|A|();|SCH.3|FISAINHMGR|1|V02 NT 09 00158||||0|0|0|0|Evènement interruption PMH .
Fisa_EveTDC_FisaRFuDet|C|();|SCH.3|FISARFUDET|1|V02 NT 08 07467||||0|0|0|0|Interruption PMH
Fisa_SdlMid_FisaInhMgr|A|();|SCH.2|FISAINHMGR|1|V02 NT 09 00158||||0|0|0|0|Moniteur medium pour la fonction FISA .
FISAINHMGR_vidCrankingState|B|();|FCT1.3|FISAINHMGR|0|V02 NT 09 00158||||0|0|0|0|Au démarrage , si le regime moteur est inférieure au seuil d'inhibition FISA ou  si le seuil maximal pour le gradient de tension batterie est dépassé ou bien le demarrage à la poussette est  détecté .Il y'aura détection d'un état cranking.
FISAINHMGR_vidEntryInit|A|();|SCH.1|FISAINHMGR|1|V02 NT 09 00158||||0|0|0|0|Fonction d'accroche sur l'évent FISAINHMGR_vidEntryInit.
FISAINHMGR_vidFisaCaseDetermin|A|();|FCT1.2|FISAINHMGR|0|V02 NT 09 00158||||0|0|0|0|Ce bloc permet de déterminer des cas de vie spécifique aux besoins de reconfiguration pour la fonction FISA .
FISAINHMGR_vidFisaLearningInhib|A|();|FCT1.5|FISAINHMGR|0|V02 NT 09 00158||||0|0|0|0|cette fonction permet de déterminer la démande d'inhibition du FISA via le booléen FISA_bInhFISA.
FISAINHMGR_vidInhibObservInst|A|();|FCT1.8|FISAINHMGR|0|V02 NT 09 00158||||0|0|0|0|cette fonction permet de déterminer la demande d’inhibition de l’observation des instabilités.
FISAINHMGR_vidInitOutput|A|();|FCT1.1|FISAINHMGR|0|V02 NT 09 00158||||0|0|0|0|Fonction d'initialisation des sorties.
FISAINHMGR_vidMoveModeRefugeLean|A|();|FCT1.6|FISAINHMGR|0|V02 NT 09 00158||||0|0|0|0|La demande de passage en mode FISA pauvre via le booléen FISA_bPoor a lieu dans les cas suivants : FRM_bAcvFISAPoor à 1
FISAINHMGR_vidMoveModeRefugeRich|A|();|FCT1.7|FISAINHMGR|0|V02 NT 09 00158||||0|0|0|0|La demande de passage en mode FISA riche via le booléen FISA_bRich a lieu dans les cas suivants : FRM_bAcvFISARich à 1
FISAINHMGR_vidReconfigManagement|A|();|FCT1.4|FISAINHMGR|0|V02 NT 09 00158||||0|0|0|0|Cette fonction permet de considérer tous les modes de défaillances et cas de vie particuliers impactant la  stratégie d’adaptation de l’injection au démarrage.
FISARFUDET_vidArretMoteur|A|();|FCT1.2|FISARFUDET|0|V02 NT 08 07467||||0|0|0|0|cette fonction permet de retourner le volume carburant à la coupure moteur
FISARFUDET_vidCalcCoefLissage|A|();|FCT1.7|FISARFUDET|0|V02 NT 08 07467||||0|0|0|0|remise à jour à chaque détection de remplissage carburant de la valeur  de reset du coefficient de qualité carburant
FISARFUDET_vidCalcConsoDepRempl|A|();|FCT1.8|FISARFUDET|0|V02 NT 08 07467||||0|0|0|0|Cette fonction  permet l’évaluation du volume d'essence consommée sans prendre en compte la purge canister à 80  mm3 près .
FISARFUDET_vidCalculDelta|A|();|FCT1.4|FISARFUDET|0|V02 NT 08 07467||||0|0|0|0|cette fonction permet de détecter le remplissage du réservoir
FISARFUDET_vidCalculValeursReset|A|();|FCT1.5|FISARFUDET|0|V02 NT 08 07467||||0|0|0|0|cette fonction permet la demande de reset après détection de plein
FISARFUDET_vidClefOn|A|();|FCT1.3|FISARFUDET|0|V02 NT 08 07467||||0|0|0|0|cette fonction permet de determiner le Volume carburant au key on
FISARFUDET_vidCndCalcCoefLissage|A|();|FCT1.6|FISARFUDET|0|V02 NT 08 07467||||0|0|0|0|cette fonction permet l'activation du bloc 1_Calcul_coefficient_lissage
FISARFUDET_vidConsomDepuisPlein|A|();|FCT1.9|FISARFUDET|0|V02 NT 08 07467||||0|0|0|0|cette fonction permet de calculer la quantité de carburant consommée depuis le remplissage du réservoir ainsi elle demande la reset après détection de plein
FISARFUDET_vidInit|B|();|FCT1.1|FISARFUDET|0|V02 NT 08 07467||||0|0|0|0|Fonction d'initialisation des variables EEPROM
FISARFUDET_vidResetCoefEffectue|A|();|FCT1.10|FISARFUDET|0|V02 NT 08 07467||||0|0|0|0|cette fonction permet de mettre à zero les informations de remplissage et de demande de reset après detection du plein
FLOWMNG_CtCoBatt|A|();|FCT6.6|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui gère le défaut déconnexion batterie.|
FLOWMNG_vidAlt_Bss_Load_Time|E|();|FCT2.5|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui traite le temps progressive de chargement de l'aternateur en fonction de la valeur de la variable ElProdMgt_stProdPrgCh|
FLOWMNG_vidAlt_Cpt_Dem_Redem|D|();|FCT1.4|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Ce bloc permet le calcul de la variable AraMth_ctStaAcv|
FLOWMNG_vidAlt_Current|D|();|FCT5.6|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui determine le courant d'exitation de l'alternateur dependament du type de l'alternateur et des types de communication BSS et LIN|
FLOWMNG_vidAlt_Duty_Cycle|D|();|FCT5.5|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui determine le duty cycle de l'aternateur dependament de son type et des types de communication BSS et LIN,|
FLOWMNG_vidAlt_ID_Supplier|D|();|FCT5.7|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui traite l'identificateur du fournisseur de l'alternateur en fonction du type de l'aternateur et des types de communication BSS et LIN|
FLOWMNG_vidAlt_Load_Time|D|();|FCT5.10|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui traite le temps de chargement progressive de l'alternateur en fonction du type de l'alternateur et des types de communication BSS et LIN,|
FLOWMNG_vidAlt_Shut_Off|D|();|FCT5.9|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui détermine la valeur de d'arrêt de l'alternateur en fonction de BSS et LIN et détermine la sortie Ext_stPrgChLINDi_nEng en fonction de la vitesse du vilbroquin|
FLOWMNG_vidAlt_Voltage|E|();|FCT5.8|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui détermine le voltage de l'alternateur en fonction des deux types de communication BSS et LIN,|
FLOWMNG_vidAltFlowMng_Init|E|();|FCT5.3|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui initialise les variables de sorties sur évenement de RESET,|
FLOWMNG_vidAltFlowMng_Processing|D|();|FCT5.4|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Cette fonction traite : Gneric Duty cycle, Generic excitation current, Generic identifier supplier, Voltage request, Shut off value dependant of crankshaft speed, Progressive load  time|
FLOWMNG_vidBrk_CAN_Info|C|();|FCT2.1|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|fonction qui traite le flux de données relatives aux freinage en fonction de la présence ou d'abscence de l 'ABS ou de l'ESP.|
FLOWMNG_vidBrkDiagBVH2P|B|();|FCT2.4|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Cette fonction met à jour l'etat du frein primaire.|
FLOWMNG_vidBrkHorsDiagBVH2P|B|();|FCT2.2|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Cette fonction met à jour l'etat du frein primaire.|
FLOWMNG_vidBrkPush|D|();|FCT1.9|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui gère les informations relatives à l'appuie sur le frein.|
FLOWMNG_vidCANSeln|F|();|FCT3.1|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Cette stratégie définit quel paramètre CAN doit être pris en compte en fonction de l’architecture du véhicule,|
FLOWMNG_vidClu|C|();|FCT1.2|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Ce bloc traite les différents cas pour les signaux d'embrayage|
FLOWMNG_vidClu2|A|();|FCT6.7|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Ce bloc 2 traite les différents cas pour les signaux d'embrayage|
FLOWMNG_vidCtInitUpDate|D|();|FCT3.7|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction contenant toutes les fonctions de mise à jour compteurs|
FLOWMNG_vidCtInitUpDate2004|C|();|FCT4.3|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui mesure le temps d'arrêt Ext_ctSecEngStop2004.|
FLOWMNG_vidDAGMP_Traction|D|();|FCT1.10|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui détermine l'état du traction en fonction du type de DAGMP et de la boite à vitesse.|
FLOWMNG_vidDay_InitUpDate|D|();|FCT4.1|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction d'initilaisation du compteur jour|
FLOWMNG_vidDay_UpDate|D|();|FCT4.8|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui met à jour le compteur des secondes|
FLOWMNG_vidDayCtMng|D|();|FCT4.4|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Cette fonction gère la sélection des flux compteur temporel ou des paramètres seconde, jour, année.|
FLOWMNG_vidDayCtMng_Calc1|B|();|FCT3.6|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui appelle les deux macro de calcule de nombre de jours et d'années|
FLOWMNG_vidDayCtMng_Calc2|C|();|FCT4.5|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction of day Contrôle Management Calculation|
FLOWMNG_vidDayCtMng_EEPROM|E|();|FCT5.1|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction sauvegardant la valeur du compteur secondes, jours et années au powerlatch|
FLOWMNG_vidDstVeh|B|();|FCT6.5|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Cette fonction permet de d'affecter le kilometrage selon la valeur de Ext_bArchiCf.|
FLOWMNG_vidEntryInit|A|();|SCH1.1|FLOWMNG|1|PTS_DOC_5068508||||0|0|0|0|Evénement reset ECU du module FLOWMNG|
FLOWMNG_vidFirst_DayCtMng|B|();|FCT3.5|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui fais incrémenter le compteur temporel à chaque récepton de la trame 552.|
FLOWMNG_vidFirstCases|B|();|FCT2.8|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|First cases of Position Gear Level|
FLOWMNG_vidFirstDayCtMngInit|B|();|FCT2.6|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction d'initialisation de la variable FlowMng_bFirstDayCtMng.|
FLOWMNG_vidGMV|B|();|FCT2.7|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui détermine la vitesse predite ou recommandée du ventilateur en fonction de la configuration de MDF.|
FLOWMNG_vidHorsDiagBVH2P_ABS|B|();|FCT2.3|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Cette fonction met à jour l'etat du frein primaire.|
FLOWMNG_vidInit_EEPROM|B|();|FCT3.4|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction d'initialisation des variables memoire à chaque connexion/deconnexion|
FLOWMNG_vidInit_InitUpDate|D|();|FCT3.8|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonctions d'initialisation des compteurs avant mise à jour|
FLOWMNG_vidInit_UpDate|E|();|FCT4.6|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui initialise le compteur du dixième de seconde d'arrêt moteur.|
FLOWMNG_vidInitOutput|D|();|FCT1.1|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction d'initialisation des variables produites par la spec.|
FLOWMNG_vidLoFuPmp|B|();|FCT6.8|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui gère la commande de la pompe à essence.|
FLOWMNG_vidOil|C|();|FCT1.7|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Function OIL|
FLOWMNG_vidOutput_GBxLev1|B|();|FCT6.2|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction de selection de la position levier lorsque Ext_stGBxCf = 1|
FLOWMNG_vidOutput_GBxLev2|B|();|FCT6.3|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction de selection de la position levier lorsque Ext_stGBxCf = 0.|
FLOWMNG_vidOutput_posnGBxLev|B|();|FCT6.1|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction de selection de la position levier.|
FLOWMNG_vidPMastervac|C|();|FCT1.3|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Ce bloc permet le calcul des variables Ext_pRelBrkAsi et Ext_pBrkAsi|
FLOWMNG_vidPosGearLev|C|();|FCT1.8|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui gère le niveau delevier de vitesse.|
FLOWMNG_vidPosGearSel|C|();|FCT1.5|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui gère le flux relativement à la position du levier du vitessse et la position du PN|
FLOWMNG_vidPosGearTempo|C|();|FCT1.6|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction de gestion du flux relativement à la position du levier de vitesse et celle du PN avec temporisation.|
FLOWMNG_vidSec_InitUpDate|G|();|FCT3.9|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction d'initialisation du compteur des secondes|
FLOWMNG_vidSec_UpDate|F|();|FCT4.7|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui let a jour le compteur des dix première millisecondes après arrêt moteur|
FLOWMNG_vidTemporisation|B|();|FCT6.4|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction de temporisation de la position levier.|
FLOWMNG_vidTExtMng|E|();|FCT3.2|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui calcule les température air extérieures traitée et venant du CAN|
FLOWMNG_vidTOilMng|E|();|FCT3.3|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Si le flux Eng_tOilEstim est produit par une fonction d'estimation alors Ext_tOil est égal  Eng_tOilEstim|
FLOWMNG_vidTqSel|C|();|FCT5.2|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui specifie la selection du flux pour le torque C2000|
FLOWMNG_vidUpDate2004|D|();|FCT4.10|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Foncton de mise à jour du compteur Ext_tiCurVeh2004|
FLOWMNG_vidYr_InitUpDate|D|();|FCT4.2|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction initilaisation compteur année|
FLOWMNG_vidYr_UpDate|D|();|FCT4.9|FLOWMNG|0|PTS_DOC_5068508||||0|0|0|0|Fonction qui met à jour les compteurs jour et année.|
FRM_vidDemInit|A|();|FCT1.2|FRM|0|PTS_DOC_5447829|PTS_DOC_5447824|||0|0|0|0|Re_initialization of FRM module.
FRM_vidF01_PrmDft_Init|C|(argin uint16 u16Index, argin uint8 u8StatusOld, argin uint8 u8Status);|FCT1.1|FRM|0|PTS_DOC_5447829|PTS_DOC_5447824|||0|0|0|0|
FRM_vidF01_PrmDft_Init_opt_suite|A|();|3|HEADER|1|NONE||||0|0|0|0||
FRM_vidF02_FidMng_F02_AcvTable|C|(argin uint16 u16LDIndex);|FCT2.1|FRM|0|PTS_DOC_5447829|PTS_DOC_5447824|||0|0|0|0|
FRM_vidF03_EnaFid_Idx_Switch|C|func_GetFunctionPermission|FCT3.1|FRM|0|PTS_DOC_5447829|PTS_DOC_5447824|||0|0|0|0|
FRM_vidInit|C|();|FCT0.1|FRM|0|PTS_DOC_5447829|PTS_DOC_5447824|||0|0|0|0|Initialization of FRM module
FRunTime_GetTimer100msU32|D|(argout uint32* CurrentTime100msPtr)Std_ReturnType;|API.10|FRT|1|PTS_DOC_6307798||||0|0|0|0|API permettant d'obtenir un Timer 100ms|
FRunTime_GetTimer100usU32|C|(argout uint32* CurrentTime100usPtr)Std_ReturnType;|API.04|FRT|1|PTS_DOC_6307798||||0|0|0|0|API permettant d'obtenir un timer de 100µs|
FRunTime_GetTimer1minU32|C|(argout uint32* CurrentTime1minPtr)Std_ReturnType;|API.03|FRT|1|PTS_DOC_6307798||||0|0|0|0|API permettant d'obtenir un Timer 1min|
FRunTime_GetTimer1msU32|D|(argout uint32* CurrentTime1msPtr)Std_ReturnType;|API.01|FRT|1|PTS_DOC_6307798||||0|0|0|0|API permettant d'obtenir un Timer 1ms|
FRunTime_GetTimer1sU32|C|(argout uint32* CurrentTime1sPtr)Std_ReturnType;|API.02|FRT|1|PTS_DOC_6307798||||0|0|0|0|API permettant d'obtenir un Timer 1S|
FRunTime_GetTimer_100ms_U32|C|(argout uint32* CurrentTime100msPtr)Std_ReturnType;|API.11|FRT|1|PTS_DOC_6307798||||0|0|0|0|API permettant d'obtenir un Timer 100ms|
FRunTime_GetTimer_100us_U32|C|(argout uint32* CurrentTime100usPtr)Std_ReturnType;|API.08|FRT|1|PTS_DOC_6307798||||0|0|0|0|API permettant d'obtenir un timer de 100µs|
FRunTime_GetTimer_1min_U32|C|(argout uint32* CurrentTime1minPtr)Std_ReturnType;|API.07|FRT|1|PTS_DOC_6307798||||0|0|0|0|API permettant d'obtenir un Timer 1min|
FRunTime_GetTimer_1ms_U32|C|(argout uint32* CurrentTime1msPtr)Std_ReturnType;|API.05|FRT|1|PTS_DOC_6307798||||0|0|0|0|API permettant d'obtenir un Timer 1ms|
FRunTime_GetTimer_1s_U32|C|(argout uint32* CurrentTime1sPtr)Std_ReturnType;|API.06|FRT|1|PTS_DOC_6307798||||0|0|0|0|API permettant d'obtenir un Timer 1S|
FRunTime_Init|D|();|SCH.01|FRT|1|PTS_DOC_6307798||||0|0|0|0|Fonction d'INIT|
FRunTime_SdlFast|D|();|SCH.04|FRT|1|PTS_DOC_6307798||||0|0|0|0|Function Fast|
FRunTime_SdlMid|D|();|SCH.02|FRT|1|PTS_DOC_6307798||||0|0|0|0|Function middle|
FRunTime_SdlSlow|D|();|SCH.03|FRT|1|PTS_DOC_6307798||||0|0|0|0|Fonction lente du FRT|
FRunTime_vidUpdate_Nb_Roll_Ov|C|();|API.09|FRT|0|PTS_DOC_6307798||||0|0|0|0|vérifie si un roll-over a eu lieu et incrémente le compteur si un roll-over est detecté"|
FTPCtl_Sdl10ms_FTPCtl|C|();|SCH.2|FTPCTL|1|PTS_DOC_5139357||||0|0|0|0|Monitor of the FTPCTL function|
FTPCTL_vidCorresponding_ratio|C|();|FCT1.4|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|The input corresponds to the necessary flow for the pump calculted into L/h.|
FTPCTL_vidEngine_need_calculus|C|();|FCT1.2|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This function aims at evaluating the real need from the engine in pump flow.|
FTPCTL_vidEntryInit|D|();|SCH.1|FTPCTL|1|PTS_DOC_5139357||||0|0|0|0|Event reset|
FTPCTL_vidEOLMemorisation|D|();|FCT2.1|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This subfunction memorizes if a first priming was done in end of line or not. It’s possible to re-activate it if needed via an aftersales’ request. It also provides first priming  done flag” for Afts tool.|
FTPCTL_vidEOLStateTimer|D|();|FCT2.2|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This subfunction memorizes the accumulated time spend in End Of Line mode in case of Key Off action while priming.  At the end of the timer this function outputs a flag. Counter is cleared when priming is done.|
FTPCTL_vidFalling_edge_filtering|D|();|FCT1.6|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This subfunction aims at avoiding rough falling edges on the flow ratio requests.|
FTPCTL_vidFlow_optimum|D|();|FCT1.3|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|The mass flow set point for the engine’s injectors corresponds to the product of the number of cylinders by the injection setpoint.|
FTPCTL_vidFlowSetpointSynthesis|C|();|FCT2.6|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This subfunction synthesizes ratio setpoints, depending on the engine state. It takes also into account the on/off pump to be generic.|
FTPCTL_vidHysteresis_filtering|D|();|FCT1.5|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This elementary function realizing an hysteresis filter of the flow ratio|
FTPCTL_vidInitOutput|E|();|FCT1.1|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|initialization function for output|
FTPCTL_vidPressHoldCaseCutStall|E|();|FCT2.3|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This stateflow manages the different life situation of the vehicle where the engine feeding of fuel shall be prepared.|
FTPCTL_vidPressHoldEngineActive|F|();|FCT2.4|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This stateflow manages the different life situations for all the engine states except cut/stall.|
FTPCTL_vidPressure_hold_in_gas|D|();|FCT2.5|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This stateflow manages the transitions to the gas fuel for vehicle that need it.  It works in case of mono or bi-fueling.|
FTPCTL_vidPriming_need|D|();|FCT1.9|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This function memorizes if a first priming was done in end of line or not. It’s possible to re-activate it if needed (for example, after a change of the component in aftersales) via an aftersales’ request.|
FTPCTL_vidRecovryModesActivation|D|();|FCT2.7|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This subfunction manages the applications of diverse recovery modes concerning the fuel pump.|
FTPCTL_vidVolt_Control_activ|E|();|FCT1.8|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This subfunction aims at compelling the pump to provide more flow in some life situations than in case of nominal feeding. To manage it, a request is sent to the alternator, so that it increases its output voltage.|
FTPCTL_vidWorking_field|D|();|FCT1.7|FTPCTL|0|PTS_DOC_5139357||||0|0|0|0|This subfunction aims at initializing pump’s sequences at the ECU’s wake up and defining the working field of the pump|
Fu_EveInj_FuCns|C|();|SCH.2|FUCNS|1|PTS_DOC_5139613||||0|0|0|0|Evènement injection pour la fonction carburant|
Fu_EveKOf_FuLvl|C|();|SCH.7|FULVL|1|PTS_DOC_5462804||||0|0|0|0|Evénement associé au passage de clef ON à clef OFF.|
Fu_EveKOn_FuLvl|C|();|SCH.2|FULVL|1|PTS_DOC_5462804||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON.|
Fu_EvePwrl_FuLvl|C|();|SCH.8|FULVL|1|PTS_DOC_5462804||||0|0|0|0|Evènement Powerlatch.|
Fu_EveRst_FuCns|D|();|SCH.1|FUCNS|1|PTS_DOC_5139613||||0|0|0|0|Evènement Reset du calculateur|
Fu_EveRst_FuLvl|C|();|SCH.1|FULVL|1|PTS_DOC_5462804||||0|0|0|0|Evènement reset du calculateur.|
Fu_EveRTSt_FuLvl|C|();|SCH.10|FULVL|1|PTS_DOC_5462804||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant.|
Fu_EveRxn412_FuLvl|C|();|SCH.4|FULVL|1|PTS_DOC_5462804||||0|0|0|0|Evènement de rception de la trame 412.|
Fu_EveRxn612_FuLvl|C|();|SCH.5|FULVL|1|PTS_DOC_5462804||||0|0|0|0|Evènement de rception de la trame 612.|
Fu_EveStTR_FuLvl|C|();|SCH.9|FULVL|1|PTS_DOC_5462804||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant.|
Fu_SdlFast_FuLvl|A|();|SCH.11|FULVL|1|PTS_DOC_5462804||||0|0|0|0|Moniteur rapide de la fonction Fu|
Fu_SdlMid_FuCns|B|();|SCH.3|FUCNS|1|PTS_DOC_5139613||||0|0|0|0|Moniteur moyen pour la fonction Fu|
Fu_SdlMid_FuLvl|B|();|SCH.3|FULVL|1|PTS_DOC_5462804||||0|0|0|0|Moniteur moyen pour la fonction Fuel.|
Fu_SdlSlow_FuLvl|C|();|SCH.6|FULVL|1|PTS_DOC_5462804||||0|0|0|0|Moniteur lent pour la fonction Fuel.|
FuAcq_EveInj_AcqAdc|A|();|SCH.4|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|Engine running indicator|
FuAcq_EveInj_PFuAcq|D|();|SCH.4|PFUACQ|1|PTS_DOC_6851391||||0|0|0|0|INJ task for the rail pressure acquisition|
FuAcq_EveRst_PFuAcq|D|();|SCH.1|PFUACQ|1|PTS_DOC_6851391||||0|0|0|0|Reset event|
FuAcq_EveSpl_AcqAdc|A|();|SCH.5|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|"Spill" event|
FuAcq_EveSpl_PFuAcq|D|();|SCH.3|PFUACQ|1|PTS_DOC_6851391||||0|0|0|0|Spill event|
FuAcq_EveSpl_PFuAcqIf|C|();|SCH16.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement "spill" pour l'acquisition de la pression rail .|
FuAcq_SdlFast_AcqAdc|A|();|SCH.6|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|Fast monitor for rail pressure acquisition|
FuAcq_SdlFast_PFuAcq|E|();|SCH.2|PFUACQ|1|PTS_DOC_6851391||||0|0|0|0|Fast monitor for rail pressure acquisition|
FuAcq_SdlFast_PFuAcqIf|D|();|SCH15.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide pour l'acquisition de la pression rail .|
FUCNS_vidActTotalInjFuelInjDir|B|();|FCT2.8|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Actualisation totale du carburant.|
FUCNS_vidCalcFuelConsBwnFrInjDir|B|();|FCT2.5|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Le coefficient "1/10 " appliqué à Cpc_fuel_mass_flow_rate permet de passer de [kg/s] à [kg/100ms]. Le coefficient "1e-9" appliqué à Rho_carburant permet de passer de [g/L] à [kg/ mm3].|
FUCNS_vidCalcFuelConsoInjDir|B|();|FCT2.6|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Lorsque Conso_carburant_can_InjDir atteint sa valeur maximale, celle-ci est réinitialisée à 0.|
FUCNS_vidCalcFuelUsedBetweenFram|E|();|FCT1.7|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Bloc de calcul de la quantité arrondie d'essence consommée|
FUCNS_vidCalcFuelUsedNotCounted|E|();|FCT1.8|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Bloc de calcul du temps d'ouverture injecteur non pris en compte dans la quantité d'essence consommée entre 2 trames|
FUCNS_vidCalcFuelUseNotCntInjDir|C|();|FCT2.4|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Le coefficient "1e-9" appliqué à Rho_carburant permet de passer de [g/L] à [kg/mm3].|
FUCNS_vidCalcInstantConsoInjDir|B|();|FCT2.7|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Le coefficient "3.6" appliqué à Vitesse_vehicule permet de passer de [km/h] à [100km/100ms] et Conso_carburant_entre_trame_InjDir de passer de [mm3] en [L].Nous obtenons ainsi, après filtrage, une consommation instantanée Conso_inst_InjDir en L/100km.|
FUCNS_vidCalcInstantUsedFuel|C|();|FCT1.10|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Bloc de calcul la consommation instantanée de carburant|
FUCNS_vidCalcPseudoConso|B|();|FCT2.2|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Clacule de la pseudo consommation.|
FUCNS_vidCalcRealConso|C|();|FCT1.5|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Ce bloc calcule la consommation horaire de carburant, la consommation de carburant depuis l'initialisation du calculateur, la consommation totale de carburant ainsi que la consommation instantanée.|
FUCNS_vidCalcTotalMassInj|C|();|FCT1.3|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Lors de chaque occurrence de l’évènement injection, on incrémente le compteur de la masse totale injectée estimée pour le calcul de la consommation carburant totale.|
FUCNS_vidCalcUsedFuel|D|();|FCT1.9|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Bloc de calcul de la consommation de carburant depuis l'initialisation du calculateur et de la consommation totale de carburant|
FUCNS_vidCalcUsedFuelPerHour|D|();|FCT1.6|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Bloc de calcul de la consommation horaire de carburant|
FUCNS_vidCalFuelUseBwnFrmeInjDir|B|();|FCT2.3|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Le coefficient "1/10 " appliqué à Cpc_fuel_mass_flow_rate permet de passer de [kg/s] à [kg/100ms]. Le coefficient "1e-9" appliqué à Rho_carburant permet de passer de [g/L] à [kg/mm3].|
FUCNS_vidDirectInjCount|C|();|FCT1.4|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Ce compteur servira à calculer la consommation instantanée en injection directe sans prendre en compte la surconsommation due à la purge du catalyseur.|
FUCNS_vidFinalInstructionCalc|E|();|FCT2.9|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Ce bloc calcule la consigne réelle finale de débit d’essence qui a été appliquée.|
FUCNS_vidInit|D|();|FCT1.2|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Bloc d'initialisation des variables appelé lors du reset|
FUCNS_vidInitOutput|E|();|FCT1.1|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Initialisation des sorties|
FUCNS_vidSendFrame|C|();|FCT2.10|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|On sélectionne ici les informations à transmettre sur le CAN en fonction de l’architecture d’injection.|
FUCNS_vidUpdatingTotalInjTime|C|();|FCT2.1|FUCNS|0|PTS_DOC_5139613||||0|0|0|0|Total_injection_time est ré-initialisée à la valeur de Fuel_used_not_counted pour la trame suivante|
FULVL_vid1BisDiagLowFuelLevel|A|();|FCT4.1|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Le flag niveau carburant mini peut être fourni par une information CAN ou par une information filaire.|
FULVL_vidCounterDec|D|();|FCT1.4|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction de décrémentation du compteur Flev_fuel_level_count.|
FULVL_vidDetectionRunningEngine|C|();|FCT3.8|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction qui permet de détecter moteur tournant.|
FULVL_vidEepromWrite|C|();|FCT1.10|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Ecriture en EEPROM du niveau carburant.|
FULVL_vidFailureInv|C|();|FCT3.2|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction qui met Fu_bDgoORng_FuGauge à 1.|
FULVL_vidFailureOc|C|();|FCT3.4|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction qui met Fu_bDgoOc_FuGauge à 1.|
FULVL_vidFailureScg|C|();|FCT3.3|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction qui met Fu_bDgoScg_FuGauge à 1.|
FULVL_vidFilteringInfoMux|C|();|FCT2.4|FULVL|0|PTS_DOC_5462804||||0|0|0|0|L’information de niveau de carburant provenant du CAN est filtrée.|
FULVL_vidFuelGaugeSt|C|();|FCT2.1|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction qui permet de donner l'Etat de la jauge à carburant(CC, CO, donnée invalide).|
FULVL_vidFuelGaugeState|C|();|FCT1.5|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction qui permet de donner l'Etat de la jauge à carburant(CC, CO, donnée invalide).|
FULVL_vidFuelIncComputeRunning|C|();|FCT3.7|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Lorsque l’information niveau carburant est disponible (Flev_fuel_level_count = 0), on détermine la détection de remplissage du réservoir par rapport au niveau de carburant mémorisé à l’initialisation du compteur de temps précédent.|
FULVL_vidFuelLevel|C|();|FCT2.3|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Cette fonction permet de filter l’information de niveau de carburant provenant du CAN et la détection d’ajout de carburant(au démarrage après un reset ou après un calage moteur ou un key on -off sans qu’il n’y ait eu reset ou moteur tournant).|
FULVL_vidFuelLevelCaleOrOff|C|();|FCT3.9|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction de calcul du niveau de carburant de référence sur événement cale tournant ou clé à OFF.|
FULVL_vidFuelLevelCompute|C|();|FCT2.5|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Si on a un défaut confirmé sur la jauge à carburant ou sur le niveau fonctionnel du carburant (FRM_bInhFuLvlClcn à 1), la valeur du niveau carburant est mise à FFh.|
FULVL_vidFuelLevelCpteCaleOrOff|D|();|FCT1.9|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Détection d’un cle on-off ou d’un calage.|
FULVL_vidFuelLevelIncComputeDem|C|();|FCT2.6|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction dui permet le calcul du niveau carburant lorsqu'on n'est pas en calage ou clé à OFF (Flev_last_stall_or_key_off != 1).|
FULVL_vidFuelLevelIncCpteDem|E|();|FCT3.5|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Lorsque l’information niveau carburant est disponible (Flev_fuel_level_count = 0), on calcule le remplissage du réservoir par rapport au dernier réveil.|
FULVL_vidFuelLevelIncRunning|C|();|FCT2.9|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction dui permet le calcul du niveau carburant sur événement RUNNING.|
FULVL_vidFuelLevelSt|D|();|FCT3.10|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Un diagnostic fonctionnel du niveau de carburant est effectué par rapport à la consommation carburant. Ce diagnostic est inhibé si un remplissage moteur tournant a été détecté.|
FULVL_vidFuelLevelState|D|();|FCT1.8|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction de gestion du défaut lié au niveau de carburant.|
FULVL_vidInitEngineRunning|C|();|FCT2.10|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction d'initialisation du niveau carburant sur événement RUNNING.|
FULVL_vidInitKeyOffOn|D|();|FCT1.3|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Sur cle off_on : le délai avant validité de l’information niveau carburant disponible sur le CAN (trame 612h) est initialisé et la consommation carburant totale est mémorisée.|
FULVL_vidInitOutputs|D|();|FCT1.1|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction d'initialisation des variables de sorties.|
FULVL_vidInitReset|E|();|FCT1.2|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction qui initialise le délai avant validité de l’information niveau carburant disponible sur CAN (trame 612h), Les compteurs de décrémentation, les indicateurs de niveau bas du réservoir estimé par le soft et qui détecte le remplissage du réservoir.|
FULVL_vidLowFuelLevelHardware|D|();|FCT1.6|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction représentant  le calcul nominal de l’information niveau bas carburant.|
FULVL_vidLowFuelLevelSoftware|D|();|FCT1.7|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Cette fonction .choisit le signal niveau carburant mini en fonction de la configuration véhicule, et lance une solution software si le capteur est défaillant.|
FULVL_vidLvlIncCaleRunning|D|();|FCT3.6|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction dui permet le calcul du niveau carburant après calage ou clé à OFF (Flev_last_stall_or_key_off = 1).|
FULVL_vidLvlIncCpeCaleRunning|C|();|FCT2.7|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction dui permet le calcul du niveau carburant s'il y a eu calage ou clé à OFF.|
FULVL_vidNoFaultMeasure|C|();|FCT3.1|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction qui met tous les indicateurs d'état jauge à 0.|
FULVL_vidRunningCounter|C|();|FCT2.8|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction de calcul du compteur tournant Flev_fuel_level_last_count.|
FULVL_vidTemporisation|G|();|FCT2.2|FULVL|0|PTS_DOC_5462804||||0|0|0|0|Fonction qui gère une temporisation (Flev_low_fuel_level_sw_tempo) correspondant au temps maximum observé sur véhicule entre l’apparition d’un défaut du système d’alimentation en carburant ou un manque de carburant dans le réservoir et le calage du moteur|
FuPmp_EveKOn_Mng|B|();|SCH.2|FUPMPMNG|1|V02 NT 07 01322||||0|0|0|0|Fonction d'accroche sur l'event FuPmp_EveKOn_Mng
FuPmp_EveRst_Mng|B|();|SCH.1|FUPMPMNG|1|V02 NT 07 01322||||0|0|0|0|Fonction d'accroche sur l'event FuPmp_EveRst_Mng
FuPmp_EveRst_PropFuPmp|C|();|SCH.1|PROPFUPMP|1|PTS_DOC_6562300||||0|0|0|0|ECU Event Reset.
FuPmp_EveRst_PropFuPmpPwd|A|();|SCH.4|ACQPWD|1|PTS_DOC_6717056||||0|0|0|0|ECU Event Reset.
FuPmp_EveRTSt_Mng|B|();|SCH.4|FUPMPMNG|1|V02 NT 07 01322||||0|0|0|0|Fonction d'accroche sur l'event FuPmp_EveRTSt_Mng
FuPmp_EveRxnIdDaRcdDml|B|();|SCH.3|FUPMPMNG|1|V02 NT 07 01322||||0|0|0|0|FuPmp_EveKOn_Mng
FuPmp_EveStTR_Mng|B|();|SCH.5|FUPMPMNG|1|V02 NT 07 01322||||0|0|0|0|Fonction d'accroche sur l'event FuPmp_EveStTR_Mng
FuPmp_SdlFast_CmdDiagPropFuPmp|A|();|SCH2.1|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Moniteur rapide de la fonction FuPmp.
FuPmp_SdlFast_CmdPwmPropFuPmp|A|();|SCH.3|CMDPWM|1|PTS_DOC_6669891||||0|0|0|0|Evènement moniteur rapide de la fonction FuPmp.
FuPmp_SdlFast_Mng|A|();|SCH.6|FUPMPMNG|1|V02 NT 07 01322||||0|0|0|0|Moniteur rapide de la fonction pompe à essence
FuPmp_SdlFast_PropFuPmp|E|();|SCH.2|PROPFUPMP|1|PTS_DOC_6562300||||0|0|0|0|Fast scheduler.
FuPmp_SdlMid_Mng|B|();|SCH.7|FUPMPMNG|1|V02 NT 07 01322||||0|0|0|0|Moniteur moyen de la fonction pompe à essence
FuPmp_SdlSlow_PropFuPmp|A|();|SCH.3|PROPFUPMP|1|PTS_DOC_6562300||||0|0|0|0|Moniteur lent de la fonction FuPmp.
FuPmp_SdlSlow_PropFuPmpDiagPwd|A|();|SCH.5|ACQPWD|1|PTS_DOC_6717056||||0|0|0|0|Moniteur lent de la fonction FuPmp.
FUPMPMNG_vidCondAcv|C|();|FCT2.2|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|Le choix de l'activation d'un mode de commande (précommande nominale, périodique ou moteur en rotation) se fait suivants les phases de vie du CMM et du moteur.
FUPMPMNG_vidControlPump|B|();|FCT2.1|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|Controller la pompe d'essence
FUPMPMNG_vidCtl|D|();|FCT2.3|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|Application de la précommande nominale suivi de la périodique
FUPMPMNG_vidEngineRunning|B|();|FCT2.4|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|La commande de la pompe est active en continue si le Régime   > Régime_seuil_1
FUPMPMNG_vidInit|B|();|FCT1.2|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|Fonction d'initialisation des paramètres produits
FUPMPMNG_vidInitCallMng|B|();|FCT1.5|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|Fonction qui gère la pré-commande pompe
FUPMPMNG_vidInitEveKOnMng|A|();|FCT1.3|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|Fonction d'initialisation de la variable Fuel_pump_bEveKOn_Mng
FUPMPMNG_vidInitEveRxnIdDaRcdDml|A|();|FCT1.4|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|Fonction d'initialisation de la variable Fuel_pump_bEveRxnIdDaRcdDml
FUPMPMNG_vidInitFuPmpPctl|E|();|FCT1.6|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|controller la pompe d'essence
FUPMPMNG_vidInitOutput|B|();|FCT1.1|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|Initialisation des sorties
FUPMPMNG_vidInitPumpCrankStall|B|();|FCT1.7|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|Lorsque le moteur cale, le système initialise le délai de commande de la pompe et réactive l’autorisation de la précommande
FUPMPMNG_vidInitPumpStallCrank|B|();|FCT1.8|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|Lorsque le moteur se met à tourner (i.e. sur une transition STALL -> CRANKING), le système commande le relais.
FUPMPMNG_vidStopEngReqOrKeyOff|B|();|FCT2.5|FUPMPMNG|0|V02 NT 07 01322||||0|0|0|0|Desactivation continue de la commande
FuSysM_EveRst_tFuMIf|B|();|SCH5.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement d'initialisation pour le calcul des températures amont pompe et rail.|
FuSysM_SdlSlow_tFuMIf|B|();|SCH18.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur lent pour le calcul des températures carburant.|
GD_bBitRead|A|fun_GD|1|HEADER|1|NONE||||0|0|0|0||
GD_CDThd|B|(argin uint16 u16DftIdx);|API.3|STATUSOFDTC|1|PTS_DOC_5446103||||0|0|0|0|The single failure detection counter has reached one of its threshold|
GD_CDThd_opt|A|(argin sint32 s32IdxDft);|1|HEADER|1|HEADER||||0|0|0|0|header|
GD_DftClr|B|(argin uint16 u16DftIdx);|API.5|STATUSOFDTC|1|PTS_DOC_5446103||||0|0|0|0|Update StatusOfDTC when the counter of WarmUpCycle is equal to 0|
GD_EveCrTR|D|();|SCH1.3|GD|1|PTS_DOC_5447643||||0|0|0|0|Crank To Run event|
GD_EveCrTR_DCIf|C|();|SCH12.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement Cranck To Run|
GD_EveCrTR_IndicOBD|B|();|SCH.3|INDICOBD|1|PTS_DOC_5075367||||0|0|0|0|Crank To Run event|
GD_EveCrTSt|D|();|SCH1.7|GD|1|PTS_DOC_5447643||||0|0|0|0|Crank To Stall event|
GD_EveCrTSt_IndicOBD|B|();|SCH.4|INDICOBD|1|PTS_DOC_5075367||||0|0|0|0|Crank To Stall event|
GD_EveKOf|C|();|SCH1.5|GD|1|PTS_DOC_5447643||||0|0|0|0|Key off event|
GD_EveKOf_DC|B|();|SCH.10|DC|1|V02 NT 10 04662||||0|0|0|0|Evènement passage de la clef de contact de ON à OFF|
GD_EveKOf_DCIf|C|();|SCH12.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement passage de la clef de contact de ON à OFF|
GD_EveKOn|C|();|SCH1.2|GD|1|PTS_DOC_5447643||||0|0|0|0|Ignition key's transit from ON to OFF|
GD_EveKOn_GDU|C|();|SCH.4|GDU|1|PTS_DOC_5444560||||0|0|0|0|Ignition key's transit from ON to OFF|
GD_EveRst|D|();|SCH1.1|GD|1|PTS_DOC_5447643||||0|0|0|0|ECU reset event|
GD_EveRst_DftLogTx|A|();|SCH.1|JDDISCANIF|1|V02 NT 11 02911||||0|1|0|0|Evènement reset ECU de la fonction GD|
GD_EveRst_DiagTab|A|();|SCH.1|DIAGTAB|1|V02 NT 11 00293||||0|0|0|0|Evénement reset du calculateur.|
GD_EveRst_GDU|C|();|SCH.1|GDU|1|PTS_DOC_5444560||||0|0|0|0|ECU reset event|
GD_EveRst_GJDD|C|();|SCH.1|JDD|1|PTS_DOC_5447356||||0|0|0|0|Evènement Reset CMM|
GD_EveRst_GJDDIf|B|();|SCH9.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reset.|
GD_EveRst_HrdRcvMng|A|();|SCH.1|HRDRCVMNG|1|V02 NT 09 03395||||0|0|0|0|Fonction d'accroche à l'événement GD_EveRst_HrdRcvMng
GD_EveRst_IndicOBD|C|();|SCH.1|INDICOBD|1|PTS_DOC_5075367||||0|0|0|0|ECU reset event|
GD_EveRst_IuprFrz|A|();|SCH.1|IUPRFRZ|1|V02 NT 11 03256||||0|1|0|0|ECU reset event|
GD_EveRst_IuprGenDen|B|();|SCH.1|IUPRGENDEN|1|PTS_DOC_5497341||||0|0|0|0|Evénement reset du calculateur.|
GD_EveRst_IuprRatio|C|();|SCH.2|IUPRRATIO|1|PTS_DOC_5338298||||0|0|0|0|Evenement RESET.|
GD_EveRst_Rdy|C|();|SCH.1|RC01|1|PTS_DOC_5263162||||0|0|0|0|Evènement reset de l'ECU|
GD_EveRst_StatusOfDTC|B|();|SCH1.1|STATUSOFDTC|1|PTS_DOC_5446103||||0|0|0|0|ECU Reset Event|
GD_EveRst_SumRat|A|();|SCH.1|SUMRAT|1|V02 NT 10 06202||||0|0|0|0|ECU reset event
GD_EveRstDft|C|();|SCH1.4|GD|1|PTS_DOC_5447643||||0|0|0|0|After-sale tool request for a clear failure|
GD_EveRstDft_DC|B|();|SCH.5|DC|1|V02 NT 10 04662||||0|0|0|0|Requête d'effacement des défauts avec l'outil APV|
GD_EveRstDft_GDU|C|();|SCH.2|GDU|1|PTS_DOC_5444560||||0|0|0|0|After-sale tool request for a clear failure|
GD_EveRstDft_GJDD|B|();|SCH.5|JDD|1|PTS_DOC_5447356||||0|0|0|0|Requête d'effacement des défauts avec l'outil APV.|
GD_EveRstDft_IndicOBD|B|();|API.1|INDICOBD|1|PTS_DOC_5075367||||0|0|0|0|After-sale tool request for a clear failure|
GD_EveRstDft_Rdy|C|();|SCH.3|RC01|1|PTS_DOC_5263162||||0|0|0|0|Requête d'effacement des défauts avec l'outil APV|
GD_EveRstDft_StatusOfDTC|B|();|SCH1.2|STATUSOFDTC|1|PTS_DOC_5446103||||0|0|0|0|After-sale tool request failures clear|
GD_EveRstDftObd|C|();|SCH1.6|GD|1|PTS_DOC_5447643||||0|0|0|0|After-sale tool request for an OBD clear failure|
GD_EveRstDftObd_DC|B|();|SCH.9|DC|1|V02 NT 10 04662||||0|0|0|0|Demande d'effacement des défauts OBD par le ScanTool|
GD_EveRstDftObd_GDU|C|();|SCH.5|GDU|1|PTS_DOC_5444560||||0|0|0|0|After-sale tool request for an OBD clear failure|
GD_EveRstDftObd_IndicOBD|B|();|API.2|INDICOBD|1|PTS_DOC_5075367||||0|0|0|0|After-sale tool request for an OBD clear failure|
GD_EveRstDftObd_Rdy|C|();|SCH.4|RC01|1|PTS_DOC_5263162||||0|0|0|0|Requête d'effacement des défauts OBD par le ScanTool|
GD_EveRstDftObd_StatusOfDTC|B|();|SCH1.4|STATUSOFDTC|1|PTS_DOC_5446103||||0|0|0|0|Scan-Tool request OBD failures clear|
GD_EveRxn55F|C|();|SCH2.3|GD|1|PTS_DOC_5447643||||0|0|0|0|Event receipt of frame 772|
GD_EveRxn55F_GJDD|D|();|SCH.4|JDD|1|PTS_DOC_5447356||||0|0|0|0|Evènement de réception de la trame 55F|
GD_EveRxn772|C|();|SCH2.2|GD|1|PTS_DOC_5447643||||0|0|0|0|Event receipt of frame 772|
GD_EveRxn772_GJDD|D|();|SCH.3|JDD|1|PTS_DOC_5447356||||0|0|0|0|Evènement de réception de la trame 772|
GD_EveSendDftLog_DftLogTx|A|();|1|HEADER|1|NONE||||0|0|0|0|Evènement demandant d’envoyer la trame 0x768 avec le contenu de Jbsi_IscanBufferPosX|
GD_GlbDCStrt|B|();|API.4|STATUSOFDTC|1|PTS_DOC_5446103||||0|0|0|0|Start-up of a new Global Driving Cycle|
GD_RstDftCal|B|();|SCH1.3|STATUSOFDTC|1|PTS_DOC_5446103||||0|0|0|0|Manual clear failure request|
GD_RstEventSt|A|();|API2.12|GDEXTINT|1|PTS_DOC_5075312||||0|0|0|0|Event indicating an update of StatusOfDTC information on failure clear|
GD_SdlFast|C|();|SCH2.1|GD|1|PTS_DOC_5447643||||0|0|0|0|Event receipt of frame 55F|
GD_SdlFast_GJDD|E|();|SCH.2|JDD|1|PTS_DOC_5447356||||0|0|0|0|Moniteur rapide de la fonction GD.|
GD_SdlFast_GJDDIf|B|();|SCH10.9|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Scheduler rapide.|
GD_SdlMid_HrdRcvMng|A|();|SCH.2|HRDRCVMNG|1|V02 NT 09 03395||||0|0|0|0|Fonction d'accroche à l'événement GD_SdlMid_HrdRcvMng
GD_SdlSlow|C|();|SCH1.8|GD|1|PTS_DOC_5447643||||0|0|0|0|Slow scheduler|
GD_SdlSlow_DiagTab|A|();|SCH.2|DIAGTAB|1|V02 NT 11 00293||||0|0|0|0|Moniteur lent pour la fonction DIAGTAB.|
GD_SdlSlow_IndicOBD|D|();|SCH.2|INDICOBD|1|PTS_DOC_5075367||||0|0|0|0|Slow scheduler|
GD_SdlSlow_IuprFrz|A|();|SCH.2|IUPRFRZ|1|V02 NT 11 03256||||0|1|0|0|Slow scheduler|
GD_SdlSlow_SumRat|A|();|SCH.2|SUMRAT|1|V02 NT 10 06202||||0|0|0|0|Slow scheduler
GD_SetEventSt|D|(argin uint16 u16IdxDft);|API2.9|GDExtInt|1|PTS_DOC_5075312||||0|0|0|0|Update the GAR upon changes of the event status|
GD_SetEventSt_opt|B|(argin uint16 u16DftIdx);|5|HEADER|1|NONE||||0|0|0|0|Event indicating an update of StatusOfDTC information|
GD_SetEventSt_reinit|D|(argin uint16 u16IdxDft);|API2.11|GDExtInt|1|PTS_DOC_5075312||||0|0|0|0|Reinit the GAR upon changes of the event status|
GD_vidBitWrite|A|GD_macro|xx|HEADER|1|HEADER||||0|0|0|1|Macro|
GDEXTINT_ClearDTC|F|func_GDEI_ClearDTC|FCT1.7|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Clears single DTCs as well as groups of DTCs. This API can only be used  through the RTE, and therefore no declaration is exported via Dem.h.|
GDEXTINT_DcmReadDataOfPID01|D|(argin uint8* u8PID01value)Std_ReturnType;|FCT2.9|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Service to report the value of PID $01 computed by the Dem.|
GDEXTINT_DisableDTCRecordUpdate|B|func_DisableDTCRecordUpdate|FCT1.5|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Enables the DTC setting for a DTC group.|
GDEXTINT_DisableDTCSetting|B|func_GDEI_DisableDTCSetting|FCT1.3|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Disables the DTC setting for a DTC group.|
GDEXTINT_EnableDTCRecordUpdate|B|func_EnableDTCRecordUpdate|FCT1.6|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Disables the DTC record update.|
GDEXTINT_EnableDTCSetting|B|func_GDEI_EnableDTCSetting|FCT1.4|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Enables the DTC setting for a DTC group.|
GDEXTINT_EveRstDft|B|();|API.1|GD|1|PTS_DOC_5447643||||0|0|0|0|After-sale tool request for a clear failure.|
GDEXTINT_EveRstDftObd|B|();|API.2|GD|1|PTS_DOC_5447643||||0|0|0|0|After-sale tool request for an OBD clear failure.|
GDEXTINT_GetDTCOfOBDFreezeFrame|C|(argin uint8 u8FrameNumber, argin uint32* u32DTC)Std_ReturnType;|FCT2.7|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Gets DTC by freeze frame record number.|
GDEXTINT_GetDTCStatAvailbltyMask|B|func_GDEI_GetDTCStatusAvailabilityMask|FCT2.5|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Gets the DTC Status availability mask.|
GDEXTINT_GetEventStatus|B|func_GDEI_GetEventStatus|FCT1.2|GDExtInt|0|PTS_DOC_5075312||||0|0|0|0|Gets the current extended event status of an event|
GDEXTINT_GetFreezeFrameDataByD1|E|func_GetFreezeFrameDataByDTC1|FCT2.4|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Sub function of GDEXTINT_GetFreezeFrameDataByDTC|
GDEXTINT_GetFreezeFrameDataByDTC|D|func_GetFreezeFrameDataByDTC|FCT2.3|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Gets freeze frame data by DTC. The function stores the data in the provided  DestBuffer.|
GDEXTINT_GetNextFilteredDTC|D|func_GDEI_GetNextFilteredDTC|FCT1.10|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Gets the next filtered DTC.|
GDEXTINT_GetNumberOfFilteredDTC|B|func_GDEI_GetNumberOfFilteredDTC|FCT1.9|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Gets the number of a filtered DTC.|
GDEXTINT_GetSizeOfFrzeFrameByDTC|E|func_GetSizeOfFreezeFrameByDTC|FCT2.2|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Gets the size of freeze frame data by DTC.|
GDEXTINT_GetStatusOfDTC|C|func_GDEI_GetStatusOfDTC|FCT2.1|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Gets the status of a DTC.|
GDEXTINT_GetTranslationType|B|func_GDEI_GetTranslationType|FCT2.6|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Gets the supported DTC formats of the ECU. The supported formats are  configured via DemTypeOfDTCSupported.|
GDEXTINT_ReadDataOfOBDFreezeFrame|D|(argin uint8 u8PID,argin uint8 u8DataElementIndexOfPID,argin uint8* u8DestBuffer, argin uint8* u8BufSize)Std_ReturnType;|FCT2.8|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Gets data element per PID and index of the most important freeze frame being selected for the output of service $02. The function stores the data in the provided  DestBuffer.|
GDEXTINT_SetDTCFilter|D|func_GDEI_SetDTCFilter|FCT1.8|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|The server shall perform a bit-wise logical AND-ing operation between the mask specified in the client's request and the actual status associated with each DTC supported by the server.|
GDEXTINT_SetEventStatus|B|func_GDEI_SetEventStatus|FCT1.1|GDExtInt|0|PTS_DOC_5075312||||0|0|0|0|Set the status of an Event|
GDEXTINT_vidEveRst_GDExtInt|D|();|FCT2.10|GDExtInt|0|PTS_DOC_5075312||||0|0|0|0|Return old value of the GAR upon changes of the event status|
GDEXTINT_vidRstEventSt|A|();|FCT3.3|GDEXTINT|0|PTS_DOC_5075312||||0|0|0|0|Event indicating an update of StatusOfDTC information on failure clear|
GDEXTINT_vidSetEventSt|C|(argin uint16 u16IdxDft);|FCT3.1|GDExtInt|0|PTS_DOC_5075312||||0|0|0|0|Update the GAR upon changes of the event status|
GDEXTINT_vidSetEventSt_reinit|A|(argin uint16 u16IdxDft);|FCT3.2|GDExtInt|0|PTS_DOC_5075312||||0|0|0|0|Update the GAR upon changes of the event status|
GDGAR_bGetEndDiagStrt|C|func_GDGAR_bGetEndDiagStrt|API1.6|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Value of EndDiagStrt|
GDGAR_bGetFRM|D|func_FRM_bGetFRM|API1.2|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Get FRM Value|
GDGAR_EepromRamCpyPack|B|();|API2.2|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Archivage des fautes loguées avant stockage en EEPROM|
GDGAR_EepromRamCpyUnpack|B|();|API2.1|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Extraction et récupération des fautes stockées en EEPROM|
GDGAR_EveCrkRun|E|();|SCH.7|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Event CRANKING to RUN|
GDGAR_EveCrTst|C|();|SCH.8|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Event CRANKING to STALL|
GDGAR_EveKeyOff|C|();|SCH.6|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Event Key Off|
GDGAR_EveKeyOn|H|();|SCH.5|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Event Key On|
GDGAR_EveRst|J|();|SCH.1|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Evenement reset du calculateur|
GDGAR_SdlFast|D|();|SCH.4|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Moniteur 10ms|
GDGAR_SdlMid|C|();|SCH.3|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Moniteur 40ms|
GDGAR_SdlSlow|I|();|SCH.2|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Moniteur 1024ms|
GDGAR_tenuGetStDgo|C|func_GDGAR_tenuGetStDgo|API1.5|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Value of the GDU states|
GDGAR_vidGdu|D|(argin uint16 u16IdxDft, argin boolean bDgo, argin boolean bMonRun, argin boolean Ns_bMonWait);|API1.1|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|API permettant d'appeler la fonction de gestion du GDU. Elle verifie les paramètres passés en arguments et si il y un problème, elle sort sans executer la fonction.|
GDGAR_vidGUS|A|(argin uint16 u16idxDefaut, argin boolean bDgo);|API1.1|HEADER|1|NONE||||0|0|0|0|API for using GUS|
GDGAR_vidMngEveRstDftApv|F|();|API1.3|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Requete d'effacement des defauts avec l'outil APV|
GDGAR_vidMngEveRstDftObd|F|();|API1.4|GDGAR|1|PTS_DOC_5012623||||0|0|0|0|Requete d'effacement des défauts avec l'outil ScanTool|
GDU_bGetEndDiagStrt|B|Func_GDU_bGetEndDiagStrt|API.3|GDU|1|PTS_DOC_5444560||||0|0|0|0|API which returns the value of the boolean EndDiaStrt|
GDU_bMngAutomateTrans|C|func_bMngAutomateTrans|FCT3.2|GDU|0|PTS_DOC_5444560||||0|0|0|0|This function manage the transition of GDU manager state. It returns true if the state has changed.|
GDU_tenuGetStDgo|B|Fct_GDU_tenuGetStDgo|API.2|GDU|1|PTS_DOC_5444560||||0|0|0|0|API which return the state of the single default. If the index is wrong it's return the default state|
GDU_vidAutomate|D|(argin uint16 u16IdxDft);|FCT3.1|GDU|0|PTS_DOC_5444560||||0|0|0|0|Function which launchs all steps which are necessary to update the GDU Manager state.|
GDU_vidExitEveCDThd|B|(argin uint16 u16DftIdx);|API.5|GDU|1|PTS_DOC_5444560||||0|0|0|0|function which manage the event CDth produce by the module and the scheduling of the call to the other module.|
GDU_vidExitEveCDThdUp|B|(argin uint16 u16DftIdx);|API.6|GDU|1|PTS_DOC_5444560||||0|0|0|0|function which manage the event CDth produce by the module and the scheduling of the call to the other module.|
GDU_vidExitEveDftClr|B|(argin uint16 u16IdxDft);|API.11|GDU|1|PTS_DOC_5444560||||0|0|0|0|Function which manage the event Default clear|
GDU_vidExitEveFrfRec|C|(argin uint16 u16IdxDft);|API.8|GDU|1|PTS_DOC_5444560||||0|0|0|0|function which manage the event FrFRec produce by the module and the scheduling of the call to the other module.|
GDU_vidExitEveRstDftCal|C|();|API.9|GDU|1|PTS_DOC_5444560||||0|0|0|0|function which manage the event RstDftCal used in validation|
GDU_vidExitEveSt|C|(argin uint16 u16IdxDft);|API.7|GDU|1|PTS_DOC_5444560||||0|0|0|0|function which manage the event St (change state) produce by the module and the scheduling of the call to the others modules.|
GDU_vidExitEveUnval|B|(argin uint16 u16IdxDft);|API.10|GDU|1|PTS_DOC_5444560||||0|0|0|0|function which manage the event unval.|
GDU_vidF01_CntDet|C|(argin uint16 u16DftIdx);|FCT1.1|GDU|0|PTS_DOC_5444560||||0|0|0|0|This function manages state of GDU manager|
GDU_vidF01_EndDiag|B|(argin uint16 u16DftIdx);|FCT1.5|GDU|0|PTS_DOC_5444560||||0|0|0|0|This function manages the parameter bEndDiagStrt|
GDU_vidF01_EndDiag_opt|A|(argin sint32 s32IdxDft);|1|HEADER|1|HEADER||||0|0|0|0|header|
GDU_vidF02_IniCntDet|B|();|FCT1.2|GDU|0|PTS_DOC_5444560||||0|0|0|0|Set the meter detection to zero|
GDU_vidF02_IniEndDiag|B|();|FCT1.6|GDU|0|PTS_DOC_5444560||||0|0|0|0|This function initializes the parameter bEndDiagStrt|
GDU_vidF03_IniCntDetScanTool|B|();|FCT1.3|GDU|0|PTS_DOC_5444560||||0|0|0|0|This function initializes the parameter s16ctDet which detect meter for default|
GDU_vidF03_IniEndDiagScanTool|B|();|FCT1.7|GDU|0|PTS_DOC_5444560||||0|0|0|0|This function intializes the parameter bEndDiagStrt for an OBD type failure by an after-sale tool|
GDU_vidF04_IniCntDetGlbDCStrt|C|();|FCT1.4|GDU|0|PTS_DOC_5444560||||0|0|0|0|This function initializes s16ctDet at start of a global driving cycle|
GDU_vidF04_IniCntDetGlbDCStrt_opt|B|(void);|FCT1.9|GDU|0|PTS_DOC_5444560||||0|0|0|0|This function initializes s16ctDet at start of a global driving cycle. Optimization of the function GDU_vidF04_IniCntDetGlbDCStrt.|
GDU_vidF06_ClearCntDetEvents|B|(void);|FCT1.10|GDU|0|PTS_DOC_5444560||||0|0|0|0|Replace function GDU_vidF06_CntDetEvents on a Global DC Start. This function is dedicated to the creation of various events linked to the fault detection counter.|
GDU_vidF06_CntDetEvents|C|(argin uint16 u16DftIdx);|FCT1.8|GDU|0|PTS_DOC_5444560||||0|0|0|0|This function is dedicated to the creation of various events linked to the fault detection counter|
GDU_vidGdu|C|(argin uint16 u16IdxDft);|API.1|GDU|1|PTS_DOC_5444560||||0|0|0|0|Main API to manage the GDU.|
GDU_vidGlbDCStrt|B|();|API.4|GDU|1|PTS_DOC_5444560||||0|0|0|0|Start-up of a new Global Driving Cycle|
GDU_vidMngAutomateEntry|C|(argin uint16 u16IdxDft);|FCT3.3|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action which must be done when the manager enter in a different state.|
GDU_vidMngAutomateExit|C|(argin uint16 u16IdxDft, argin GDFRM_tenuGDUState enuStDgo);|FCT3.4|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action which must be done when the manager leave in a different state.|
GDU_vidMngEntryStAbsent|D|(argin uint16 u16IdxDft);|FCT2.1|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you enter in the state ABSENT.|
GDU_vidMngEntryStDeval|B|(argin uint16 u16DftIdx);|FCT2.9|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you enter in the state DEVALIDATION|
GDU_vidMngEntryStFugitif|D|(argin uint16 u16IdxDft);|FCT2.11|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you exit from the state FUGITIF.|
GDU_vidMngEntryStPctlAbsent|B|(argin uint16 u16IdxDft);|FCT2.5|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you enter in the state PCTL ABSENT|
GDU_vidMngEntryStPctlPresent|C|(argin uint16 u16IdxDft);|FCT2.7|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you exit from the state PCTPRESENT.|
GDU_vidMngEntryStPresent|D|(argin uint16 u16IdxDft);|FCT2.3|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you exit from the state PRESENT.|
GDU_vidMngExitStAbsent|C|(argin uint16 u16IdxDft);|FCT2.2|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you exit from the state ABSENT.|
GDU_vidMngExitStDeval|C|(argin uint16 u16IdxDft);|FCT2.10|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you exit from the state DEVALIDATION.|
GDU_vidMngExitStFugitif|C|(argin uint16 u16IdxDft);|FCT2.12|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you exit from the state  FUGITIF.|
GDU_vidMngExitStPctlAbsent|C|(argin uint16 u16IdxDft);|FCT2.6|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you exit from the state PTCL ABSENT.|
GDU_vidMngExitStPctlPresent|C|(argin uint16 u16IdxDft);|FCT2.8|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you exit from the state PTCL  PRESENT.|
GDU_vidMngExitStPresent|C|(argin uint16 u16IdxDft);|FCT2.4|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the action to do when you exit from the state PRESENT.|
GDU_vidSdlSlow|D|();|SCH.3|GDU|1|PTS_DOC_5444560||||0|0|0|0|Function used only on debug. It used to reset all the  default on a rising edge for GD_bRstDftCal.|
GDU_vidTransAbs|E|(argin uint16 u16IdxDft);|FCT4.1|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the transition in the state ABSENT.|
GDU_vidTransDeval|E|(argin uint16 u16IdxDft);|FCT4.5|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the transition in the state DEVALIDATION.|
GDU_vidTransFugit|E|(argin uint16 u16IdxDft);|FCT4.6|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the transition in the state FUGITIF.|
GDU_vidTransPctlAbs|D|(argin uint16 u16IdxDft);|FCT4.3|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the transition in the state PTCL ABSENT.|
GDU_vidTransPctlPrst|D|(argin uint16 u16IdxDft);|FCT4.2|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the transition in the state PTCL PRESENT.|
GDU_vidTransPrst|D|(argin uint16 u16IdxDft);|FCT4.4|GDU|0|PTS_DOC_5444560||||0|0|0|0|Manage the transition in the state PRESENT.|
Gear_EveRst_NeutPosnAcq|C|();|SCH.1|NEUTPOSNACQ|1|PTS_DOC_6533527||||0|0|0|0|Evénement reset
Gear_EveRst_NeutPosnAcqPwd|A|();|SCH.6|ACQPWD|1|PTS_DOC_6717056||||0|0|0|0|Evénement reset.
Gear_EveRst_StrtLockAcq|B|();|SCH.1|STRTLOCKACQ|1|PTS_DOC_6530087||||0|0|0|0|Fonction d'accroche à l'évenement RESET
Gear_SdlFast_NeutPosnAcq|C|();|SCH.2|NEUTPOSNACQ|1|PTS_DOC_6533527||||0|0|0|0|Moniteur rapide de la fonction Gear
Gear_SdlFast_NeutPosnAcqPwd|A|();|SCH.7|ACQPWD|1|PTS_DOC_6717056||||0|0|0|0|Moniteur rapide de la fonction Gear.
Gear_SdlFast_StrtLockAcq|B|();|SCH.2|STRTLOCKACQ|1|PTS_DOC_6530087||||0|0|0|0|Moniteur rapide
Gear_SdlFast_StrtLockAcqDio|A|();|SCH3.5|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Moniteur rapide
Gear_SdlMid_FctDiagRvsSt|C|();|SCH.2|RVSSTDIAG|1|V02 NT 09 01180||||0|0|0|0|Moniteur moyen.
GetDTRValue_OBDMID01_TID01|A|func_OBDMIDxx_TIDxxx|API.1|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde Amont : OBDMID 01, TID 01|
GetDTRValue_OBDMID01_TID02|A|func_OBDMIDxx_TIDxxx|API.2|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde Amont : OBDMID 01, TID 02|
GetDTRValue_OBDMID01_TID03|A|func_OBDMIDxx_TIDxxx|API.3|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde Amont : OBDMID 01, TID 03|
GetDTRValue_OBDMID01_TID04|A|func_OBDMIDxx_TIDxxx|API.4|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde Amont : OBDMID 01, TID 04|
GetDTRValue_OBDMID01_TID07|A|func_OBDMIDxx_TIDxxx|API.5|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde Amont : OBDMID 01, TID 07|
GetDTRValue_OBDMID01_TID08|A|func_OBDMIDxx_TIDxxx|API.6|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde Amont : OBDMID 01, TID 08|
GetDTRValue_OBDMID01_TID0A|A|func_OBDMIDxx_TIDxxx|API.7|OBDSRV06|1|V02 NT 11 04787||||0|1|0|0|Sonde Amont : OBDMID 01, TID 0A|
GetDTRValue_OBDMID01_TIDA0|A|func_OBDMIDxx_TIDxxx|API.8|OBDSRV06|1|V02 NT 11 04787||||0|1|0|0|Sonde Amont : OBDMID 01, TID A0|
GetDTRValue_OBDMID01_TIDA1|A|func_OBDMIDxx_TIDxxx|API.9|OBDSRV06|1|V02 NT 11 04787||||0|1|0|0|Sonde Amont : OBDMID 01, TID A1|
GetDTRValue_OBDMID02_TID01|A|func_OBDMIDxx_TIDxxx|API.10|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde aval : OBDMID 02, TID 01|
GetDTRValue_OBDMID02_TID02|A|func_OBDMIDxx_TIDxxx|API.11|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde aval : OBDMID 02, TID 02|
GetDTRValue_OBDMID02_TID03|A|func_OBDMIDxx_TIDxxx|API.12|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde avl : OBDMID 02, TID 03|
GetDTRValue_OBDMID02_TID04|A|func_OBDMIDxx_TIDxxx|API.13|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde aval : OBDMID 02, TID 04|
GetDTRValue_OBDMID02_TID07|A|func_OBDMIDxx_TIDxxx|API.14|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde aval : OBDMID 02, TID 07|
GetDTRValue_OBDMID02_TID08|A|func_OBDMIDxx_TIDxxx|API.15|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde aval : OBDMID 02, TID 08|
GetDTRValue_OBDMID02_TIDC0|A|func_OBDMIDxx_TIDxxx|API.16|OBDSRV06|1|V02 NT 11 04787||||0|1|0|0|Sonde aval : OBDMID 02, TID C0|
GetDTRValue_OBDMID02_TIDC1|A|func_OBDMIDxx_TIDxxx|API.17|OBDSRV06|1|V02 NT 11 04787||||0|1|0|0|Sonde aval : OBDMID 02, TID C1|
GetDTRValue_OBDMID02_TIDC2|A|func_OBDMIDxx_TIDxxx|API.18|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Sonde aval : OBDMID 02, TID C2|
GetDTRValue_OBDMID21_TID81|A|func_OBDMIDxx_TIDxxx|API.19|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Catalyseur : OBDMID 21, TID 81|
GetDTRValue_OBDMID41_TIDD0|A|func_OBDMIDxx_TIDxxx|API.20|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Chauffage sonde amont : OBDMID 41, TID D0|
GetDTRValue_OBDMID42_TIDDA|A|func_OBDMIDxx_TIDxxx|API.21|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Chauffage sonde aval : OBDMID 42, TID DA|
GetDTRValue_OBDMIDA2_TID0B|A|func_OBDMIDxx_TIDxxx|API.22|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Misifre cylindre 1 :  OBDMID A2, TID 0B|
GetDTRValue_OBDMIDA2_TID0C|A|func_OBDMIDxx_TIDxxx|API.23|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Misifre cylindre 1 : OBDMID A2, TID 0C|
GetDTRValue_OBDMIDA3_TID0B|A|func_OBDMIDxx_TIDxxx|API.24|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Misifre cylindre 2 : OBDMID A3, TID 0B|
GetDTRValue_OBDMIDA3_TID0C|A|func_OBDMIDxx_TIDxxx|API.25|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Misifre cylindre 2 : OBDMID A3, TID 0C|
GetDTRValue_OBDMIDA4_TID0B|A|func_OBDMIDxx_TIDxxx|API.26|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Misifre cylindre 3 : OBDMID A4, TID 0B|
GetDTRValue_OBDMIDA4_TID0C|A|func_OBDMIDxx_TIDxxx|API.27|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Misifre cylindre 3 : OBDMID A4, TID 0C|
GetDTRValue_OBDMIDA5_TID0B|A|func_OBDMIDxx_TIDxxx|API.28|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Misifre cylindre 4 : OBDMID A5, TID 0B|
GetDTRValue_OBDMIDA5_TID0C|A|func_OBDMIDxx_TIDxxx|API.29|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Misifre cylindre 4 : OBDMID A5, TID 0C|
GMIL_DftAndWarnSt|D|();|FCT1.5|GMIL|0|V02 NT 10 04661||||0|0|0|0|Cette fonction produit 2 requêtes d'allumage voyant: clignotement et fixe ainsi que l'état voyant MIL pour le Scan Tool.|
GMIL_DftSt|D|();|FCT1.8|GMIL|0|V02 NT 10 04661||||0|0|0|0|Cette fonction permet, à partir des différentes requêtes issues des fonctions précédentes de créer le booléen GMIL_bMilDftPres. Il informe si l'allumage de la MIL est lié ou non à une défaillance.|
GMIL_Init|D|();|FCT1.2|GMIL|0|V02 NT 10 04661||||0|0|0|0|Initialisation des variables et récupération des données mémorisées en EEPROM au Power Latch précédent.|
GMIL_MilReqCanConf|D|();|FCT1.7|GMIL|0|V02 NT 10 04661||||0|0|0|0|Ce bloc permet de créer 2 booléens GMIL_bMilOn et GMIL_bMilBlink à partir de l'état d'automate GMIL_stMILReq qui seront envoyés sur le Can via la trame 348.|
GMIL_Req|D|(argin uint8 u8Event);|FCT1.6|GMIL|0|V02 NT 10 04661||||0|0|0|0|Cet automate synthétise via la variable GMIL_stMilReq les demandes d'allumage issues des fonctions|
GMIL_StrtCntIni|D|();|FCT1.3|GMIL|0|V02 NT 10 04661||||0|0|0|0|Cette fonction permet d'initialiser les variables sur l'événement GD_EveKeyOBD|
GMIL_StrtMng|D|();|FCT1.4|GMIL|0|V02 NT 10 04661||||0|0|0|0|Cette fonction exécutée à la récurrence GD_SdlSlow_GMIL gère l'allumage de la MIL avant démarrage.|
GMIL_vidEveRstDft|A|();|6|HEADER|1|NONE||||0|0|0|0||
GMIL_vidEveRstDftOBD|A|();|19|HEADER|1|NONE||||0|0|0|0||
GMIL_vidInitOutput|A|();|FCT1.1|GMIL|0|V02 NT 10 04661||||0|0|0|0|Initializing outputs of GMIL module.|
GMIL_vidMngEveKeyOBD|D|();|SCH.2|GMIL|1|V02 NT 10 04661||||0|0|0|0|Evènement représentant le front montant de l'information CONTACT_OBD|
GMIL_vidMngEveRst|D|();|SCH.3|GMIL|1|V02 NT 10 04661||||0|0|0|0|Evènement Reset CMM|
GMIL_vidMngEveSldSlow|D|();|SCH.1|GMIL|1|V02 NT 10 04661||||0|0|0|0|Moniteur lent associé au module GMIL|
GOBD_bMngAutomateTrans|B|FUNC_GOBD_bF07_MngAutomateTrans|FCT2.2|GOBD|0|PTS_DOC_5075502||||0|0|0|0|This function manage the transition of GDU manager state. It returns true if the state has changed.|
GOBD_tenuGetStDgo|D|funct_get_gobd_state|API.7|GOBD|1|PTS_DOC_5075502||||0|0|0|0|API which returns the state of the GOBD manager.|
GOBD_vidAutomate|B|(argin uint16 u16IdxDft);|FCT2.1|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Function which launchs all steps which are necessary to update the GDU Manager state.|
GOBD_vidAutomateRstDft|C|(argin uint16 u16IdxDft);|FCT2.3|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the state change on the event EveRstDft et RstDftCal.|
GOBD_vidAutomateUnval|B|(argin uint16 u16IdxDft);|FCT2.4|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the transitions from the event DftUnval.|
GOBD_vidCDThdUp|B|(argin uint16 u16IdxDft);|FCT3.1|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Do all the actions which must be done on the event GD_EveCDThdUp.|
GOBD_vidClrCntWUC|B|(argin uint16 u16IdxDft);|FCT3.6|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the re-initalization of the WUC's meter on the clear tools event.|
GOBD_vidCntWUC|B|(argin uint16 u16IdxDft);|FCT3.4|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the WUC meter for the automatic erasure of the default.|
GOBD_vidExitEveKeyOBD|C|();|API.8|GOBD|0|PTS_DOC_5075502||||0|0|0|0|function which manage the event KeyOBD produce by the module and the scheduling of the call to the other module.|
GOBD_vidExitEveStObd|D|(argin uint16 u16IdxDft);|API.9|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the scheduling on the event StDgo produce by GOBD.|
GOBD_vidExitEveStObdClear|A|(argin uint16 u16IdxDft);|API.11|GOBD|1|PTS_DOC_5075502||||0|0|0|0|Evènement de deconfirmation d'un défaut unitaire au sens OBD|
GOBD_vidExitEveStObdRec|B|(argin uint16 u16IdxDft);|API.10|GOBD|1|PTS_DOC_5075502||||0|0|0|0|Evènement entrée du Gestionnaire OBD dans l'état GOBD_ST_ENREGISTRE|
GOBD_vidF07_MngAutomateExit|B|(argin uint16 u16IdxDft);|FCT2.3|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Function which manage the actions which are done when the GOBD state change.|
GOBD_vidGlbDC|C|(argin uint16 u16IdxDft);|FCT3.2|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage all the actins which must be done on the vent Cal_GlbDCStrt.|
GOBD_vidIniCntWUC|B|(argin uint16 u16IdxDft);|FCT3.5|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the re-initialization of the WUC's meter.|
GOBD_vidInit|C|();|FCT1.1|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Initialize the GOBD module parameters.|
GOBD_vidInitTiSinceEngStrt|B|();|FCT1.6|GOBD|0|PTS_DOC_5075502||||0|0|0|0|reset the data GOBD_vidInitTiSinceEngStrt.|
GOBD_vidMngEveCDThdUp|C|(argin uint16 u16IdxDft);|API.1|GOBD|1|PTS_DOC_5075502||||0|0|0|0|API called on the event EveCDThdUp generated by the module GDU. This API calls after the GOBD functions linked to this event.|
GOBD_vidMngEveCDThdUp_opt|A|(argin sint32 s32IdxDft);|1|HEADER|1|HEADER||||0|0|0|0|header|
GOBD_vidMngEveDftUnval|B|(argin uint16 u16IdxDft);|API.6|GOBD|1|PTS_DOC_5075502||||0|0|0|0|event produce by the GDU when the default enters in the FUGITIF state.|
GOBD_vidMngEveGlbDCStrt|C|();|API.2|GOBD|1|PTS_DOC_5075502||||0|0|0|0|API called on the event EveGlbDcStrt generated by the module DC. This API calls after the GOBD functions linked to this event.|
GOBD_vidMngEveKOf|C|();|SCH.3|GOBD|1|PTS_DOC_5075502||||0|0|0|0|API called on the event Key Off by the scheduler.|
GOBD_vidMngEveKOn|C|();|SCH.2|GOBD|1|PTS_DOC_5075502||||0|0|0|0|API called on the event Key On by the scheduler.|
GOBD_vidMngEveRst|D|();|SCH.4|GOBD|1|PTS_DOC_5075502||||0|0|0|0|API called on the event reset by the scheduler.|
GOBD_vidMngEveRstDft|C|();|API.4|GOBD|1|PTS_DOC_5075502||||0|0|0|0|API called on the event EveRstDft generated by the module  GDGAR. This API calls after the GOBD functions linked to this event.|
GOBD_vidMngEveRstDftCal|B|();|API.3|GOBD|1|PTS_DOC_5075502||||0|0|0|0|API called on the event EveRstDftCal generated by the module GDU . This API calls after the GOBD functions linked to this event.|
GOBD_vidMngEveRstDftObd|B|();|API.5|GOBD|1|PTS_DOC_5075502||||0|0|0|0|API called on the event EveRstDftObd generated by the module GDGAR. This API calls after the GOBD functions linked to this event.|
GOBD_vidMngEveSldSlow|D|();|SCH.1|GOBD|1|PTS_DOC_5075502||||0|0|0|0|API called on the slow recurrence by the scheduler.|
GOBD_vidMngEveStPres|A|(argin uint16 u16IdxDft);|1|HEADER|1|HEADER||||0|0|0|0|header|
GOBD_vidRstCntDC|B|(argin uint16 u16IdxDft);|FCT3.3|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Reset the DC meter of the default give in argument.|
GOBD_vidRstKeyOBD|B|();|FCT1.3|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Set the parameter GOBD_bKeyOBD to FALSE.|
GOBD_vidSetKeyOBD|B|();|FCT1.2|GOBD|0|PTS_DOC_5075502||||0|0|0|0|This function generate the information "CONTACT OBD" and  modified some data.|
GOBD_vidTiSinceEngStrt|B|();|FCT1.5|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the time's meter since the engine starts.|
GOBD_vidTransEnregistre|B|(argin uint16 u16IdxDft);|FCT4.4|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the transitions from the state GOBD_ETAT_ENREGISTRE.|
GOBD_vidTransHistoOff|C|(argin uint16 u16IdxDft);|FCT4.6|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the transitions from the state GOBD_HISTORIQUE_OFF.|
GOBD_vidTransHistoOn|C|(argin uint16 u16IdxDft);|FCT4.5|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the transitions from the state GOBD_ETAT_HIDTORIQUE_ON.|
GOBD_vidTransOK|C|(argin uint16 u16IdxDft);|FCT4.1|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the transitions from the state GOBD_ETAT_OK.|
GOBD_vidTransPending1|C|(argin uint16 u16IdxDft);|FCT4.2|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the transition from the state GOBD_ETAT_PENDING1.|
GOBD_vidTransPending2|C|(argin uint16 u16IdxDft);|FCT4.3|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Manage the transistions from the state GOBD_ETAT_PENDING2.|
GOBD_vidWriteCntAcv|C|(argin boolean bValue);|FCT1.4|GOBD|0|PTS_DOC_5075502||||0|0|0|0|Write the value give in argument to Ns_bCntAcv. (F04_F02_RstCntAcv and F04_F01_SetCntAcv)|
GoToMode|A|(argin uint8 NetId, argin uint8 NewMode);|1|HEADER|1|V01 NT 08 05903||||0|0|0|0|
Gpt_GetTimeElapsed|A|(argin uint16 channel)uint32;|1|HEADER|1|NONE||||0|0|0|0|Release_fonction|
HBHAL_vidDisable|A|(argin uint8 u8Channel);|3|HEADER|1|NONE||||0|0|0|0|
HBHAL_vidEnable|A|(argin uint8 u8Channel);|4|HEADER|1|NONE||||0|0|0|0|
HBHAL_vidWrite|A|(argin uint8 u8Channel, argin HBHAL_tudtSetPoint udtSetPoint);|5|HEADER|1|NONE||||0|0|0|0|
HeatSenO2_EveCrTR_DsMgr|A|();|SCH.5|HEATSENO2DS|1|PTS_DOC_5421274||||0|0|0|0|Evénement de détection le passage de cranking to running|
HeatSenO2_EveCrTR_HotSenO2Flg|A|();|SCH.2|HOTSENO2FLG|1|V02 NT 08 06204||||0|0|0|0|Evénement Cranking -> Running|
HeatSenO2_EveCrTR_UsMgr|A|();|SCH.6|HEATSENO2US|1|PTS_DOC_5211932||||0|0|0|0|Evénement de détection le passage de cranking vers running|
HeatSenO2_EveKOf_DrvrSenO2Ds|A|();|SCH.3|DRVRSENO2DS|1|PTS_DOC_6545446||||0|0|0|0|Evénement Clé On -> Off.
HeatSenO2_EveKOf_DrvrSenO2DsDio|A|();|SCH2.10|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evénement Clé On -> Off.
HeatSenO2_EveKOf_DrvrSenO2Us|A|();|SCH.3|DRVRSENO2US|1|PTS_DOC_6559003||||0|0|0|0|Evénement Clé On -> Off.
HeatSenO2_EveKOf_DrvrSenO2UsDio|A|();|SCH3.1|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evénement Clé On -> Off.
HeatSenO2_EveRst_ActrTSO2Ds|C|();|SCH.1|SENO2DSACTEST|1|V02 NT 09 01049||||0|0|0|0|Evènement Reset du calculateur|
HeatSenO2_EveRst_ActrTSO2Us|C|();|SCH.1|SENO2USACTEST|1|V02 NT 08 08131||||0|0|0|0|Evènement reset du calculateur|
HeatSenO2_EveRst_DsMgr|D|();|SCH.1|HEATSENO2DS|1|PTS_DOC_5421274||||0|0|0|0|Evènement reset du calculateur|
HeatSenO2_EveRst_HeatSenO2Mon|D|();|SCH.1|HEATSENO2HOTDIAG|1|V02 NT 12 00470||||0|0|0|0|Evènement reset|
HeatSenO2_EveRst_HotSenO2Flg|A|();|SCH.1|HOTSENO2FLG|1|V02 NT 08 06204||||0|0|0|0|Evenement Reset.|
HeatSenO2_EveRst_ReqAdjVltCtl|A|();|SCH.1|REQADJVLTCTL|1|V02NT1103742||||0|0|0|0|Evènement reset du calculateur
HeatSenO2_EveRst_UsMgr|F|();|SCH.1|HEATSENO2US|1|PTS_DOC_5211932||||0|0|0|0|Evènement reset du calculateur|
HeatSenO2_EveRTSt_DsMgr|A|();|SCH.6|HEATSENO2DS|1|PTS_DOC_5421274||||0|0|0|0|Evenement de détection le passage de l'état running vers stall|
HeatSenO2_EveRTSt_UsMgr|A|();|SCH.7|HEATSENO2US|1|PTS_DOC_5211932||||0|0|0|0|Evènement reset du calculateur|
HeatSenO2_EveStTCr_DsMgr|A|();|SCH.4|HEATSENO2DS|1|PTS_DOC_5421274||||0|0|0|0|Evenement de détection  du passage de  l'état stall vers cranking|
HeatSenO2_EveStTCr_UsMgr|A|();|SCH.5|HEATSENO2US|1|PTS_DOC_5211932||||0|0|0|0|Evenement de détection du passage de l'état stall vers cranking|
HeatSenO2_SdlFast_ActrTSO2Ds|C|();|SCH.2|SENO2DSACTEST|1|V02 NT 09 01049||||0|0|0|0|Moniteur rapide de la fonction HeatSenO2|
HeatSenO2_SdlFast_ActrTSO2Us|C|();|SCH.2|SENO2USACTEST|1|V02 NT 08 08131||||0|0|0|0|Moniteur rapide de la fonction HeatSenO2|
HeatSenO2_SdlFast_CmdDiagDrvO2Ds|A|();|SCH1.6|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Récurrence rapide de la fonction HeatSenO2 aval
HeatSenO2_SdlFast_CmdDiagDrvO2Us|A|();|SCH1.7|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Récurrence rapide de la fonction HeatSenO2 amont.
HeatSenO2_SdlFast_DrvrSenO2Ds|B|();|SCH.2|DRVRSENO2DS|1|PTS_DOC_6545446||||0|0|0|0|Récurrence rapide de la fonction HeatSenO2.
HeatSenO2_SdlFast_DrvrSenO2DsAdc|A|();|SCH2.1|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Récurrence rapide de la fonction HeatSenO2
HeatSenO2_SdlFast_DrvrSenO2DsDio|A|();|SCH2.9|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Récurrence rapide de la fonction HeatSenO2.
HeatSenO2_SdlFast_DrvrSenO2Us|A|();|SCH.2|DRVRSENO2US|1|PTS_DOC_6559003||||0|0|0|0|Récurrence rapide de la fonction HeatSenO2.
HeatSenO2_SdlFast_DrvrSenO2UsAdc|A|();|SCH2.2|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Récurrence rapide de la fonction HeatSenO2
HeatSenO2_SdlFast_DrvrSenO2UsDio|A|();|SCH3.2|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Récurrence rapide de la fonction HeatSenO2.
HeatSenO2_SdlFast_DsCmd|A|();|SCH.3|HEATSENO2DSCMD|1|V02 NT 09 04727||||0|0|0|0|Moniteur rapide du module chauffage sonde 02|
HeatSenO2_SdlFast_DsMgr|D|();|SCH.2|HEATSENO2DS|1|PTS_DOC_5421274||||0|0|0|0|Moniteur rapide pour le module chauffage sonde O2|
HeatSenO2_SdlFast_HeatSenO2Mon|D|();|SCH.2|HEATSENO2HOTDIAG|1|V02 NT 12 00470||||0|0|0|0|Moniteur rapide pour la fonction HeatSenO2|
HeatSenO2_SdlFast_HeatSenO2MonIf|B|();|SCH2.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide pour la fonction HeatSenO2|
HeatSenO2_SdlFast_UsCmd|A|();|SCH.3|HEATSENO2USCMD|1|V02 NT 09 04308||||0|0|0|0|Moniteur rapide du module chauffage sonde 02|
HeatSenO2_SdlFast_UsMgr|G|();|SCH.2|HEATSENO2US|1|PTS_DOC_5211932||||0|0|0|0|Moniteur rapide pour le module chauffage sonde O2|
HeatSenO2_SdlMid_DsCmd|A|();|SCH.2|HEATSENO2DSCMD|1|V02 NT 09 04727||||0|0|0|0|Moniteur moyen du module chauffage sondes O2|
HeatSenO2_SdlMid_DsMgr|E|();|SCH.3|HEATSENO2DS|1|PTS_DOC_5421274||||0|0|0|0|Moniteur moyen pour le module chauffage sonde O2|
HeatSenO2_SdlMid_HotSenO2Flg|B|();|SCH.3|HOTSENO2FLG|1|V02 NT 08 06204||||0|0|0|0|Moniteur intermédiaire de la fonction HeatSenO2|
HeatSenO2_SdlMid_ReqAdjVltCtl|A|();|SCH.2|REQADJVLTCTL|1|V02NT1103742||||0|0|0|0|Moniteur moyen pour le module chauffage sonde O2
HeatSenO2_SdlMid_UsCmd|A|();|SCH.2|HEATSENO2USCMD|1|V02 NT 09 04308||||0|0|0|0|Moniteur moyen du module chauffage sondes O2|
HeatSenO2_SdlMid_UsMgr|H|();|SCH.3|HEATSENO2US|1|PTS_DOC_5211932||||0|0|0|0|Moniteur moyen pour le module chauffage sonde O2|
HeatSenO2_SdlSlow_UsMgr|G|();|SCH.4|HEATSENO2US|1|PTS_DOC_5211932||||0|0|0|0|Moniteur lent pour le module chauffage sonde O2|
HEATSENO2DS_vidDetDewPt|G|();|FCT1.4|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Détermination du passage du  du point de rosée en fonction de la durée du chauffage de protection|
HEATSENO2DS_vidDetDewPtRev|C|();|FCT1.3|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Déterminer si le point de rosée a été franchi à l'envers depuis la fin du dernie rarrêt moteur|
HEATSENO2DS_vidDlyDewPt|C|();|FCT1.5|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Lorsque le point de rosée est considéré comme franchi, un compteur s’active afin de connaître depuis combien de temps le point de rosée est franchi et est entretenu par les gaz d’échappements|
HEATSENO2DS_vidDlyDewTranOkStall|C|();|FCT1.6|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Durée pendant laquelle la sonde à oxygène a été chauffée par les gaz d’échappements depuis le franchissement du point de rosée|
HEATSENO2DS_vidInitOutput|F|();|FCT1.1|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Initialisation des variables au reset|
HEATSENO2DS_vidLsDsDetRTStall|A|();|FCT2.8|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Lors de la détection du passage de l’état moteur « Running » vers Stall, la variable est mise à 1|
HEATSENO2DS_vidLsDsDetRTStallint|A|();|FCT2.7|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Lors de la détection d’un passage de l’état moteur stall vers cranking ou d’état moteur cranking vers running, la variable est mise à zéro|
HEATSENO2DS_vidLsDsDewPt|G|();|FCT1.2|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Détection du passage du point de rosée pour la sonde aval|
HEATSENO2DS_vidLsDsMgrHeatState|J|();|FCT1.10|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Cette fonction contient l’automate de gestion des phases de chauffage de la sonde O2 aval|
HEATSENO2DS_vidMgrFastTran|H|();|FCT1.7|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Cette transition consiste a réfugier le chauffage sonde dans un mode dégradé dans le  cas d'une surtension batterie.|
HEATSENO2DS_vidMgrMidTran|F|();|FCT1.8|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Calcul de toutes les transitions ayant un chauffage non nul et détermination du délai avant réautorisation du chauffage maximal|
HEATSENO2DS_vidMgrSlowTran|D|();|FCT1.9|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Lorsque le chauffage réduit reste activé trop longtemps, on passe en chauffage coupé  afin de réduire la consommation électrique|
HEATSENO2DS_vidTranAToCOrAToE|H|();|FCT2.1|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Lorsque le l’automate se trouve en phase de chauffage coupé, il peut activer le chauffa ge de protection si la sonde est considérée froide ou activer le chauffage modulé si la sonde est considérée chaude|
HEATSENO2DS_vidTranC1toC2|C|();|FCT2.6|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|La phase C est composée par la sous phase C1 qui est un boost de préchauffage de la sonde aval rapidement et la sous phase C2 qui est un intensif de préchauffage de la sonde aval maintenu pour la rapidité et la protection du préchauffage de la sonde aval.|
HEATSENO2DS_vidTranCToD|D|();|FCT2.2|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|La transition de la phase de chauffage de protection (phase C) vers la phase de chauffage maximal (phase D) est autorisée lorsque le chauffage de protection est terminé|
HEATSENO2DS_vidTranCToEOrDToE|F|();|FCT2.3|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Le chauffage modulé consiste à appliquer un chauffage en fonction du débit de gaz et de la température des gaz d'échappements|
HEATSENO2DS_vidTranEToF|E|();|FCT2.4|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Lors d'une phase stop STT on passe de la phase E modulation de chauffe à la phase F chauffe réduite|
HEATSENO2DS_vidTranFToA|D|();|FCT2.5|HEATSENO2DS|0|PTS_DOC_5421274||||0|0|0|0|Lorsque le chauffage réduit reste activé trop longtemps on passe en chauffage coupé afin de réduire la consommation électrique|
HEATSENO2DSCMD_vidCalcPwmPeriod|B|();|FCT1.9|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|fonction de  calcul et/ou  détermination de la période du signal de commande de chauffage|
HEATSENO2DSCMD_vidCalculTimeOn|B|();|FCT1.10|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|fonction de calcul et/ou détermination du temps d’activation du signal de commande de chauffage pendant cette période|
HEATSENO2DSCMD_vidDriverCmd|D|();|FCT2.1|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|fonction de  calcul de la sortie calculateur commandant le transistor de gestion du chauffage de la sonde|
HEATSENO2DSCMD_vidEntryInit|A|();|SCH.1|HEATSENO2DSCMD|1|V02 NT 09 04727||||0|0|0|0|Fonction d'accroche à l'événement Reset|
HEATSENO2DSCMD_vidInitOutput|D|();|FCT1.1|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|fonction d'initialisation des sorties.|
HEATSENO2DSCMD_vidLsUsHeatCmd|B|();|FCT1.8|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|L’objectif de ce module est la génération du signal de commande du transistor régissant le chauffage de la sonde à oxygène aval.|
HEATSENO2DSCMD_vidLsUsHeatCor|D|();|FCT1.5|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|Ce module permet de prendre en compte la tension batterie dans le calcul de la puissance de chauffage de la sonde, en corrigeant la valeur du signal RCO brut(une hausse du signal traduisant une baisse de la tension batterie)|
HEATSENO2DSCMD_vidLsUsHeatDiag|E|();|FCT1.6|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|Afin de pouvoir diagnostiquer un éventuel court-circuit au niveau du driver de puissance du chauffage sonde, la commande de chauffage est volontairement annulée de façon périodique|
HEATSENO2DSCMD_vidLsUsHeatMan|C|();|FCT1.4|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|Ce bloc prévoit l’utilisation d’un mode banc pour le signal de commande du chauffage sonde aval.|
HEATSENO2DSCMD_vidLsUsHeatRaw|D|();|FCT1.2|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|Ce module calcule la puissance de chauffage de la sonde O2, qui doit être adaptée en fonction des phases de vie du véhicule|
HEATSENO2DSCMD_vidLsUsHeatReq|C|();|FCT1.7|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|La puissance de chauffage précédemment calculée est remplacée par la valeur nulle lorsque le mode dégradé de fonctionnement est activé ou en cas de surtension batterie.|
HEATSENO2DSCMD_vidLsUsHeatTst|A|();|FCT2.2|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|Ce bloc provisionne l’interface permettant d’effectuer le test actionneur chauffage sonde O2 aval.|
HEATSENO2DSCMD_vidSlopHeat|D|();|FCT1.3|HEATSENO2DSCMD|0|V02 NT 09 04727||||0|0|0|0|Ce bloc met à jour les valeurs maximales de variation des puissances de chauffe lors des changements de phase de chauffage sonde aval ;|
HEATSENO2DSDERIDIAG_vidAvgEwma|D|();|FCT2.1|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Calcul de la moyenne de type EWMA (Exponentially Weighted Moving Average)|
HEATSENO2DSDERIDIAG_vidAvgPnd|E|();|FCT1.10|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Calcul de la moyenne pondérée de la tension sonde aval|
HEATSENO2DSDERIDIAG_vidCalcAvg|D|();|FCT1.9|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Pour chaque mesure réussie de la décroissance de la tension sonde aval, le bloc de calcul s’active une fois et effectue le calcul des moyennes et la synthése de diagnostic.|
HEATSENO2DSDERIDIAG_vidDiag|E|();|FCT2.7|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Un nombre calibrable (Ldsd_trk_sonde_ok_thresh) indique le nombre de fois où le compteur (cf bloc 1_Ldsd_trk_pannes) doit être incrémenté pour déclarer la sonde sans défaut.|
HEATSENO2DSDERIDIAG_vidDiagSO2Ok|D|();|FCT2.4|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Ce bloc renvoie la dernière valeur de la moyenne EWMA supérieure au seuil Ldsd_trk_ewma_thresh.|
HEATSENO2DSDERIDIAG_vidDiaSO2Nok|D|();|FCT2.5|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Ce bloc renvoie la dernière valeur de la moyenne EWMA inférieure au seuil Ldsd_trk_ewma_thresh.|
HEATSENO2DSDERIDIAG_vidFacMes|B|();|FCT3.3|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|La valeur envoyée au ScanTool mode06 est mise à jour lorsque le résultat du diag est disponible (autrement dit bMonRun à 1)|
HEATSENO2DSDERIDIAG_vidFirstDiag|E|();|FCT2.3|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|A la fin du roulage, la valeur de EWMA(t) est stockée en EEPROM pour servir de conditions initiales pour le prochain roulage.|
HEATSENO2DSDERIDIAG_vidFirstTime|D|();|FCT2.2|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Lors du premier roulage, la valeur initiale de la moyenne EWMA est fixée à la première valeur calculée de la moyenne pondérée.|
HEATSENO2DSDERIDIAG_vidGasGsl|C|();|FCT1.4|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|La valeur de la moyenne des pente enregistrée en EEPROM Ldsd_trk_ewma_eep est initialisée à sa valeur maximum 5000 (FFFF en Hexadécimal) afin de différencier le premier cycle de roulage.|
HEATSENO2DSDERIDIAG_vidGslGas|C|();|FCT1.3|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|La valeur de la moyenne des pente enregistrée en EEPROM Ldsd_trk_ewma_eep est initialisée à sa valeur maximum 5000 (FFFF en Hexadécimal) afin de différencier le premier cycle de roulage.|
HEATSENO2DSDERIDIAG_vidIniOutput|E|();|FCT1.1|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Fonction d'initialisation|
HEATSENO2DSDERIDIAG_vidInitGaz|C|();|FCT3.2|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Cette fonction permet d’initialiser la valeur de la moyenne de tension de type EWMA.|
HEATSENO2DSDERIDIAG_vidInitGsl|C|();|FCT3.1|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Cette fonction permet d’initialiser correctement les variables de la fonction diagnostic  dérivée sonde aval ainsi qu'elle indique si on effectue le premier roulage.|
HEATSENO2DSDERIDIAG_vidInitTran|C|();|FCT1.2|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Ce bloc permet la réinitialisation du diagnostic lors des transitions essence ver gaz, ou gaz vers essence lorsque l’application gaz est applicable.|
HEATSENO2DSDERIDIAG_vidSavePwrl|C|();|FCT2.9|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Sauvegarde en  EEPROM de la moyenne de tension Ldsd_trk_ewma_eep au powerlatch.|
HEATSENO2DSDERIDIAG_vidSeqDiag|E|();|FCT2.8|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Le booléen de calibration SenO2Ds_bAcvSeqSigGrdDiag_C permet d'inhiber le séquencement.Le booléen SenO2Ds_bAcvSeqSigGrdDiag indique que le séquenceur est actif.|
HEATSENO2DSDERIDIAG_vidSigEuro6|B|();|FCT3.4|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Les variables finales envoyées au Mode06 (FacMes, FacMin) sont gelées lorsque la panne est présente mais non encore confirmée par le GD/GAR|
HEATSENO2DSDERIDIAG_vidSwitch|C|();|FCT2.10|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Cette fonction permet d’initialiser les variables dépendantes de la présence d’une application Gaz et le cas échéant, du mode carburant utilisé au moment de la réception de la première trame Gaz.|
HEATSENO2DSDERIDIAG_vidTrkCond|G|();|FCT1.6|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Ce bloc regroupe les conditions d’activation à vérifier pour valider le démarrage de la fonction diagnostic|
HEATSENO2DSDERIDIAG_vidTrkDiag|D|();|FCT1.8|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Le diagnostic s’active lorsque l’on est dans l’état LDSD_TRK_DIAG_THRESH_MIN, ce qui correspond à la fin d’une pente, la valeur de la pente sera alors rajoutée à la moyenne générale et au bout d’un certain nombre de pentes calculées.|
HEATSENO2DSDERIDIAG_vidTrkInit|E|();|FCT1.5|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|La valeur de la moyenne des pente enregistrée en EEPROM Ldsd_trk_ewma_eep est initialisée à sa valeur maximum 5000 afin de différencier le premier cycle de roulage.|
HEATSENO2DSDERIDIAG_vidTrkMgr|G|();|FCT1.7|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|Ce bloc mesure les paramètres nécessaires au calcul de la dérivée de la décroissance de la tension sonde aval|
HEATSENO2DSDERIDIAG_vidTrkNormal|E|();|FCT2.6|HEATSENO2DSDERIDIAG|0|PTS_DOC_5012852||||0|0|0|0|A la fin du roulage, la valeur de EWMA(t) est stockée en EEPROM pour servir de conditions initiales pour le prochain roulage.|
HEATSENO2DSFONCDIAG_vidAcvDgBva|B|();|FCT4.6|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Demande diagnostic intrusif pour la sonde aval|
HEATSENO2DSFONCDIAG_vidAcvDiag|B|();|FCT3.6|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Demande diagnostic intrusif pour la sonde aval|
HEATSENO2DSFONCDIAG_vidAvFDiag|C|();|FCT1.2|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Le diagnostic fonctionnel est décomposé en plusieurs parties : On vérifie si les conditions sont réuni pour effectuer le diagnostique et On détermine le type de diagnostic.|
HEATSENO2DSFONCDIAG_vidCalcDiag|H|();|FCT1.9|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Activation du diagnostic|
HEATSENO2DSFONCDIAG_vidCheckrMCy|A|();|FCT5.5|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Vérifier si la consigne de richesse est supérieure ou égale au créneau riche demandé.Sinon, la demande de créneau est annulée puis relancée après l’écoulement d’une temporisation.|
HEATSENO2DSFONCDIAG_vidChMCyBva|A|();|FCT5.7|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Vérifier si la consigne de richesse est inférieure ou égale au créneau riche demandé. Sinon, la demande de créneau est annulée puis relancée après l’écoulement d’une temporisation.|
HEATSENO2DSFONCDIAG_vidCondDiag|L|();|FCT1.6|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Le diagnostic fonctionnel n'est effectué qu'a certaines conditions.|
HEATSENO2DSFONCDIAG_vidDecTConfD|D|();|FCT2.1|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Decrementation de Ldsd_av_f_diag_confirm_count|
HEATSENO2DSFONCDIAG_vidDecTempo|C|();|FCT1.8|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Decrementation de Ldsd_av_diag_ai_count|
HEATSENO2DSFONCDIAG_vidDgCntBva|D|();|FCT4.2|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Fonction de calcul de temporisation de confirmation du seuil minimum atteint.|
HEATSENO2DSFONCDIAG_vidDgInDnBva|B|();|FCT4.8|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Mise de LsMon_bItrsvSenO2DsDiagDoneFco à 1|
HEATSENO2DSFONCDIAG_vidDgIntrBva|F|();|FCT4.1|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Ce bloc correspond à la mise à jour du diagnostic « Sonde aval bloquée riche », pour l’application Euro 5+ avec IUPR.|
HEATSENO2DSFONCDIAG_vidDiag|H|();|FCT1.10|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Le diagnostic vérifie que les valeurs de la tension sonde sont cohérentes|
HEATSENO2DSFONCDIAG_vidDiagCount|D|();|FCT3.2|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Fonction de calcul de temporisation de confirmation du seuil minimum atteint.|
HEATSENO2DSFONCDIAG_vidDiagIhBva|A|();|FCT5.3|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Lancement des fonctions de diagnostic|
HEATSENO2DSFONCDIAG_vidDiagInDon|C|();|FCT3.8|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Mise de LsMon_bItrsvSenO2DsDiagDone à 1|
HEATSENO2DSFONCDIAG_vidDiagInInh|C|();|FCT3.9|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Mise de LsMon_bAcvItrsvSenO2DsDiag à 0|
HEATSENO2DSFONCDIAG_vidDiagIntru|I|();|FCT3.1|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Lancement des fonctions de diagnostic.|
HEATSENO2DSFONCDIAG_vidDsDgOKBva|B|();|FCT4.3|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Fonction de calcul résultat du diagnostic sonde aval|
HEATSENO2DSFONCDIAG_vidDsDiagOK|C|();|FCT3.3|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Fonction de calcul résultat du diagnostic sonde aval bloquée pauvre|
HEATSENO2DSFONCDIAG_vidFcoMdEr6|A|();|FCT5.1|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Ce bloc permet de respecter les exigences euro6.|
HEATSENO2DSFONCDIAG_vidFcoObd6M|C|();|FCT2.5|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Comptage panne fco|
HEATSENO2DSFONCDIAG_vidFldMdEr6|A|();|FCT5.2|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Ce bloc permet de respecter les exigences euro6.|
HEATSENO2DSFONCDIAG_vidFldObd6M|C|();|FCT2.4|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|comptage panne fld|
HEATSENO2DSFONCDIAG_vidFldOrFco|D|();|FCT1.3|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Le diagnostic est déclenché dans deux cas de vie :  Soit coupure injection  ou Etat pleine charge avec dépassement d'un seuil d'objectif de richesse sans misfire|
HEATSENO2DSFONCDIAG_vidIncCtDiag|C|();|FCT1.4|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Comptage du diagnostic|
HEATSENO2DSFONCDIAG_vidIniAvDiag|I|();|FCT1.1|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Fonction d'initialisation des parametres|
HEATSENO2DSFONCDIAG_vidIniTConfD|C|();|FCT2.2|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Initialisation de Ldsd_av_f_diag_confirm_count|
HEATSENO2DSFONCDIAG_vidInitDiag|C|();|FCT1.5|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Initialisation du diagnostic|
HEATSENO2DSFONCDIAG_vidInitDiag1|B|();|FCT2.8|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Initialisation des compteurs du diagnostic sonde aval.|
HEATSENO2DSFONCDIAG_vidInitTempo|D|();|FCT1.7|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Initialisation de Ldsd_av_diag_ai_count|
HEATSENO2DSFONCDIAG_vidInMod6Bva|B|();|FCT4.7|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Fonction de renvoie de valeur minimale au mode $06 du scantool .|
HEATSENO2DSFONCDIAG_vidIntrMode6|B|();|FCT3.7|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Fonction de renvoie de valeur minimale au mode $06 du scantool .|
HEATSENO2DSFONCDIAG_vidIsDgNOKBv|B|();|FCT4.5|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Demande diagnostic intrusif pour la sonde aval|
HEATSENO2DSFONCDIAG_vidIsDgOKBva|C|();|FCT4.4|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Demande diagnostic intrusif pour la sonde aval|
HEATSENO2DSFONCDIAG_vidItrsvFco|B|();|FCT4.10|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|La valeur du créneau de richesse est remise à jour uniquement lorsque le défaut est en cours de confirmation, afin que les diagnostics « bloqué riche » et « bloqué pauvre »  ne demandent pas simultanément un créneau à des valeurs antagonistes.|
HEATSENO2DSFONCDIAG_vidItrsvFld|B|();|FCT4.9|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|La valeur du créneau de richesse est remise à jour uniquement lorsque le défaut est en cours de confirmation afin que les diagnostics « bloqué riche » et « bloqué pauvre »  ne demandent pas simultanément un créneau à des valeurs antagonistes.|
HEATSENO2DSFONCDIAG_vidItsDiaNOK|C|();|FCT3.5|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Demande diagnostic intrusif pour la sonde aval|
HEATSENO2DSFONCDIAG_vidItsDiaOK|D|();|FCT3.4|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Demande diagnostic intrusif pour la sonde aval .|
HEATSENO2DSFONCDIAG_vidMode6|G|();|FCT2.3|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Dans ce bloc on enregistre les dernières valeurs de la tension sonde aval dans le cas d’une panne sonde aval bloquée riche et sonde aval bloquée pauvre.|
HEATSENO2DSFONCDIAG_vidModTran|B|();|FCT2.7|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Ce bloc permet la réinitialisation du diagnostic lors des transitions essence ver gaz ou gaz vers essence.|
HEATSENO2DSFONCDIAG_vidSeqFld|D|();|FCT2.6|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Le diagnostic de la sonde aval bloquée pauvre est séquencé par le diagnostic "condition" chauffage sonde aval.|
HEATSENO2DSFONCDIAG_vidtrsvCount|A|();|FCT5.4|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Vérifier si la consigne de richesse est supérieure ou égale au créneau riche demandé. Sinon, la demande de créneau est annulée puis relancée après l’écoulement d’une temporisation.|
HEATSENO2DSFONCDIAG_vidtrsvCtBva|A|();|FCT5.6|HEATSENO2DSFONCDIAG|0|V02 NT 11 07942||||0|0|0|0|Vérifier si la consigne de richesse est inférieure ou égale au créneau riche demandé. Sinon, la demande de créneau est annulée puis relancée après l’écoulement d’une temporisation.|
HEATSENO2HOTDIAG_vidDsHDiagCalc|G|();|FCT1.10|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|La valeur donnée par Rchauff_SO2Ds est la résistance de chauffage de la sonde aval. Enfin on compare Rchauff_SO2Ds à un seuil qui dépend de la température du catalyseur.|
HEATSENO2HOTDIAG_vidDsHDiagCond|G|();|FCT1.9|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|Le diagnostique ne se lance qu’a la fin d’une temporisation Ds_heat_transit_count après le passage de OFF à ON de la commande de chauffage de la sonde aval.|
HEATSENO2HOTDIAG_vidDsheat|D|();|FCT1.8|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|Appel des fonctions HEATSENO2HOTDIAG_vidDsHDiagCond et HEATSENO2HOTDIAG_vidDsHDiagCalc|
HEATSENO2HOTDIAG_vidDsHeat_Euro6|A|();|FCT2.2|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|Les variables finales envoyées au Mode06 (FacMes, FacMax) sont gelées lorsque la panne est présente mais non encore confirmée par le GD/GAR. Si on calibreHeatSenO2_bAcvEuro6DsHeat_C à 0, on revient sur le fonctionnel d’origine (EB).|
HEATSENO2HOTDIAG_vidInit|B|();|FCT1.4|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|Initialization of module outputs|
HEATSENO2HOTDIAG_vidInitCbModTrn|B|();|FCT1.3|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|Initialisation du diagnostic lors des transitions essence vers gaz, ou gaz vers essence|
HEATSENO2HOTDIAG_vidInitOutput|C|();|FCT1.1|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|Initialization of module outputs|
HEATSENO2HOTDIAG_vidTgInitCbMdTn|B|();|FCT1.2|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|Cette fonction permet la réinitialisation du diagnostic lors des transitions essence ver gaz, ou gaz vers essence (lorsque l’application gaz est applicable)|
HEATSENO2HOTDIAG_vidUsHDiagCalc|H|();|FCT1.7|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|La valeur donnée par Rchauff_SO2Us est la résistance de chauffage de la sonde amont. Enfin  on   compare Rchauff_SO2Us à un seuil qui dépend de la température des gazes d’échappement.|
HEATSENO2HOTDIAG_vidUsHDiagCond|G|();|FCT1.6|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|Le diagnostique ne se lance qu’a la fin d’une temporisation Us_heat_transit_count après le passage de OFF à ON de la commande de chauffage de la sonde amont.|
HEATSENO2HOTDIAG_vidUsheat|D|();|FCT1.5|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|Appel des fonctions HEATSENO2HOTDIAG_vidUsHDiagCond et HEATSENO2HOTDIAG_vidUsHDiagCalc|
HEATSENO2HOTDIAG_vidUsHeat_Euro6|A|();|FCT2.1|HEATSENO2HOTDIAG|0|V02 NT 12 00470||||0|0|0|0|Les variables finales envoyées au Mode06 (FacMes, FacMax) sont gelées lorsque la panne est présente mais non  encore confirmée par le GD/GAR. Si on calibre HeatSenO2_bAcvEuro6UsHeat_C à 0, on revient sur le fonctionnel  d’origine (EB).|
HEATSENO2UPFONCDIAG_vidAmFDiag|D|();|FCT1.2|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Le diagnostic fonctionnel est décomposé en plusieurs parties : On vérifie si les conditions sont réuni pour effectuer le diagnostique et On détermine le type de diagnostic.|
HEATSENO2UPFONCDIAG_vidCalcDiag|F|();|FCT1.9|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Activation du diagnostic|
HEATSENO2UPFONCDIAG_vidCondDiag|K|();|FCT1.6|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Le diagnostic fonctionnel n'est effectué qu'a certaines conditions.|
HEATSENO2UPFONCDIAG_vidDecTConfD|E|();|FCT2.1|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Decrementation de Ldsd_am_f_diag_confirm_count|
HEATSENO2UPFONCDIAG_vidDecTempo|D|();|FCT1.7|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Decrementation de Ldsd_am_diag_ai_count|
HEATSENO2UPFONCDIAG_vidDiag|I|();|FCT1.10|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Le diagnostic vérifie que les valeurs de la tension sonde sont cohérentes|
HEATSENO2UPFONCDIAG_vidDiagCount|C|();|FCT2.10|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Le diagnostic vérifie si la tension de la sonde amont est bien au-dessus d’un certain seuil.|
HEATSENO2UPFONCDIAG_vidFcoMdEr6|C|();|FCT3.2|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Ce bloc permet de respecter les exigences euro6.|
HEATSENO2UPFONCDIAG_vidFcoObd6M|D|();|FCT2.5|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Comptage panne fco|
HEATSENO2UPFONCDIAG_vidFldMdEr6|B|();|FCT3.3|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Ce bloc permet de respecter les exigences euro6.|
HEATSENO2UPFONCDIAG_vidFldObd6M|D|();|FCT2.4|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|comptage panne fld|
HEATSENO2UPFONCDIAG_vidFldOrFco|E|();|FCT1.3|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Le diagnostic est déclenché dans deux cas de vie :  Soit coupure injection  ou Etat pleine charge avec dépassement d'un seuil d'objectif de richesse sans misfire|
HEATSENO2UPFONCDIAG_vidIncCtDiag|D|();|FCT1.4|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Comptage du diagnostic|
HEATSENO2UPFONCDIAG_vidIniAmDiag|I|();|FCT1.1|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Fonction d'initialisation des parametres|
HEATSENO2UPFONCDIAG_vidIniTConfD|E|();|FCT2.2|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Initialisation de Ldsd_am_f_diag_confirm_count|
HEATSENO2UPFONCDIAG_vidInitDiag|E|();|FCT1.5|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Initialisation du diagnostic|
HEATSENO2UPFONCDIAG_vidInitModTr|C|();|FCT2.8|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Initialisation des compteurs du diagnostic sonde amont.|
HEATSENO2UPFONCDIAG_vidInitTempo|E|();|FCT1.8|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Initialisation de Ldsd_am_diag_ai_count|
HEATSENO2UPFONCDIAG_vidIntmpDiag|B|();|FCT3.4|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Lancement des fonctions de diagnostic|
HEATSENO2UPFONCDIAG_vidMode6|H|();|FCT2.3|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Dans ce bloc on enregistre les dernières valeurs de la tension sonde amont dans le cas d’une panne sonde amont bloquée riche et sonde amont bloquée pauvre.|
HEATSENO2UPFONCDIAG_vidModTran|C|();|FCT2.7|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Ce bloc permet la réinitialisation du diagnostic lors des transitions essence ver gaz ou gaz vers essence.|
HEATSENO2UPFONCDIAG_vidNormDiag|E|();|FCT2.9|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Ce bloc correspond à la mise à jour du diagnostic « Sonde amont bloquée pauvre »,pour l’application Euro 5+ avec IUPR. Le diagnostic vérifie si la tension de la sonde amont est bien au-dessus d’un certain seuil.|
HEATSENO2UPFONCDIAG_vidNormMod06|C|();|FCT3.1|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Ce bloc Vérifie si la tension de la sonde amont est bien au-dessus d’un certain seuil.|
HEATSENO2UPFONCDIAG_vidSeqFld|E|();|FCT2.6|HEATSENO2UPFONCDIAG|0|PTS_DOC_5482727||||0|0|0|0|Le diagnostic de la sonde amont bloquée pauvre est séquencé par le diagnostic "condition" chauffage sonde amont.|
HEATSENO2UPPERDDIAG_vidApvPMonit|E|();|FCT3.10|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Séquenceur du diagnostic OxyApvPerd|
HEATSENO2UPPERDDIAG_vidCalcPerdL|C|();|FCT2.1|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Afin d’anticiper l’allumage de la MIL sur défaut de période du signal de la sonde à oxygène amont, un seuil intermédiaire " agrément " a été ajouté|
HEATSENO2UPPERDDIAG_vidCalcPerdR|C|();|FCT2.10|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Afin d’anticiper l’allumage de la MIL sur défaut de période du signal de la sonde à oxygène amont, un seuil intermédiaire " agrément " a été ajouté|
HEATSENO2UPPERDDIAG_vidcallGDU|B|();|FCT4.9|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Les appels au GDU se font sur front montant des bMonRun.|
HEATSENO2UPPERDDIAG_vidCntLean|D|();|FCT1.6|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Incrémentation de la variable Oxy_ups_tempo_lean|
HEATSENO2UPPERDDIAG_vidCntRich|D|();|FCT1.8|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Incrémentation de la variable Oxy_ups_tempo_rich|
HEATSENO2UPPERDDIAG_vidCompPerL|B|();|FCT2.2|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|calcul de Oxy_ups_period|
HEATSENO2UPPERDDIAG_vidCompPerR|B|();|FCT3.1|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Calcul de Oxy_ups_period.|
HEATSENO2UPPERDDIAG_vidCorLean|C|();|FCT5.3|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Cette fonction fait le bilan des pannes  présentes concernant la période pauvre|
HEATSENO2UPPERDDIAG_vidCorRich|C|();|FCT5.2|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Cette fonction fait le bilan des pannes  présentes concernant la période riche|
HEATSENO2UPPERDDIAG_vidCounters|D|();|FCT1.5|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Compteurs temporels pour le calcul de la période|
HEATSENO2UPPERDDIAG_vidCpThdApvR|B|();|FCT3.3|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Ici le seuil max apv est calculé et moyenné. De plus, si l’application GPL/GNV est active, les seuils utilisés sont spécifiques à cette application.|
HEATSENO2UPPERDDIAG_vidCpThdSnsR|B|();|FCT3.2|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Ici le seuil max est calculé et moyenné. De plus, si l’application GPL/GNV est active, les seuils utilisés sont spécifiques à cette application.|
HEATSENO2UPPERDDIAG_vidCrPrdLean|C|();|FCT4.10|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Cette fonction fait le bilan des pannes  présentes concernant la période pauvre|
HEATSENO2UPPERDDIAG_vidCrPrdRich|C|();|FCT5.1|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Cette fonction fait le bilan des pannes  présentes concernant la période riche|
HEATSENO2UPPERDDIAG_vidCtThdApvL|B|();|FCT2.4|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Ici le seuil max apv est calculé et moyenné. De plus, si l’application GPL/GNV est active, les seuils utilisés sont spécifiques à cette application.|
HEATSENO2UPPERDDIAG_vidCtThdsnsL|B|();|FCT2.3|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Ici le seuil max est calculé et moyenné. De plus, si l’application GPL/GNV est active, les seuils utilisés sont spécifiques à cette application.|
HEATSENO2UPPERDDIAG_vidDiagCompl|D|();|FCT3.8|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Détecte et comptabilise la fin du diagnostic|
HEATSENO2UPPERDDIAG_vidDiagCond|I|();|FCT1.3|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Cette fonction définit les conditions de diagnostic par rapport à l’état moteur et aux paramètres de celui-ci|
HEATSENO2UPPERDDIAG_vidEfLeanCal|C|();|FCT4.5|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Calcul du période instantanée|
HEATSENO2UPPERDDIAG_vidEfRichCal|C|();|FCT4.6|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Calcul du période instantannée|
HEATSENO2UPPERDDIAG_vidIniCnLean|C|();|FCT1.7|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Initialisation de la variable Oxy_ups_tempo_lean|
HEATSENO2UPPERDDIAG_vidIniCnRich|C|();|FCT1.9|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Initialisation de la variable Oxy_ups_tempo_rich|
HEATSENO2UPPERDDIAG_vidIniOutput|G|();|FCT1.2|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Initialisation des sorties|
HEATSENO2UPPERDDIAG_vidInit|E|();|FCT1.1|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Met à zéro certaines variables au début du calcul|
HEATSENO2UPPERDDIAG_vidInitCbTrn|C|();|FCT4.2|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Initialisation du diagnostic lors des transitions essence vers gaz, ou gaz vers essence|
HEATSENO2UPPERDDIAG_vidIniTimers|C|();|FCT4.3|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Fonction d'initialisation des timers|
HEATSENO2UPPERDDIAG_vidOsPFaultL|D|();|FCT2.5|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Reporter la période fausse de la sonde pauvre à l'OS|
HEATSENO2UPPERDDIAG_vidOsPFaultR|D|();|FCT3.4|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Reporter la période fausse de la sonde riche à l'OS|
HEATSENO2UPPERDDIAG_vidPerDgApv|B|();|FCT4.8|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Les variables accompagnant l’information panne (bMonRun, bMonWait) sont redéfinies afin d’intégrér l’ensemble de la fonctionnalité dans le seul flux SenO2Us_bMonRunORng_OxyApvPerd.|
HEATSENO2UPPERDDIAG_vidPerDgSens|B|();|FCT4.7|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Les variables finales envoyées au Mode06 (FacMes, FacMax) sont gelées lorsque la panne est présente mais non encore confirmée par le GD/GAR.|
HEATSENO2UPPERDDIAG_vidPerdLean|F|();|FCT1.10|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Cette fonction fait le bilan des pannes présentes concernant la période, les temps de réponse et le mark space ratio|
HEATSENO2UPPERDDIAG_vidPerdRich|F|();|FCT2.9|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Cette fonction fait le bilan des pannes présentes concernant la période, les temps de réponse et le mark space ratio|
HEATSENO2UPPERDDIAG_vidPerTest|B|();|FCT3.6|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Une fois le nombre d’échantillon souhaité atteint, on effectue la comparaison entre la moyenne des périodes et la moyenne des seuils.|
HEATSENO2UPPERDDIAG_vidPMonitor|E|();|FCT3.9|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Séquenceur du diagnostic OxySensPerd|
HEATSENO2UPPERDDIAG_vidReInPrTst|B|();|FCT3.7|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Calcul de Os_period_tests_done. Initialisation de Oxy_period_tests.|
HEATSENO2UPPERDDIAG_vidReIntPer|B|();|FCT2.8|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|calcul de Os_period_tests_done. Initialisation du Oxy_period_tests.|
HEATSENO2UPPERDDIAG_vidRepOsPFlL|E|();|FCT2.6|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Calculer la période fausse de la sonde pauvre|
HEATSENO2UPPERDDIAG_vidRepOsPFlR|E|();|FCT3.5|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Calculer la période fausse de la sonde riche|
HEATSENO2UPPERDDIAG_vidSensPerEf|C|();|FCT4.4|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Production du rapport d’efficacité de la période sonde amont|
HEATSENO2UPPERDDIAG_vidsnsPTest|B|();|FCT2.7|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Une fois le nombre d’échantillon souhaité atteint, on effectue la comparaison entre la moyenne des périodes et la moyenne des seuils.|
HEATSENO2UPPERDDIAG_vidStateMgr|H|();|FCT1.4|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Diagramme d’état qui défini l’état dans lequel la sonde se trouve et créé les balises pour le calcul de la période|
HEATSENO2UPPERDDIAG_vidTgInitTrn|C|();|FCT4.1|HEATSENO2UPPERDDIAG|0|PTS_DOC_5012863||||0|0|0|0|Cette fonction permet la réinitialisation du diagnostic lors des transitions essence ver gaz, ou gaz vers essence (lorsque l’application gaz est applicable)|
HEATSENO2US_vidAcvHeatWku|C|();|FCT3.2|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|La fonction chauffage sonde doit être active au réveil partiel, notamment pour pouvoir réaliser le préchauffage sonde|
HEATSENO2US_vidDetDewPt|G|();|FCT1.6|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Détermination du passage du  du point de rosée en fonction de la durée du chauffage de protection|
HEATSENO2US_vidDetDewPtRev|D|();|FCT1.5|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Déterminer au bout de combien de temps la sonde  va franchir le point de rosée à l’envers|
HEATSENO2US_vidDisableFLO|C|();|FCT1.10|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Lorsque le moteur se trouve dans le phase d’un redémarrage STT, le Fast Light Off n’est plus autorisée et ceci jusqu’au prochain Driving Cycle|
HEATSENO2US_vidDlyDewPt|C|();|FCT1.7|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Lorsque le point de rosée est considéré comme franchi, un compteur s’active afin de connaître depuis combien de temps le point de rosée est franchi et est entretenu par les gaz d’échapements|
HEATSENO2US_vidDlyDewTranOkStall|C|();|FCT1.8|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Détermination de la durée pendant laquelle la sonde à oxygène a été chauffée par les gaz d’échappements depuis le franchissement du point de rosée|
HEATSENO2US_vidFastLightOff|I|();|FCT1.9|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Condition d'activation du Fast Light Off|
HEATSENO2US_vidInitOutput|I|();|FCT1.1|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Initialisation des variables au reset|
HEATSENO2US_vidLsUsDetRTStall|A|();|FCT3.7|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0| Lors de la détection du passage de l’état moteur « Running » vers Stall, la variable est mise à 1.|
HEATSENO2US_vidLsUsDetRTStallint|A|();|FCT3.6|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0| Lors de la détection d’un passage de l’état moteur stall vers cranking ou d’état moteur cranking vers running, la variable est mise à zéro.|
HEATSENO2US_vidLsUsDewPt|H|();|FCT1.4|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Détection du passage du point de rosée pour la sonde O2 amont|
HEATSENO2US_vidLsUsMgrHeatState|J|();|FCT2.9|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Automate de gestion des phases de chauffage de la sonde O2 amont|
HEATSENO2US_vidMgrFastTran|J|();|FCT2.1|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Lorsqu'une surtension batterie est présente, le chauffage sonde est placé en mode dégradé et le chauffage est donc coupé|
HEATSENO2US_vidMgrMidTran|H|();|FCT2.2|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Calcul de toutes les transitions ayant un chauffage non nul et détermination du délai avant réautorisation du chauffage maximal|
HEATSENO2US_vidMgrSlowTran|G|();|FCT2.7|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Lorsque l’automate se trouve en chauffage réduit trop longtemps, le chauffage est coupé pour limiter la consommation électrique.|
HEATSENO2US_vidOxCHeatAftStrt|D|();|FCT1.3|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Afin de détecter au mieux le passage du point de rosée, l’état de la chauffe catalyseur doit être pris en compte|
HEATSENO2US_vidOxCHeatReq|H|();|FCT2.10|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Requête de maintien de la chauffe catalyseur en cas de stratégie FLO|
HEATSENO2US_vidTCoLsHeat|F|();|FCT1.2|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Lorsque l’information température d’eau (Ext_tCoMes) n’est pas valide, celle-ci doit être reconfigurée pour l’ensemble de la fonction par une valeur de remplacement calibrable|
HEATSENO2US_vidTDsThrLsHeat|B|();|FCT3.5|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Lorsque l'information température air (Ext_tDsThrStrtMes) n'est pas valide, celle-ci doit être reconfigurée pour l'ensemble de la  fonction par une valeur de remplacement calibrable.|
HEATSENO2US_vidTranAtoBandBtoA|C|();|FCT3.3|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Pour activer le préchauffage il faut notamment une tension batterie suffisamment élevée, les conditions de fast light off réunies, que le préchauffage n’ait pas déjà été effectué.|
HEATSENO2US_vidTranAToCOrAToE|H|();|FCT2.3|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Lorsque le l’automate se trouve en phase de chauffage coupé, il peut activer le chauffa  ge de protection si la sonde est considérée froide ou activer le chauffage modulé si la sonde est considérée chaude|
HEATSENO2US_vidTranC1ToC2|E|();|FCT3.1|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Cette fonction autorise la transition de la phase C1 à C2 lorsqu’un temps passé LsSys_tiLsUsBoostProtReq en phase C1 dépasse un seuil calibrable dépendant de la température d’eau.|
HEATSENO2US_vidTranCToD|H|();|FCT2.4|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Le passage en chauffage maximal se réalise si on estime que la sonde a suffisamment été chauffé en phase de préchauffage, en phase de protection ou dans le dernier cycle moteur|
HEATSENO2US_vidTranCToEOrDToE|I|();|FCT2.5|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Conditions de transition vers le chauffage modulé de la sonde O2 amont|
HEATSENO2US_vidTranEToF|G|();|FCT2.6|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Conditions de transition vers le chauffage réduit pour la sonde amont|
HEATSENO2US_vidTranFToA|G|();|FCT2.8|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Transition du chauffage réduit au chauffage coupé de la sonde amont|
HEATSENO2US_vidTReCoLsHeat|B|();|FCT3.4|HEATSENO2US|0|PTS_DOC_5211932||||0|0|0|0|Reconfiguration de l'ensemble des informations Température d'eau et Température d'air eronnés par une valeur de remplacement calibrable.|
HEATSENO2USCMD_vidCalcPwmPeriod|B|();|FCT1.9|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|fonction de calcul et/ou  détermination de la période du signal de commande de chauffage|
HEATSENO2USCMD_vidCalculTimeOn|B|();|FCT1.10|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|fonction de calcul et/ou  détermination du temps d’activation du signal de commande de chauffage pendant cette période|
HEATSENO2USCMD_vidDriverCmd|E|();|FCT2.1|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|fonction de calcul de la sortie calculateur commandant le transistor de gestion du chauffage de la sonde|
HEATSENO2USCMD_vidEntryInit|A|();|SCH.1|HEATSENO2USCMD|1|V02 NT 09 04308||||0|0|0|0|Fonction d'accroche à l'événement Reset|
HEATSENO2USCMD_vidInitOutput|D|();|FCT1.1|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|fonction d'initialisation des sorties.|
HEATSENO2USCMD_vidLsUsHeatCmd|D|();|FCT1.8|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|L’objectif de ce module est la génération du signal de commande du transistor régissant le chauffage de la sonde à oxygène amont.|
HEATSENO2USCMD_vidLsUsHeatCor|E|();|FCT1.5|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|Ce module permet de prendre en compte la tension batterie dans le calcul de la puissance de chauffage de la sonde, en corrigeant la valeur du signal RCO brut (une hausse du signal traduisant une baisse de la tension batterie) :|
HEATSENO2USCMD_vidLsUsHeatDiag|F|();|FCT1.6|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|Afin de pouvoir diagnostiquer un éventuel court-circuit au niveau du driver de puissance du chauffage sonde, la commande de chauffage est volontairement annulée de façon périodique|
HEATSENO2USCMD_vidLsUsHeatMan|D|();|FCT1.4|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|Ce bloc prévoit l’utilisation d’un mode banc pour le signal de commande du chauffage sonde amont.|
HEATSENO2USCMD_vidLsUsHeatRaw|F|();|FCT1.2|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|Ce module calcule la puissance de chauffage de la sonde O2, qui doit être adaptée en fonction des phases de vie du véhicule.|
HEATSENO2USCMD_vidLsUsHeatReq|D|();|FCT1.7|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|La puissance de chauffage précédemment calculée est remplacée par la valeur nulle lorsque le mode dégradé de fonctionnement est activé ou en cas de surtension batterie.|
HEATSENO2USCMD_vidLsUsHeatTst|A|();|FCT2.2|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|Ce bloc provisionne l’interface permettant d’effectuer le test actionneur chauffage sonde O2 amont.|
HEATSENO2USCMD_vidSlopHeat|E|();|FCT1.3|HEATSENO2USCMD|0|V02 NT 09 04308||||0|0|0|0|Ce bloc met à jour les valeurs maximales de variation des puissances de chauffe lors des changements de phase de chauffage sonde amont|
HOTSENO2FLG_vidDetHotLsDs|B|();|FCT2.10|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|Inversement lorsque l’automate retourne dans les phases de chauffage réduit ou nulle (A, F ou G) la sonde est déclarée froide au bout d’une certaine durée.|
HOTSENO2FLG_vidDetHotLsUS|B|();|FCT2.9|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|Inversement lorsque l’automate retourne dans les phases de chauffage reduit ou nulle (A, F ou G) la sonde est déclarée froide au bout d’une certaine duree.|
HOTSENO2FLG_vidDetHotLsUsdiagOK|A|();|FCT3.3|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|indication si  la sonde amont est chaude et prête pour le diagnostic|
HOTSENO2FLG_vidDetSenO2Ds|C|();|FCT2.3|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|vérification que  la  tension de  la sonde à oxygène se trouve hors d’une plage de  tension.|
HOTSENO2FLG_vidDetSenO2DsCold|B|();|FCT2.4|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|Si le mélange oscille entre riche et pauvre, la tension va bagotter. La tension devra se trouver en dehors d’un intervalle de tensions pour que la sonde puisse être déclarée chaude.|
HOTSENO2FLG_vidDetSenO2DsHot|B|();|FCT2.5|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|Le signal utilisé est le signal sonde filtré afin d’éviter de fausses détections de sonde chaude dues à des perturbations des signaux bruts.|
HOTSENO2FLG_vidDetSenO2Us|C|();|FCT1.10|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|vérification que  la  tension de  la sonde à oxygène se trouve hors d’une plage de  tension.|
HOTSENO2FLG_vidDetSenO2UsCold|B|();|FCT2.2|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|Si le mélange oscille entre riche et pauvre, la tension va bagotter. La tension devra se trouver en dehors d’un intervalle de tensions pour que la sonde puisse être déclarée chaude.|
HOTSENO2FLG_vidDetSenO2UsHot|B|();|FCT2.1|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|Le signal utilisé est le signal sonde filtré afin d’éviter de fausses détections de sonde chaude dues à des perturbations des signaux bruts|
HOTSENO2FLG_vidDsHotdiagFlgInit|A|();|FCT1.3|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|A l’initialisation du calculateur la sonde aval est déclarée froide : LsSys_bLsDsHeatOkDiag et LsSys_bLsDsHeatOk valent 0.|
HOTSENO2FLG_vidDsTiStHeatOkdiag|A|();|FCT3.4|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|La sonde est considérée chaude et prête pour le diagnostic lorsque LsSys_b[XXXX]HeatOkDiag==1|
HOTSENO2FLG_vidHotSenO2Fil|B|();|FCT1.9|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|filtrage de Tension_sonde_amont  (Tension_sonde_aval) pour créer Lshd_voltage_upstr_sens_filtered (Lshd_voltage_dnstr_sens_filtered)|
HOTSENO2FLG_vidHotSenO2Heatst|A|();|FCT2.6|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0| Les sondes sont considérées chaudes lorsqu'une durée calibrable s'est écoulée depuis que l'automate de chauffage est rentré en phase E en passant par les phases (C1 ou C2) ou D, ou lorsque l'on a quitté la phase A pour la phase E directement.|
HOTSENO2FLG_vidHotSenO2Volt|A|();|FCT1.8|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|Fonction de calcul du filtrage de Tension_sonde_amont (Tension_sonde_aval)|
HOTSENO2FLG_vidInitCrTR|D|();|FCT1.5|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0| Lorsque la stratégie de détection des sondes chaudes est basée est la valeur des tensions sondes, les variables sont initialisées au démarrage du moteur.Les sondes sont déclarées froides.|
HOTSENO2FLG_vidInitEveRst|A|();|FCT1.1|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|Selon la stratégie de détection sonde lambda chaude basée sur les états de chauffage, à l’initialisation du calculateur,les sondes amont et aval sont déclarées froides.|
HOTSENO2FLG_vidInitHotSenO2DsFlg|B|();|FCT1.7|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0| Lorsque la stratégie de détection de sonde aval chaude est basée sur la tension sonde et lorsque le moteur démarre,la sonde aval doit être déclarée froide et le compteur associé à la détection de sonde chaude  Lshd_dwn_lbda_sens_heat_delay.|
HOTSENO2FLG_vidInitHotSenO2UsFlg|B|();|FCT1.6|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|Lorsque la stratégie de détection de sonde amont chaude est basée sur la tension sonde et lorsque le moteur démarre la sonde amont doit être déclarée froideet le compteur associé à la détection de sonde chaude doit être Lshd_up_lbda_sens_heat_delay.|
HOTSENO2FLG_vidInitOutput|D|();|FCT1.4|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|Initialisation des variables internes et des sorties du module.|
HOTSENO2FLG_vidSenO2DsHot|A|();|FCT2.8|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|La détection de la sonde se basant sur les états de l’automate de chauffage estime qu’au bout d’une certaine durée la sonde est suffisamment chauffée|
HOTSENO2FLG_vidSenO2DsTiStHeat|D|();|FCT2.3|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|La détection de la sonde se basant sur les états de l’automate de chauffage estime qu’au bout d’une certaine durée la sonde est suffisamment chauffée|
HOTSENO2FLG_vidSenO2UsHot|A|();|FCT2.7|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|La sonde est considérée chaude  et prête pour le diagnostic losrque  LsSys_b[LsUsMainOxCHeatOkDiag==1|
HOTSENO2FLG_vidSenO2UsTiStHeat|C|();|FCT1.7|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|La détection de la sonde se basant sur les états de l’automate de chauffage estime qu’au bout d’une certaine durée la sonde est suffisamment chauffée.|
HOTSENO2FLG_vidUsHotdiagFlgInit|A|();|FCT1.2|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|.A l’initialisation du calculateur la sonde amont est déclarée froide,: LsSys_bLsUsHeatOkDiag et LsSys_bLsUsHeatOk valent 0.|
HOTSENO2FLG_vidUsTiStHeatOkdiag|A|();|FCT3.2|HOTSENO2FLG|0|V02 NT 08 06204||||0|0|0|0|La sonde est considérée chaude  et prête pour le diagnostic losrque  LsSys_b[LsUsMainOxCHeatOkDiag==1|
HPPmpActCmd_vidbStopHPPmpActCmd|C|();|FCT1.3|HPPMPACTCMD|0|PTS_DOC_6882952||||0|0|0|0|Cette fonction retourne l’état du driver de la pompe|
HPPmpActCmd_vidHPPmpActCmd_DiagEl|J|();|FCT1.2|HPPMPACTCMD|0|PTS_DOC_6882952||||0|0|0|0|Le diagnostic, fait par le LdB, fournit une information de panne présente, utilisée par la gestion des défauts unitaires pour générer les éventuelles demandes de reconfiguration et définir les modes dégradés associés.|
HPPmpActCmd_vidHPPmpActCmd_Init|C|();|FCT1.1|HPPMPACTCMD|0|PTS_DOC_6882952||||0|0|0|0|Fonction de désactivation du driver de la pompe HP au calage.|
HPPMPACTCMDACQ_DT_vidbStopHPPCmd|A|();|FCT1.7|HPPMPACTCMDACQ_DT|0|PTS_DOC_6882935||||0|0|0|0|Fonction qui retourne l’état du driver de la pompe.|
HPPMPACTCMDACQ_DT_vidHPPApplCmd|A|();|FCT1.3|HPPMPACTCMDACQ_DT|0|PTS_DOC_6882935||||0|0|0|0|Fonction qui gère la commande de la Pompe HP: sélectionne le profil de commande  et applique l'angle et la mise sous tension pour les pulses de commande et de décélération.|
HPPMPACTCMDACQ_DT_vidHPPCmd_Ena|A|();|FCT1.2|HPPMPACTCMDACQ_DT|0|PTS_DOC_6882935||||0|0|0|0|Fonction d'activation du Driver e la pompe HP.|
HPPMPACTCMDACQ_DT_vidHPPCmd_Init|A|();|FCT1.1|HPPMPACTCMDACQ_DT|0|PTS_DOC_6882935||||0|0|0|0|Fonction de désactivation de driver de la pompe HP au calage du moteur.|
HPPMPACTCMDACQ_DT_vidHPPCmdAppl|A|();|FCT1.5|HPPMPACTCMDACQ_DT|0|PTS_DOC_6882935||||0|0|0|0|Fonction qui envoie la commande au LdB.|
HPPMPACTCMDACQ_DT_vidHPPContnCmd|A|();|FCT1.6|HPPMPACTCMDACQ_DT|0|PTS_DOC_6882935||||0|0|0|0|Fonction qui assure la commande en continu de la pompe HP au démarrage.|
HPPMPACTCMDACQ_DT_vidHPPProfSeln|A|();|FCT1.4|HPPMPACTCMDACQ_DT|0|PTS_DOC_6882935||||0|0|0|0|Fonction qui  choisit le profil de commande à appliquer à la spill valve de la pompe HP.|
HRDRCVMNG_vidInitialization|A|();|FCT1.1|HRDRCVMNG|0|V02 NT 09 03395||||0|0|0|0|Fonction d'initialisation des sorties
HRDRCVMNG_vidXvv|A|();|FCT1.2|HRDRCVMNG|0|V02 NT 09 03395||||0|0|0|0|Les différents booléens d’initialisations sont mis à 1 sur front montant de l’indicateur d'autorisation de surveillance intersystème ( Diag _on ) et uniquement lorsque clef de contact est à 1.
IDLCMDMOD_vidCalibration1|A|();|FCT2.1|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Cette consigne de régime de ralenti est calculée pour le mode de fonctionnement 1.|
IDLCMDMOD_vidCalibration2|A|();|FCT2.2|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Cette consigne de régime de ralenti est calculée pour le mode de fonctionnement 2.|
IDLCMDMOD_vidCalibration3|A|();|FCT2.3|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Cette consigne de régime de ralenti est calculée pour le mode de fonctionnement 3.|
IDLCMDMOD_vidCalibration4|A|();|FCT2.4|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Cette consigne de régime de ralenti est calculée pour le mode de fonctionnement 4.|
IDLCMDMOD_vidCalibration5|A|();|FCT2.5|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Cette consigne de régime de ralenti est calculée pour le mode de fonctionnement 5.|
IDLCMDMOD_vidCalibration6|A|();|FCT2.6|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Cette consigne de régime de ralenti est calculée pour le mode de fonctionnement 6.|
IDLCMDMOD_vidCalibration7|A|();|FCT2.7|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Cette consigne de régime de ralenti est calculée pour le mode de fonctionnement 7.|
IDLCMDMOD_vidCalibrations|A|();|FCT1.5|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Un vecteur de consigne est calculé à partir des différents modes de fonctionnement possibles.|
IDLCMDMOD_vidDetermineSetpoint|A|();|FCT1.4|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|La consigne de régime de ralenti spécifique aux modes de combustion est calculée en 3 étapes en prenant en compte les entrées EOM.|
IDLCMDMOD_vidDtrminePwrtrainStat|A|();|FCT1.2|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|L’état de la chaine de traction permet de sélectionner une consigne de régime de ralenti spécifique pour chaque mode de combustion.|
IDLCMDMOD_vidEntryInit|A|();|SCH.1|IDLCMDMOD|1|V02 NT 10 08588||||0|0|0|0|Evénement reset du calculateur|
IDLCMDMOD_vidInitOutput|A|();|FCT1.1|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Fonction d'initialisation.|
IDLCMDMOD_vidInterpolation|B|();|FCT1.7|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Deux interpolations successives permettent de calculer la consigne de régime de ralenti finale à appliquer.|
IDLCMDMOD_vidSelectModes|A|();|FCT1.6|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Les calibrations actives sont utilisées d’après les flux en provenance du manager de mode de fonctionnement EOM pour chacun des quatre modes.|
IDLCMDMOD_vidUnvectorizeMode|B|();|FCT1.3|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|La composante 8 relative à la consigne de régime de ralenti spécifique aux modes de combustion est sélectionnée pour chaques vecteurs d’entrée EOM.|
IDLCMDMOD_vidVectorizCalibration|A|();|FCT2.8|IDLCMDMOD|0|V02 NT 10 08588||||0|0|0|0|Cette fonction crée un vecteur de consignes de régime de ralenti applicables.|
IDLCTRL_vidAppliquer_SBPA|D|();|FCT2.4|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Le paramètre de mise au point « IdlSys_bAcvSBPA_C » permet de substituer la correction du régulateur avance par un signal en provenance d’un générateur de SBPA.|
IDLCTRL_vidBorner_correction|D|();|FCT2.1|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Fonction qui calcule la saturation maximale et minimale de la correction du régulateur avance..|
IDLCTRL_vidCalc_correction_PID|D|();|FCT2.2|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Fonction de calcul du régulateur PID.|
IDLCTRL_vidCalc_regulateur_air|D|();|FCT2.5|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|La correction de couple émise par le régulateur avance est filtrée par un filtre passe-bas dont la constante de temps dépend de son sens de variation.|
IDLCTRL_vidCalc_regulateur_av|D|();|FCT1.3|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Fonction de calcul de la correction demandée par le régulateur avance.|
IDLCTRL_vidCalc_terme_regulateur|D|();|FCT2.3|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Fonction qui recalcule les différents termes du régulateur PID. Ce besoin sert juste pour la mise au point de la fonction.|
IDLCTRL_vidCalculer_couple_init|D|();|FCT1.10|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Fonction qui calcule le couple d’initialisation de la correction du régulateur de ralenti.|
IDLCTRL_vidConditionner_erreur|H|();|FCT1.4|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Cette fonction  calcule  l’erreur  de  position  à  destination  du  régulateur :  différence entre  la  consigne dynamique de régime et le régime moteur mesuré.|
IDLCTRL_vidCoord_couples_ralenti|E|();|FCT2.6|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Lorsque le régulateur de ralenti est actif, les couples calculés par le régulateur de ralenti sont appliqués en sortie de la fonction. Sinon, les couples basculent sur leurs valeurs de repli (couple nul).|
IDLCTRL_vidEntryInit|E|();|SCH.1|IDLCTRL|1|PTS_DOC_5659858||||0|0|0|0|Fonction d'accroche au moniteur Reset|
IDLCTRL_vidIdleSpeedControl|F|();|FCT1.2|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|La fonction « Régulation du Régime de Ralenti » se décompose en 3 sous fonctions appelées à la récurrence synchro : calcul de la correction , filtrage différentiel de la correction  et synthèse des consignes de couple avance et air .|
IDLCTRL_vidInitOutput|F|();|FCT1.1|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Cette fonction initialise les variables du module|
IDLCTRL_vidParametrer_mode_1|D|();|FCT1.6|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Calcul des gains du régulateur avance pour le mode 1.|
IDLCTRL_vidParametrer_mode_2|D|();|FCT1.7|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Calcul des gains du régulateur avance pour le mode 2.|
IDLCTRL_vidParametrer_mode_3|D|();|FCT1.8|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Calcul des gains du régulateur avance pour le mode 3.|
IDLCTRL_vidParametrer_mode_4|D|();|FCT1.9|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Calcul des gains du régulateur avance pour le mode 4.|
IDLCTRL_vidParametrer_PID|D|();|FCT1.5|IDLCTRL|0|PTS_DOC_5659858||||0|0|0|0|Les coefficients proportionnel (KP), intégral (KI), dérivée (KD) et dérivée filtrée (KF) du régulateur air sont interpolés dans des cartographies indexées selon le rapport de boite engagé et la valeur de la correction avance en entrée du régulateur.|
IDLMGR_vidActiver_ralenti|C|();|FCT1.4|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Cette fonctiondétermine l’activation des calculs des fonctions de la gestion ralenti suivant des seuils de régime.Au dessus d’un seuil de régime, les calculs sont stoppés pour économiser de la charge sur le calculateur.|
IDLMGR_vidBoucler_stuct_couple|C|();|FCT5.6|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Ce bloc gère la transition de la structure couple du débouclage vers le bouclage lors que le ralenti s’active. On gère 2 informations par calibrations : - une pente de transition - une durée maximale de transition|
IDLMGR_vidCalc_auto_coupure_inj|B|();|FCT3.1|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Dans cette fonction, on calcule la condition d’autorisation de coupure-injection pour le ralenti.|
IDLMGR_vidCalc_autorisation_inj|C|();|FCT3.4|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|L’autorisation de coupure injection est activée lorsque Le régulateur de ralenti n’est plus actif OU la condition dynamique n’est plus remplie ET le couple issu  du régulateur de ralenti est sur sa butée minimum.|
IDLMGR_vidCalc_condition_couple|B|();|FCT3.2|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|L’autorisation de coupure injection est accordée lorsque le couple du régulateur de ralenti est sur le couple minimum du ralenti.|
IDLMGR_vidCalc_couple_init_reg|E|();|FCT3.6|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Selon l’état du superviseur de ralenti (IdlSys_bAcvIdlCtl),on calcule la valeur d’initialisation des couples du régulateur(branche air et avance).|
IDLMGR_vidCalc_couple_isop|B|();|FCT3.5|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|A partir du gradient de régime d’entrée au ralenti, on calcule un couple indiqué permettant d’assurer l’entrée au ralenti.Il est possible de moduler l’impact de ce couple en fonction de l’erreur de régime.|
IDLMGR_vidCalc_couple_perte_comp|B|();|FCT1.7|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Cette fontion filtre le couple de pertes compensées.|
IDLMGR_vidCalc_gains_filt_regime|C|();|FCT2.3|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Dans cette fonction on calcule les gains de l’estimateur de régime moteur, et gérer la transition entre ceux-ci.|
IDLMGR_vidCalc_gains_filtre_grad|C|();|FCT2.4|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Dans cette fonction on calcule les gains de l’estimateur de gradient de régime moteur, et gérer la transition entre ceux-ci.|
IDLMGR_vidCalc_inertie_veh|D|();|FCT2.1|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Dans cette fonction, on calcule l’inertie du véhicule à partir des informations de régime moteur, vitesse véhicule, masse véhicule et inertie du moteur à vide.|
IDLMGR_vidCalc_offset_coup_inj|B|();|FCT3.3|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Un offset de régime est calculé pour autoriser la coupure injection. Celui-ci est fonction du gradient de régime et du rapport de boite, et peut être corrigé par un facteur dépendant de la température moteur.|
IDLMGR_vidCalc_pertes_convr_BVA|B|();|FCT5.7|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Permet de récupérer le couple prélevé par le convertisseur en BVA|
IDLMGR_vidCalc_pertes_embr_BVMP|C|();|FCT1.8|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Cette fonction  filtre le couple prélevé par l’embrayage en BVMP.|
IDLMGR_vidCalc_transition_gains|C|();|FCT2.2|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Dans cette fonction, on gère un état qui viendra piloter les gains de l'estimateur en fonction de la situation de vie : Moteur à vide, Moteur entrainé sans appui frein et Moteur entrainé avec appui frein.|
IDLMGR_vidCalculer_coef_ralenti|E|();|FCT2.8|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Le profil d’entrée au ralenti est déterminé à partir de l’erreur de régime entre la consigne statique de ralenti et le régime moteur filtré. On différencie les cas appui frein et hors appui frein.|
IDLMGR_vidCalculer_cond_regime|C|();|FCT4.2|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Lorsque le régime moteur est supérieur à l’offset calculé plus la consigne de ralenti statique, alors  on autorise l’activation du ralenti.|
IDLMGR_vidCalculer_consigne_dyn|I|();|FCT2.10|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Lors de l’initialisation de la consigne dynamique par IdlSys_bIniIdlCtl, la consigne dynamique est rendue égale au maximum entre la consigne statique de ralenti et le régime moteur.|
IDLMGR_vidCalculer_couple_pertes|C|();|FCT1.6|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Cete fonction calcule le couple de pertes déjà compensées pour le ralenti.|
IDLMGR_vidCalculer_info_regime|B|();|FCT5.1|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Cette fonction calcule le gradient de régime moteur.|
IDLMGR_vidCalculer_ralenti|E|();|FCT2.7|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|cette fonction calcule le ralenti lorsque les calculs sont activés.|
IDLMGR_vidCalculer_reg_grad_spec|D|();|FCT2.6|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Cette fonction calcule le e régime moteur filtré à utiliser dans la fonction du ralenti et le gradient de régime moteur filtré à utiliser dans la fonction du ralenti.|
IDLMGR_vidCalculer_regime_estime|C|();|FCT5.3|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Cette fonction estime deux régimes moteur (un pour le régime filtré, et un pour le gradient de régime filtré.|
IDLMGR_vidCalculer_regime_filtre|C|();|FCT5.2|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Cette fonction calcule deux régimes moteur filtrés (un pour le régime moteur filtré, et un pour le gradient de régime moteur filtré).|
IDLMGR_vidCalculer_valeurs_replis|B|();|FCT5.5|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Dans ce bloc, on calcule les valeurs de repli à appliquer lorsque les calculs de la fonction ralenti sont désactivés.|
IDLMGR_vidChange_rapport_boite|D|();|FCT4.9|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Sur  variation  de  l’information  rapport  de  boite  engagé  d’une  mesure  à  l’autre,  une  information indiquant un changement de rapport est levée.|
IDLMGR_vidDet_chang_etat_rampage|B|();|FCT4.7|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Dans ce bloc, on détermine si l’état de rampage BVMP a changé d’état et de provoquer une réinitialisation du régulateur si c’est le cas.|
IDLMGR_vidDet_changement_mode|B|();|FCT4.10|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Sur variation du sélecteur de gains pour le régulateur d’une mesure à l’autre, une information indiquant un changement de rapport est levée, et une réinitialisation du régulateur est effectuée.|
IDLMGR_vidDet_etat_moteur|D|();|FCT4.3|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Dans l’état initial, le ralenti est désactivé. Ensuite pour activer les fonctions ralenti, on considère l’état de la structure couple, les demandes d’arrêt moteur, et le franchissement d’un seuil de régime.|
IDLMGR_vidDet_ralenti_effectif|B|();|FCT4.6|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Dans ce bloc, on détermine si le régulateur de ralenti n’est plus effectif pour autoriser sa coupure.|
IDLMGR_vidDet_regime_critique|C|();|FCT4.5|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|On demande l’activation du ralenti lorsque le régime moteur est proche de la consigne statique.On demande la désactivation du ralenti lorsque le régime moteur est supérieur au seuil d’activation décrit précédemment plus un offset calibrable.|
IDLMGR_vidDeterminer_demarrage|B|();|FCT5.8|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|L’activation de la structure couple active le ralenti|
IDLMGR_vidDeterminer_etat_moteur|C|();|FCT4.1|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Dans ce bloc, si on peut autoriser l’activation du ralenti, en fonction de l’état du moteur.|
IDLMGR_vidDeterminer_inj_dyn|C|();|FCT4.4|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|L’activation dynamique permet d’activer le régulateur de ralenti sur une condition comparant la dynamique du moteur avec celle nécessaire pour réaliser l’entrée au ralenti attendue.|
IDLMGR_vidEntryInit|F|();|SCH.1|IDLMGR|1|PTS_DOC_5010777||||0|0|0|0|Initialisation des variables produites|
IDLMGR_vidEstimer_regime|D|();|FCT2.5|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Ce bloc calcule le régime moteur estimé à partir du régime moteur que l’on filtre par un passe-bas de 1er  ordre, auquel on ajoute une composante issue du couple moteur réalisé.|
IDLMGR_vidInitOutput|J|();|FCT1.1|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Fonction d'initialisation des parametres produits|
IDLMGR_vidMainTraiter_les_info|E|();|FCT1.2|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Cette fonction contient le traitement ,lecalcul et la gestion du ralenti.|
IDLMGR_vidManager_le_ralenti|E|();|FCT2.9|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|La fonction de supervision du régulateur se décompose en 8 blocs de détection des conditions du ralenti et 1 bloc de décision.|
IDLMGR_vidPiloter_avances_mini|B|();|FCT3.7|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Dans ce bloc, on vient piloter spécifiquement les avances minimum pour l’agrément lors de l’activation du régulateur de ralenti.|
IDLMGR_vidReinit_en_surregime|F|();|FCT4.8|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Ce module  détecte  le  besoin  de  réinitialiser  le  régulateur  de  ralenti  et  la  consigne  dynamique  lors d’une forte envolée de régime.|
IDLMGR_vidSuperv_regu_de_ralenti|D|();|FCT5.4|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|L’automate d’état de commande du régulateur et de la consigne dynamique possède 2 états macroscopiques :  Régulateur désactivé (« Regulateur_OFF »), Régulateur activé (« Regulateur_ON/ »).|
IDLMGR_vidTraiter_informations|F|();|FCT1.5|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Ce bloc de traitement des informations permet de traiter les signaux d’entrée pour le ralenti en cas de défaut et de calculer des signaux nécessaires à la gestion du ralenti|
IDLMGR_vidTraiter_les_info|C|();|FCT1.3|IDLMGR|0|PTS_DOC_5010777||||0|0|0|0|Cette fonction permet de traiter les signaux d’entrée pour le ralenti en cas de défaut et de calculer des signaux nécessaires à la gestion du ralenti.|
IdlSys_EveSync_AntiStall|A|();|SCH.2|TQANTISTALLBVM|1|V02 NT 10 04974||||0|0|0|0|Fonction d'accroche au PMH.|
IdlSys_EveSync_bAcvIdlCtl|D|();|SCH.2|IDLMGR|1|PTS_DOC_5010777||||0|0|0|0|Sceduler de la fonction.|
IdlSys_EveSync_bInjCutOff|B|();|SCH.2|IDLSYSCUTOFF|1|V02 NT 10 04612||||0|0|0|0|Evenement de synchronisation|
IdlSys_EveSync_GslIdlCtl|B|();|SCH.2|ENGIDLEINTERFACE|1|V02 NT 10 04614||||0|0|0|0|Evénement du module ENGIDLEINTERFACE.|
IdlSys_EveSync_tqIdcIdl|B|();|SCH.2|IDLCTRL|1|PTS_DOC_5659858||||0|0|0|0|Fonction d'accroche au moniteur Pmh (TDC)|
IDLSYSCUTOFF_vidAutoriCoupureInj|A|(void);|FCT1.7|IDLSYSCUTOFF|0|V02 NT 10 04612||||0|0|0|0|L’autorisation de coupure injection pour les besoins agrément et ralenti fait la synthèse des autorisations de coupure pour ces 2 fonctions.|
IDLSYSCUTOFF_vidCalcAutorCoupIVC|A|(void);|FCT1.6|IDLSYSCUTOFF|0|V02 NT 10 04612||||0|0|0|0|On autorise la coupure injection pour l’agrément lorsque : la condition sur le couple  ET la condition sur le régime moteur sont actives OU lorsque le ralenti est effectif|
IDLSYSCUTOFF_vidCalcCondCouple|A|(void);|FCT1.5|IDLSYSCUTOFF|0|V02 NT 10 04612||||0|0|0|0|Lorsque le couple demandé par l’IVC est inférieur à un seuil, on active un booléen permettant l’autorisation de la coupure injection.|
IDLSYSCUTOFF_vidCalcCondRegime|A|(void);|FCT1.4|IDLSYSCUTOFF|0|V02 NT 10 04612||||0|0|0|0|On calcule une condition sur le régime moteur pour autoriser la coupure agrément.|
IDLSYSCUTOFF_vidCalculCondIVC|A|(void);|FCT1.3|IDLSYSCUTOFF|0|V02 NT 10 04612||||0|0|0|0|Cette fonction calcule la condition de coupure injection pour le besoin agrément.|
IDLSYSCUTOFF_vidCalculCondRegime|A|(void);|FCT1.2|IDLSYSCUTOFF|0|V02 NT 10 04612||||0|0|0|0|Ce bloc permet de gérer la coupure - réinjection en fonction du gradient de régime moteur.|
IDLSYSCUTOFF_vidEntryInit|A|();|SCH.1|IDLSYSCUTOFF|1|V02 NT 10 04612||||0|0|0|0|Tache reset.|
IDLSYSCUTOFF_vidInitOutput|A|(void);|FCT1.1|IDLSYSCUTOFF|0|V02 NT 10 04612||||0|0|0|0|Reinitialisation des variables du module IDLSYSCUTOFF|
IFADV_vidIgSys1|A|();|FCT1.1|IFADV|0|V02 NT 11 07695||||0|0|0|0|Calcul de la variable IgSys_agIgLimMinRef2.|
IFADV_vidIgSys2|A|();|FCT1.2|IFADV|0|V02 NT 11 07695||||0|0|0|0|Calcul des variables Cha_bASRReg et Cha_bESPReg.|
IFAIRSYS_vidAccP|C|();|FCT1.2|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|Production de l'indicateur position pédale pied levé|
IFAIRSYS_vidBoostPressure|D|();|FCT1.7|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|Ce bloc contient les entrées de la chaine d’air issus de la chaine d’injection.|
IFAIRSYS_vidCrkMgt|E|();|FCT1.3|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|Ce bloc contient les entrées de la chaine d’air issus de la chaine d’injection.|
IFAIRSYS_vidCrkMgt2|C|();|FCT2.4|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|cette fonction détermine l'état du gestionnaire de la section efficace du papillon.|
IFAIRSYS_vidEngSt|B|();|FCT2.2|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|cette fonction détermine l'état de fonctionnement du moteur.|
IFAIRSYS_vidEntryInit|D|();|SCH1.1|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Evénement reset ECU du module d'interface|
IFAIRSYS_vidInitCrkMgt|C|();|FCT2.3|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|cette fonction détermine l'état du gestionnaire de la section efficace du papillon en démarrage.|
IFAIRSYS_vidInitFilter|B|();|FCT1.9|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|Fonction d'initialisation de la sortie du filter|
IFAIRSYS_vidInitOutput|C|();|FCT1.1|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|Initialisation des sorties du module IFAIRSYS.|
IFAIRSYS_vidInj|D|();|FCT1.6|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|Ce bloc contient les entrées de la chaine d’air issus de la chaine d’injection.|
IFAIRSYS_vidmfAirMid2|D|();|FCT1.8|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|Ce bloc initialise la temperature d'air avant papillon T2|
IFAIRSYS_vidNEngGrd|C|();|FCT2.1|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|cette fonction calcule le gradiant du régime moteur à partir de sa dérivée.|
IFAIRSYS_vidThr|D|();|FCT1.4|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|Ce bloc contient les entrées de la chaine d’air issus de la chaine d’injection.|
IFAIRSYS_vidVehRun|D|();|FCT1.5|IFAIRSYS|0|PTS_DOC_5199971||||0|0|0|0|Production de l'indicateur véhicule roulant.|
IFAIRSYSIGSYS_vidAFAInit|F|();|FCT2.5|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction de remise à 0 du régime moteur en faible résolution|
IFAIRSYSIGSYS_vidAFASyncIf|G|();|FCT2.6|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction de synchronisation entre régime moteur en résolution 32 tr/mn et régime moteur en faible résolution|
IFAIRSYSIGSYS_vidAFAThrIf|F|();|FCT2.7|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction d'initialisation de la butée basse du papillon motorisé|
IFAIRSYSIGSYS_vidAntiFlood|B|();|FCT7.5|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable InjSys_bInhInjAntiFlood.|
IFAIRSYSIGSYS_vidBattVolt|F|();|FCT3.6|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Interface function for Ext_uBattMes|
IFAIRSYSIGSYS_vidCkMngIf|D|();|FCT3.5|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Interface function for Duree_dent and Moteur_tournant|
IFAIRSYSIGSYS_vidCmdCoFan|B|();|FCT9.3|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction de production d'état consigne appliquée au GMV|
IFAIRSYSIGSYS_vidCptrTempsEcuSt|A|();|FCT6.10|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Cette fonction calcule le temps le temps d'allumage ECU depuis le dernier RAZ eeprom|
IFAIRSYSIGSYS_vidCptrTempsEngSt|A|();|FCT6.9|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Cette fonction calcule le temps de fonctionnement moteur ECU depuis le dernier RAZ eeprom|
IFAIRSYSIGSYS_vidCstr|D|();|FCT6.3|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Evénement pour l'initialisation|
IFAIRSYSIGSYS_vidCtTDC|B|();|FCT7.4|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_ctTDCTot.|
IFAIRSYSIGSYS_vidDetInstMisf|C|();|FCT6.7|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|fonction appelée à  l'interruption logicielle de fin d'acquisition de la fenêtre misfire.|
IFAIRSYSIGSYS_vidDiag_Trim|B|();|FCT7.1|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable InjCtl_rDiagTrim.|
IFAIRSYSIGSYS_vidDsLsAcqIf|D|();|FCT3.7|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Interface function for Ext_uLsDsMes|
IFAIRSYSIGSYS_vidDuree_Fctmt|A|();|FCT6.1|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Cette fonction calcule le temps de fonctionnement moteur ainsi que le temps d'allumage ECU depuis le dernier RAZ eeprom|
IFAIRSYSIGSYS_vidECU|E|();|FCT2.2|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Ce bloc contient les entrées de la chaine d’air issus des modules projets Ebx.|
IFAIRSYSIGSYS_vidECU1|C|();|FCT6.8|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Ce block contient les entrées de la chaîne d’air issues des modules projets EBx-DT.|
IFAIRSYSIGSYS_vidEndDiagDsHeat|B|();|FCT3.8|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Ce block contient les entrées de la chaîne d’air issues des modules projets EBx-DT.|
IFAIRSYSIGSYS_vidEntryInit|B|();|SCH1.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset ECU du module d'interface|
IFAIRSYSIGSYS_vidFrstCrk|B|();|FCT7.3|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_bFrstCrk.|
IFAIRSYSIGSYS_vidFuTnk|B|();|FCT7.2|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Flev_fuel_level_mux.|
IFAIRSYSIGSYS_vidInit_tOil|B|();|FCT7.7|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_bStrtEnd et Ext_bTOilChk .|
IFAIRSYSIGSYS_vidInitOutput|K|();|FCT1.1|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Initialisation des sorties du module IFAIRSYSIGSYS.|
IFAIRSYSIGSYS_vidInjCtlIf2|E|();|FCT3.1|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction d'interfaçage.|
IFAIRSYSIGSYS_vidInjCtlIf3|E|();|FCT3.2|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction d'interaçage.|
IFAIRSYSIGSYS_vidInjrMSys1|C|();|FCT7.6|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Injector_constant.|
IFAIRSYSIGSYS_vidInputVlvActExIf|D|();|FCT3.3|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable VlvSys_agCkClsExVlvCorRaw (interfacé avec VlvSys_agCkClsExVlvReqRef0)|
IFAIRSYSIGSYS_vidInputVlvActInIf|D|();|FCT3.4|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la varaible  VlvSys_agCkOpInVlvCorRaw (interfacé avec VlvSys_agCkOpInVlvReqRef0)|
IFAIRSYSIGSYS_vidInterfacCstrIf|B|();|FCT2.3|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Permet de calculer le Signal d'autorisation de prélèvement de couple brute|
IFAIRSYSIGSYS_vidInterfacCstrIf1|E|();|FCT4.3|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Interface function for CoPTSt_stEngNew|
IFAIRSYSIGSYS_vidInterfEngStrt|B|();|FCT1.6|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production des variables VoltCtl_IexctMax, VoltCtl_tiAltPrgCh, VoltCtl_AltPrgChDi_nEng et VoltCtl_uReqProdElec.|
IFAIRSYSIGSYS_vidInterfISLin|B|();|FCT1.3|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production des variables Ext_iCtlAltLINExct, Ext_iRvAltExct, Ext_rCtlAltLINCycOp, Ext_rAltCycOpStd et Ext_rRvAltCycOp.|
IFAIRSYSIGSYS_vidIntfacIsCanIf1|F|();|FCT5.1|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Interface function for VSCtl_bVSLimReg|
IFAIRSYSIGSYS_vidIntfacIsCanIf14|D|();|FCT4.6|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction appelé à la réception d'une trame CAN 30D|
IFAIRSYSIGSYS_vidIntfacIsCanIf15|C|();|FCT4.7|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction appelé à la réception d'une trame CAN 38D|
IFAIRSYSIGSYS_vidIntfacIsCanIf16|C|();|FCT4.8|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction appelé à la réception d'une trame CAN 50E|
IFAIRSYSIGSYS_vidIntfacIsCanIf17|B|();|FCT5.4|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction appelé à la réception d'une trame CAN 7F2|
IFAIRSYSIGSYS_vidIntfacIsCanIf2|F|();|FCT5.2|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Interface function for CsCtl_stVSReg|
IFAIRSYSIGSYS_vidIntfacIsCanIf5|C|();|FCT5.5|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Interface function for Ext_bDrvCyGlbl|
IFAIRSYSIGSYS_vidISLinInterf|C|();|FCT1.4|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_idxCtlAltLINProvIdf et Ext_idxAltClas.|
IFAIRSYSIGSYS_vidKnk|C|();|FCT10.9|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|cette fonction permet d'interfacer  KnkMgt_bAcvKnkReg avec Zone_Critique.|
IFAIRSYSIGSYS_vidmFuSpIf|C|();|FCT4.2|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide pour la correction de richesse de la régulation richesse|
IFAIRSYSIGSYS_vidMFuTranCor|A|();|FCT10.10|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable InjSys_prm_facTranCmpCyl|
IFAIRSYSIGSYS_vidOutAmbPressEep|E|();|FCT1.7|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction de copie de la valeur eeprom de UsThrM_pAirExtEstim dans Eep_UsThrM_pAirExtEstim|
IFAIRSYSIGSYS_vidOutAtmphPress|E|();|FCT5.6|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Atmospheric_pressure.|
IFAIRSYSIGSYS_vidOutbCtlPmpReq|D|();|FCT10.6|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable IgCmd_bCtlPmpReqTstCmpl.|
IFAIRSYSIGSYS_vidOutbElecltgr|B|();|FCT8.5|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_bElecItgrReq.|
IFAIRSYSIGSYS_vidOutBrakePedInp|B|();|FCT8.6|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Bps_brake_pedal_input.|
IFAIRSYSIGSYS_vidOutEngStopAuth|B|();|FCT10.3|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable CoReqStg_stEngStopAuth.|
IFAIRSYSIGSYS_vidOutfacVlvOvlp|C|();|FCT10.8|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable InM_pDsThr_facVlvOvlp.|
IFAIRSYSIGSYS_vidOutFHCanF4F2AV|C|();|FCT9.9|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction appelé à la réception d'une trame 4F2.|
IFAIRSYSIGSYS_vidOutFHCanF7F2AV|D|();|FCT9.6|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction appelé à la réception d'une trame 7F2.|
IFAIRSYSIGSYS_vidOutInjCutOffPtl|C|();|FCT10.2|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable KnkMgt_prm_ctRblInjCutOffPtl.|
IFAIRSYSIGSYS_vidOutMainOxCEstim|D|();|FCT6.5|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable ExM_tExLsDsMainOxCEstim et ExM_tExLsUsMainOxCEstim.|
IFAIRSYSIGSYS_vidOutMaxPrevAdpCy|C|();|FCT10.1|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable IgSys_prm_agIgMaxWiPrevAdpCy.|
IFAIRSYSIGSYS_vidOutN3F34DPM1413|C|();|FCT9.4|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable ISCAN_u8N3F34DPM1413.|
IFAIRSYSIGSYS_vidOutNotAvlBatMes|B|();|FCT8.3|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_bNotAvl_iBattMes.|
IFAIRSYSIGSYS_vidOutOCHeatPhaReq|D|();|FCT5.7|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable OxC_bOxCHeatPhaReq.|
IFAIRSYSIGSYS_vidOutput_bStaReq|D|();|FCT9.8|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable StaCtl_bStaReq.|
IFAIRSYSIGSYS_vidOutput_bTqReq|B|();|FCT8.1|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable CoCha_bTqReq.|
IFAIRSYSIGSYS_vidOutput_iBattMes|C|();|FCT8.4|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_iBattMes.|
IFAIRSYSIGSYS_vidOutput_IdlLim|B|();|FCT7.9|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable EngSt_bCtlEngNOnIdl.|
IFAIRSYSIGSYS_vidOutput_nEng|C|();|FCT9.1|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production des variables Eng_nEng, Ext_noNEngCplm et TqSys_tiEveSync2.|
IFAIRSYSIGSYS_vidOutput_OxC|D|();|FCT9.2|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction d'interface du module CatMon.|
IFAIRSYSIGSYS_vidOutput_pFuMes|B|();|FCT1.2|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Cette fonction permet l'acquisition de la pression rail.|
IFAIRSYSIGSYS_vidOutput_tFuMes|B|();|FCT10.4|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_tFuMes.|
IFAIRSYSIGSYS_vidOutput_tiAst|C|();|FCT10.5|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_tiAst.|
IFAIRSYSIGSYS_vidOutput_tOilChk|B|();|FCT8.2|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Eng_bTOilChk.|
IFAIRSYSIGSYS_vidOutput_tOilMes|D|();|FCT6.6|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_tOilMes.|
IFAIRSYSIGSYS_vidOutputbDft|D|();|FCT9.7|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_bDft.|
IFAIRSYSIGSYS_vidOutputCrash|B|();|FCT8.7|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Crash_fps_mux.|
IFAIRSYSIGSYS_vidOutputFHCanF572|B|();|FCT4.5|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Permet de calculer le  paramètre PM1375 à travers les Données brutes du paramètre PM1446, reçue du CAN.|
IFAIRSYSIGSYS_vidOutputGearRatio|B|();|FCT7.8|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Gear_engagedet CoPt_noGearCord_Sfty.|
IFAIRSYSIGSYS_vidOutputInMnfReq|D|();|FCT6.4|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable AirSys_pInMnfReq.|
IFAIRSYSIGSYS_vidOutputLoad|E|();|FCT1.5|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Ce bloc contient les sortie de la chaine d’air utilisés par les modules projets Ebx.|
IFAIRSYSIGSYS_vidOutputObdSrv|C|();|FCT10.7|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Output ObdSrv|
IFAIRSYSIGSYS_vidOutputpAC|B|();|FCT4.4|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Cette fonction permet la production de la variable EngLim_tqIdcRed.|
IFAIRSYSIGSYS_vidOutputStrtEnd|B|();|FCT7.10|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Ext_bStrtEnd.|
IFAIRSYSIGSYS_vidOutputThMgt|B|();|FCT5.3|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production des variables ThMgt_bWarn_tCo et ThMgt_bPwrHldReq.|
IFAIRSYSIGSYS_vidOutSlaveWkuReq|C|();|FCT8.8|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction appelé à la réception d'une trame CAN432.|
IFAIRSYSIGSYS_vidPhyM|C|();|FCT1.9|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|cette fonction permet d'interfacer PhyM_tTrbCaseEstim avec PhyMSI_tTrbCaseEstim.|
IFAIRSYSIGSYS_vidrapEngaMeca349|E|();|FCT8.9|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la variable Bv_rapport_enga_meca_rx349.|
IFAIRSYSIGSYS_vidSTTIf|D|();|FCT5.8|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fontion appelé sur evenement 100ms|
IFAIRSYSIGSYS_vidTDsThr|F|();|FCT1.8|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Ce bloc contient les entrées de la chaine d’air issus des modules projets Ebx.|
IFAIRSYSIGSYS_vidtEcuAct|B|();|FCT9.5|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction de production de la temprature interne du CMM|
IFAIRSYSIGSYS_vidTqCurSfty|C|();|FCT2.4|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Mise à jour de la valeur du couple courant utilisé pour initialiser la limitation de couple safety.|
IFAIRSYSIGSYS_vidTqRes|B|();|FCT2.1|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction qui permet la production de la varible Ext_tqAlt.|
IFAIRSYSIGSYS_vidTqSys|C|();|FCT6.2|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Fonction li à l'événement synchro|
IFAIRSYSIGSYS_vidTqSys_2|B|();|FCT4.1|IFAIRSYSIGSYS|0|PTS_DOC_5076182||||0|0|0|0|Cette fonction permet la production de la variable EngLim_tqIdcRed.|
IFAUTHDFTSTT_vidEntryInit|C|();|SCH.1|IFAUTHDFTSTT|1|V02 NT 11 01213||||0|0|0|0|Evenement RESET|
IFAUTHDFTSTT_vidInitOutput|C|();|FCT1.1|IFAUTHDFTSTT|0|V02 NT 11 01213||||0|0|0|0|Initialisation des output|
IFAUTHDFTSTT_vidIrfAutrstDftSTT|C|();|FCT1.2|IFAUTHDFTSTT|0|V02 NT 11 01213||||0|0|0|0|Cette fonction permet de sécuriser les demandes Démarrage redémarrage STTd.|
IFAUTHDFTSTT_vidSansSTTCfg|C|();|FCT1.4|IFAUTHDFTSTT|0|V02 NT 11 01213||||0|0|0|0|Cette fonction permet de bypasser la sécurisation dans le cas de la non présence d’un STT.|
IFAUTHDFTSTT_vidSTTConfig|C|();|FCT1.3|IFAUTHDFTSTT|0|V02 NT 11 01213||||0|0|0|0|Test de la configuration définissant le code à compiler|
IFAUTHDFTSTT_vidSTTPrstCfg|C|();|FCT1.5|IFAUTHDFTSTT|0|V02 NT 11 01213||||0|0|0|0|Cette fonction Coordonne le flux d’inhibition de Démarrage / redémarrage du niveau 1 avec les défauts détectés par le niveau 2 et vient contrôler le démarreur.|
IFCATMDLSYS_vidTWCMgtIf|B|();|FCT1.1|IFCATMDLSYS|0|V02 NT 11 06970||||0|0|0|0|Fonction de determination des sorties.|
IFELECMOTESS_vidByte_carrier|B|();|FCT1.2|IFELECMOTESS|0|V02 NT 12 00929||||0|0|0|0|« Ext_bfAcvConstEng1 » est un porteur d’information, consommé par la fonction « CoOptmEl ». Chaque booléen en entrée est positionné dans un octet.|
IFELECMOTESS_vidEntryInit|B|();|SCH.1|IFELECMOTESS|1|V02 NT 12 00929||||0|0|0|0|Evennement Reset|
IFELECMOTESS_vidInitOutput|B|();|FCT1.1|IFELECMOTESS|0|V02 NT 12 00929||||0|0|0|0|fonction d'initialisation des sorties|
IfEngReq_Sdl10ms_Cord|B|();|SCH.2|IFELECMOTESS|1|V02 NT 12 00929||||0|0|0|0|La fonction est appelée toutes les 10 ms.|
IFFAR_vidAcvReqMonItrsv|A|();|FCT1.3|IFFAR|0|V02 NT 12 01358||||0|0|0|0|Fonction d'interfacage de la demande de diagnostic intrusif pour la sonde aval|
IFFAR_vidInitFar|B|();|FCT1.1|IFFAR|0|V02 NT 12 01358||||0|0|0|0|fonction d'initialisation du module|
IFFAR_vidMixtReqMonItrsv|B|();|FCT1.4|IFFAR|0|V02 NT 12 01358||||0|0|0|0|fonction d'interfacage de la consigne de créneau de richesse.|
IFFAR_vidObjRich|A|();|FCT1.2|IFFAR|0|V02 NT 12 01358||||0|0|0|0|fonction d'interfacage de l'objectif de richesse après départ.|
IFNENGCLC_vidBDCEngineSpeed|B|();|FCT1.5|IFNENGCLC|0|V02 NT 11 03031||||0|0|0|0|Production du régime moteur recentré à partir du régime moteur au PMB.|
IFNENGCLC_vidBDCGeneration|B|();|FCT1.3|IFNENGCLC|0|V02 NT 11 03031||||0|0|0|0|Génération de l'évènement PMB.|
IFNENGCLC_vidEntryInit|B|();|SCH.1|IFNENGCLC|1|V02 NT 11 03031||||0|0|0|0|Initialisation du calculateur.|
IFNENGCLC_vidInitOutput|B|();|FCT1.1|IFNENGCLC|0|V02 NT 11 03031||||0|0|0|0|Fonction d'initialisation des sorties.|
IFNENGCLC_vidTDCEngineSpeed|B|();|FCT1.4|IFNENGCLC|0|V02 NT 11 03031||||0|0|0|0|Production du régime moteur recentré à partir du régime moteur.|
IFNENGCLC_vidTDCGeneration|B|();|FCT1.2|IFNENGCLC|0|V02 NT 11 03031||||0|0|0|0|Génération de l'évènement PMH.|
IFTQSTRUCT_TQMON_vidEntryInit|F|();|SCH.1|IFTQSTRUCT_TQMON|1|PTS_DOC_5050415||||0|0|0|0|Evenement reset du calculateur .|
IFTQSTRUCT_TQMON_vidFluxInternes|E|();|FCT1.5|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|cette fonction permet de déterminer les flux internes.|
IFTQSTRUCT_TQMON_vidGeInf40m2Bis|D|();|FCT1.8|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|fonction generer info 40 ms.|
IFTQSTRUCT_TQMON_vidGeInf40m3Bis|G|();|FCT1.9|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|fonction generer info 40 ms.|
IFTQSTRUCT_TQMON_vidGeInf40m4Bis|C|();|FCT1.10|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|fonction generer info 40 ms.|
IFTQSTRUCT_TQMON_vidGeInf40msBis|H|();|FCT1.7|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|fonction generer info 40 ms.|
IFTQSTRUCT_TQMON_vidGenerInf10ms|D|();|FCT1.4|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|Fonction Generer info 10 ms|
IFTQSTRUCT_TQMON_vidGenerInf40ms|F|();|FCT1.6|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|fonction generer info 40 ms.|
IFTQSTRUCT_TQMON_vidGenerInfTole|K|();|FCT2.2|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|fonction generer info tolerence|
IFTQSTRUCT_TQMON_vidGenerInfTran|D|();|FCT2.1|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|cette fonction permet de générer les informations de transmission|
IFTQSTRUCT_TQMON_vidGerCprInject|G|();|FCT1.3|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|fonction gerer coupure injection|
IFTQSTRUCT_TQMON_vidInitOutput|H|();|FCT1.1|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|Initialisation des sorties|
IFTQSTRUCT_TQMON_vidInitOutputBis|H|();|FCT1.2|IFTQSTRUCT_TQMON|0|PTS_DOC_5050415||||0|0|0|0|Initialisation des sorties|
IgArb_vidDwellEnergyBenchMode|B|();|FCT1.5|IGARB|0|V02 NT 09 07775||||0|0|0|0|Ignition energy in bench mode|
IgArb_vidIgArbInit|B|();|FCT1.2|IGARB|0|V02 NT 09 07775||||0|0|0|0|Init function|
IgArb_vidIgnitionArbitration|B|();|FCT1.6|IGARB|0|V02 NT 09 07775||||0|0|0|0|En mode nominal (IgSys_bIgBenchModEna_C = 0) on recopie les consignes d’avance à l’allumage provenant de la  chaîne d’avance.|
IgArb_vidIgnitionClcBenchMod|B|();|FCT1.3|IGARB|0|V02 NT 09 07775||||0|0|0|0|Enable of ignition calculation in bench mode|
IgArb_vidIgnitionTimingBenchMode|B|();|FCT1.4|IGARB|0|V02 NT 09 07775||||0|0|0|0|Ignition timing in bench mode|
IGARB_vidInitOutput|A|();|FCT1.1|IGARB|0|V02 NT 09 07775||||0|0|0|0|output initialization.|
IgArb_vidMngBenchMod|B|();|FCT1.7|IGARB|0|V02 NT 09 07775||||0|0|0|0|export of authorization of bench mode|
IgCmd_EveBDC_MisfGenr|B|();|SCH.5|IGCMDMISFGENR|1|V02 NT 09 06148||||0|0|0|0|Interruption PMB|
IgCmd_EveCkSnOf_IgCoilMng|C|();|SCH.7|IGCOILMNG|1|PTS_DOC_6668934||||0|0|0|0|Evènement synchronisation perdue|
IgCmd_EveICD_IgCoilDiag|A|();|SCH.1|IGCOILDIAG|1|PTS_DOC_6719446||||0|0|0|0|Evénement de diagnostique du driver des bobines d'allumage
IgCmd_EveICD_IgCoilMng|B|();|SCH.4|IGCOILMNG|1|PTS_DOC_6668934||||0|0|0|0|Evénement de commande du driver des bobines d'allumage|
IgCmd_EveRst_ActrTstCoil|A|();|SCH.1|IGCOILACTEST|1|V02 NT 09 00741||||0|0|0|0|Evénement reset du calculateur|
IgCmd_EveRst_IgCoilMng|B|();|SCH.1|IGCOILMNG|1|PTS_DOC_6668934||||0|0|0|0|Evénement reset du calculateur|
IgCmd_EveRst_MisfGenr|A|();|SCH.1|IGCMDMISFGENR|1|V02 NT 09 06148||||0|0|0|0|Evénement reset du calculateur|
IgCmd_EveRTSt_MisfGenr|A|();|SCH.2|IGCMDMISFGENR|1|V02 NT 09 06148||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant.|
IgCmd_EveStTR_IgCoilMng|B|();|SCH.5|IGCOILMNG|1|PTS_DOC_6668934||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant.|
IgCmd_EveStTR_MisfGenr|A|();|SCH.3|IGCMDMISFGENR|1|V02 NT 09 06148||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant.|
IgCmd_EveSyncAccu_IgCoilMng|C|();|SCH.6|IGCOILMNG|1|PTS_DOC_6668934||||0|0|0|0|Evénement indiquant le passage en synchronisation précise du moteur|
IgCmd_SdlFast_ActrTstCoil|A|();|SCH.2|IGCOILACTEST|1|V02 NT 09 00741||||0|0|0|0|Moniteur rapide de la fonction IgCmd|
IgCmd_SdlFast_IgCoilDiag|A|();|SCH.2|IGCOILDIAG|1|PTS_DOC_6719446||||0|0|0|0|Moniteur rapide de la fonction diagnostic IgCmd
IgCmd_SdlFast_IgCoilMng|B|();|SCH.3|IGCOILMNG|1|PTS_DOC_6668934||||0|0|0|0|Moniteur rapide de la fonction IgCmd|
IgCmd_SdlMid_IgCoilDiag|A|();|SCH.3|IGCOILDIAG|1|PTS_DOC_6719446||||0|0|0|0|Moniteur moyen de la fonction diagnostic IgCmd
IgCmd_SdlSlow_IgCoilMng|B|();|SCH.2|IGCOILMNG|1|PTS_DOC_6668934||||0|0|0|0|Moniteur lent de la fonction IgCmd|
IgCmd_SdlSlow_MisfGenr|B|();|SCH.4|IGCMDMISFGENR|1|V02 NT 09 06148||||0|0|0|0|Moniteur lent de la fonction MisfGenr.|
IGCMDMISFGENR_vidAutorisMisfConf|A|();|FCT1.4|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Cette fonction permet l'initialisation de Msm_spark_counter à Recurrence_misfire_deterministe afin de déclencher un misfire sur le premier cylindre choisi par Msm_coupure_cylindre.|
IGCMDMISFGENR_vidCylSelection|A|();|FCT2.3|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Cette fonction permet de redistribuer les composantes du vecteur Misfire_cylindre dans les variables de sortie propre à chaque cylindre.|
IGCMDMISFGENR_vidDeterministMode|A|();|FCT1.7|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Cette fonction permet de couper la bobine courante en mode déterministe et d' autoriser aussi la coupure de la bobine suivante en cas de mode successif.|
IGCMDMISFGENR_vidInhibMisfConf|A|();|FCT1.5|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Cette fonction permet la réinitalisation du calcul du générateur de misfire.|
IGCMDMISFGENR_vidInit|D|();|FCT1.1|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Initialisation des variables au reset.|
IGCMDMISFGENR_vidInitcompteurs|A|();|FCT2.4|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Le compteur global du nombre de combustions Cnt_global ainsi que le compteur de misfire Cnt_misfire sont réinitialisés à 0 lors de la détection d’un changement effectué sur la valeur de la calibration Taux_misfire_aleatoire.|
IGCMDMISFGENR_vidInitOutput|C|();|FCT1.2|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Initialisation des sorties.|
IGCMDMISFGENR_vidManageMisfCoils|D|();|FCT1.3|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Gestion des Misfire des  bobines.|
IGCMDMISFGENR_vidMisfireCylinder|B|();|FCT1.6|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Cette fonction permet de faire le choix du mode de génération de misfire : Déterministe ou Aléatoire.|
IGCMDMISFGENR_vidMisfireGenStop|A|();|FCT2.6|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Ce bloc réinitalise le calcul de Misfire_cylindre.|
IGCMDMISFGENR_vidMisfireRatio|E|();|FCT2.2|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Cette fonction pemet de produire les taux de misfire en mode aléatoire et déterministe ainsi que le taux de misfire EOBD (mode aléatoire ou déterministe).|
IGCMDMISFGENR_vidNotReachedRecur|A|();|FCT1.10|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Cette fonction permet, si Recurrence_misfire_deterministe n’est pas atteinte, d'initialiser Misfire_cylindre à zéro.|
IGCMDMISFGENR_vidRandomMode|C|();|FCT1.8|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Cette fonction produit l'indicateur de génération d'un raté d'allumage.|
IGCMDMISFGENR_vidRazMsmSparkCnt|A|();|FCT2.1|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Cette fonction permet, en mode successif, d'initialiser  le compteur de récurrence uniquement lors du premier misfire.|
IGCMDMISFGENR_vidReachedRecur|B|();|FCT1.9|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Cette fonction permet,lorsque Recurrence_misfire_deterministe est atteinte, de générer un misfire sur le cylindre actuellement en compression.Dans le cas d’un mode successif, elle permet l'inhibition de la réinitialisation du compteur de récurrence.|
IGCMDMISFGENR_vidTauxmisfirereel|A|();|FCT2.5|IGCMDMISFGENR|0|V02 NT 09 06148||||0|0|0|0|Le taux réel de misfire générés est calculés mis à jour en permanence grâce à deux compteurs : Cnt_global comptant toutes les combustions et Cnt_misfire comptant les combustions avec misfire.|
IGCOILACTEST_vidCoilEntryMode|A|();|FCT1.7|IGCOILACTEST|0|V02 NT 09 00741||||0|0|0|0|Exécution du test actionneur|
IGCOILACTEST_vidCoilTestEnd|A|();|FCT1.9|IGCOILACTEST|0|V02 NT 09 00741||||0|0|0|0|Fin du test actionneur|
IGCOILACTEST_vidCoilTestMode|A|();|FCT1.8|IGCOILACTEST|0|V02 NT 09 00741||||0|0|0|0|Envoi de la consigne de temps d’activation des bobines au LDB si un des tests actionneur bobine est demandé.|
IGCOILACTEST_vidEntryMode|C|();|FCT1.3|IGCOILACTEST|0|V02 NT 09 00741||||0|0|0|0|informer le LdB qu’un test actionneur va s’exécuter|
IGCOILACTEST_vidIgnTime|D|();|FCT1.2|IGCOILACTEST|0|V02 NT 09 00741||||0|0|0|0|calcul le temps de commande de bobine à envoyer au LdB|
IGCOILACTEST_vidInitOutput|D|();|FCT1.1|IGCOILACTEST|0|V02 NT 09 00741||||0|0|0|0|Initialisation des sorties|
IGCOILACTEST_vidTestEnd|C|();|FCT1.6|IGCOILACTEST|0|V02 NT 09 00741||||0|0|0|0|Le LdB doit se remettre en configuration synchrone à la fin du test.|
IGCOILACTEST_vidTestMode|B|();|FCT1.4|IGCOILACTEST|0|V02 NT 09 00741||||0|0|0|0|fonction de test si l'envoi au LdB de temps du test s'effectue ou pas.|
IGCOILACTEST_vidTestRealisation|C|();|FCT1.5|IGCOILACTEST|0|V02 NT 09 00741||||0|0|0|0|Envoi au LdB le temps du test|
IGCOILDIAG_vidCalcIcdDiagEnabled|C|();|FCT1.1|IGCOILDIAG|0|PTS_DOC_6719446||||0|0|0|0|A haut régime ou faible tension batterie, il devient impossible de diagnostiquer un court-circuit ouvert sur les bobines.
IGCOILDIAG_vidCallDiagICD|B|();|FCT1.2|IGCOILDIAG|0|PTS_DOC_6719446||||0|0|0|0|Il est inutile de prendre en compte la condition sur Code_test_action ni celle Srv_stActrTstStatus puisque les tests actionneurs n’ont lieu que lorsque le moteur est arrêté (pas de PMB).
IGCOILDIAG_vidCallDiagSdlFast|B|();|FCT1.3|IGCOILDIAG|0|PTS_DOC_6719446||||0|0|0|0|call the diagnosis function depending on IgCmd_bCallDiagTyp_C, Srv_stActrTstStatus and Code_test_action.
IGCOILDIAG_vidDiagBob1|B|();|FCT1.5|IGCOILDIAG|0|PTS_DOC_6719446||||0|0|0|0|Fonction du diagnostic du bobine 1
IGCOILDIAG_vidDiagBob2|B|();|FCT1.6|IGCOILDIAG|0|PTS_DOC_6719446||||0|0|0|0|Fonction du diagnostic du bobine 2
IGCOILDIAG_vidDiagBob3|B|();|FCT1.7|IGCOILDIAG|0|PTS_DOC_6719446||||0|0|0|0|Fonction du diagnostic du bobine 3
IGCOILDIAG_vidDiagBob4|B|();|FCT1.8|IGCOILDIAG|0|PTS_DOC_6719446||||0|0|0|0|Fonction du diagnostic du bobine 4. La génération des événements CALL_GduOc_IgCoil4Cmd et CALL_GduScp_IgCoil4Cmd doit se faire après l’appel de l’API DgoHALRead.
IGCOILDIAG_vidDiagnostic|B|();|FCT1.4|IGCOILDIAG|0|PTS_DOC_6719446||||0|0|0|0|Pour garder la transversalité 3 cylindres/4 cylindres, l'appel au diagnostic se fera pour tous les cylindres à chaque PMB. Les diagnostics non réalisés seront couverts par les _bMonRun à 0
IGCOILMNG_vidAgIgMng|B|();|FCT1.10|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Ce bloc gère l’envoi de l’avance finale à appliquer et l’avance finale suivante et la demande d’inhibition de l’allumage pour les besoins de la stratégie Misfire.|
IGCOILMNG_vidCalcDwellTime|C|();|FCT1.7|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Calcul du seuil temporel du diagnostic du circuit ouvert c’est à dire du temps de Dwell|
IGCOILMNG_vidCalcIcdRatioEnergy|C|();|FCT1.5|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Le rapport « Icd_ratio_energy » est géré entre l’énergie souhaitée et nominale  (cf. déterminé en fonction de caractéristiques hardware) de la commande des bobines, Deux cas peuvent se présenter:  cas où le moteur est froid/cas où le moteur est chaud|
IGCOILMNG_vidCalcIcdState|C|();|FCT1.4|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Cet automate détermine le mode de fonctionnement des bobines: Phase de démarrage ou normale où l’énergie d’allumage nommée Icd_max_current_coils bénéficiera de l’adaptation via le ratio nommé Icd_ratio_energy. Initialement, l’énergie d’allumage sera fixe.|
IGCOILMNG_vidCallDiagICD|B|();|FCT3.1|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Il est inutile de prendre en compte la condition sur Code_test_action ni celle Srv_stActrTstStatus puisque les tests actionneurs n’ont lieu que lorsque le moteur est arrêté (pas de PMB).|
IGCOILMNG_vidCallDiagSdlFast|B|();|FCT3.2|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|call the diagnosis function depending on IgCmd_bCallDiagTyp_C, Srv_stActrTstStatus and Code_test_action.|
IGCOILMNG_vidDiagBob1|B|();|FCT2.7|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Fonction du diagnostic du bobine 1|
IGCOILMNG_vidDiagBob2|B|();|FCT2.8|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Fonction du diagnostic du bobine 2|
IGCOILMNG_vidDiagBob3|B|();|FCT2.9|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Fonction du diagnostic du bobine 3|
IGCOILMNG_vidDiagBob4|B|();|FCT2.10|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Fonction du diagnostic du bobine 4. La génération des événements CALL_GduOc_IgCoil4Cmd et CALL_GduScp_IgCoil4Cmd doit se faire après l’appel de l’API DgoHALRead.|
IGCOILMNG_vidDiagCoil|C|(argin uint32 udtChannel,argout boolean *bDgoOc,argout boolean *bMonRunOc,argout boolean *bDgoScg,argout boolean *bMonRunScg,argout boolean *bDgoScp,argout boolean *bMonRunScp);|FCT1.6|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|En cas de procédure « Test actionneurs » active, aucunes de ces deux pannes ne seront comptées, mais les booléens « Defaut_cc_plus » et « Defaut_circuit_ouvert » seront mis à jour.|
IGCOILMNG_vidDiagnostic|B|();|FCT2.6|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Pour garder la transversalité 3 cylindres/4 cylindres, l'appel au diagnostic se fera pour tous les cylindres à chaque PMB. Les diagnostics non réalisés seront couverts par les _bMonRun à 0|
IGCOILMNG_vidDisable|B|();|FCT3.3|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Le driver est désactivé sur perte de synchronisation et sur Key Off.|
IGCOILMNG_vidDwellTime|C|();|FCT1.8|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Le temps de Dwell est calculé via la cartographie Table_dwell_dem puis envoyé au Ldb par l’API IgnHALWriteDwellTime|
IGCOILMNG_vidEnable|C|();|FCT1.2|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Le driver allumage est activé sur validation de la synchronisation précise et sur sens de rotation avant.|
IGCOILMNG_vidIcdRatioEnergy|C|();|FCT1.9|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Fonction permet de calculer Le courant primaire  définie par une cartographie Régime Charge.|
IGCOILMNG_vidInhibIgn|B|();|FCT2.2|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Calling IGNHAL_vidInhibCoil for the current cylinder.|
IGCOILMNG_vidInhibIgnNext|B|();|FCT2.3|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Calling IGNHAL_vidInhibCoil for the next cylinder.|
IGCOILMNG_vidInitilization|C|();|FCT1.3|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Initialisation de l'automate de commande des bobines|
IGCOILMNG_vidInitOutput|B|();|FCT1.1|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Initialisation of the output|
IGCOILMNG_vidProgAvance|B|();|FCT2.4|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Calling IgnHALWriteAngle for the current cylinder.|
IGCOILMNG_vidProgAvanceNext|B|();|FCT2.5|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Calling IgnHALWriteAngle for the next cylinder.|
IGCOILMNG_vidTestInhibIgn|B|();|FCT2.1|IGCOILMNG|0|PTS_DOC_6668934||||0|0|0|0|Ce bloc gère la demande d’inhibition de la bobine du cylindre en cours de compression et celle de la bobine du cylindre suivant.|
IGCRK_vidCalcAdvanceCranking|E|();|FCT1.2|IGCRK|0|V02 NT 09 04922||||0|0|0|0|L’avance sous démarreur est calculée en fonction de la température d’eau et du régime moteur.
IGCRK_vidInitOutput|A|();|FCT1.1|IGCRK|0|V02 NT 09 04922||||0|0|0|0|Fonction d'initialisation des variables produites par la spec.
IGEXTHERMOPROT_vidAdvCalc|C|();|FCT2.3|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction permettant le débornage des avances mini en cas de protection composants pour assurer les suivis de couple|
IGEXTHERMOPROT_vidASRAdvCalc|D|();|FCT2.7|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Quatrième fonction permettant le débornage des avances mini en cas de protection composants pour assurer les suivis de couple|
IGEXTHERMOPROT_vidBVAdvCalc|C|();|FCT2.6|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Troisième fonction permettant le débornage des avances mini en cas de protection composants pour assurer les suivis de couple|
IGEXTHERMOPROT_vidCalOnCutOrCutP|B|();|FCT2.2|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Focntion de calcul du during des transitions COUPURE et COUPURE_PROT|
IGEXTHERMOPROT_vidCalOnIntOrProt|B|();|FCT2.1|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction de calcul du during de la transition INTEGRATION et PROTECTION|
IGEXTHERMOPROT_vidCurAdvCalc|C|();|FCT2.5|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Deuxième fonction permettant le débornage des avances mini en cas de protection composants pour assurer les suivis de couple|
IGEXTHERMOPROT_vidCut|B|();|FCT1.8|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction de transition de l'état THERMOPROT_COUPURE|
IGEXTHERMOPROT_vidCutProt|B|();|FCT1.10|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction de transition de l'état THERMOPROT_COUP_PROT|
IGEXTHERMOPROT_vidEntryInit|B|();|SCH.1|IGEXTHERMOPROT|1|V02 NT 08 06151||||0|0|0|0|Fonction d'accroche au reset|
IGEXTHERMOPROT_vidInhAdvMinTimer|A|();|FCT2.9|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Une fois le temps d'un des quatre premiers Timers écoulé, les quatre second Timers sont lancés en même temps pour décompter un temps d’inhibition du débornage des avances calibrables|
IGEXTHERMOPROT_vidInit|B|();|FCT1.6|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction de transition de l'état THERMOPROT_INIT|
IGEXTHERMOPROT_vidInitOutput|B|();|FCT1.1|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction d'initialisation des sorties|
IGEXTHERMOPROT_vidIntegration|B|();|FCT1.7|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction de transition de l'état THERMOPROT_INTEGRATION|
IGEXTHERMOPROT_vidPrevAdvCalc|C|();|FCT2.4|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Première fonction permettant le débornage des avances mini en cas de protection composants pour assurer les suivis de couple|
IGEXTHERMOPROT_vidProtAdvCalc|A|();|FCT1.3|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction permettant de déterminer une nouvelle avance min de protection thermique échappement|
IGEXTHERMOPROT_vidProtection|B|();|FCT1.9|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction de transition de l'état THERMOPROT_PROTECTION|
IGEXTHERMOPROT_vidResetProtTherm|B|();|FCT1.2|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction d'initialisation des outputs|
IGEXTHERMOPROT_vidThermProt|C|();|FCT1.5|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Gestion de l'automate permettant la proctection de la ligne d'échappement|
IGEXTHERMOPROT_vidThermProtCalc|B|();|FCT2.8|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction permettant le calcul des variables nécessaires pour le fonctionnement de l'automate|
IGEXTHERMOPROT_vidYieldAdvCalc|B|();|FCT1.4|IGEXTHERMOPROT|0|V02 NT 08 06151||||0|0|0|0|Fonction permettant de faire le calcul destiné à utiliser les rendements fournis par le module d’avance.|
IgLim_EveBDC_CritZone|B|();|SCH.4|KNKCRITZONE|1|V02 NT 08 05110||||0|0|0|0|Interruption PMB|
IgLim_EveBDC_CritZoneIf|C|();|SCH20.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Interruption PMB.|
IgLim_EveBDC_FastCor|C|();|SCH.4|KNKFASTCOR|1|PTS_DOC_5059533||||0|0|0|0|Interruption PMB|
IgLim_EveBDC_KnkAdpCor|F|();|SCH.1|KNKADPCOR|1|PTS_DOC_5154831||||0|0|0|0|Evènement point mort bas admission|
IgLim_EveBDC_ShdCor|A|();|SCH.3|KNKSHDCOR|1|V02 NT 08 07294||||0|0|0|0|Interruption PMB
IgLim_EveCkSnOn_ShdCor|A|();|SCH.2|KNKSHDCOR|1|V02 NT 08 07294||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise
IgLim_EveCrTR_CritZone|B|();|SCH.2|KNKCRITZONE|1|V02 NT 08 05110||||0|0|0|0|Evénement CRANKING vers RUNNING|
IgLim_EveCrTR_CritZoneIf|C|();|SCH20.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement CRANKING vers RUNNING.|
IgLim_EveCrTR_FastCor|C|();|SCH.2|KNKFASTCOR|1|PTS_DOC_5059533||||0|0|0|0|Evénement CRANKING vers RUNNING|
IgLim_EveRst_CritZone|B|();|SCH.1|KNKCRITZONE|1|V02 NT 08 05110||||0|0|0|0|Evénement reset du calculateur|
IgLim_EveRst_CritZoneIf|C|();|SCH20.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset du calculateur|
IgLim_EveRst_FastCor|C|();|SCH.1|KNKFASTCOR|1|PTS_DOC_5059533||||0|0|0|0|Evénement reset du calculateur|
IgLim_EveRst_KnkAdpCor|C|();|SCH.2|KNKADPCOR|1|PTS_DOC_5154831||||0|0|0|0|Evènement reset|
IgLim_EveRst_KnkInhAdp|A|();|SCH.1|KNKINHADP|1|V02 NT 09 02295||||0|0|0|0|Evénement reset du calculateur|
IgLim_EveRst_ShdCor|A|();|SCH.1|KNKSHDCOR|1|V02 NT 08 07294||||0|0|0|0|Evénement reset du calculateur
IgLim_EveRTCr_CritZone|B|();|SCH.3|KNKCRITZONE|1|V02 NT 08 05110||||0|0|0|0|Evénement RUNNING vers CRANKING|
IgLim_EveRTCr_CritZoneIf|C|();|SCH20.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement RUNNING vers CRANKING.|
IgLim_EveRTCr_FastCor|C|();|SCH.3|KNKFASTCOR|1|PTS_DOC_5059533||||0|0|0|0|Evénement RUNNING vers CRANKING|
IgLim_SdlFast_KnkAdpCor|C|();|SCH.3|KNKADPCOR|1|PTS_DOC_5154831||||0|0|0|0|Moniteur rapide de la fonction IgLim|
IgLim_SdlMid_KnkAdpCor|C|();|SCH.4|KNKADPCOR|1|PTS_DOC_5154831||||0|0|0|0|Moniteur moyen de la fonction IgLim|
IgLim_SdlMid_KnkInhAdp|A|();|SCH.2|KNKINHADP|1|V02 NT 09 02295||||0|0|0|0|Moniteur moyen pour la fonction KnkInhAdp|
IgLim_SdlSlow_KnkAdpCor|C|();|SCH.5|KNKADPCOR|1|PTS_DOC_5154831||||0|0|0|0|Moniteur lent de la fonction IgLim|
IGNHAL_vidInhibCoil|B|(argin uint8 u8Channel);|13|HEADER|1|NONE||||0|0|0|0||
IGNHAL_vidWriteEnergy|B|(argin uint16 u16MaxCurrent);|5|HEADER|1|NONE||||0|0|0|0||
IgnHALDisable|B|();|10|HEADER|1|NONE||||0|0|0|0||
IgnHALEnable|B|();|9|HEADER|1|NONE||||0|0|0|0||
IgnHALWriteAngle|B|(argin uint8 u8Channel, argin uint16 u16Advance);|4|HEADER|1|NONE||||0|0|0|0||
IgnHALWriteDwellTime|B|(argin uint16 u16DwellTime);|6|HEADER|1|NONE||||0|0|0|0||
IgnHALWriteMode|B|func_IgnHALWriteMode|8|HEADER|1|NONE||||0|0|0|0||
IgnHALWriteTestTime|A|(argin uint8 u8Channel, argin uint32 u32TestTime);|3|HEADER|1|NONE||||0|0|0|0||
IgSys_EveBDC_IgArb|A|();|SCH.3|IGARB|1|V02 NT 09 07775||||0|0|0|0|Interruption PMB de la fonction IgSys|
IgSys_EveBDC_IgCrk|B|();|SCH.2|IGCRK|1|V02 NT 09 04922||||0|0|0|0|Evénement PMB admission
IgSys_EveBDC_IgExThermoProt|A|();|SCH.3|IGEXTHERMOPROT|1|V02 NT 08 06151||||0|0|0|0|Fonction d'accroche au moniteur IgSys_EveBDC_IgExThermoProt|
IgSys_EveCkSnOn_IgCoilMng|C|();|SCH.8|IGCOILMNG|1|PTS_DOC_6668934||||0|0|0|0|Evènement d'appel de l'enable du driver allumage pour couvrir les cas de redémarrages STT rapides.|
IgSys_EveRst_IgArb|B|();|SCH.1|IGARB|1|V02 NT 09 07775||||0|0|0|0|Evènement Reset de la fonction IgSys|
IgSys_EveRst_IgCrk|C|();|SCH.1|IGCRK|1|V02 NT 09 04922||||0|0|0|0|Evènement reset du calculateur
IgSys_EveRTSt_IgCrk|B|();|SCH.3|IGCRK|1|V02 NT 09 04922||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant
IgSys_EveTDC_AddOnAdvMax|A|();|SCH.2|ADDONADVMAX|1|V02 NT 11 01471||||0|0|0|0|Occurrence de calcul de la fonction AddOnAdvMax.|
IgSys_EveTDC_AddOnAdvMin|A|();|SCH.2|ADDONADVMIN|1|V02 NT 11 01472||||0|0|0|0|Occurrence de calcul de la fonction AddOnAdvMin.|
IgSys_EveTDC_AddOnAdvOptm|A|();|SCH.2|ADDONADVOPTM|1|V02 NT 11 01474||||0|0|0|0|Accroche moniteur pour le module ADDONADVOPTM|
IgSys_EveTDC_AddOnAgCor|A|();|SCH.2|ADDONAGCOR|1|V02 NT 11 01473||||0|0|0|0|Occurrence de calcul de la fonction AddOnAgCor|
IgSys_SdlFast_TCoRegKnk|A|();|SCH.2|TCOREGKNK|1|V02 NT 11 04673||||0|0|0|0|Occurrence  d'appel de la  fonction  activation du refroidissement pour la garde rumble|
IgSys_SdlMid_IgExThermoProt|B|();|SCH.2|IGEXTHERMOPROT|1|V02 NT 08 06151||||0|0|0|0|Fonction d'accroche au moniteur IgSys_SdlMid_IgExThermoProt|
IgSys_SdlSlow_IgArb|A|();|SCH.2|IGARB|1|V02 NT 09 07775||||0|0|0|0|Moniteur lent de la fonction IgSys|
IGVOLTADJ_vidEntryInit|B|();|SCH.1|IGVOLTADJ|1|PTS_DOC_6444206||||0|0|0|0|Fonction d'accroche Reset|
IGVOLTADJ_vidIgVoltAdj|B|();|FCT1.2|IGVOLTADJ|0|PTS_DOC_6444206||||0|0|0|0|Two conditions are considered in this specification to generate a boost request:  when the ignition energy ratio is lower than the threshold value and the Boolean IgVoltAdj_bVoltAdj turns to true under some high-load operating points|
IGVOLTADJ_vidInitOutput|B|();|FCT1.1|IGVOLTADJ|0|PTS_DOC_6444206||||0|0|0|0|initialisation des sorties|
IGVOLTADJ_vidVoltAdjZone|B|();|FCT1.3|IGVOLTADJ|0|PTS_DOC_6444206||||0|0|0|0|A RS-FlipFlop is implemented in this block to define the operating zone requiring a boost request for ignition system.  The flag IgVoltAdjReq_bVoltAdj indicates the entry of high load area followed by a temporisation of IgVoltAdj_tiActDly_C seconds.|
Immo_100ms|A|();|HD_2|HEADER|1|HEADER||||0|0|0|0||
Immo_EndWr|A|(argin uint8 Ext_stEndWrImmo);|HD_3|HEADER|1|HEADER||||0|0|0|0||
Immo_GetConf|B|(argout uint8 *Immo_stProgImmoConf, argout boolean *Immo_bLockECUConf, argout uint8 *Immo_stCANOptConf);|4|HEADER|1|HEADER||||0|0|0|0||
Immo_Init|A|();|HD_01|HEADER|1|HEADER||||0|0|0|0||
Immo_KeyMgt|B|(argin uint32 Ext_noKeyCtlUnit, argin uint8 Ext_noRcvSrvTypImmo);|HD|HEADER|1|HEADER||||0|0|0|0||
Immo_ReqCtlCod|A|(argin uint32 Ext_noImmoCodTestDiag);|HD|HEADER|1|HEADER||||0|0|0|0||
Immo_ReqMatch|A|(argin uint8 Ext_stMatchSrvDiag);|HD|HEADER|1|HEADER||||0|0|0|0||
Immo_ReqReadSt|A|();|HD|HEADER|1|HEADER||||0|0|0|0||
Immo_ReqWrCod|A|(argin uint32 Ext_noImmoCodProgDiag, argin uint8 Ext_stCANMatchOptDiag);|HD|HEADER|1|HEADER||||0|0|0|0||
INAIRFLOWDIAG_vidDgPrLeak|C|();|FCT1.5|INAIRFLOWDIAG|0|PTS_DOC_5198333||||0|0|0|0|Le test compare le rapport de cohérence entre les débits entrant et sortant du collecteur (InM_rCohMnfMf) avec 1, sa valeur d'équilibre : => AirSys_rCohMnfMfBoostDeac = 1 - InM_rCohMnfMf|
INAIRFLOWDIAG_vidDgPrLwAirfl|C|();|FCT1.3|INAIRFLOWDIAG|0|PTS_DOC_5198333||||0|0|0|0|Le test compare le rapport de cohérence entre les débits entrant et sortant du collecteur (InM_rCohMnfMf) avec 1, sa valeur d'équilibre : => AirSys_rCohMnfMfBoost = InM_rCohMnfMf - 1|
INAIRFLOWDIAG_vidInit|B|();|FCT1.1|INAIRFLOWDIAG|0|PTS_DOC_5198333||||0|0|0|0|Fonction d'initialisation|
INAIRFLOWDIAG_vidLeak|C|();|FCT1.4|INAIRFLOWDIAG|0|PTS_DOC_5198333||||0|0|0|0|Ce diagnostic permet de détecter une fuite ou une augmentation du débit dans le répartiteur (aval BPM) de plus de X g/s en situation de vie "moteur atmosphérique".|
INAIRFLOWDIAG_vidLowAirflow|B|();|FCT1.2|INAIRFLOWDIAG|0|PTS_DOC_5198333||||0|0|0|0|Ce diagnostic permet de détecter une baisse du débit d'air à l'admission de X g/s en aval du BPM en mode sural.|
INDICOBD_DstAndDurMIL|C|();|FCT1.5|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|The strategy calculating the regulatory indicators relatives to the MIL lights up is divided into 2 functions : - F01_IndicOBD_DstCntRstCdn and F02_IndicOBD_DstAndDurnCnt_MilOn|
INDICOBD_RstDftCal|B|();|API.3|INDICOBD|1|PTS_DOC_5075367||||0|0|0|0|Manual clear failure request|
INDICOBD_vidDftMILCntDec|A|();|FCT2.5|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|Each time a MIL relevant failure is cleared, the counter is decremented by one unit.|
INDICOBD_vidDftMILCntInc|A|();|FCT2.3|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|This function check if ther is a MIL relevant failure is cleared, the counter is decremented by one unit.|
INDICOBD_vidDftMILCntPrev|A|();|FCT2.1|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|This function recovers the previous value of the counter in order to reinit it even for a failure clear event.|
INDICOBD_vidDftMILRstCnt|A|();|FCT2.6|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|The time and distance traveld counter with MIL illuminated are reinitialized when no more OBD relevant failure is confirmed|
INDICOBD_vidDisableEngRun|B|();|FCT1.9|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|The Boolean GMIL_bEngRun is set to 0 as soon as the engine stops.|
INDICOBD_vidDstAndDurnCnt|D|(argin uint32* DistHecto, argin uint32* GMIL_tiEngRun,argin uint16* GMIL_DstKm,argin uint16* GMIL_tiMinsEngRun);|FCT1.6|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|Generic Function|
INDICOBD_vidDstCntRstCdn|B|();|FCT2.7|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|This function reinitializes the time and distance counters to 0|
INDICOBD_vidDstPrevCalc|A|();|FCT1.10|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|This function produces the previous value of Distance_parcourue_hectometre.|
INDICOBD_vidEnableEngRun|B|();|FCT1.8|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|The Boolean GMIL_bEngRun is set to 1 as soon as the engine starts.|
INDICOBD_vidF04_RstCnt|B|();|FCT1.7|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|This function reinitializes the time and distance counters at each manual clear failure event generated by calibration, the after sale tool or Scan-Tool|
INDICOBD_vidIndicOBDDstRstDft|C|();|FCT1.3|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|This function generates GMIL_dstKmRstDft : The covered distance since the last clear failure in kilometres.|
INDICOBD_vidIndicOBDDurRstDft|B|();|FCT1.4|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|This function generates The time spent since the last clear failure in minutes.|
INDICOBD_vidIndObdDstAndDurRstDf|B|();|FCT1.2|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|The calculation of  the time and distance since the last clear failure is effective only during the ECU’s main wake up.|
INDICOBD_vidInit|D|();|FCT1.1|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|This bloc is called at the ECU’s reset event. It initialises and read the data written in EEPROM at the last powerltach by the bloc F05_IndicOBD_StoreData|
INDICOBD_vidMngDftMILCntDec|A|(argin uint16 u16IdxDft);|FCT2.4|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|Each time a MIL relevant failure enters the OBD confirmed state, the counter is incremented by one unit.|
INDICOBD_vidMngDftMILCntInc|A|(argin uint16 u16IdxDft);|FCT2.2|INDICOBD|0|PTS_DOC_5075367||||0|0|0|0|This function check if there is a MIL relevant failure enters the OBD confirmed state|
INDICOBD_vidMngEveStObdClear|A|(argin uint16 u16IdxDft);|API.5|INDICOBD|1|PTS_DOC_5075367||||0|0|0|0|Evènement entrée du Gestionnaire OBD dans l'état GOBD effacé|
INDICOBD_vidMngEveStObdRec|A|(argin uint16 u16IdxDft);|API.4|INDICOBD|1|PTS_DOC_5075367||||0|0|0|0|Evènement entrée du Gestionnaire OBD dans l'état GOBD_ST_ENREGISTRE|
INFOCRASH_vidConfirmInfoCrash|A|();|FCT1.3|INFOCRASH|0|V02 NT 08 07842||||0|1|0|0|Dès que l’information CRASH est détectée le compteur RlyPwr_confirm_crash_count est incrémenté à chaque réception de trame 4C8h, lorsque le compteur atteint le seuil max de confirmation, l’information crash devient confirmée.|
INFOCRASH_vidEndConfirmCrash|A|();|FCT1.4|INFOCRASH|0|V02 NT 08 07842||||0|1|0|0|Fonction de finalisation de la confirmation information crash|
INFOCRASH_vidInhOrAuthInfoCrash|A|();|FCT1.5|INFOCRASH|0|V02 NT 08 07842||||0|1|0|0|Fonction d'inhibition/autorisation de l'information crash|
INFOCRASH_vidInit|A|();|FCT1.1|INFOCRASH|0|V02 NT 08 07842||||0|1|0|0|Fonction d'initialisation des sorties au reset|
INFOCRASH_vidInitOutput|A|();|FCT1.2|INFOCRASH|0|V02 NT 08 07842||||0|1|0|0|Fonction d'initialisation des sorties au reset|
InitExtNodeMonitoring|A|(argin uint8 NetId, argin uint8 NodeId, argin uint8 DeltaInc, argin uint8 DeltaDec);|1.4|HEADER|1|V01 NT 08 05903||||0|0|0|0|
INITPROTECT_vidInitProtectDisable|A|();|1.2|INITPROTECT|1|NONE||||0|0|0|0|Desactive la protection contre les activateTask à l'init
INITPROTECT_vidInitProtectEnable|A|();|1.1|INITPROTECT|1|NONE||||0|0|0|0|Active la protection contre les activateTask à l'init
Inj_EveCkOff_InjCmd|B|();|SCH.2|INJCMD|1|PTS_DOC_6886136||||0|0|0|0|Evènement de sortie de cranking|
Inj_EveCkSnOf_InjCmd|D|();|SCH.3|INJCMD|1|PTS_DOC_6886136||||0|0|0|0|Evénement  d'appel  de  tâche  "synchro  perdue"  du  CMM  (à  la  perte  de  synchro  et  au  calage)|
Inj_EveCrTR_InjCmd|E|();|SCH.6|INJCMD|1|PTS_DOC_6886136||||0|0|0|0|Evénement CRANKING vers RUNNING|
Inj_EveInj_InjCmd|C|();|SCH.8|INJCMD|1|PTS_DOC_6886136||||0|0|0|0|Tâche INJ pour la commande injection|
Inj_EveKOf_InjCmd|D|();|SCH.5|INJCMD|1|PTS_DOC_6886136||||0|0|0|0|Evènement associé au passage de clef ON à clef OFF|
Inj_EveRst_ActrTstInj|C|();|SCH.1|INJACTEST|1|PTS_DOC_5135792||||0|0|0|0|Evènement reset du calculateur|
Inj_EveRst_FuTiRunIf2|D|();|SCH1.7|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Evènement.|
Inj_EveRst_InjCmd|D|();|SCH.1|INJCMD|1|PTS_DOC_6886136||||0|0|0|0|Evénement reset du calculateur|
Inj_EveRst_InjTiCor|F|();|SCH.1|INJTICOR|1|PTS_DOC_5147608||||0|0|0|0|Reset du calculateur.|
Inj_EveRst_InjTiCorIf|B|();|SCH4.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement reset du calculateur.|
Inj_EveRTSt_InjTiCor|B|();|SCH.4|INJTICOR|1|PTS_DOC_5147608||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant|
Inj_EveSpl_InjCmd|C|();|SCH.10|INJCMD|1|PTS_DOC_6886136||||0|0|0|0|Evénement "Spill"|
Inj_EveStTCr_InjCmd|F|();|SCH.7|INJCMD|1|PTS_DOC_6886136||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant|
Inj_EveSyncNotAccu_InjCmd|C|();|SCH.4|INJCMD|1|PTS_DOC_6886136||||0|0|0|0|Evénement indiquant le passage en synchronisation non précise du moteur|
Inj_SdlFast_ActrTstInj|C|();|SCH.2|INJACTEST|1|PTS_DOC_5135792||||0|0|0|0|Moniteur rapide de la fonction Inj|
Inj_SdlFast_DgoHalAcqInj|A|();|SCH.1|DGOHALACQINJ|1|PTS_DOC_6913684||||0|0|0|0|Moniteur rapide pour la commande des injecteurs|
Inj_SdlFast_FuTiRunIf2|D|();|SCH1.6|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Moniteur de module d'interface.|
Inj_SdlFast_InjCmd|F|();|SCH.9|INJCMD|1|PTS_DOC_6886136||||0|0|0|0|Moniteur rapide pour la commande des injecteurs|
Inj_SdlFast_InjTiCor|F|();|SCH.2|INJTICOR|1|PTS_DOC_5147608||||0|0|0|0|Moniteur rapide de la fonction Inj.|
Inj_SdlFast_InjTiCorIf|C|();|SCH14.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur lent de la fonction Inj.|
Inj_SdlMid_InjTiCor|G|();|SCH.3|INJTICOR|1|PTS_DOC_5147608||||0|0|0|0|Moniteur moyen de la fonction Inj.|
INJACTEST_vidEntryMode|D|();|FCT1.4|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|LDB is informed that an actuator test or an injector opening first start factory will be executed.|
INJACTEST_vidInitOutput|F|();|FCT1.1|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|Outputs initialization|
INJACTEST_vidStateEnd|E|();|FCT2.6|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|Treatment executed on state INJ_ACTRTST_END|
INJACTEST_vidStateFirstFull|A|();|FCT2.8|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|Treatment executed on state INJ_FIRSTFULL|
INJACTEST_vidStateIdle|E|();|FCT2.1|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|Treatment executed on state INJ_ACTRTST_IDLE|
INJACTEST_vidStateLdbReconf|C|();|FCT2.7|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|Treatment executed on state INJ_ACTRTST_LDB_RECONF|
INJACTEST_vidStateOff|F|();|FCT2.4|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|Treatment executed on state INJ_ACTRTST_OFF|
INJACTEST_vidStateOn|F|();|FCT2.3|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|Treatment executed on state INJ_ACTRTST_ON|
INJACTEST_vidStateStart|C|();|FCT2.2|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|Treatment executed on state INJ_ACTRTST_START|
INJACTEST_vidStateStop|E|();|FCT2.5|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|Treatment executed on state INJ_ACTRTST_STOP|
INJACTEST_vidTestEnd|F|();|FCT1.6|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|When the actuator test or the injector opening first start factory has ended, the LDB must go back to a synchronous configuration.|
INJACTEST_vidTestFrLstRun|G|();|FCT1.7|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|Il est nécessaire de savoir si un test actionneur injecteur a été réalisé depuis le dernier démarrage moteur afin de ne pas autoriser le test actionneur bobine.|
INJACTEST_vidTestMode|F|();|FCT1.5|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|An injection time is calculated for the actuator testor injector opening first start factoryand sent to the LDB.|
INJACTEST_vidTimeToInj|H|();|FCT1.2|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|The manager determines if an actuator testor injector opening first start factorymust be launched or not. In case of an actuator test request, the power relay is closed and Inj_bInjTstCmpl is set at 0 (test uncompleted).|
INJACTEST_vidTimeToInjCln|G|();|FCT1.3|INJACTEST|0|PTS_DOC_5135792||||0|0|0|0|La machine à états détermine si un test actionneur doit être lancé ou non.|
INJCMD_vidDiagnosticInjecteur1|E|();|FCT2.2|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Diagnostique du premier injecteur|
INJCMD_vidDiagnosticInjecteur2|E|();|FCT2.3|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Diagnostique du deuxième injecteur|
INJCMD_vidDiagnosticInjecteur3|E|();|FCT2.4|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Diagnostique du troisième injecteur|
INJCMD_vidDiagnosticInjecteur4|D|();|FCT2.5|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Diagnostique du quatrième injecteur|
INJCMD_vidDisableDriver|C|();|FCT3.3|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Cela permettra sa réactivation au redépart suivant,  l’autorisation étant faite sur le passage des états véhicule de VS_STALL à VS_CRANKING.|
INJCMD_vidFormatInjTime|C|FUNC_vidFormatInjTime|FCT1.3|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Scaling pour les temps d' injection|
INJCMD_vidInhibitAllCylinder|D|();|FCT3.4|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Ce bloc gère la demande de désactivation des injections séquentielles.|
INJCMD_vidInitDiag|A|();|FCT3.5|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Toutes les sorties API DGOHAL BSW sont initialisées à 0.|
INJCMD_vidInitEnable|D|();|FCT3.1|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|L’injection sera autorisée si la synchronisation « imprécise » est validée si le vilebrequin tourne en sens avant|
INJCMD_vidInitialisationMode|C|();|FCT3.2|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Initialise le mode d’injection (1, 2, 3 ou 4 pulses) , sur l’événement Stall to Crank,|
INJCMD_vidInitOutput|C|();|FCT1.1|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Initialisation des variables du module.|
INJCMD_vidInjectorsDiagnostic|B|();|FCT2.1|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Le diagnostic fournit une information de panne présente, utilisée par la gestion des défauts unitaire pour générer les éventuelles  demande de reconfiguration et définir les modes dégradés associés.|
INJCMD_vidInjHALCmdProfile|C|();|FCT1.6|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Fonction de changement de profil de commande.|
INJCMD_vidInjHALUpdate|D|();|FCT1.5|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Mise a jour de la couche hard d'injection|
INJCMD_vidManCutByCylinder|F|();|FCT2.6|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Deux entrées contrôlent la coupure (totale ou partielle) de l'injection: Auto_injection = 0 (lâché de pied ou véhicule arrêté) : coupure totale (sur les 3 cylindres), Coupure_decel_progr_inj ? 0 : coupure de l’injecteur concerné|
INJCMD_vidManInjTime|F|();|FCT1.2|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Les consignes phase et temps d'injection séquentielle doivent être immédiatement prises en compte par le driver injection si l'indicateur d'inhibition Inhibe_reactualisation_t_inj (calibration) n'est pas positionné.|
INJCMD_vidModeInjectionSequentielleCyl1|C|();|FCT1.7|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Mode d'injection sequentielle appliqué au cylindre 1|
INJCMD_vidModeInjectionSequentielleCyl2|C|();|FCT1.8|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Mode d'injection sequentielle appliqué au cylindre 2|
INJCMD_vidModeInjectionSequentielleCyl3|C|();|FCT1.9|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Mode d'injection sequentielle appliqué au cylindre 3|
INJCMD_vidModeInjectionSequentielleCyl4|D|();|FCT1.10|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Mode d'injection sequentielle appliqué au cylindre 4|
INJCMD_vidUpdate|B|();|FCT1.4|INJCMD|0|PTS_DOC_6886136||||0|0|0|0|Gestion de la mise a jour de la couche hard d'injection.|
INJCRK_ANTIFLOOD_vidConfAntFlood|C|();|FCT2.3|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Appel de la fonction INJCRK_ANTIFLOOD_vidPosPedNok si Dv_position_pedale_relative est inférieur ou égale à la différence entre Anti_flood_pedale_limit et Anti_flood_pedale_hysteresis, sinon INJCRK_ANTIFLOOD_vidPosPedOk sera appelé
INJCRK_ANTIFLOOD_vidCranking|B|();|FCT1.5|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Appel de la fonction INJCRK_ANTIFLOOD_vidEngSpdOk si Regime_moteur_32 est inférieur à Anti_flood_regime_reinj, sinon INJCRK_ANTIFLOOD_vidEngSpdNok sera appelé
INJCRK_ANTIFLOOD_vidCrkFuelling|B|();|FCT1.2|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Fonction qui active la fonction INJCRK_ANTIFLOOD_vidInitAntFlood si Vehicle_active_state et VS_CRANKING sont égaux
INJCRK_ANTIFLOOD_vidDetAntiFlood|B|();|FCT2.1|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Appel de la focntions INJCRK_ANTIFLOOD_vidIniAntiFlood si Dv_position_pedale_relative est supérieur à Anti_flood_pedale_limit
INJCRK_ANTIFLOOD_vidEngSpdNok|A|();|FCT1.7|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Fonction d'initialisation à 0 de Disable_inj_for_anti_flood et de Function_anti_flood
INJCRK_ANTIFLOOD_vidEngSpdOk|B|();|FCT1.6|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Appel de la focntions INJCRK_ANTIFLOOD_vidDetAntiFlood si Function_anti_flood égale à 1, sinon INJCRK_ANTIFLOOD_vidConfAntFlood sera appelé
INJCRK_ANTIFLOOD_vidEntryInit|B|();|SCH.1|INJCRK_ANTIFLOOD|1|V02 NT 08 04908||||0|0|0|0|Fonction d'accroche à l'evenement Reset
INJCRK_ANTIFLOOD_vidIniRunToCrnk|A|();|FCT1.8|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Fonction d'initialisation à 0 de Disable_inj_for_anti_flood et de Function_anti_flood
INJCRK_ANTIFLOOD_vidInitAntiFlood|B|();|FCT2.2|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Initialisation à 1 de Function_anti_flood et affectation de la valeur de Anti_flood_delay à Anti_flood_delay_counter
INJCRK_ANTIFLOOD_vidInitCrkFlood|A|();|FCT1.3|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Fonction d'initialisation à 0 de Disable_inj_for_anti_flood et de Function_anti_flood
INJCRK_ANTIFLOOD_vidInitOutput|A|();|FCT1.1|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Fonction d'initialisation des sorties
INJCRK_ANTIFLOOD_vidMngAntiFlood|B|();|FCT1.4|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Appel de la focntions INJCRK_ANTIFLOOD_vidCranking si Vehicle_active_state repasse dans l'état VS_CRANKING, sinon INJCRK_ANTIFLOOD_vidNotCranking sera appelé
INJCRK_ANTIFLOOD_vidNotCranking|B|();|FCT2.5|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Appel de la focntions INJCRK_ANTIFLOOD_vidRestAntFlood si Regime_moteur_32 est supérieur à Anti_flood_regime_reinj
INJCRK_ANTIFLOOD_vidPosPedNok|A|();|FCT2.7|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Fonction d'initialisation à 0 de Disable_inj_for_anti_flood et de Function_anti_flood
INJCRK_ANTIFLOOD_vidPosPedOk|B|();|FCT2.4|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|calcule de Anti_flood_delay_counter et de Disable_inj_for_anti_flood
INJCRK_ANTIFLOOD_vidRestAntFlood|A|();|FCT2.6|INJCRK_ANTIFLOOD|0|V02 NT 08 04908||||0|0|0|0|Fonction d'initialisation à 0 de Disable_inj_for_anti_flood et de Function_anti_flood
InjCrk_EveKOn_AntiFlood|A|();|SCH.3|INJCRK_ANTIFLOOD|1|V02 NT 08 04908||||0|0|0|0|Fonction d'accroche à l'evenement InjCrk_EveKOn_AntiFlood
InjCrk_EveKOn_AntiFloodIf|C|();|SCH14.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON.|
InjCrk_EveRTCr_AntiFlood|A|();|SCH.4|INJCRK_ANTIFLOOD|1|V02 NT 08 04908||||0|0|0|0|Fonction d'accroche à l'evenement InjCrk_EveRTCr_AntiFlood
InjCrk_EveRTCr_AntiFloodIf|C|();|SCH14.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement RUNNING vers CRANKING .|
InjCrk_EveStTCr_AntiFlood|A|();|SCH.2|INJCRK_ANTIFLOOD|1|V02 NT 08 04908||||0|0|0|0|Fonction d'accroche à l'evenement InjCrk_EveStTCr_AntiFlood
InjCrk_EveStTCr_AntiFloodIf|C|();|SCH14.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Event STALL vers CRANKING.|
InjCrk_SdlFast_AntiFlood|A|();|SCH.5|INJCRK_ANTIFLOOD|1|V02 NT 08 04908||||0|0|0|0|Fonction d'accroche à l'evenement InjCrk_SdlFast_AntiFlood
InjCrk_SdlFast_AntiFloodIf|C|();|SCH14.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide de la fonction injection.|
InjCtl_EveCrTR_FarCtlMgr|C|();|SCH.3|INJCTL_INJFARCTLMGR|1|PTS_DOC_5147287||||0|0|0|0|Evènement de CRANKING vers RUNNING|
InjCtl_EveFbDisab_FarCtlMgr|B|();|SCH.13|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Evènement de désactivation de la régulation de richesse|
InjCtl_EveFbEnad_FarCtlMgr|B|();|SCH.1|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l'event InjCtl_EveFbEnad_FarCtlMgr|
InjCtl_EveFbForSafEnad_FarCtlMgr|B|();|SCH.2|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l'event InjCtl_EveFbForSafEnad_FarCtlMgr|
InjCtl_EveIniClsdLoop_FarCtlMgr|B|();|SCH.3|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l 'event InjCtl_EveIniClsdLoop_FarCtlMgr|
InjCtl_EveIniFbClcn_FarCtlMgr|B|();|SCH.4|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l'event InjCtl_EveIniFbClcn_FarCtlMgr|
InjCtl_EveIniFbPrm_FarCtlMgr|B|();|SCH.5|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l'event InjCtl_EveIniFbPrm_FarCtlMgr|
InjCtl_EveMonrFbCdn_FarCtlMgr|C|();|SCH.12|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l'event  InjCtl_EveMonrFbCdn_FarCtlMgr|
InjCtl_EveReIniFbSaf_FarCtlMgr|B|();|SCH.7|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l'event InjCtl_EveReIniFbSaf_FarCtlMgr|
InjCtl_EveRst_FarCtlMgr|C|();|SCH.1|INJCTL_INJFARCTLMGR|1|PTS_DOC_5147287||||0|0|0|0|Evènement de Reset du calculateur|
InjCtl_EveRst_IfAirSysIgSys|D|();|SCH6.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur de module d'interface.|
InjCtl_EveRst_InjFarCtlDsCtl|B|();|SCH.1|INJFARCTLDSCTL|1|V02 NT 08 05886||||0|0|0|0|Reset du calculateur
InjCtl_EveRst_InjFarCtlUsCtl|B|();|SCH.9|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l'event InjCtl_EveRst_InjFarCtlUsCtl|
InjCtl_EveRst_LamClmpd|A|();|SCH.1|LAMCLMPD|1|V02 NT 09 02030||||0|0|0|0|Fonction d'accroche à l'event InjCtl_EveRst_LamClmpd
InjCtl_EveRstLbdFb_FarCtlMgr|B|();|SCH.8|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l'event InjCtl_EveRstLbdFb_FarCtlMgr|
InjCtl_EveRTSt_FarCtlMgr|C|();|SCH.2|INJCTL_INJFARCTLMGR|1|PTS_DOC_5147287||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant|
InjCtl_EveRTSt_FarCtlUsCtl|C|();|SCH.6|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l'event InjCtl_EveRTSt_FarCtlUsCtl|
InjCtl_EveRTSt_IfAirSysIgSys|D|();|SCH9.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur de module d'interface.|
InjCtl_EveTDC_FarCtlUsCtl|B|();|SCH.10|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l'event InjCtl_EveTDC_FarCtlUsCtl|
InjCtl_EveTDC_FarCtlUsCtlIf|D|();|SCH9.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur de module d'interface.|
INJCTL_INJFARCTLMGR_vidDecDelay|C|();|FCT1.4|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|Ce bloc décrémente le délai d’activation de la régulation de richesse de la valeur du pas de InjCtl_SampleTiSlow_SC.|
INJCTL_INJFARCTLMGR_vidDiagCata|D|();|FCT1.9|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|Ce bloc permet d’évaluer les conditions d’autorisation du diagnostic catalyseur intrusif.|
INJCTL_INJFARCTLMGR_vidFdRegCnd|B|();|FCT2.2|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|Cette fonction permet de gérer les conditions de bouclage/ débouclage de la régulation de richesse pour une configuration utilisant les module FAR fournit par PSA ou les moteurs de type injection directe.|
INJCTL_INJFARCTLMGR_vidFdRichCnd|B|();|FCT2.1|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|Cette fonction permet de gérer les conditions de bouclage/ débouclage de la régulation de richesse pour une configuration utilisant les modules FAR Valéo en injection indirecte.|
INJCTL_INJFARCTLMGR_vidFSM|J|();|FCT1.5|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|Ce bloc permet de gérer les conditions de régulation, en modifiant l’état de la variable : Monitor_feedback_conds_state.|
INJCTL_INJFARCTLMGR_vidGlobalCnd|C|();|FCT2.3|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|Cette fonction permet de désactiver le bouclage,lorsque un diagnostic intrusif pour la sonde aval est demandé, pour permettre l’utilisation du créneau de richesse.|
INJCTL_INJFARCTLMGR_vidInit|C|();|FCT1.1|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|Le bouclage de la richesse est désactivé lors d’un calage moteur ou lors de l’initialisation du calculateur. Alors, "Lambda_cond_for_adaptation = 0"|
INJCTL_INJFARCTLMGR_vidInitDelay|F|();|FCT1.3|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|A froid, l’objectif de richesse visé n’est plus unitaire mais légèrement supérieur. Par conséquent, il est nécessaire de laisser la régulation de richesse inactive pendant un délai fonction de la température d’eau.|
INJCTL_INJFARCTLMGR_vidInitFdbk|C|();|FCT1.2|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|Initialise l'automate Monitor_feedback_conds_state.|
INJCTL_INJFARCTLMGR_vidMontrCond|H|();|FCT1.8|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|Le système de régulation par feedback de la sonde ne fonctionne qu' à richesse 1. Toute consigne de richesse différente ne peut être régulée. Cependant, l' objectif de richesse à atteindre est calibrable avec hystérésis.|
INJCTL_INJFARCTLMGR_vidResetCond|D|();|FCT1.7|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|Ce bloc permet de réinitialiser les compteurs de validation avant débouclage.|
INJCTL_INJFARCTLMGR_vidSetThresh|C|();|FCT1.6|INJCTL_INJFARCTLMGR|0|PTS_DOC_5147287||||0|0|0|0|Lors d’un démarrage, le seuil de température d’eau à atteindre peut être adapté à 3 fonctionnements différents. En fonction de la température de l’eau au démarrage, un offset est appliqué au seuil de température.|
InjCtl_SdlFast_FarCtlMgr|C|();|SCH.4|INJCTL_INJFARCTLMGR|1|PTS_DOC_5147287||||0|0|0|0|Moniteur rapide de la fonction régulation de richesse|
InjCtl_SdlFast_FarCtlUsCtl|C|();|SCH.11|INJFARCTLUSCTL|1|PTS_DOC_5215083||||0|0|0|0|Fonction d'accroche à l'event  InjCtl_SdlFast_FarCtlUsCtl|
InjCtl_SdlFast_IfAirSysIgSys|E|();|SCH8.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur de module d'interface.|
InjCtl_SdlFast_InjFarCtlDsCtl|B|();|SCH.3|INJFARCTLDSCTL|1|V02 NT 08 05886||||0|0|0|0|Moniteur rapide pour la fonction injection
InjCtl_SdlFast_LamClmpd|A|();|SCH.2|LAMCLMPD|1|V02 NT 09 02030||||0|0|0|0|Fonction d'accroche à l'event InjCtl_SdlFast_LamClmpd
InjCtl_SdlMid_InjFarCtlDsCtl|C|();|SCH.2|INJFARCTLDSCTL|1|V02 NT 08 05886||||0|0|0|0|Moniteur medium pour la fonction injection
InjCtl_SdlSlow_FarCtlMgr|C|();|SCH.5|INJCTL_INJFARCTLMGR|1|PTS_DOC_5147287||||0|0|0|0|Moniteur lent de la fonction régulation de richesse|
InjCutOff_EveInj_CutOffIf|B|();|SCH.3|STTIF|1|PTS_DOC_5199315||||0|0|0|0|Evènement injection.|
InjCutOff_EveRst_CutOffIf|B|();|SCH.1|STTIF|1|PTS_DOC_5199315||||0|0|0|0|Evènement reset.|
InjCutOff_EveRst_InjCutOffBvmp|A|();|SCH.1|INJCUTOFFBVMP|1|V02 NT 11 07837||||0|0|0|0|Evènement de reset du calculateur.
InjCutOff_SdlFast_CutOffIf|B|();|SCH.2|STTIF|1|PTS_DOC_5199315||||0|0|0|0|Scheduler rapide.|
InjCutOff_SdlFast_InjCutOffBvmp|A|();|SCH.2|INJCUTOFFBVMP|1|V02 NT 11 07837||||0|0|0|0|Moniteur rapide pour la fonction coupure d'injection.
INJCUTOFFBVMP_vidAcvBvmpFco|A|();|FCT1.4|INJCUTOFFBVMP|0|V02 NT 11 07837||||0|0|0|0|Cette fonction détermine la requète de coupure d'injection en passage de vitesse Bvmp.
INJCUTOFFBVMP_vidCalcBVMPFCO|A|();|FCT1.3|INJCUTOFFBVMP|0|V02 NT 11 07837||||0|0|0|0|Cette fonction décrit la gestion de la demande e coupure injection pour la BVMP.
INJCUTOFFBVMP_vidDisBvmpFco|A|();|FCT1.5|INJCUTOFFBVMP|0|V02 NT 11 07837||||0|0|0|0|Cette fonction décrit la mise à zero de la requète de coupure d'injection en passage de vitesse Bvmp.
INJCUTOFFBVMP_vidInitBVMPFCO|A|();|FCT1.1|INJCUTOFFBVMP|0|V02 NT 11 07837||||0|0|0|0|Initialisation des sorties.
INJCUTOFFBVMP_vidInitOutput|A|();|FCT1.2|INJCUTOFFBVMP|0|V02 NT 11 07837||||0|0|0|0|Initialisation des sorties.
INJFARCTLDSCTL_DownStrmSenTrans|F|();|FCT2.3|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Transition DOWNSTREAM_SENSOR_CTRL
INJFARCTLDSCTL_InitCtrlTrans|C|();|FCT1.7|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Transition de INIT_CTRL_DNSTR_CORRECTION  vers WAITING_DNSTR_GENERAL_CONDS
INJFARCTLDSCTL_PurgeCataTrans|G|();|FCT2.4|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Transition  DNSTR_PURGE_CATA
INJFARCTLDSCTL_vidCalcErrTenGain|F|();|FCT3.9|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|calculer la tension de référence de la sonde aval
INJFARCTLDSCTL_vidCalcErrTension|B|();|FCT3.8|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|L’erreur de tension sur la sonde aval est calculée par la différence entre l’Erreur entre la tension sonde et la tension de référence et la dernière tension différentielle correcte.
INJFARCTLDSCTL_vidCalcModifiers|D|();|FCT1.3|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|mécanisme d’adaptation pour affiner  Feedback_correction pendant le fonctionnement du moteur.
INJFARCTLDSCTL_vidCalculationMod|A|();|FCT1.9|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Fonction qui assure l'appel de 01_Calculation_modifiers (INJFARCTLDSCTL_vidCalcModifiers)
INJFARCTLDSCTL_vidDecrEntryDly|B|();|FCT1.2|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Décrémentation du délai d'entrée
INJFARCTLDSCTL_vidDecrLowCount|A|();|FCT3.5|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|La décrémentation du temps restant d'appauvrissement possible par la pu InjCtl_SampleTiFast_SC. Dnstr_purge_cata_done_wo_result indique la fin de la purge catalyseur
INJFARCTLDSCTL_vidDecrRichCount|A|();|FCT3.7|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|La décrémentation du temps restant d'enrichissement possible par la purge cata est réalisé à la valeur du pas InjCtl_SampleTiFast_SC.  Dnstr_purge_cata_done_wo_result indique la fin de la purge catalyseur
INJFARCTLDSCTL_vidDecSettlingDly|A|();|FCT1.5|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Décrémentation du délai de prise en compte de l’offset de la valeur du pas InjCtl_SampleTiFast_SC
INJFARCTLDSCTL_vidDownstreamCond|C|();|FCT1.6|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Ce module permet d’évaluer si les conditions d’adaptation sont remplies en agissant sur le booléen Dnstr_conds_met.
INJFARCTLDSCTL_vidFeedbackCorr|F|();|FCT3.10|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|calculer les paramètres de correction
INJFARCTLDSCTL_vidInitEntryDly|B|();|FCT2.9|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|réinitialiser le délai d’attente après l’obtention de toutes les conditions dynamiques d’adaptation.
INJFARCTLDSCTL_vidInitOutput|E|();|FCT1.1|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|initializing inputs
INJFARCTLDSCTL_vidInitParam|F|();|FCT2.5|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|initialiser les différents paramètres de la double boucle de régulation
INJFARCTLDSCTL_vidInitPurgeCata|A|();|FCT3.1|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|spécifier les délais d’enrichissement et d’appauvrissement.
INJFARCTLDSCTL_vidInitSetlingDly|B|();|FCT2.10|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|réinitialiser le délai d’attente après application de l’offset de biais de richesse du à la régulation de richesse.
INJFARCTLDSCTL_vidManager|D|();|FCT1.4|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|La stratégie de régulation double boucle
INJFARCTLDSCTL_vidPurgeCata|B|();|FCT3.3|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|détermine les conditions et les paramètres de la purge catalyseur pour les cas d’enrichissement et d’appauvrissement.
INJFARCTLDSCTL_vidPurgeCataLow|C|();|FCT3.4|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|calcule le délai (en PMH)  avant de basculer la régulation de richesse vers un mélange riche. Ce calcul est réalisé par l’intermédiaire d’une hystérésis.
INJFARCTLDSCTL_vidPurgeCataRich|C|();|FCT3.6|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|calcule le délai (en PMH)  avant de basculer la régulation de richesse vers un mélange pauvre. Ce calcul est réalisé par l’intermédiaire d’une hystérésis.
INJFARCTLDSCTL_vidResetOffset|C|();|FCT2.6|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Lorsque la purge du catalyser est réalisée, et lorsque qu’on sort de la boucle de régulation, les paramètres du délai d’attente sont réinitialisés.
INJFARCTLDSCTL_vidResetOffsetVal|B|();|FCT2.8|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Initialisation des paramètres du délai d’attente
INJFARCTLDSCTL_vidResetPurgeCata|A|();|FCT3.2|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|réinitialiser les délais d’enrichissement et d’appauvrissement possible par la purge du catalyseur
INJFARCTLDSCTL_vidSaveFeedbackCr|B|();|FCT2.7|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Enregistrement de Feedback_correction dans une Variable temporaire
INJFARCTLDSCTL_WaitCtrlCondTrans|D|();|FCT2.1|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Transition de WAITING_FOR_DNSTR_CTRL_CONDS vers WAITING_FOR_OFFSET_DELAY
INJFARCTLDSCTL_WaitGnrlCondTrans|D|();|FCT1.8|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Transition WAITING_DNSTR_GENERAL_CONDS vers  WAITING_FOR_DNSTR_CTRL_CONDS
INJFARCTLDSCTL_WaitOffDlyTrans|F|();|FCT2.2|INJFARCTLDSCTL|0|V02 NT 08 05886||||0|0|0|0|Transition WAITING_FOR_OFFSET_DELAY  vers les différentes états
INJFARCTLUSCTL_vidAdaplambdaMean|A|();|FCT3.8|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction permet de calculer la valeur moyenne du correcteur de richesse de la régulation de richesse.|
INJFARCTLUSCTL_vidAdaplamfeebcal|C|();|FCT3.7|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction permet de mettre en oeuvre une stratégie rapide d'adaptation capable d'assurer la cohérence entre le créneau de richesse demandé par le diag KTA et le lambda réel.|
INJFARCTLUSCTL_vidCalcGain|D|();|FCT2.8|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Selon que l’on est dans une phase d’enrichissement sur un step ou un lump, ou sur une phase d’appauvrissement également sur un step ou un lump, on applique un gain d’atténuation différent.|
INJFARCTLUSCTL_vidCalcLFB|C|();|FCT6.1|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction permet de déterminer le correcteur de richesse de la régulation de richesse.|
INJFARCTLUSCTL_vidCalcLFBFilt|C|();|FCT6.5|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction est appelé si l'indicateur de prise en compte des sauts de  richesse est mis à "1"|
INJFARCTLUSCTL_vidCalcLump|C|();|FCT4.3|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Ce processus calcule les sauts de richesse qui sont appliqués par le processus Calculer Lambda Feedback. Il est déclenché par l' automate de gestion de poursuite de richesse sur certaines transitions.|
INJFARCTLUSCTL_vidCalcStep|C|();|FCT5.1|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|La régulation de richesse fonctionne suivant 2 modes de poursuite, lent et rapide. Ce mode de poursuite est donné par l' automate Feedback_calculations_state.|
INJFARCTLUSCTL_vidCallbdSafDiag|E|();|FCT6.4|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction est appelée si Indicateur d' activation de la régulation de richesse  pour l' IAE est active.|
INJFARCTLUSCTL_vidCalLFbDelayOk|C|();|FCT1.7|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Filtrage du premier ordre de Lambda_feedback lorsque le mélange au niveau du capteur est resté riche ou pauvre pendant un certain temps.|
INJFARCTLUSCTL_vidCalLFBLean|E|();|FCT6.2|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction permet de déterminer le correcteur richesse de la régulation de la richesse pour le cas pauvre.|
INJFARCTLUSCTL_vidCalLFBRich|E|();|FCT6.3|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction permet de déterminer le correcteur richesse de la régulation de la richesse pour le cas riche.|
INJFARCTLUSCTL_vidControlEna|C|();|FCT5.9|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Le calcul de Lambda_feedback est effectué tous les TDC de manière asynchrone avec l' automate de  détermination des pas et sauts de richesse. Pour cette raison, un indicateur Lambda_waiting est utilisé pour  prendre en compte les sauts de richesse.|
INJFARCTLUSCTL_vidCounter|B|();|FCT2.7|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Le booléen ‘Lbda_active_gain_attenu_rich’ permet la prise en compte des gains d’atténuation dans la boucle de richesse.|
INJFARCTLUSCTL_vidDecCounter|D|();|FCT5.10|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction permet la décrementation du Compteur du temps de transition entre riche et pauvre ,la durée maximum de la poursuite lente ainsi que le délai avant filtrage du Lambda_feedback en mode rapide.|
INJFARCTLUSCTL_vidEdSafRqToSfEnl|B|();|FCT3.2|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Affecter lla valeur du pas de richesse IAE riche à la valeur du pas de Lambda_feedback.|
INJFARCTLUSCTL_vidEdSfEnlToSfEnr|B|();|FCT3.3|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Affecter la valeur du pas de richesse IAE pauvre à la valeur du pas Lambda_Feedback , la valeur du saut de richesse IAE pauvre à la valeur du saut de Lambda_feedback et mettre Indicateur de prise en compte des sauts de richesse à "1".|
INJFARCTLUSCTL_vidEdSfEnrToSfEnl|B|();|FCT3.4|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Affecter la valeur d u pas de richesse IAE riche  à la valeur du pas de Lambda_Feedback , la valeur du saut de richesse IAE riche à  la valeur du saut de Lambda_feedback et mettre Indicateur de prise en compte des sauts de richesse à "1".|
INJFARCTLUSCTL_vidFCallbdLdDerv|D|();|FCT6.6|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction permet de déterminer la dérivée de la charge moteur entre deux PMH|
INJFARCTLUSCTL_vidFFastTracking|C|();|FCT4.1|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Indicateur d' enclenchement du Fast Tracking|
INJFARCTLUSCTL_vidFuncCalAttGain|B|();|FCT2.1|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Pour résoudre le problème de l'EPT A806 n° 602 ,on choisit de diminuer l’influence de la correction de richesse lors des transitoires de décollage à froid en lui appliquant un gain d’atténuation.|
INJFARCTLUSCTL_vidFuncCalLFbFilt|D|();|FCT1.5|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Figeage de Lambda_feedback_filtered en phase de diagnostic catalyseur intrusif|
INJFARCTLUSCTL_vidFuncCtlFdInjAc|D|();|FCT5.8|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Le calcul de Lambda_feedback est effectué tous les TDC de manière asynchrone avec l' automate de  détermination des pas et sauts de richesse|
INJFARCTLUSCTL_vidIniAdap|A|();|FCT3.9|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|cette fonction permet d'initialiser les variables de l'Adaptation de la correction de régulation de richesse moyennée.|
INJFARCTLUSCTL_vidInit|F|();|FCT1.2|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Fonction d'initialisation au reset|
INJFARCTLUSCTL_vidInitClosedLoop|E|();|FCT6.9|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Sur la première activation de l' automate Feedback_calculations_state après démarrage, on initialise la valeur  du Lambda_feedback à partir des corrections de richesse en cours d' application pour éviter un saut de richesse important .|
INJFARCTLUSCTL_vidInitFedSaf|B|();|FCT1.3|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Fonction d'initialisation de l'automate Feedback_saf_diag_calc_state|
INJFARCTLUSCTL_vidInitFeedCalc|C|();|FCT4.8|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Fonction d'initialisation du calcul du bouclage|
INJFARCTLUSCTL_vidInitFeedParam|C|();|FCT6.8|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Fonction d'initialisation des paramètres Feedback.|
INJFARCTLUSCTL_vidInitFeedState|C|();|FCT1.4|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Fonction d'initialisation de l'automate Feedback_calculations_state|
INJFARCTLUSCTL_vidInitLambdaFB|B|();|FCT6.10|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Si l’autorisation de bouclage est nulle, le correcteur de richesse est mis à zéro.|
INJFARCTLUSCTL_vidInitOutput|I|();|FCT1.1|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Fonction d'initialisation des variables de sortie|
INJFARCTLUSCTL_vidIniUplamMaxMin|B|();|FCT3.5|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction permet de tester l'initialisation des Indicateurs de calcul du Lambda feedback max et min.|
INJFARCTLUSCTL_vidLambdaGazDelay|C|();|FCT7.2|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Ajouter une valeur d’offset en nombre de PMH en mode gaz (Delta_PMH_gaz) au  temps de transfert (Transfer_count).|
INJFARCTLUSCTL_vidLamdaGazDelcal|B|();|FCT7.1|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Condition d'activation de la régulation de richesse en boucle fermée.|
INJFARCTLUSCTL_vidLbdaNotTrans|B|();|FCT2.4|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Le booléen ‘Ldba_transitoire_detect’ est remis à 0 sur un seuil bas pour éviter toutes oscillations.|
INJFARCTLUSCTL_vidLbdaTrans|B|();|FCT2.3|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|La détection de transitoire sur le régime et la charge .|
INJFARCTLUSCTL_vidLdbTrGainAttnu|B|();|FCT2.5|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Appliquer  un gain d’atténuation pour diminuer l’influence de la correction de richesse lors des transitoires  de décollage à froid .|
INJFARCTLUSCTL_vidLFbDelayNok|C|();|FCT1.8|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Filtrage du premier ordre de Lambda_feedback lorsque le mélange au niveau du capteur est resté riche ou pauvre pendant un certain temps.|
INJFARCTLUSCTL_vidLFbFilSDiagCta|D|();|FCT1.6|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|calcul de Lambda_feedback_filtered sans diagnostic catalyseur|
INJFARCTLUSCTL_vidLumpNotOnIdle|D|();|FCT4.5|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|L'appel de cette fonction est effectuée si l'etat de fonctionnement du moteur prend un état différent de l'etat ralenti de l' automate Engine_running_state.|
INJFARCTLUSCTL_vidLumpOnIdle|C|();|FCT4.4|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|L'appel de cette fonction est effectuée si l'etat de fonctionnement du moteur prend l'etat ralenti de l' automate Engine_running_state.|
INJFARCTLUSCTL_vidMeanCalc|B|();|FCT7.6|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Calcul de la valeur moyenne du correcteur de richesse de la régulation de richesse .|
INJFARCTLUSCTL_vidMeanFilt|B|();|FCT7.7|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Filtration de la valeur moyenne du correcteur de richesse de la régulation de richesse .|
INJFARCTLUSCTL_vidMeanLamFeedCal|B|();|FCT7.5|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Calcul de la moyenne du correcteur de richesse de la régulation de richesse puis sa filtration .|
INJFARCTLUSCTL_vidMgtFeedCalc|E|();|FCT4.2|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Automate de calcul de la boucle fermée de  richesse .|
INJFARCTLUSCTL_vidMonitorFedSaf|D|();|FCT3.1|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Les transitions sont évaluées à récurrence du moniteur rapide de la régulation de richesse, si  Moniteur_feedback_conds_state = FEEDBACK_FOR_SAF_ENABLED.|
INJFARCTLUSCTL_vidNotTrGainAttnu|D|();|FCT2.6|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Le calcul des gains d’atténuation en fonction de la température d’eau|
INJFARCTLUSCTL_vidRangeCalc|B|();|FCT7.3|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Calcul de l'amplitude du signal correcteur de richesse de la régulation de richesse .|
INJFARCTLUSCTL_vidRangeFilt|B|();|FCT7.4|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Calcul de l'amplitude du signal correcteur de richesse de la régulation de richesse après filtrage .|
INJFARCTLUSCTL_vidResetLFB|E|();|FCT6.7|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Fonction reset de correcteur de richesse .|
INJFARCTLUSCTL_vidSetlbdFltMdDly|C|();|FCT4.6|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction permet de déterminer le délai avant filtrage du Lambda_feedback en mode  rapide.|
INJFARCTLUSCTL_vidSetlbdSlwMdDly|C|();|FCT4.7|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction permet de déterminer la durée maximum de la poursuite lente.|
INJFARCTLUSCTL_vidSetTransfCount|E|();|FCT5.4|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Optimisation de la fonction régulation richesse en fonction du vieillissement.|
INJFARCTLUSCTL_vidStepNotOnIdle|E|();|FCT5.3|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|L'appel de cette fonction est effectuée si l'etat de fonctionnement du moteur prend un état différent de l'etat ralenti de l' automate Engine_running_state.|
INJFARCTLUSCTL_vidStepOnIdle|D|();|FCT5.2|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|L'appel de cette fonction est effectuée si l'etat de fonctionnement du moteur prend l'etat ralenti de l' automate Engine_running_state.|
INJFARCTLUSCTL_vidTransDetect|D|();|FCT2.2|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|La détection de transitoire sur le régime et la charge est faite par le booléen ‘Ldba_transitoire_detect’ sur un  seuil haut. Pour éviter toutes oscillations, ce booléen est remis à 0 sur un seuil bas|
INJFARCTLUSCTL_vidTrsfCtNtOnIdle|H|();|FCT5.6|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|L'appel de cette fonction est effectuée si l'etat de fonctionnement du moteur prend un état différent de l'etat ralenti de l' automate Engine_running_state.|
INJFARCTLUSCTL_vidTrsfCtOnIdle|F|();|FCT5.5|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|L'appel de cette fonction est effectuée si l'etat de fonctionnement du moteur prend l'etat ralenti de l' automate Engine_running_state.|
INJFARCTLUSCTL_vidTrsfCttimescal|B|();|FCT5.7|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|calcul du terme correctif des paramètres de régulation de richesse|
INJFARCTLUSCTL_vidUplamMaxMinIni|A|();|FCT3.6|INJFARCTLUSCTL|0|PTS_DOC_5215083||||0|0|0|0|Cette fonction permet d'initialiser les Indicateurs de calcul du Lambda feedback max et min.|
INJHAL_bfUpdate|A|FUNC_bfUpdate|4|HEADER|1|NONE||||0|0|0|0||
INJHAL_udtSwitchGdiProfile|A|func_INJHAL_udtSwitchGdiProfile|10|HEADER|1|NONE||||0|0|0|0||
INJHAL_vidDisable|A|(argin uint8 u8InstanceId);|15|HEADER|1|NONE||||0|0|0|0||
INJHAL_vidEnable|A|(argin uint8 u8InstanceId);|2|HEADER|1|NONE||||0|0|0|0||
INJHAL_vidInhibit|A|(uint8 u8InstanceId, INJHAL_tbfInhibitMask bfInhibitMask);|7|HEADER|1|NONE||||0|0|0|0||
INJHAL_vidTestModeEntry|A|();|2|HEADER|1|NONE||||0|0|0|0||
INJHAL_vidTestModeExit|A|();|4|HEADER|1|NONE||||0|0|0|0||
INJHAL_vidWriteAngle|A|(uint8 u8Channel, uint8 u8PulseNumber, uint16 u16InjectionAngle);|6|HEADER|1|NONE||||0|0|0|0||
INJHAL_vidWriteMode|A|(uint8 u8InstanceId, uint8 u8Channel, uint8 u8InjectionMode);|9|HEADER|1|NONE||||0|0|0|0||
INJHAL_vidWriteTestTime|B|(argin uint8 u8Channel, argin uint32 u32InjTestTime);|3|HEADER|1|NONE||||0|0|0|0||
INJHAL_vidWriteTime|A|(uint8 u8Channel, uint8 u8PulseNumber, uint32 u32InjectionTime);|5|HEADER|1|NONE||||0|0|0|0||
InjrM_EveCkSnOn_InjrMdlIf|B|();|SCH15.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement correspondant au passage à 1 de la variable Moteur_synchronise pour InjrMdlFct|
InjrM_EveInj_InjrMdlIf|B|();|SCH15.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement Injection pour la fonction de calcul du modèle injecteur.|
InjrM_EveRst_InjrMdlIf|B|();|SCH4.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement Reset pour InjrMdlFct.|
InjrM_EveSpl_InjrMdlIf|B|();|SCH15.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement Spill pour la fonction du calcul du modèle injecteur.|
InjrM_SdlFast_InjrMdlIf|B|();|SCH15.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide pour la fonction de calcul du modèle injecteur.|
InjSys_EveInj_facFuTranIf|A|();|SCH18.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement d'injection pour l'interfacage facfutran|
InjSys_EveInj_mFuInjIf|C|();|SCH11.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement d'injection|
InjSys_EveRst_facFuTranIf|A|();|SCH18.9|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement reset pour l'interface facfutran|
InjSys_EveRst_mFuInjIf|C|();|SCH6.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement pour l'initialisation|
InjSys_SdlFast_facFuTranIf|A|();|SCH18.10|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide pour l'interface facfutran|
InjSys_SdlFast_mFuSpIf|D|();|SCH7.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide pour la correction de richesse de la régulation richesse|
INJTICOR_vidAcvDiagEngineRunning|B|();|FCT5.2|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Ce bloc ne doit être vérifié que si le moteur est tournant.|
INJTICOR_vidbDgoAlimLeanFuel|C|();|FCT5.10|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction traite le cas d'un Défaut injecteur pauvre : Lfbk_on_enrich_clamp est à l'état ON et Sonde_riche_aval est à l'état OFF.|
INJTICOR_vidbDgoAlimRichFuel|D|();|FCT6.3|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction traite le cas d'un Défaut injecteur riche : Lfbk_on_enrich_clamp est à l'état OFF et Sonde_riche_aval est à l'état ON.|
INJTICOR_vidbDgoSen02AmLeanBlo|C|();|FCT6.1|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction traite le cas d'un Défaut sonde amont bloquée pauvre : Lfbk_on_enrich_clamp et Sonde_riche_aval sont à l'état ON.|
INJTICOR_vidbDgoSen02AmRichBlo|D|();|FCT6.2|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction traite le cas d'un Défaut sonde amont bloquée riche : Lfbk_on_enrich_clamp et Sonde_riche_aval sont à l'état OFF.|
INJTICOR_vidClampDiagnosis|B|();|FCT3.9|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Ce bloc est activé si la régulation de richesse revient en butée pendant la temporisation Lfbk_fuelling_clamp_delay_c, et remonte instantanément le booléen de défaillance.|
INJTICOR_vidClampTstNotPerformed|M|();|FCT1.6|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction permet de détecter la régulation de richesse en butée. Il est désactivé  si la correction sur la chaîne d'injection est en cours.|
INJTICOR_vidComputation|M|();|FCT1.5|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Les diagnostics de surveillance de la régulation de richesse doivent être activés si la régulation de richesse est en boucle fermée depuis une temporisation calibrable les diagnostics ne sont pas inhibés et la température moteur est > à un seuil.|
INJTICOR_vidCtrlLfbkMonitoring|I|();|FCT1.3|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|la stratégie de surveillance de la régulation de richesse est active s'il n'y a pas d'inhibition manuelle, via le FRM, et si le diagnostic dans la totalité n'a pas encore été réalisé.|
INJTICOR_vidDiagComputation|C|();|FCT4.10|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Lorsque les conditions de diagnostic sont réunies, la régulation est surveillée.|
INJTICOR_vidDiagEngineRunning|B|();|FCT5.3|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Lorsque le moteur est tournant, la stratégie regarde le résultat des 6 diagnostics. Pour que les défauts soient pris en compte dans le GDGAR, il faut la présence d’un  défaut de butée et la présence d’un défaut incriminant les sondes ou les injecteurs.|
INJTICOR_vidDiagnostic|B|();|FCT5.9|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette partie de la surveillance du FuelSystem utilise la cohérence entre le signal de la sonde  aval et l’état de la régulation de richesse, sans utiliser une modification de l’injection via le « Diag_trim ».|
INJTICOR_vidDiagTrim|B|();|FCT1.8|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Le booléen Lfbk_diag_completed passe à 1 lorsque la temporisation de validation du diagnostic de régulation de richesse en butée est arrivée à son terme.|
INJTICOR_vidEndOfDlyPeriodCntDec|B|();|FCT3.8|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Pendant la temporisation, si la régulation de richesse revient en butée (Clamp_operated = 1) alors on active Check_fuelling_fault, ce qui a pour conséquence de sortir de ce bloc et de rentrer dans 02_clamp_diagnosis.|
INJTICOR_vidEndOfDlyPeriodCntMgr|C|();|FCT3.7|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Le booléen Lfbk_clamp_tests_aborted indique que la régulation de richesse n'est pas revenue en butée durant la temporisation Lfbk_fuelling_clamp_delay_c. Et lediagnostic est toujours actif au cas où la régulation revienne en butée.|
INJTICOR_vidFailureManager|B|();|FCT4.2|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Lorsqu'une panne Inj_bDgoStuckLfbk remonte, c'est-à-dire que la régulation ne peut pas être décollée de la butée, Lfbk_cor_completed passe à 1, et le diagnostic est fini jusqu'au prochain reset.|
INJTICOR_vidFailuresCalculations|C|();|FCT2.8|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Lorsque une panne de la surveillance de la régulation de richesse est remontée, la correction agissant sur la chaîne d'injection, Diag_trim, est activée.|
INJTICOR_vidFuelAdjustment|B|();|FCT3.1|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Ajustement de carburant|
INJTICOR_vidInitGasMod|B|();|FCT5.5|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Initialiser le compteur du temps d'établissement à la calibration du temps d'établissement (pour application gaz).|
INJTICOR_vidInitGslMod|B|();|FCT5.4|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Initialiser le compteur du temps d'établissement à la calibration du temps d'établissement.|
INJTICOR_vidInitializeCorrection|D|();|FCT2.7|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette initialisation signifie que la première étape de la correction est autorisée par Oxy_sensor_test, la deuxième partie de la correction Check_fuelling_fault sera autorisée ou non dans la suite du diagnostic.|
INJTICOR_vidInitLfbkMonitoring|G|();|FCT1.2|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Initialisation des variables à l'événement reset.|
INJTICOR_vidInitLfbkSwitchGslGas|B|();|FCT5.6|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction permet d’initialiser correctement les variables dépendantes de la présence d’une application Gaz et le cas échéant, du mode carburant utilisé au moment de la réception de la première trame Gaz.|
INJTICOR_vidInitOutput|I|();|FCT1.1|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Initialisation des sorties.|
INJTICOR_vidInjTimeCorSwitchLean|C|();|FCT3.5|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction permet de décrémenter Diag_trim.|
INJTICOR_vidInjTimeCorSwitchRich|C|();|FCT3.3|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction permet d'incrémenter Diag_trim.|
INJTICOR_vidLeanFuelCalc|E|();|FCT1.9|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction permet le calcul de Lfbk_mod_6_var en butée d'appauvrissement|
INJTICOR_vidLfbkInitGas|B|();|FCT5.7|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction permet d’initialiser correctement les variables dépendantes de la présence d’une application Gaz|
INJTICOR_vidLfbkInitGsl|B|();|FCT5.8|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction permet d’initialiser correctement les variables dépendantes de la présence d’une application Gsl|
INJTICOR_vidLfbkMod6NoFailure|F|();|FCT2.4|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|le système doit renvoyer le dernier résultat des tests de surveillance de la régulation de  richesse au mode$06 du scantool.|
INJTICOR_vidLowFuelTempo|H|();|FCT2.5|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Lorsque le niveau de carburant minimum est atteint, si la stratégie détecte un défaut de régulation de richesse en butée d’enrichissement (système bloqué pauvre), une temporisation est lancée.|
INJTICOR_vidNoFailure|C|();|FCT4.3|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|si les conditions d'activation du diagnostic sont présentes et qu'il n'y a pas de panne, les booléens de sortie de la partie curative sont à 0.|
INJTICOR_vidOnEnleanClampDiag|B|();|FCT4.1|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Lorsque cette fonction est activé, Lfbk_stuck_rich prend la valeur 1.|
INJTICOR_vidOnEnrichClampDiag|B|();|FCT3.10|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Lorsque cette fonction est activé Lfbk_stuck_lean prend la valeur 1.|
INJTICOR_vidOxySensorTPerformed|D|();|FCT2.10|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|orsque la partie curative est lancée, la chaîne d'injection est corrigée par le Diag_trim.|
INJTICOR_vidPerformClampTests|D|();|FCT2.6|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|La partie curative du diagnostic de la régulation de richesse en butée  est active si : Elle n'est pas inhibée manuellement, la surveillance de régulation de richesse a remonté une panne ou si la partie curative n'a pas été réalisée.|
INJTICOR_vidReinitFarStraMon|B|();|FCT5.1|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Lorsque le Gestionnaire des Stratégies n’autorise pas le diagnostics de régulation de richesse en butée, les booléens de diagnostics de butées sont réinitialisés à 0.|
INJTICOR_vidResetCorrection|B|();|FCT2.9|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Si la régulation de richesse quitte la butée, la correction est arrêtée.|
INJTICOR_vidResetDelayCount|E|();|FCT2.1|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Si les conditions d'activation sont perdues ou bien que la régulation de richesse n'est plus en butée, la demande de diagnostic ainsi que la temporisation sont initialisées.|
INJTICOR_vidResetDiag|D|();|FCT1.4|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction permet d'initialiser la correction sur la chaîne d'injection ainsi que la demande de diagnostic.|
INJTICOR_vidResetDiagTempo|C|();|FCT2.2|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|si la correction sur la chaîne d'injection est en cours et que les conditions d'activation sont perdues, alors les variables sont réinitialisées.|
INJTICOR_vidRichFuelCalc|F|();|FCT1.10|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction permet le calcul de Lfbk_mod_6_var en butée d'enrichissement.|
INJTICOR_vidSeqDftFuAfl|D|();|FCT4.4|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Diagnostic de la regulation de richesse bloquee pauvre a cause de l'injection.|
INJTICOR_vidSeqDftFuAfr|D|();|FCT4.7|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Diagnostic de la regulation de richesse bloquee riche a cause de l'injection.|
INJTICOR_vidSeqDftSenO2Afl|D|();|FCT4.5|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Diagnostic de la regulation de richesse bloquee pauvre a cause des sondes O2|
INJTICOR_vidSeqDftSenO2Afr|D|();|FCT4.8|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Diagnostic de la regulation de richesse bloquee riche a cause des sondes O2.|
INJTICOR_vidSeqORngLfbkAfl|E|();|FCT4.6|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Diagnostic de la regulation de richesse en butee pauvre.|
INJTICOR_vidSeqORngLfbkAfr|D|();|FCT4.9|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Diagnostic de la regulation de richesse en butee riche.|
INJTICOR_vidSwitchLeanCalc|C|();|FCT3.4|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|La correction sur la chaîne d'injection Diag_trim est décrémentée d'un pas de Lfbk_enlean_extra_c jusqu'au seuil Lfbk_enlean_max_c, où le booléen de défaillance Inj_bDgoStuckLfbk_SwitchLean passe à 1.|
INJTICOR_vidSwitchRichCalc|C|();|FCT3.2|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|La correction sur la chaîne d'injection Diag_trim est incrémentée d'un pas de Lfbk_enrich_extra_c jusqu'au seuil Lfbk_enrich_max_c, où le booléen de défaillance Inj_bDgoStuckLfbk_SwitchRich passe à 1.|
INJTICOR_vidTempoNoFailure|E|();|FCT2.3|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Cette fonction contient la temporisation de validation du diagnostic sans défaut.|
INJTICOR_vidWaitAbortFuelCheck|B|();|FCT3.6|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Lorsque la correction 02_oxy_sensor_test_performed est interrompue, un passage par le bloc 01_re_initialization annule la requête de correction (Performing_oxy_sensor_test = 0) et la stratégie entre dans le bloc 03_wait_abort_fuel_check.|
INJTICOR_vidWaitApplyInitAdjust|E|();|FCT1.7|INJTICOR|0|PTS_DOC_5147608||||0|0|0|0|Le booléen Lfbk_mon_diag_test_request  passe à 1 pour indiquer que la régulation de richesse est en butée et donc que la temporisation de validation du défaut est en cours.|
INJVOLTADJ_vidEntryInit|B|();|SCH.1|INJVOLTADJ|1|PTS_DOC_5074748||||0|0|0|0|Evénement Reset du module INJVOLTADJ|
INJVOLTADJ_vidInitOutput|B|();|FCT1.1|INJVOLTADJ|0|PTS_DOC_5074748||||0|0|0|0|Initialisation des sorties|
INJVOLTADJ_vidInjCmdVolt|C|();|FCT1.3|INJVOLTADJ|0|PTS_DOC_5074748||||0|0|0|0|Ce bloc traite la génération de stimuler la demande de tension pour injecteur pour examiner certaines restrictions liées aux limites du matériel.|
INJVOLTADJ_vidInjVoltAdj|B|();|FCT1.2|INJVOLTADJ|0|PTS_DOC_5074748||||0|0|0|0|Ce bloc d'injection peut être divisé en deux parties: InjSys_bInjVoltAdj; demande coup de pouce pour injecteurs. InjSys_bPmpVoltAdj: coup de pouce pour la demande de la pompe HP.|
INJVOLTADJ_vidPmpCmdVolt|B|();|FCT1.4|INJVOLTADJ|0|PTS_DOC_5074748||||0|0|0|0|Ce bloc envoie une requête pour stimuler la pompe HP.|
InM_SdlFast_stTraLd|A|();|SCH.2|STTRALD|1|V02 NT 09 04622||||0|0|0|0|Fonction d'accroche au moniteur 5 ms.|
INMNFPRESACQ_vidAcqPressManifld|C|();|FCT1.2|INMNFPRESACQ|1|PTS_DOC_6525158||||0|0|0|0|La tension brute renvoyée par le capteur est normalisée en fonction de la tension d’alimentation du capteur,avant d’être envoyée au LdA.|
INMNFPRESACQ_vidArbPressManifld|D|();|FCT1.6|INMNFPRESACQ|0|PTS_DOC_6525158||||0|0|0|0|En présence de défauts, la valeur de la pression collecteur n’est plus acquise mais figée à sa dernière valeur valide. Si le défaut est confirmée la pression est égale à une valeur de repli dépendant de la synchronisation du moteur.|
INMNFPRESACQ_vidDiagPressManifld|C|();|FCT1.3|INMNFPRESACQ|0|PTS_DOC_6525158||||0|0|0|0|Les diagnostics éléctriques pour les valeurs haute et basse sur signal de pression collecteur sont activés lorsque la chaîne d’acquisition est activée et si aucun défaut n’est confirmé.|
INMNFPRESACQ_vidFormPressManifld|D|();|FCT1.5|INMNFPRESACQ|0|PTS_DOC_6525158||||0|0|0|0|Un filtre, de type ordre 1 avec gain calibrable en fonction du régime, est appliquée sur la tension renvoyée par le capteur en valeur de pression collecteur.|
INMNFPRESACQ_vidInit|C|();|FCT1.1|INMNFPRESACQ|0|PTS_DOC_6525158||||0|0|0|0|Les valeurs de la pression collecteur sont initialisés à la valeur de la pression atmosphérique.|
INMNFPRESACQ_vidPresElectricDiag|C|();|FCT1.4|INMNFPRESACQ|0|PTS_DOC_6525158||||0|0|0|0|A chaque acquisition de la tensions collecteur, un diagnostic est effectué sur la validité de la nouvelle mesure, à l’aide de seuils calibrables, permettant  l’actualisation des indicateurs de défauts.|
INMNFPRESDIAG_vidAirPressSens|E|();|FCT3.8|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Le diagnostic revient à calculer la valeur absolue de la differnce de  deux valeurs réalistes de pression atmosphérique.
INMNFPRESDIAG_vidAirPressSens1|D|();|FCT3.6|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Le diagnostic revient à calculer la valeur absolue de la differnce de  deux valeurs réalistes de pression atmosphérique.
INMNFPRESDIAG_vidCanPurgVerif|D|();|FCT1.3|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|La stratégie doit vérifier en continu que la vanne de purge canister est restée fermée suffisamment longtemps afin d’autoriser les diagnostics utilisant l’information.
INMNFPRESDIAG_vidDetectInCrank|D|();|FCT1.9|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Lorsque  le délai est écoulé,  la stratégie compare  la pression collecteur mesurée  juste avant  le démarrage du moteur avec la pression collecteur minimale mesurée pendant le démarrage.
INMNFPRESDIAG_vidDetectionEnabled|D|();|FCT3.3|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|La détection du défaut revient à tester si la variation de la pression collecteur reste raisonnable (pas de pic de  pression intempestifs).
INMNFPRESDIAG_vidDftPres_GrdPres|E|();|FCT3.1|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Résultat du diagnostic de cohérence dans le taux de variation  de la pression de la collecteur d'admission
INMNFPRESDIAG_vidDftPres_PresLim|F|();|FCT2.6|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|La détection du défaut revient à tester avec 2 seuils calibrables (seuil Mini et seuil Maxi) si la valeur mesurée se  trouve hors de la zone de fonctionnement normale.
INMNFPRESDIAG_vidDftPres_Reinit|D|();|FCT3.4|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|A chaque  fois que  le diagnostic s’active,  la  fenêtre de vérification se  réinitialise. Cela permet ainsi d’éviter  les  fausses détections lors des phases de désactivations puis de réactivations successives du diagnostic.
INMNFPRESDIAG_vidDftPres_Stall|D|();|FCT1.6|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Fonction qui lancer un diagnostic suivant la valeur d'une booléene.
INMNFPRESDIAG_vidDftPresFullload|D|();|FCT2.8|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Fonction qui lancer un diagnostic suivant la valeur d'une booléene.
INMNFPRESDIAG_vidDftPresNormOper|D|();|FCT2.4|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Résultat du diagnostic de cohérence entre la position papillon et la pression d'admission
INMNFPRESDIAG_vidDftPresStallRun|D|();|FCT2.1|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Le diagnostic du capteur de pression collecteur au démarrage revient à comparer la différence de pression  calculée avec un seuil minimale de pression.
INMNFPRESDIAG_vidDiagAuthFulLoad|D|();|FCT2.7|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Gestion de l'autorisation du diagnostic de la pression collecteur en pleine charge.
INMNFPRESDIAG_vidDiagFctStab|F|();|FCT2.3|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Le diagnostic revient à vérifier que la pression collecteur est comprise entre un seuil min et un seuil max lorsque la position papillon est comprise entre un seuil min et un seuil max depuis un certain temps.
INMNFPRESDIAG_vidInitOutput|G|();|FCT1.1|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Fonction d'initialisation des variables internes.
INMNFPRESDIAG_vidMfPrDiagBfStart|G|();|FCT1.4|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Gestion du diagnostic de la pression collecteur avant démarrage.
INMNFPRESDIAG_vidMfPrDiagDrStart|E|();|FCT1.7|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Gestion du diagnostic de la pression collecteur pendant le démarrage.
INMNFPRESDIAG_vidMnfPresDiagAuth|F|();|FCT2.2|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Gestion de l'autorisation du diagnostic de la pression collecteur.
INMNFPRESDIAG_vidMnfPresDiagGrd|D|();|FCT2.9|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Le diagnostic du gradient de la pression collecteur est activé seulement si : -  Le diagnostic n’est pas inhibé,  -  La vanne canister est fermée depuis suffisamment longtemps.
INMNFPRESDIAG_vidMnfPresDiagInit|D|();|FCT1.2|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|A l’initialisation du calculateur, le booléen lié à la durée de la fermeture de la vanne canister est mis à 0, et le compteur pour le diagnostic de cohérence de la pression collecteur pendant le démarrage doit être réinitialisé.
INMNFPRESDIAG_vidMnfPresDiagLim|E|();|FCT2.5|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Le diagnostic « hors zone » de la pression collecteur est activé seulement si :   -  Le diagnostic n’est pas inhibé,  -  La vanne canister est fermée depuis suffisamment longtemps.
INMNFPRESDIAG_vidMngActivStart|B|();|FCT4.3|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|A l’initialisation, toutes les variables sont mises à zéro.   Les pressions admission et atmo sont mises à jour dès le premier réveil principal (AirPres_bAuthUpdPres=1)
INMNFPRESDIAG_vidNoAirPressSens|E|();|FCT3.9|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Le diagnostic de la pression collecteur en pleine charge revient à vérifier que la pression collecteur se trouve  bien dans une plage de valeur de pression.
INMNFPRESDIAG_vidNoAirPressSens1|C|();|FCT3.7|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Le diagnostic revient à comparer la pression admission à deux valeurs réalistes de pression atmosphérique (valeurs mini et maxi majorées).
INMNFPRESDIAG_vidPrsDiagStallIni|D|();|FCT3.5|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|le seuil minimale de pression du capteur de pression au démarrage.
INMNFPRESDIAG_vidRefPressFreeze|D|();|FCT3.2|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Figeage de la valeur de référence de la pression collecteur qui sera utilisée par la suite pour la comparaison  avec la pression « courante n point de mesures plus tard ».
INMNFPRESDIAG_vidThrCohAuth|F|();|FCT4.1|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|On définit ici les conditions d’activation du diagnostic de cohérence de pression d’admission avec la position d’ouverture papillon.
INMNFPRESDIAG_vidThrCohDiag|F|();|FCT4.2|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|On effectue ici la comparaison entre la position papillon mesurée et une position théorique recalculée à partir du rapport de pression amont et aval papillon.
INMNFPRESDIAG_vidUpdtMnfPresCrnk|F|();|FCT1.8|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|Pendant  le délai durant  le démarrage,  la  stratégie  vient mémoriser  la  valeur de  la pression  collecteur  la plus  basse obtenue.
INMNFPRESDIAG_vidUpdtMnfPresStll|F|();|FCT1.5|INMNFPRESDIAG|0|PTS_DOC_6539920||||0|0|0|0|La pression collecteur est recopiée dans la variable de mémorisation de la pression collecteur « Moteur calé ».
INTERFACAGE_BA_SC_vidEntryInit|E|();|SCH.1|INTERFACAGE_BA_SC|1|V02 NT 10 07792||||0|0|0|0|reset du calculateur|
INTERFACAGE_BA_SC_vidInitOutput|E|();|FCT1.1|INTERFACAGE_BA_SC|0|V02 NT 10 07792||||0|0|0|0|Initialisation des sorties|
INTERFACAGE_BA_SC_vidIntAirSysSC|B|();|FCT1.4|INTERFACAGE_BA_SC|0|V02 NT 10 07792||||0|0|0|0|Interfaçage de la masse d’air pompée maximale et de l’objectif de débit d’air papillon|
INTERFACAGE_BA_SC_vidIntEngMSC|B|();|FCT1.2|INTERFACAGE_BA_SC|0|V02 NT 10 07792||||0|0|0|0|Interfaçage de la charge moteur en air corrigée|
INTERFACAGE_BA_SC_vidInterfExMSC|H|();|FCT1.3|INTERFACAGE_BA_SC|0|V02 NT 10 07792||||0|0|0|0|Interfaçage du débit de gaz échappement sans EGR, de la température et de la pression d'échappement du  collecteur|
INTERFACAGE_BA_SC_vidIntrfUsThrM|D|();|FCT1.5|INTERFACAGE_BA_SC|0|V02 NT 10 07792||||0|0|0|0|Interfaçage de la pression atmosphérique|
INTOBDSRV_vid14PMH_Pid|C|();|FCT1.7|INTOBDSRV|0|V02 NT 11 05149||||0|1|0|0|La production du PID OB est réalisée sur ¼ PMH et sur récurrence temporelle quand le moteur n’est pas tournant.|
INTOBDSRV_vidFast_Pid|C|();|FCT1.3|INTOBDSRV|0|V02 NT 11 05149||||0|0|0|0|Les PID concernant la position papillon sont produits à récurrence rapide.|
INTOBDSRV_vidIni_PID4F|A|();|FCT1.1|INTOBDSRV|0|V02 NT 11 05149||||0|0|0|0|Le PID 4F est un PID de configuration, il est égal à 0.|
INTOBDSRV_vidInitOutput|B|();|FCT1.2|INTOBDSRV|0|V02 NT 11 05149||||0|0|0|0|Initialization of the outputs|
INTOBDSRV_vidMid_Pid|E|();|FCT2.1|INTOBDSRV|0|V02 NT 11 05149||||0|1|0|0|Les autres PID sont produits à récurrence moyenne.|
INTOBDSRV_vidMid_Pid1|A|();|FCT1.4|INTOBDSRV|0|V02 NT 11 05149||||0|1|0|0|Les autres PID sont produits à currence moyenne (suite1).|
INTOBDSRV_vidMid_Pid2|A|();|FCT1.5|INTOBDSRV|0|V02 NT 11 05149||||0|1|0|0|Les autres PID sont produits à currence moyenne(suite2)|
INTOBDSRV_vidMid_Pid3|A|();|FCT1.6|INTOBDSRV|0|V02 NT 11 05149||||0|1|0|0|Les autres PID sont produits à currence  moyenne (suite3)|
INTOBDSRV_vidPMB_PID|C|();|FCT1.9|INTOBDSRV|0|V02 NT 11 05149||||0|1|0|0|La production du PID 0E est réalisée sur PMB et sur récurrence temporelle quand le moteur n’est pas tournant.|
INTOBDSRV_vidPMH_Pid|C|();|FCT1.8|INTOBDSRV|0|V02 NT 11 05149||||0|1|0|0|La production des PID 06 et OC est réalisée sur événement PMH et sur récurrence temporelle quand le moteur n’est pas tournant.|
ISCAN_EveRxn4C8_If|D|();|SCH13.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reception trame 4C8.|
ISCAN_EveRxn572_If|B|();|SCH16.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reception trame 572|
ISCAN_EveRxn7F2_If|B|();|SCH8.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reception trame 7F2|
ISLIN_vidCmdeAlt|E|();|SCH.6|ISLIN|1|V02 NT 09 03043||||0|0|0|0|
ISLIN_vidDiagEna|B|();|FCT1.6|ISLIN|0|V02 NT 09 03043||||0|0|0|0|This functions checks conditions to enable the diag and calls GDGAR functions
ISLIN_vidEtatAlt1|H|();|FCT1.4|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
ISLIN_vidEtatAlt2|H|();|FCT1.5|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
ISLIN_vidEveRst|E|();|SCH.1|ISLIN|1|V02 NT 09 03043||||0|0|0|0|
ISLIN_vidEveRxnEtatAlt1|F|();|SCH.4|ISLIN|1|V02 NT 09 03043||||0|0|0|0|Fonction appelée lors de la reception de la trame ETAT_ALT1
ISLIN_vidEveRxnEtatAlt2|F|();|SCH.5|ISLIN|1|V02 NT 09 03043||||0|0|0|0|Fonction appelée lors de la reception de la trame ETAT_ALT2
ISLIN_vidFreeze|F|();|FCT1.3|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
ISLIN_vidInitCons|F|();|FCT1.2|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
ISLIN_vidInitProd|F|();|FCT1.1|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
ISLIN_vidLinStatus|G|();|FCT1.9|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
ISLIN_vidSdlFast|E|();|SCH.2|ISLIN|1|V02 NT 09 03043||||0|0|0|0|
ISLIN_vidSdlMid|E|();|SCH.3|ISLIN|1|V02 NT 09 03043||||0|0|0|0|
ISLIN_vidShutDown|F|();|FCT1.8|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
ISLIN_vidWakeUp|F|();|FCT1.7|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
IUPRFRZ_vidDeactivation|A|();|FCT1.1|IUPRFRZ|0|V02 NT 11 03256||||0|1|0|0|La gestion des ratios de désactivation de l'IUPR.|
IUPRGENDEN_vidF01_ObdCond|D|();|FCT1.4|IUPRGENDEN|0|PTS_DOC_5497341||||0|0|0|0|Cette fonction gère le calcul du Dénominateur Général de l’IUPR ainsi que le Compteur de démarrages OBD.|
IUPRGENDEN_vidF01_SinceEngStrt|D|();|FCT1.6|IUPRGENDEN|0|PTS_DOC_5497341||||0|0|0|0|Cette fonction gère le compteur de temps depuis le démarrage moteur IUPR_tiSinceEngStrt|
IUPRGENDEN_vidF02_bObdStrt|C|();|FCT1.2|IUPRGENDEN|0|PTS_DOC_5497341||||0|0|0|0|Cette fonction crée un booléen qui s’active quand le régime moteur est supérieur à un seuil calibrable (GOBD_nObdStrtThd_C) correspondant au régime de ralenti -150tr/min. Cela correspond au critère d’un démarrage OBD.|
IUPRGENDEN_vidF02_ObdStrt|D|();|FCT1.5|IUPRGENDEN|0|PTS_DOC_5497341||||0|0|0|0|Cette fonction calcule le nombre de démarrage OBD (IUPR_ctObdStrt).|
IUPRGENDEN_vidF02_VehSpdOver40|D|();|FCT1.7|IUPRGENDEN|0|PTS_DOC_5497341||||0|0|0|0|Cette fonction gère le compteur de temps passé avec la vitesse véhicule supérieure à 40 km/h IUPR_tiVehSpdOver40|
IUPRGENDEN_vidF03_GenDen|D|();|FCT1.3|IUPRGENDEN|0|PTS_DOC_5497341||||0|0|0|0|Cette fonction comprend une sous-fonction F01_IUPR_OBDCOND dans laquelle est calculé le Dénominateur Général et le Compteur de démarrages OBD. Elle peut être inhiber et les paramètres de sortie figés si FRM_bFrzOBDGenDen provenant du GAR est activé.|
IUPRGENDEN_vidF03_VehIdle|D|();|FCT1.8|IUPRGENDEN|0|PTS_DOC_5497341||||0|0|0|0|Cette fonction gère le compteur de temps passé au ralenti|
IUPRGENDEN_vidF04_ReInitPrm|C|();|FCT1.9|IUPRGENDEN|0|PTS_DOC_5497341||||0|0|0|0|Cette fonction est appelée à chaque début de DC Global qui correspond aussi au démarrage moteur (hors calage et arrêts « Stop&Start ») et permet de ré-initialiser à 0 chaque compteurs de temps|
IUPRGENDEN_vidInitOutput|B|();|FCT1.1|IUPRGENDEN|0|PTS_DOC_5497341||||0|0|0|0|Initialisation des variables internes et sorties.|
IUPRGENDEN_vidMngEveGlbDCStrt|C|();|SCH.4|IUPRGENDEN|1|PTS_DOC_5497341||||0|0|0|0|Evenement Global DC Start|
IUPRGENDEN_vidMngEveSdlFast|C|();|SCH.3|IUPRGENDEN|1|PTS_DOC_5497341||||0|0|0|0|Evenement rapide|
IUPRGENDEN_vidMngEveSdlSlow|C|();|SCH.2|IUPRGENDEN|1|PTS_DOC_5497341||||0|0|0|0|Evenement lent|
IUPRRATIO_vidF01_CntDen|C|(uint16 u16IdxDft);|FCT1.5|IUPRRATIO|0|PTS_DOC_5338298||||0|0|0|0|Cette fonction gère le calcul du dénominateur du ratio du défaut unitaire. A chaque fois que les conditions du roulage ont répondue aux critères définis dans la note spécifiant le calcul du Dénominateur Général (Iupr_gen_denom_ok), le dénominateur, s’il n|
IUPRRATIO_vidF01_CntNum|C|(uint16 u16IdxDft);|FCT1.4|IUPRRATIO|0|PTS_DOC_5338298||||0|0|0|0|Cette fonction gère le calcul du numérateur du ratio du défaut unitaire. A chaque début de DC appliqué du défaut unitaire, le numérateur, s’il n’est pas égal à sa valeur maxi 65535, est incrémenté d’une unité. Lorsqu’il a atteint 65535, et qu’un nouveau D|
IUPRRATIO_vidF01_DenNumCal|B|(uint16 u16IdxDft, uint8 u8IdxGrpRat);|FCT1.6|IUPRRATIO|0|PTS_DOC_5338298||||0|0|0|0|M-fonction pour le calcul des Dénominateurs et Numérateurs des Groupes Ratios|
IUPRRATIO_vidF01_Ratio|C|(argin uint16 u16IdxIupr, argin uint16 u16IdxDft);|FCT1.3|IUPRRATIO|0|PTS_DOC_5338298||||0|0|0|0|F01 est activée à chaque début de DC appliqué du défaut concerné (DC_bTypCc_NameVar), et F02 à chaque fois que les conditions du roulage ont répondue aux critères définis dans la note spécifiant le calcul du Dénominateur Général (Iupr_gen_denom_ok).|
IUPRRATIO_vidF02_CntNumDen|D|();|FCT1.2|IUPRRATIO|0|PTS_DOC_5338298||||0|0|0|0|Cette fonction comprend une sous-fonction F01_IUPR_EnaGrpRat dans laquelle sont calculés les ratios des défauts unitaires ainsi que les Numérateurs et Dénominateurs des Groupes Ratios. Ces variables peuvent être réinitialisés à 0 par calibration (IUPR_bRs|
IUPRRATIO_vidInitOutput|B|();|FCT1.1|IUPRRATIO|0|PTS_DOC_5338298||||0|0|0|0|Initialisation des sorties.|
IUPRRATIO_vidMngEveSdlSlow|C|();|SCH.1|IUPRRATIO|1|PTS_DOC_5338298||||0|0|0|0|Evenement lent|
IUPRSPCDEN_bF01_tCoSen|C|Func_F01_tCoSen|FCT1.5|IUPRSPCDEN|0|V02 NT 11 03254||||0|0|0|0|Cette fonction produit le critère d’incrémentation du dénominateur spécifique « ColdStart » pour les défauts du capteur température d’eau.|
IUPRSPCDEN_bF06_pSpgSen|B|Func_F06_pSpgSen|FCT1.8|IUPRSPCDEN|0|V02 NT 11 03254||||0|0|0|0|Cette fonction produit le critère d’incrémentation du dénominateur spécifique « BP » pour les diagnostics de la suralimentation.|
IUPRSPCDEN_bF07_tCoDiag|A|Func_bF07_tCoDiag|FCT1.9|IUPRSPCDEN|0|V02 NT 11 03254||||0|0|0|0|Cette fonction produit le critère d'incrémentation du dénominateur spécifique diagnostic "cold start" validés|
IUPRSPCDEN_bF0x_XxCmSen|B|Func_XxCmSen|FCT1.7|IUPRSPCDEN|0|V02 NT 11 03254||||0|0|0|0|Cette fonction produit le critère d’incrémentation du dénominateur spécifique « VVT » pour les défauts du capteur arbre à cames admission. Cette fonction est appelée deux fois avec des paramêtres différents…|
IUPRSPCDEN_bF0x_XxVlv|B|Func_XxVlv|FCT1.6|IUPRSPCDEN|0|V02 NT 11 03254||||0|0|0|0|Cette fonction produit le critère d’incrémentation du dénominateur spécifique « VVT » pour les défauts de la VVT admission. Cette fonction est appelée deux fois avec des paramêtres différents.|
IuprSpcDen_EveRst|B|();|SCH.1|IUPRSPCDEN|1|V02 NT 11 03254||||0|0|0|0|Fonction appelée à l'initialisation du calculateur.|
IuprSpcDen_GlbDCStrt|B|();|SCH.2|IUPRSPCDEN|1|V02 NT 11 03254||||0|0|0|0|Fonction appelée lors de la réinitialisation lors d'un nouveau DC global.|
IuprSpcDen_SdlSlow|B|();|SCH.3|IUPRSPCDEN|1|V02 NT 11 03254||||0|0|0|0|Calcul des conditions d'incrémentation des dénominateurs spécifiques à la récurrence du moniteur lent de la fonction GD|
IUPRSPCDEN_vidF01_Ini|B|();|FCT1.1|IUPRSPCDEN|0|V02 NT 11 03254||||0|0|0|0|Fonction d'initialisation appelée soir sur un événement Reset au sur un événement DC global.|
IUPRSPCDEN_vidF02_ColdStrtCdn|A|();|FCT1.3|IUPRSPCDEN|0|V02 NT 11 03254||||0|0|0|0|Détection du démarrage à froid|
IUPRSPCDEN_vidF03_ClcnIncCdn|A|();|FCT1.4|IUPRSPCDEN|0|V02 NT 11 03254||||0|0|0|0|Calcul des conditions d'incrémentation des dénominateurs spécifiques à la récurrence du moniteur lent de la fonction GD.|
IUPRSPCDEN_vidInternalValueInit|B|();|FCT1.2|IUPRSPCDEN|0|V02 NT 11 03254||||0|0|0|0|Fonction d'initialisation appelée uniquement sur un événement Reset|
JDD_CxtFrfRec|C|(argin uint16 u16IdxDft);|SCH.9|JDD|1|PTS_DOC_5447356||||0|0|0|0|Evènement défauts|
JDD_DftExitUnval|C|(argin uint16 u16IdxDft);|SCH.8|JDD|1|PTS_DOC_5447356||||0|0|0|0|Evènement défauts pannes disparus|
JDD_DftInPres|C|(argin uint16 u16IdxDft);|SCH.7|JDD|1|PTS_DOC_5447356||||0|0|0|0|Evènement défauts pannes apparus|
JDD_RstDftCal|B|();|SCH.6|JDD|1|PTS_DOC_5447356||||0|0|0|0|Demande d'effacement Manuel des défauts.|
JDD_vidAcqFrame55F|F|();|FCT2.4|JDD|0|PTS_DOC_5447356||||0|0|0|0|Cette fonction est exécutée à chaque réception de la trame d’acquittement du journal BSI (AEE 2010).|
JDD_vidAcqFrame772|F|();|FCT2.3|JDD|0|PTS_DOC_5447356||||0|0|0|0|Cette fonction est exécutée à chaque réception de la trame d’acquittement du journal BSI (AEE 2004).|
JDD_vidAcquisitionCptBeforSyncro|B|();|FCT1.4|JDD|0|PTS_DOC_5447356||||0|0|0|0|Acquisition de la référence horaire|
JDD_vidCaptureData|F|(argin uint16 u16IdxDft);|FCT1.7|JDD|0|PTS_DOC_5447356||||0|0|0|0|Ce bloc traite du figeage des paramètres (captures) pour les 2 architecture AEE 2004 / 2010 lors de la détection ou de la confirmation d’absence d’un défaut.|
JDD_vidDftClrData|B|();|FCT3.10|JDD|0|PTS_DOC_5447356||||0|0|0|0|Cette fonction gère l’effacement du contexte associé à un défaut lorsque celui-ci a été correctement transmis au BSI ou lorsque toutes les tentatives d’envoi de celui-ci ont été épuisées.|
JDD_vidDftUnval|A|(argin uint16 u16IdxDft);|1|HEADER|1|HEADER||||0|0|0|0|header|
JDD_vidFillBufferContextFailure|F|(argin uint16 u16IdxDft);|FCT2.1|JDD|0|PTS_DOC_5447356||||0|0|0|0|La gestion du remplissage dans le Buffer des évènements défauts à émettre peut être inhibé par calibration (Jbsi_manu_inh).|
JDD_vidIni|C|();|FCT1.2|JDD|0|PTS_DOC_5447356||||0|0|0|0|A l’initialisation de l’ECU, les données statiques de l’entête des différentes trames se configurent selon l’architecture AEE en place.|
JDD_vidInitOutput|E|();|FCT1.1|JDD|0|PTS_DOC_5447356||||0|0|0|0|Initialisation des sorties|
JDD_vidPrepaDataIscanBuffer|B|();|3|HEADER|1|NONE||||0|0|0|0|Demande de préparation par le manager de la trame JDD (768h) à émettre|
JDD_vidReqClrDft|C|();|FCT2.5|JDD|0|PTS_DOC_5447356||||0|0|0|0|Lors d'une requête d'effacement des défauts ou par passage à 1 du CLRDTC de la  trame 92h, le buffer est réinitialisé et le nombre de pannes en attente passe à 0|
JDD_vidRstAckBsi|B|();|FCT3.9|JDD|0|PTS_DOC_5447356||||0|0|0|0|A chaque demande d’émission de la trame JDD par le manager, le flag de réception de l’acquittement est  reseté.|
JDD_vidSetStateDtcFugitf|D|(argin uint16 u16IdxDft);|FCT1.6|JDD|0|PTS_DOC_5447356||||0|0|0|0|Indique que l’évènement défaut à émettre s’agit d’un défaut disparu.|
JDD_vidSetStateDtcPresent|D|(argin uint16 u16IdxDft);|FCT1.5|JDD|0|PTS_DOC_5447356||||0|0|0|0|Indique que l’évènement défaut à émettre s’agit d’un défaut confirmé.|
JDD_vidStartFaultSending|E|();|FCT2.2|JDD|0|PTS_DOC_5447356||||0|0|0|0|Cette fonction gère la préparation des données des différentes trames de l’évènement défaut à émettre l’architecture AEE en place.|
JDD_vidStateJbsiIdle|C|();|FCT3.2|JDD|0|PTS_DOC_5447356||||0|0|0|0|Transition de l'état JBSI_IDLE|
JDD_vidStateJbsiWaitAcquittement|D|();|FCT3.6|JDD|0|PTS_DOC_5447356||||0|0|0|0|Transition de l'état JBSI_ATTENTE_ACQUITTEMENT|
JDD_vidStateJbsiWaitRestartProc|E|();|FCT3.7|JDD|0|PTS_DOC_5447356||||0|0|0|0|Transition de l'état JBSI_ATTENTE_RESTART_PROCESSUS|
JDD_vidStateJbsiWaitSendFrame1|C|();|FCT3.3|JDD|0|PTS_DOC_5447356||||0|0|0|0|Transition de l'état JBSI_ATTENTE_ENVOI_TRAME_1|
JDD_vidStateJbsiWaitSendFrame2|C|();|FCT3.4|JDD|0|PTS_DOC_5447356||||0|0|0|0|Transition de l'état JBSI_ATTENTE_ENVOI_TRAME_2|
JDD_vidStateJbsiWaitSendFrame3|C|();|FCT3.5|JDD|0|PTS_DOC_5447356||||0|0|0|0|Transition de l'état JBSI_ATTENTE_ENVOI_TRAME_3|
JDD_vidTimeCounterBeforeSynchro|C|();|FCT1.3|JDD|0|PTS_DOC_5447356||||0|0|0|0|Ce bloc traite de l’acquisition de la référence horaire avant la première synchronisation (uniquement en AEE 2010).|
JDD_vidTransmissionFramesMngr|C|();|FCT3.1|JDD|0|PTS_DOC_5447356||||0|0|0|0|Cette fonction traite de la gestion du séquencement de  l’émission des évènements défauts vers le calculateur BSI.|
JDD_vidTransToIdleOrSendFrame1|C|();|FCT3.8|JDD|0|PTS_DOC_5447356||||0|0|0|0|Transition à l'état  JBSI_IDLE ou JBSI_ATTENTE_ENVOI_TRAME_1.|
JDDISCANIF_PrepaDataIscanBuffer|A|();|SCH.2|JDDISCANIF|1|V02 NT 11 02911||||0|1|0|0|Demande de préparation par le manager de la trame JDD (768h) à émettre|
JDDISCANIF_vid1Trame|A|();|FCT2.1|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|Cette fonction permet d'envoyer une trame lorsque le defaut est fugitifs|
JDDISCANIF_vid3Trames|A|();|FCT2.2|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|cette fonction envoie trois trames lorsque le défaut est present.|
JDDISCANIF_vidAEE2004Treat|B|();|FCT1.10|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|Le traitement des trames pour une AEE 2004 ou 2007 n’est pas encore spécifie. Néanmoins il est pris en compte dans l’architecture de cette NT.|
JDDISCANIF_vidAEE2010Treat|C|();|FCT1.4|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|Pour une AEE 2010, on traite les données en fonction de leur appartenance à la première ou à la deuxième trame.|
JDDISCANIF_vidDftCodTreat|A|();|FCT1.5|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|Le code défaut, émis vers le BSI dans la trame n 1, doit respecter le format de codage  du constructeur|
JDDISCANIF_vidDftTime|A|();|FCT1.7|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|La référence horaire du défaut, émise vers le BSI dans la trame n 1, doit respecter le  format de codage du constructeur|
JDDISCANIF_vidDstTreat|A|();|FCT1.6|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|L'information kilométrage du défaut, émise vers la BSI dans la trame n 2, doit respecter  le format de codage du constructeur|
JDDISCANIF_vidHdTreat|B|();|FCT1.3|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|L'octet d'entête de chaque trame à émettre doit respecter le format de codage du  constructeur|
JDDISCANIF_vidInit|A|();|FCT1.1|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|Fonction d'initialisation des paramètres produits|
JDDISCANIF_vidPrepaDataISCAN|B|();|FCT1.2|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|Sur chaque demande d’émission de trame du JDD vers la BSI, on teste l’architecture électrique et électronique, afin de déterminer le traitement à effectuer.|
JDDISCANIF_vidRcdTreat|B|();|FCT1.9|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|Fonction qui détermine L’information Etat automate RCD à émettre|
JDDISCANIF_vidRemplissageTrame1|A|();|FCT2.3|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|Cette fonction permet de remplir la 1 trame en cas d'un défaut.|
JDDISCANIF_vidRemplissageTrame2|A|();|FCT2.4|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|Cette fonction permet de remplir la 2 trame en cas d'un défaut.|
JDDISCANIF_vidRemplissageTrame3|A|();|FCT2.5|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|Cette fonction permet de remplir la 3 trame en cas d'un défaut.|
JDDISCANIF_vidVehCdn|A|();|FCT1.8|JDDISCANIF|0|V02 NT 11 02911||||0|1|0|0|L'information situation de vie, émise vers le BSI dans la trame n 2, doit respecter le  format de codage du constructeur|
KEYPUSHINFO_vidEventSelc|A|();|FCT1.3|KEYPUSHINFO|0|PTS_DOC_6543971||||0|0|0|0|Ce bloc permet de créer un événement de 10ms a partir d'un événement de 5 ms.
KEYPUSHINFO_vidInit|A|();|FCT1.2|KEYPUSHINFO|0|PTS_DOC_6543971||||0|0|0|0|Initialisation.
KEYPUSHINFO_vidInitOutput|A|();|FCT1.1|KEYPUSHINFO|0|PTS_DOC_6543971||||0|0|0|0|Initialisation des sorties.
KEYPUSHINFO_vidKeyFunct|A|();|FCT1.6|KEYPUSHINFO|0|PTS_DOC_6543971||||0|0|0|0|Ce bloc décrit la filtration de l'information Key acquis de l'API.
KEYPUSHINFO_vidKeyPushAcq|A|();|FCT1.4|KEYPUSHINFO|0|PTS_DOC_6543971||||0|0|0|0|Ce bloc décrit l'information Key/Push acquis de l'API.
KEYPUSHINFO_vidKeyPushTreat|A|();|FCT1.5|KEYPUSHINFO|0|PTS_DOC_6543971||||0|0|0|0|Ce bloc vérifie les conditions qui permettent la filtration du signal acquis de l'API (Ext_bDemLineRaw).
KEYPUSHINFO_vidPushFunct|A|();|FCT1.7|KEYPUSHINFO|0|PTS_DOC_6543971||||0|0|0|0|Ce bloc décrit la filtration de l'information Push acquis de l'API.
KNKACQ_vidBandPassFilterParam|F|();|FCT1.8|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|L'ordre de ce filtre (ordre 2) donne une bande passante correcte (2,75 kHz à –3dB) tout en respectant les contraintes de charge de calcul.|
KNKACQ_vidCalcAuthorizeDetection|D|();|FCT1.4|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|La demande de diagnostic (Knk_sens_diag_dmd_uavb0) envoyée sous certaine conditions lorsque le  diagnostic est requis "DIAG_REQUIRED" est transformée en statut actif (Knk_sens_diag_act_uavb0) lorsque  l’acquisition est autorisée.|
KNKACQ_vidCalcParameters|C|();|FCT1.6|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|Fonction qui permet de calculer les paramétres de l'acquisition du capteur cliquetis.|
KNKACQ_vidConfigParameters|C|();|FCT1.5|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|La demande de diagnostic (Knk_sens_diag_dmd_uavb0) envoyée sous certaine conditions lorsque le  diagnostic est requis "DIAG_REQUIRED" est transformée en statut actif (Knk_sens_diag_act_uavb0) lorsque  l’acquisition est autorisée.|
KNKACQ_vidConfigParametersInit|C|();|FCT1.2|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|La fréquence de coupure du filtre anti-repliement dépend de la fréquence centrale du filtre passe- bande, celle-ci est initialisée à 18,49kHz au reset du calculateur pour permettre au filtre anti-repliement d’avoir  sa fréquence de coupure au maximum.|
KNKACQ_vidEndKnoksTaskTreatment|C|();|FCT1.3|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|Dans un premier temps, on s’assure qu’on veut autoriser l’acquisition du signal cliquetis. Dans ce cas seulement, les paramètres d’acquisition sont calculés.|
KNKACQ_vidInitOutput|D|();|FCT1.1|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|Fonction d'initialisation des sorties.|
KNKACQ_vidObservationWindow|I|();|FCT1.7|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|La charge en air du moteur est utilisée plutôt que la pression collecteur pour la détermination du début de fenêtre cliquetis. Dans le cas d’un moteur à remplissage variable (par exemple VVT).|
KNKACQ_vidTBandPassFilterParam|E|();|FCT2.4|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|Fonction qui calcule la Frequence_centrale_passe_bande.|
KNKACQ_vidTCalcAuthorizDetection|C|();|FCT1.10|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|Fonction qui permet de calculer Autorise_detection_clq.|
KNKACQ_vidTCalcParameters|C|();|FCT2.2|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|Focntion qui permet de calculer Knk_sen_dyn_filt_det_uavb1 et Regime_chgt_freq_cliq .|
KNKACQ_vidTConfigParameters|C|();|FCT2.1|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|Le diagnostic du capteur cliquetis doit être réinitialisé si il a été interrompu.|
KNKACQ_vidTemporalTreatment|C|();|FCT1.9|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|Le but du traitement temporel est de pouvoir réactiver l’autorisation des acquisitions cliquetis une fois que  celles-ci ont été interrompues. La configuration des paramètres d’acquisition est sensiblement la même que  dans le cas nominal.|
KNKACQ_vidTObservationWindow|I|();|FCT2.3|KNKACQ|0|PTS_DOC_5066621||||0|0|0|0|Foncton qui premet de calculer Debut_fenetre_cliquetis|
KNKACQFILT_vidCheckCondition|B|();|FCT2.4|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|Production activation condition of block 03_Definition_knk_windows|
KNKACQFILT_vidConfigParamInit|E|();|FCT1.2|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|Dans le souci de rendre la spécification générique, nous avons dupliqué le bloc d’initialisation des APIs pour la détection de cliquetis et la détection de rumble.|
KNKACQFILT_vidDefKnkWindows|G|();|FCT1.9|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|Nous allons considérer ces 2 cas de figure:Détection de cliquetis autorisée et détection de rumble autorisée et détection de cliquetis autorisée et détection de rumble non autorisée.|
KNKACQFILT_vidFilterEnergyCalc|F|();|FCT1.4|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|Ce bloc est divisé en trois sous-blocs :01_CalcParamFilt calcule,  SignalSampleFilter et 03_Lecture_energie_cliquetis.|
KNKACQFILT_vidInitializationRbl|E|();|FCT1.3|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|Au reset calculateur, plusieurs paramètres sont envoyés au LdB via KNWHAL APIs KNWHAL_vidWriteAntiAliasingFreq, KNWHAL_vidWriteSamplePeriod, KNWHAL_vidSetSampleTblPrms et KNWHAL_vidSetSamplingWinIdxTbl.|
KNKACQFILT_vidInitOutput|G|();|FCT1.1|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|Fonction d'initialisation des sorties.|
KNKACQFILT_vidInterfaceBSW|B|();|FCT2.3|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|Fonction d'interfacage BSW.|
KNKACQFILT_vidKnkMesWin|B|();|FCT2.2|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|cette fonction détermine le nombre et le vecteur de fenetres disponibles pour l'acquisition de signal  cliquetis/rumble|
KNKACQFILT_vidOfsInjrNKnkcalc|B|();|FCT2.5|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|Ce bloc calcule la valeur à retrancher dans le bruit instantané cliquetis lorsque le début des injections tombe dans la fenêtre cliquetis.|
KNKACQFILT_vidOfsPmpHPNKnkcalc|C|();|FCT2.1|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|Ce bloc calcule la valeur à retrancher dans le bruit instantané cliquetis lorsque la commande de la pompe HP tombe dans la fenêtre cliquetis.|
KNKACQFILT_vidReadingKnkEnergy|G|();|FCT1.8|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|La somme des échantillons filtrés durant la fenêtre somme_clq est récupérée puis rangée dans l’ordre physique des cylindres dans la variable Somme_clq_cyl.|
KNKACQFILT_vidReadingRblEnergy|F|();|FCT1.7|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|La somme des échantillons filtrés durant la fenêtre somme_rbl est récupérée puis rangée dans l’ordre physique des cylindres dans la variable Somme_rbl_cyl.|
KNKACQFILT_vidReadKnkRblEnergy|F|();|FCT1.6|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|03_Lecture_energie_cliquetis récupère les sommes de cliquetis/rumble et les range dans une matrice en fonction de numéro de cylindre.|
KNKACQFILT_vidSigConvGainCalc|C|();|FCT1.10|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|fonction de de correspondance entre le numéro de gain et la valeur de gain physique|
KNKACQFILT_vidSignalSampleFilter|F|();|FCT1.5|KNKACQFILT|0|PTS_DOC_5066552||||0|0|0|0|SignalSampleFilter est une s-function servant de filtre passe bande.|
KNKADPCOR_vidAdapComputeStrategy|F|();|FCT2.4|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|L’adaptatif est incrémenté à chaque détection de cliquetis que ce soit par la stratégie de détection classique ou par la détection palliative. S’il n’y a pas de cliquetis, la décrémentation n’est autorisée que si l’avance optimale est sup à l’avance maxi.|
KNKADPCOR_vidAdaptativeCompute|I|();|FCT2.3|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Ce bloc calcule la correction d'avance à appliquer par rapport au bornage maximum pour le cylindre en cours.|
KNKADPCOR_vidAdaptativeReading|L|();|FCT2.9|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|La zone de fonctionnement courante est déterminée préalablement à la lecture des adaptatifs qui vont être appliqués au prochain allumage. Elle est fixée à 0, si le régime et la charge moteur sont en dehors des bornes min et max des points d’appui.|
KNKADPCOR_vidAdaptDec|D|();|FCT2.7|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|La borne minimale des adaptatifs est différente de zéro par rapport à la stratégie précédente; Les adaptatifs peuvent prendre des valeurs négatives afin de faire un apprentissage de carburant ayant un indice d’octane supérieur à celui des avances de base.|
KNKADPCOR_vidAdaptSlewRate|D|();|FCT2.8|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Lorsqu'une incrémentation est appliquée, elle est soumise à un slew rate afin d'éviter les à-coups dans le ressenti. Le slew rate est cartographié en fonction du régime (table Av_bmax_max_slew_rate_map).|
KNKADPCOR_vidAdaptWriteCond|D|();|FCT1.8|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|La décrémentation ou l'incrémentation des adaptatifs est figée si : une panne anti-cliquetis apparaît, un changement de rapport effectué en BVA et BVMP, le point de fonctonnement n'est pas en zone critique, le régime et la charge sont en transitoire.|
KNKADPCOR_vidAntiKnockPrevention|E|();|FCT3.6|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|La correction de limite max n'est appliquée que dans la zone critique, où un risque de cliquetis existe. En cas de panne de la fonction anti-cliquetis, on applique une correction préventive forfaitaire(Av_bmax_corr_adapt_defaut_anti_k).|
KNKADPCOR_vidCalcAvBmaxMoyen|G|();|FCT3.7|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Calcul av bmax moyen.|
KNKADPCOR_vidConditionalVarReset|C|();|FCT3.3|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|A chaque changement de zone, les compteurs de retard et de décrémentation sont réinitialisés.|
KNKADPCOR_vidCounterReset|C|();|FCT3.1|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|A chaque changement de zone, les adaptatifs correspondant à la nouvelle zone sont appliqués.|
KNKADPCOR_vidCylAdaptation|G|();|FCT3.4|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Le calcul des adaptatifs est lissé afin d'éviter une trop grande dispersion entre cylindres. On autorise les adaptations à varier dans une plage de largeur Av_bmax_ecart_max.|
KNKADPCOR_vidDecrementation|D|();|FCT2.6|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|S’il n’y a pas de cliquetis, la décrémentation n’est autorisée que si l’avance optimale est supérieure à l’avance maxi d’au moins Knk_adapt_dec_delta_min.|
KNKADPCOR_vidEngLoadStable|E|();|FCT1.7|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Le booléen Knk_adapt_n_stable passe à 1 lorsque le régime moteur est considéré stable, c'est-à-dire lorsque ses variations sont inférieures au critère Knk_adapt_n_stab_thresh.|
KNKADPCOR_vidEngSpdEngLoadSaving|E|();|FCT1.5|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Au PMB admission d’un cylindre, sont calculées l’avance à l’allumage pour ce cylindre et l’avance pour le cylindre suivant. Les corrections d’avance anti-cliquetis doivent donc être mises à jour 2 PMB admission avant le PMH combustion.|
KNKADPCOR_vidEngSpdStable|D|();|FCT1.6|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Au PMB admission d’un cylindre, sont calculées l’avance à l’allumage pour ce cylindre (Avance_finale) et l’avance pour le cylindre suivant Les corrections d’avance anti-cliquetis doivent donc être mises à jour 2 PMB admission avant le PMH combustion.|
KNKADPCOR_vidFiltering|H|();|FCT3.8|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Cette fonction permet de prendre en compte les transitions sur la zone de fonctionnement et la zone critique pour lesquelles de nouveaux adaptatifs sont appliqués. Cette fonction effectue un filtrage sur la sortie lors de ces transitions.|
KNKADPCOR_vidFuelDetection|C|();|FCT2.1|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Cette fonction permet l'appel de la fonction de remise à 0 des correctifs d'avance.|
KNKADPCOR_vidHighTemperature|E|();|FCT1.4|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Les adaptatifs sont mémorisés en EEPROM à la coupure de contact durant le power latch. Ils ne sont restitués au reset que si le moteur est encore chaud.|
KNKADPCOR_vidIncrementation|I|();|FCT2.5|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|L’adaptatif est incrémenté à chaque détection de cliquetis que ce soit par la stratégie de détection classique (Detection_cliquetis =1) ou par la détection palliative (Knk_deg_det_cur_uavb1 = 1).|
KNKADPCOR_vidInitMaxAdvance|I|();|FCT1.2|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Les adaptatifs sont mémorisés en EEPROM à la coupure de contact durant le power latch. Ils ne sont restitués au reset que si le moteur est encore chaud.|
KNKADPCOR_vidInitOutput|L|();|FCT1.1|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Fonction d'initialisation des variables produites par la spec.|
KNKADPCOR_vidInitRFuelDetection|E|();|FCT2.2|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Lorsqu’un plein est détecté et que la carburant situé entre le réservoir et les injecteur est consommé (RFuDet_bRstAdp passe de 1 à 0), les av_bmax doivent être remis à 0 comme pour un reset logiciel.|
KNKADPCOR_vidLowTemperature|E|();|FCT1.3|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Les adaptatifs sont mémorisés en EEPROM à la coupure de contact durant le power latch. Ils ne sont restitués au reset que si le moteur est encore chaud.|
KNKADPCOR_vidMajAvBmax|F|();|FCT3.5|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Mise à jour du vecteur Av_bmax_adapt_anti_k_cylx|
KNKADPCOR_vidTreatment|D|();|FCT3.2|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|A chaque changement de zone, les adaptatifs correspondant à la nouvelle zone sont appliqués.|
KNKADPCOR_vidUpdatApplAdaptShift|A|();|FCT1.9|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Cette fonction permet de mettre à jour les transitions sur la zone de fonctionnement et la zone critique pour lesquelles de nouveaux adaptatifs sont appliqués.|
KNKADPCOR_vidZoneDetermination|G|();|FCT2.10|KNKADPCOR|0|PTS_DOC_5154831||||0|0|0|0|Une hystérésis sur le régime moteur et la charge est appliquée pour chaque transition de zone de fonctionnement.|
KNKBENCHMOD_vidCalcDelay|B|();|FCT1.4|KNKBENCHMOD|0|V02 NT 09 00486||||0|0|0|0|Ce mode permet de générer une variable regroupant les signaux des quatre cylindres (bruit instantané, bruit moyen, gain, booléen de détection cliquetis) et d’effectuer un retard sur les voies citées précédemment.
KNKBENCHMOD_vidCalcVariables|A|();|FCT1.3|KNKBENCHMOD|0|V02 NT 09 00486||||0|0|0|0|Ce module permet de calculer les gains correspondants aux rapports (bruit instantané – offset) / bruit moyen (cylindre à cylindre), utilisés pour la calibration des cartographies des gains de détection (Knk_det_gain_cyl*_n_map_uacn1).
KNKBENCHMOD_vidEntryInit|A|();|SCH.1|KNKBENCHMOD|1|V02 NT 09 00486||||0|0|0|0|Fonction moniteur Reset
KNKBENCHMOD_vidInitialization|B|();|FCT1.1|KNKBENCHMOD|0|V02 NT 09 00486||||0|0|0|0|Initialisation du Rapport signal/bruit (gain) par cylindre précédent
KNKBENCHMOD_vidTestBed|C|();|FCT1.2|KNKBENCHMOD|0|V02 NT 09 00486||||0|0|0|0|Les fonctionnalités de calibration online ne sont utilisées que lors de la mise au point. Par conséquent elles sont inhibées en série.
KNKCRITZONE_vidComputeCritZone|A|();|FCT1.2|KNKCRITZONE|0|V02 NT 08 05110||||0|0|0|0|La Table_zone_critique représente la zone où il est physiquement possible d’avoir du cliquetis. Ainsi, on définit un seuil mini en charge en dessous duquel on considère qu’il ne peut pas y avoir de cliquetis|
KNKCRITZONE_vidInitialization|A|();|FCT1.1|KNKCRITZONE|0|V02 NT 08 05110||||0|0|0|0|Le paramètre zone critique est initialisé à 0|
KNKDET_vidAverageNoiseCalc|D|();|FCT2.8|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Calcul du bruit moyen.|
KNKDET_vidAverageNoiseReset|B|();|FCT2.9|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Réinitialisation du bruit moyen.|
KNKDET_vidCy14Detection|H|();|FCT2.6|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Détection des cylindres 1 et 4 simultanément.|
KNKDET_vidCy23Detection|H|();|FCT2.5|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Détection des cylindres 2 et 3 simultanément.|
KNKDET_vidCyclDetection|I|();|FCT2.2|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Le bruit instantané du dernier cylindre sur lequel on a fait la mesure est comparé avec un seuil représentatif du bruit de ce cylindre sans cliquetis pour décider de la présence de cliquetis.|
KNKDET_vidCylAverageNoiseCalc|B|();|FCT2.7|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Calcul de bruit moyen d'un cylindre.|
KNKDET_vidCylTreatment|B|();|FCT2.1|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|La détection est réalisée avant la mise à jour du bruit moyen car celle-ci tient compte de la présence ou non de cliquetis dans  le cylindre en cours.|
KNKDET_vidCylUncertainTreatment|B|();|FCT2.4|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Traitement en cas d'incertitude de detection.|
KNKDET_vidDecrDynFilterCounter|B|();|FCT1.6|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Décrémentation du compteur de filtrage dynamique.|
KNKDET_vidFactorFilterCalcFinal|D|();|FCT1.8|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Lors d'une transition de charge ou de régime ou si un changement de la fréquence du filtre passe-bande a été détecté, un filtrage différent (dynamique) est appliqué durant un délai calibrable..|
KNKDET_vidFactorFilterCalcFreq|B|();|FCT1.7|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Le changement de la fréquence du filtre-passe bande peut entraîner une variation brutale du bruit instantané qui peut être interprété à tord comme du cliquetis.|
KNKDET_vidFactorFilterCalcLoad|C|();|FCT1.4|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|La détection des transitoires de charge est calculée à fréquence SdlMid: en effet une Détection moins fréquente induit un retard trop important dans l'application du gain de filtrage dynamique,avec comme conséquence des fausses détections.|
KNKDET_vidFactorFilterCalcN|B|();|FCT1.3|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|En  prévision  du  changement  de  filtrage  lors  des  transitoires,  les  transitoires  de  régime  sont  évalués  en observant  la variation de  régime sur  l’échantillon  temporel SdlSlow.|
KNKDET_vidInhibitionCorrection|C|();|FCT1.9|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Afin d’éviter  les  fausses détections cliquetis en cas de  fortes dégradations d’avance  lors des changements de rapport,  la  détection  est  inhibée  lorsque  les  retraits  d’avance  dépassent  un seuil  calibrable.|
KNKDET_vidInitDynFilterCounter|B|();|FCT1.5|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Initialisation du compteur de filtrage dynamique.|
KNKDET_vidInitOutput|D|();|FCT1.1|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Reset du compteur de temps avant sortie du transitoire régime ou charge pour le facteur de filtrage (par cylindre).|
KNKDET_vidInitStrategy|D|();|FCT1.2|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Initialisation de stratégies à l'activation des combustions.|
KNKDET_vidPairCylTreatment|B|();|FCT2.3|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|Traitement par paire de cylindre.|
KNKDET_vidReset|B|();|FCT2.10|KNKDET|0|PTS_DOC_5068282||||0|0|0|0|En cas de panne du capteur cliquetis, le bruit moyen est réinitialisé à sa valeur maximale en raison de l'incertitude sur la pertinence des mesures précédentes.|
KnkDetRbl_vidAutoriseDetectRbl|I|();|FCT1.7|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|The calculation done when KnkTreat_EveRbl_KnkDetRbl is triggered and KnkRbl_noCyl is lower or equal to 4|
KnkDetRbl_vidCalcBruitMoyenRbl|E|();|FCT2.8|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|In every PMH, this process must be executed after the treatment of detection of the rumble so that the value Bruit_moyen_rbl_cyl is not perturbed.|
KnkDetRbl_vidCalcFactFiltrageN|C|();|FCT1.4|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|When the transient is detected, a boolean ( Knk_n_rbl_dyn_filt_det_uavb0) is raised so that the gain of dynamic filtering are applied|
KnkDetRbl_vidCalcFactFiltrLoad|D|();|FCT1.5|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|The detection of the transients of load is calculated on sched Mid. If a transient of regime was before detected (Knk_n_rbl_dyn_filt_det), the dynamic filtering is automatically applied.|
KnkDetRbl_vidCyl1_rbl|F|();|FCT2.1|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|calculate the value of Knk_det_rbl_gain_cyl1_regime from the map Knk_det_rbl_gain_cyl1_n_map|
KnkDetRbl_vidCyl2_rbl|F|();|FCT2.4|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|calculate the value of Knk_det_rbl_gain_cyl2_regime from the map Knk_det_rbl_gain_cyl2_n_map|
KnkDetRbl_vidCyl3_rbl|F|();|FCT2.2|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|calculate the value of Knk_det_rbl_gain_cyl3_regime from the map Knk_det_rbl_gain_cyl3_n_map|
KnkDetRbl_vidCyl4_rbl|F|();|FCT2.3|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|calculate the value of Knk_det_rbl_gain_cyl4_regime from the map Knk_det_rbl_gain_cyl4_n_map|
KnkDetRbl_vidDetection_index|E|();|FCT2.7|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|allows to find the index of the value of the table which is superior at the threshold of detection of the rumble. If none of the elements of the table is upper at the threshold of detection, the rumble detection is put in zero, the index at 16|
KnkDetRbl_vidDetection_rumble|K|();|FCT2.6|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|The threshold of maximal immediate noise is defined by a gain and an offset on the average noise calculated previously|
KNKDETRBL_vidInit|C|();|FCT1.1|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|At the initialization, the counter Knk_rbl_dyn_filt_counter is initialized at zero|
KnkDetRbl_vidInitOutput|K|();|FCT1.3|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|At the initialization, the counter Knk_rbl_dyn_filt_counter is initialized at zero|
KnkDetRbl_vidKnkDetRblGainRegime|E|();|FCT1.8|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|According to KnkRbl_noCyl, only the mapping of the concerned cylinder is estimated. The case " default " of the switch is treated upstream to the block by a test on the border max of KnkRbl_noCyl.|
KNKDETRBL_vidReinitTacheSynchRbl|H|();|FCT1.2|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|The variable Bruit_moyen_rbl is initialized in its maximal value on event TOURNANT_SYNCHRO. The variables Detection_rbl and Degradation_etat_rblA are initialized at 0.|
KnkDetRbl_vidTache_rumble|D|();|FCT1.6|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|The calculations are authorized only if the detection is authorized and if KnkRbl_noCyl is lower or equal to 4|
KnkDetRbl_vidTraitmntsDetectRrbl|D|();|FCT2.5|KNKDETRBL|0|PTS_DOC_5068340||||0|0|0|0|The calculation of the average noise will be executed after the detection of the rumble. You should not adapt the average noise in the same way in case of presence of rumble or presence of strong clanking.|
KNKDIAG_vidDiagnosticConditions|C|();|FCT1.5|KNKDIAG|0|PTS_DOC_5307525||||0|0|0|0|Ce module est activé lorsque le diagnostic est requis. On doit alors s’assurer que les conditions de régime, température d’eau et position papillon sont bien réunies pour le passage en mode diagnostic. Le diagnostic est inhibé lors de coupure d'injection.|
KNKDIAG_vidDiagStateManagement|C|();|FCT1.4|KNKDIAG|0|PTS_DOC_5307525||||0|0|0|0|Ce module gère les opérations menées dans chaque état du diagramme et les conditions qui déclenchent les transitions d’un état à un autre.|
KNKDIAG_vidDiagStrategy|B|();|FCT1.3|KNKDIAG|0|PTS_DOC_5307525||||0|0|0|0|La stratégie de diagnostic cliquetis peut se trouver dans quatre états différents, gérés dans un diagramme d’états: DIAG_NOT_REQUESTED, DIAG_REQUIRED, DIAG_RUNNING et DIAG_ENDING.|
KNKDIAG_vidEndDiag|C|();|FCT1.6|KNKDIAG|0|PTS_DOC_5307525||||0|0|0|0|Lorsque les bruits de tous les cylindres ont été additionnés, on compare la moyenne de bruit à un seuil calibrable. On considère qu’en dessous de ce seuil, le capteur est en panne.|
KNKDIAG_vidEntryInit|B|();|SCH.1|KNKDIAG|1|PTS_DOC_5307525||||0|0|0|0|Evènement RESET de scheduler.|
KNKDIAG_vidInitOutput|B|();|FCT1.1|KNKDIAG|0|PTS_DOC_5307525||||0|0|0|0|Fonction d'initialisation des variables produites par la spec.|
KNKDIAG_vidTreatment|D|();|FCT1.2|KNKDIAG|0|PTS_DOC_5307525||||0|0|0|0|La calibration Cliq_diag_knk_tdc_nr est à double emploi : Positionnée à zéro, elle inhibe la stratrégie de diagnostic et toute valeur strictement positive désigne le nombre de PMH que l’on souhaite laisser entre deux passages  en mode diagnostic.|
KNKFASTCOR_vidCorNotInGearChange|B|();|FCT1.5|KNKFASTCOR|0|PTS_DOC_5059533||||0|0|0|0|Après un changement de rapport BVA ou BVMP, hors panne cliquetis, la correction finale d’avance Cliquetis_cor_avance est ramenée à la correction  courante Correction_boucle_rapide par un filtre pendant le délai Cliquetis_cor_avance_delay.|
KNKFASTCOR_vidCorrInGearChange|C|();|FCT1.6|KNKFASTCOR|0|PTS_DOC_5059533||||0|0|0|0|En changement de rapport BVA ou BVMP (accompagné d’un fort retrait d’avance dans le cas de la BVMP), la correction est filtrée vers 0 par un filtre du premier ordre.|
KNKFASTCOR_vidDecrementation|C|();|FCT2.3|KNKFASTCOR|0|PTS_DOC_5059533||||0|0|0|0|La temporisation Tempo_boucle_rapide est décrémentée tous les N PMH pour un cylindre donné (Ou N est le nombre de cylindres du moteur).|
KNKFASTCOR_vidFastCorrDecre|C|();|FCT2.2|KNKFASTCOR|0|PTS_DOC_5059533||||0|0|0|0|Une fois le délai de maintien écoulé, on décrémente la correction d’avance d’une valeur interpolée dans la carto Cliq_cor_boucle_rapide_dec_map(Régime_moteur) tous les X PMH (où X est issu de la carto : Duree_decrem_boucle_rapide_map(Régime_moteur)).|
KNKFASTCOR_vidFastCorrection|D|();|FCT1.4|KNKFASTCOR|0|PTS_DOC_5059533||||0|0|0|0|En cas de détection ou de détection palliative de cliquetis, ou de détection de super cliquetis, une correction rapide sur le cylindre concerné est appliquée.|
KNKFASTCOR_vidFastCorrectionCalc|D|();|FCT1.2|KNKFASTCOR|0|PTS_DOC_5059533||||0|0|0|0|On ne peut appliquer de correction rapide d’avance qu’en cas de zone critique et si les acquisitions du capteur cliquetis sont autorisées|
KNKFASTCOR_vidFastCorrIncre|G|();|FCT2.1|KNKFASTCOR|0|PTS_DOC_5059533||||0|0|0|0|On applique une correction rapide Cliq_pas_boucle_rapide_map que l’on maintient pendant un délai Duree_maintien_boucle_rapide_map. Cette tempo est calibrée en cycles moteur de façon à être générique N cylindres.|
KNKFASTCOR_vidFastCorrOnCritZone|B|();|FCT1.3|KNKFASTCOR|0|PTS_DOC_5059533||||0|0|0|0|Hors changement de rapport BVA ou BVMP, la correction rapide appliquée a l'allure suivante (elle est calculée positivement puis retranchée par la suite)|
KNKFASTCOR_vidFastCorrOutCritZon|B|();|FCT1.8|KNKFASTCOR|0|PTS_DOC_5059533||||0|0|0|0|La correction rapide d’avance n'est pas appliquée lorsque la zone n'est pas critique ou lorsque les acquisitions du capteur cliquetis ne sont pas autorisées.|
KNKFASTCOR_vidInitOutput|E|();|FCT1.1|KNKFASTCOR|0|PTS_DOC_5059533||||0|0|0|0|Fonction d'initialisation des sorties du module|
KNKFASTCOR_vidUncertainPhase|B|();|FCT1.7|KNKFASTCOR|0|PTS_DOC_5059533||||0|0|0|0|En cas de phase incertaine (Cipd_phase_calculated_uncertain = 1), la Correction_boucle_rapide est forcée à 0 afin que la correction auto-adaptative, qui est basée sur la Correction_boucle_rapide n’apprenne pas de retrait adaptatif (Av_bmax <> 0).|
KNKINHADP_vidInitCounter|A|();|FCT1.1|KNKINHADP|0|V02 NT 09 02295||||0|0|0|0|Lors du reset du calculateur, la variable Ids_decoll_inhib_cliq_counter est mise à 0|
KNKINHADP_vidUpdateCounter|A|();|FCT1.2|KNKINHADP|0|V02 NT 09 02295||||0|0|0|0|Lorsque l’on détecte un décollage engagé, le compteur Ids_decoll_inhib_cliq_counter est maintenu à sa valeur maximale calibrée. Lorsque l’on n’est plus ou pas en phase de décollage, le compteur est décrémenté|
KNKINSTNOISE_vidCalcInstantNoise|A|();|FCT1.2|KNKINSTNOISE|0|V02 NT 08 05345||||0|0|0|0|Le calcul est inhibé lors du diagnostic du capteur cliquetis, car dans ce mode les fenêtres d'acquisition du bruit  moteur sont différentes de leur valeur en mode détection.|
KNKINSTNOISE_vidFormatInstNoise|F|();|FCT1.3|KNKINSTNOISE|0|V02 NT 08 05345||||0|0|0|0|Le formatage du bruit instantané se fait en deux étapes:  (1) un préformatage statique  (2) une adaptation dynamique permanente|
KNKINSTNOISE_vidInitInstantNoise|A|();|FCT1.1|KNKINSTNOISE|0|V02 NT 08 05345||||0|0|0|0|Le vecteur de Bruit_instantane est initialisé à 0. De cette façon, on s’assure que la valeur du bruit des cylindres non existants vaut 0. (Dans le cas du moteur trois cylindres, Bruit_instantane_cyl4 vaudra toujours 0)|
KNKINSTNOISERBL_vidCyl1KnkNoiFmt|B|();|FCT1.5|KNKINSTNOISERBL|0|V02 NT 10 02580||||0|0|0|0|Static gain noise instant normalizing (cylinder 1 Physics)|
KNKINSTNOISERBL_vidCyl2KnkNoiFmt|B|();|FCT1.6|KNKINSTNOISERBL|0|V02 NT 10 02580||||0|0|0|0|Static gain noise instant normalizing (cylinder 2 Physics)|
KNKINSTNOISERBL_vidCyl3KnkNoiFmt|B|();|FCT1.7|KNKINSTNOISERBL|0|V02 NT 10 02580||||0|0|0|0|Static gain noise instant normalizing (cylinder 3 Physics)|
KNKINSTNOISERBL_vidCyl4KnkNoiFmt|B|();|FCT1.8|KNKINSTNOISERBL|0|V02 NT 10 02580||||0|0|0|0|Static gain noise instant normalizing (cylinder 4 Physics)|
KNKINSTNOISERBL_vidEntryInit|A|();|SCH.1|KNKINSTNOISERBL|1|V02 NT 10 02580||||0|0|0|0|Reset event|
KNKINSTNOISERBL_vidGainStatLdRbl|A|();|FCT1.4|KNKINSTNOISERBL|0|V02 NT 10 02580||||0|0|0|0|The mapping Knk_noi_fmt_map_cylx_uacn2 is evaluated once a pmh|
KNKINSTNOISERBL_vidIfDiagOffRbl|B|();|FCT1.3|KNKINSTNOISERBL|0|V02 NT 10 02580||||0|0|0|0|Calculation of instantaneous noise for each cylinder.|
KNKINSTNOISERBL_vidInitOutput|A|();|FCT1.1|KNKINSTNOISERBL|0|V02 NT 10 02580||||0|0|0|0|Output's initialization|
KNKINSTNOISERBL_vidKnkInstNoiRbl|A|();|FCT1.2|KNKINSTNOISERBL|0|V02 NT 10 02580||||0|0|0|0|The instant noise is calculated on the clanking noise task.|
KnkMvNoiseAdpRbl_vidActivation_condition|D|();|FCT1.3|KNKMVNOISEADPRBL|0|V02 NT 10 02582||||0|0|0|0|The calculation of the adaptive of the clanking noise is authorized only if the average noise is representative of what is measured in normal conditions.|
KnkMvNoiseAdpRbl_vidAdaptation|B|();|FCT1.4|KNKMVNOISEADPRBL|0|V02 NT 10 02582||||0|0|0|0|Calculate an adaptive by cylinder|
KnkMvNoiseAdpRbl_vidCylindre_noi_ad_gain|C|();|FCT1.5|KNKMVNOISEADPRBL|0|V02 NT 10 02582||||0|0|0|0|The adaptive is updated according to the following iteration: Adaptive [ k ] = Adaptive [ k-1 ] + Filter(Leak out) * (Setpoint - AveraigeNoise [k])|
KnkMvNoiseAdpRbl_vidEnable_Adaptation|B|();|FCT1.2|KNKMVNOISEADPRBL|0|V02 NT 10 02582||||0|0|0|0|Manage the adaptation of the average noise if permitted or not then do adaptation action.|
KnkMvNoiseAdpRbl_vidInit_adaptation_knk|B|();|FCT1.1|KNKMVNOISEADPRBL|0|V02 NT 10 02582||||0|0|0|0|Initialize the gain of adaptation to 1.|
KNKNOISEADP_vidActivationCond|D|();|FCT1.3|KNKNOISEADP|0|V02 NT 08 05725||||0|0|0|0|Le calcul de l'adaptatif du bruit cliquetis n'est autorisé que si le bruit moyen est représentatif de ce qui est mesuré en conditions normales. Il faut donc que certaines conditions soient réunies sur le régime, charge, température eau et signal cliquetis|
KNKNOISEADP_vidAdaptation|A|();|FCT1.4|KNKNOISEADP|0|V02 NT 08 05725||||0|0|0|0|On ne calcule l’adaptatif que si les conditions le requièrent (Knk_noi_ad_cdn_ok_uavb0=1) .|
KNKNOISEADP_vidComputeAdapt|D|();|FCT1.5|KNKNOISEADP|0|V02 NT 08 05725||||0|0|0|0|L'adaptatif est mis à jour selon l'itération suivante :  Adaptatif(k) = Adaptatif(k-1) + Gain_filtre × (Consigne - BruitMoyen).|
KNKNOISEADP_vidDiagnostic|D|();|FCT1.6|KNKNOISEADP|0|V02 NT 08 05725||||0|0|0|0|Après une durée calibrable déterminée à compter de l'événement moteur_tournant et sous la condition que la température d'eau soit supérieure à un certain seuil, le diagnostic de l'adaptatif est réalisé à la fréquence SdlSlow.|
KNKNOISEADP_vidDiagResult|A|();|FCT1.8|KNKNOISEADP|0|V02 NT 08 05725||||0|0|0|0|Le résultat du diagnostic est positif lorsque l’adaptatif de l’un des N cylindres est saturé ou diverge vers sa limite. On a alors l’indicateur correspondant qui vaut 1.|
KNKNOISEADP_vidDiagTimer|A|();|FCT1.7|KNKNOISEADP|0|V02 NT 08 05725||||0|0|0|0|Cette attente est nécessaire afin de laisser à l'adaptation le temps de converger avant de commencer le diagnostic.|
KNKNOISEADP_vidInitialization|A|();|FCT1.2|KNKNOISEADP|0|V02 NT 08 05725||||0|0|0|0|On calcule un adaptatif par cylindre. Les variables visualisables sont Knk_noi_ad_gain_cyl1_uavn0 (respectivement _cyl2_, _cyl3_, _cyl4_).|
KNKNOISEADP_vidInitOutput|A|();|FCT1.1|KNKNOISEADP|0|V02 NT 08 05725||||0|0|0|0|Fonction d'initialisation|
KNKRBLACQ_vidInitConfigParam|D|();|FCT1.2|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|Calls the subroutine in charge of initializing the configuration parameters when the knock's rumble acquisition strategy is activated.|
KNKRBLACQ_vidInitOutput|H|();|FCT1.1|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|Initializing component's ouptus.|
KNKRBLACQ_vidRblAcqWinLength|B|();|FCT1.9|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|Compute of the Length of the acquisition window and the Inhibition boolean of the Rumble API.|
KNKRBLACQ_vidRblCalcDetectAuthrz|H|();|FCT1.5|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|To allow the acquisition of the rumble signal, the engine speed must be in an adequate range and the information from the crankshaft sensor reliable. The software phasing is reliable in the case of a 3 cylinder engine.|
KNKRBLACQ_vidRblCalcParameters|E|();|FCT1.7|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|Calls the subroutines configuring the observation window and the band pass filter parameters.|
KNKRBLACQ_vidRblConfigParameters|D|();|FCT1.6|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|The diagnosis request (Knk_sens_diag_dmd_uavb0), sent under condition when diagnosis is needed, is changed into active status (Knk_sens_diag_act_uavb0) when the acquisition is authorized. This allows launching the diagnosis with the disired parameters.|
KNKRBLACQ_vidRblObservtnWindow|H|();|FCT1.8|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|The engine air load is used rather than the collector pressure to set the beginning of the rumble acquisition window. This window has to be applied not too close to the TDC. A correction is applied to compensate the error on the intake VVT angle.|
KNKRBLACQ_vidRblTaskEndTreatment|D|();|FCT1.3|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|First, we make sure that we want to authorize the acquisition of the signal rumble. In that case only, the parameters of acquisition are calculated.|
KNKRBLACQ_vidRblTaskTreatment|D|();|FCT1.4|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|Calls the subroutines in charge of evaluating the activating conditions of the rumble acquisition strategy and calculating its parameters.|
KNKRBLACQ_vidSdlAcqWinLength|B|();|FCT2.7|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|Compute of the Length of the acquisition window and the Inhibition boolean of the Rumble API.|
KNKRBLACQ_vidSdlCalcDetectAuthrz|G|();|FCT2.3|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|To allow the acquisition of the rumble signal, the engine speed must be in an adequate range and the information from the crankshaft sensor reliable. The software phasing is reliable in the case of a 3 cylinder engine.|
KNKRBLACQ_vidSdlCalcParameters|E|();|FCT2.5|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|Calls the subroutines configuring the observation window and the band pass filter parameters in case of a temporal treatment.|
KNKRBLACQ_vidSdlConfigParameters|D|();|FCT2.4|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|The clank sensor diagnosis must be reset if it has been interrupted.|
KNKRBLACQ_vidSdlObservtnWindow|G|();|FCT2.6|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|The lengine air load is used rather than the collector pressure to set the beginning of the rumble acquisition window. This window has to be applied not too close to the TDC. A correction is applied to compensate the error on the intake VVT angle.|
KNKRBLACQ_vidSdlTaskTreatment|D|();|FCT2.2|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|Calls the subroutines in charge of evaluating the activating conditions of the rumble acquisition strategy and calculating its parameters in case of a temporal treatment.|
KNKRBLACQ_vidTemporalTreatment|D|();|FCT2.1|KNKRBLACQ|0|V02 NT 12 02237||||0|0|0|0|The purpose of the temporal treatment is to enable reactivating the rumble acquisition authorization when this has been interrupted. The configuration of the acquisition parameters is nearly the same as in the nominal case.|
KNKSHDCOR_vidComp_corr_dec|B|();|FCT2.7|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|Tous les Knk_deg_cor_dec_delay_uacn1 PMH, on décrémente la correction de Knk_deg_cor_dec_uacn0 °Vil.
KNKSHDCOR_vidCorr_calculate|B|();|FCT1.9|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|La correction d’avance anti-cliquetis est appliquée si dans la fenêtre d’observation, le nombre de « coups de cliquetis » en mode dégradé dépasse un seuil calibrable.
KNKSHDCOR_vidCorr_dec|A|();|FCT2.6|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|Une fois le délai de maintien écoulé, on commence à décrémenter la correction d’avance anti-cliquetis. La décrémentation Knk_deg_cor_dec_uacn0 est alors appliquée avec un délai entre chaque application.
KNKSHDCOR_vidCorr_enable|A|();|FCT2.3|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|Lorsque la correction est de nouveau autorisée (changement de rapport effectué), on filtre celle-ci vers sa dernière valeur avec un filtre de coefficient Knk_deg_cor_in_filt_uacn0.
KNKSHDCOR_vidCorr_inc|A|();|FCT2.4|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|La correction s’incrémente de la valeur de Knk_deg_cor_inc_uacn0 tous les PMB jusqu’à atteindre Knk_deg_cor_offset_uacn0.
KNKSHDCOR_vidCorr_init|A|();|FCT2.1|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|Lorsque le compteur de "coups de cliquetis" dépasse une valeur calibrable, on active la correction palliative de cliquetis et on remet à zéro des paramètres de la détection.
KNKSHDCOR_vidCorr_manage|A|();|FCT1.4|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|La correction d’avance anti-cliquetis est décomposée en deux parties : Gestion des fenêtres d'observation des détections dégradées et Gestion de la correction s'il y a eu un nombre de détections dégradées suffisantes lors de l'observation.
KNKSHDCOR_vidCorr_manager|A|();|FCT1.2|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|Si la stratégie de détection palliative de cliquetis est inhibée, la correction palliative n’a pas lieu d’être activée.
KNKSHDCOR_vidCorrect_palliative|A|();|FCT1.3|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|En cas de sortie de zone critique ou de zone d'autorisation cliquetis, la correction palliative est filtrée vers 0.Lors du retour en zone critique, la correction revient par filtrage à sa valeur lors de la sortie de la zone critique.
KNKSHDCOR_vidDec_win|B|();|FCT1.7|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|comptage du nombres de "coups de cliquetis" pendant la fenêtre d'observation
KNKSHDCOR_vidInit|A|();|FCT1.1|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|Au Reset du calculateur (EveRst), ainsi qu’a l’activation des combustions (EveRTSn), on réinitialise les variables de la stratégie.
KNKSHDCOR_vidInit_win|B|();|FCT1.6|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|Ouvertire de la fenêtre d'observation suite à une détection palliative du premier coup de cliquetis.
KNKSHDCOR_vidKnk_count|B|();|FCT1.8|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|A chaque fois que l’on détecte un « coup de cliquetis » de la stratégie palliative, on incrémente le compteur Knk_deg_det_count_uavn1 du cylindre considéré.
KNKSHDCOR_vidKnk_inc_stop|A|();|FCT2.5|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|Une fois la correction d’avance Knk_deg_cor_offset_uacn0 atteinte, on initialise le délai de maintien.
KNKSHDCOR_vidraz_corr|B|();|FCT1.10|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|Dans les cas hors zone critique, il n'est pas nécessaire d'appliquer une correction dégradée. La correction est alors filtrée vers 0. La fenêtre d’observation et le compteur de "coups de cliquetis" sont remis à zéro.
KNKSHDCOR_vidReset_win|B|();|FCT2.2|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|Lorsqu’une fenêtre se termine, on remet à zero le compteur de "coups de cliquetis".
KNKSHDCOR_vidWin_manage|B|();|FCT1.5|KNKSHDCOR|0|V02 NT 08 07294||||0|0|0|0|Une fois la détection palliative réalisée, on utilise une fenêtre d’observation (en nombre de cycles) pour confirmer ou non la présence de cliquetis.
KNKSHDDET_vidDetection|D|();|FCT1.4|KNKSHDDET|0|PTS_DOC_5145312||||0|0|0|0|Le calcul de la détection doit être effectué APRES le calcul de Somme_cliq_cyl et la  détection de cliquetis et AVANT le rafraîchissement de Autorise_detection_cl.|
KNKSHDDET_vidDetManager|B|();|FCT1.3|KNKSHDDET|0|PTS_DOC_5145312||||0|0|0|0|La détection palliative n’est calculée que si la calibration Knk_deg_manu_inh_uacb0 = 0|
KNKSHDDET_vidInitialization|B|();|FCT1.2|KNKSHDDET|0|PTS_DOC_5145312||||0|0|0|0|Au Reset du calculateur (EveRst), ainsi qu’a l’activation des combustions (EveRTSn), on réinitialise les variables suivantes : Knk_deg_det_cur_uavb1 et Knk_deg_det_uavb1|
KNKSHDDET_vidInitOutput|B|();|FCT1.1|KNKSHDDET|0|PTS_DOC_5145312||||0|0|0|0|Fonction d'initialisation|
KnkTreat_EveBDC_RblCritZone|A|();|SCH.4|RBLCRITZONE|1|V02 NT 12 00518||||0|0|0|0|Interruption PMB|
KnkTreat_EveCkSnOf_KnkAcq|C|();|SCH.6|KNKACQ|1|PTS_DOC_5066621||||0|0|0|0|Evénement d'appel de tâche "synchro perdue" du CMM.|
KnkTreat_EveCkSnOf_KnkRblAcq|D|();|SCH.6|KNKRBLACQ|1|V02 NT 12 02237||||0|0|0|0|Event corresponding to the loss of synchronisation|
KnkTreat_EveCkSnOn_InstNoise|A|();|SCH.2|KNKINSTNOISE|1|V02 NT 08 05345||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise|
KnkTreat_EveCkSnOn_KnkAcq|C|();|SCH.3|KNKACQ|1|PTS_DOC_5066621||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise|
KnkTreat_EveCkSnOn_KnkAcqFilt|F|();|SCH.5|KNKACQFILT|1|PTS_DOC_5066552||||0|0|0|0|Traitement temporel pour lancer le premier évènement Knk|
KnkTreat_EveCkSnOn_KnkDet|B|();|SCH.3|KNKDET|1|PTS_DOC_5068282||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise|
KnkTreat_EveCkSnOn_KnkDetRbl|E|();|SCH.2|KNKDETRBL|1|PTS_DOC_5068340||||0|0|0|0|Tache tournant synchro (démarrage, calage perte de synchro)|
KnkTreat_EveCkSnOn_KnkRblAcq|E|();|SCH.3|KNKRBLACQ|1|V02 NT 12 02237||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise|
KnkTreat_EveCkSnOn_ShdDet|B|();|SCH.2|KNKSHDDET|1|PTS_DOC_5145312||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise|
KnkTreat_EveCrTR_RblCritZone|A|();|SCH.2|RBLCRITZONE|1|V02 NT 12 00518||||0|0|0|0|Evénement CRANKING vers RUNNING|
KnkTreat_EveKnk_BenchMod|A|();|SCH.2|KNKBENCHMOD|1|V02 NT 09 00486||||0|0|0|0|Tâche de calcul du niveau de cliquetis pour le cylindre en cours
KnkTreat_EveKnk_InstNoise|A|();|SCH.3|KNKINSTNOISE|1|V02 NT 08 05345||||0|0|0|0|Tâche de calcul du niveau de cliquetis pour le cylindre en cours|
KnkTreat_EveKnk_KnkAcqFiltFst|E|();|SCH.2|KNKACQFILT|1|PTS_DOC_5066552||||0|0|0|0|Tâche de calcul du niveau de cliquetis pour le cylindre en cours.|
KnkTreat_EveKnk_KnkAcqFiltLst|F|();|SCH.3|KNKACQFILT|1|PTS_DOC_5066552||||0|0|0|0|Tâche de calcul du niveau de cliquetis pour le cylindre en cours.|
KnkTreat_EveKnk_KnkAcqLst|C|();|SCH.2|KNKACQ|1|PTS_DOC_5066621||||0|0|0|0|Tâche de calcul du niveau de cliquetis pour le cylindre en cours.|
KnkTreat_EveKnk_KnkDet|C|();|SCH.2|KNKDET|1|PTS_DOC_5068282||||0|0|0|0|Tâche de calcul du niveau de cliquetis pour le cylindre en cours.|
KnkTreat_EveKnk_KnkDiag|C|();|SCH.2|KNKDIAG|1|PTS_DOC_5307525||||0|0|0|0|Tâche de cacul du niveau de cliquetis pour le cylindre en cours.|
KnkTreat_EveKnk_NoiseAdp|A|();|SCH.2|KNKNOISEADP|1|V02 NT 08 05725||||0|0|0|0|Tâche de calcul du niveau de cliquetis pour le cylindre en cours|
KnkTreat_EveKnk_ShdDet|B|();|SCH.3|KNKSHDDET|1|PTS_DOC_5145312||||0|0|0|0|Tâche de calcul du niveau de cliquetis pour le cylindre en cours.|
KnkTreat_EveRbl_KnkDetRbl|F|();|SCH.3|KNKDETRBL|1|PTS_DOC_5068340||||0|0|0|0|Tâche rumble|
KnkTreat_EveRbl_KnkInstNoiseRbl|B|();|SCH.2|KNKINSTNOISERBL|1|V02 NT 10 02580||||0|0|0|0|Task computing for the cylinder being.|
KnkTreat_EveRbl_KnkMgrCorRblIf|D|();|SCH17.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Tache rumble.|
KnkTreat_EveRbl_KnkMvNoiseAdpRbl|B|();|SCH.2|KNKMVNOISEADPRBL|1|V02 NT 10 02582||||0|0|0|0|Tâche de calcul rumble|
KnkTreat_EveRbl_KnkRblAcqLst|E|();|SCH.4|KNKRBLACQ|1|V02 NT 12 02237||||0|0|0|0|Tâche de calcul du niveau de rumble pour le cylindre en cours.|
KnkTreat_EveRbl_RblDetBench|B|();|SCH.2|RBLDETBENCH|1|V02 NT 11 02549||||0|0|0|0|Tâche Rumble pour le mode banc détection.|
KnkTreat_EveRst_InstNoise|A|();|SCH.1|KNKINSTNOISE|1|V02 NT 08 05345||||0|0|0|0|Evénement reset du calculateur|
KnkTreat_EveRst_KnkAcq|C|();|SCH.1|KNKACQ|1|PTS_DOC_5066621||||0|0|0|0|Evénement reset du calculateur|
KnkTreat_EveRst_KnkAcqFilt|E|();|SCH.1|KNKACQFILT|1|PTS_DOC_5066552||||0|0|0|0|Evénement reset du calculateur.|
KnkTreat_EveRst_KnkDet|B|();|SCH.1|KNKDET|1|PTS_DOC_5068282||||0|0|0|0|Evénement reset du calculateur|
KnkTreat_EveRst_KnkDetRbl|G|();|SCH.1|KNKDETRBL|1|PTS_DOC_5068340||||0|0|0|0|tache reset|
KnkTreat_EveRst_KnkMgrCorRblIf|C|();|SCH2.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement reset du calculateur|
KnkTreat_EveRst_KnkRblAcq|E|();|SCH.1|KNKRBLACQ|1|V02 NT 12 02237||||0|0|0|0|Evénement reset du calculateur|
KnkTreat_EveRst_NoiseAdp|A|();|SCH.1|KNKNOISEADP|1|V02 NT 08 05725||||0|0|0|0|Evénement reset du calculateur|
KnkTreat_EveRst_RblCritZone|A|();|SCH.1|RBLCRITZONE|1|V02 NT 12 00518||||0|0|0|0|Evénement reset du calculateur|
KnkTreat_EveRst_ShdDet|B|();|SCH.1|KNKSHDDET|1|PTS_DOC_5145312||||0|0|0|0|Evénement reset du calculateur|
KnkTreat_EveRTCr_RblCritZone|A|();|SCH.3|RBLCRITZONE|1|V02 NT 12 00518||||0|0|0|0|Evénement RUNNING vers CRANKING|
KnkTreat_EveRTSt_KnkAcq|C|();|SCH.5|KNKACQ|1|PTS_DOC_5066621||||0|0|0|0|Fonction d'accroche à l'événement correspondant au passage à 0 de la variable Moteur_tournant|
KnkTreat_EveRTSt_KnkRblAcq|E|();|SCH.5|KNKRBLACQ|1|V02 NT 12 02237||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant|
KnkTreat_EveStTR_KnkMvNoisAdpRbl|B|();|SCH.1|KNKMVNOISEADPRBL|1|V02 NT 10 02582||||0|0|0|0|Evénement calé tournant.|
KnkTreat_SdlFast_KnkAcq|C|();|SCH.4|KNKACQ|1|PTS_DOC_5066621||||0|0|0|0|Moniteur Rapide .|
KnkTreat_SdlFast_KnkAcqFilt|F|();|SCH.4|KNKACQFILT|1|PTS_DOC_5066552||||0|0|0|0|Traitement temporel pour lancer le premier évènement Knk.|
KnkTreat_SdlFast_KnkDet|A|();|SCH.6|KNKDET|1|PTS_DOC_5068282||||0|0|0|0|Moniteur rapide KnkTreat|
KnkTreat_SdlFast_KnkRblAcq|E|();|SCH.2|KNKRBLACQ|1|V02 NT 12 02237||||0|0|0|0|Moniteur Rapide|
KnkTreat_SdlMid_KnkDet|B|();|SCH.4|KNKDET|1|PTS_DOC_5068282||||0|0|0|0|Moniteur moyen|
KnkTreat_SdlMid_KnkDetRbl|F|();|SCH.5|KNKDETRBL|1|PTS_DOC_5068340||||0|0|0|0|Moniteur moyen|
KnkTreat_SdlSlow_KnkDet|B|();|SCH.5|KNKDET|1|PTS_DOC_5068282||||0|0|0|0|Moniteur lent|
KnkTreat_SdlSlow_KnkDetRbl|F|();|SCH.4|KNKDETRBL|1|PTS_DOC_5068340||||0|0|0|0|Moniteur lent|
KnkTreat_SdlSlow_NoiseAdp|A|();|SCH.3|KNKNOISEADP|1|V02 NT 08 05725||||0|0|0|0|Moniteur lent|
KNWHAL_udtSamplingWinTrigger|D|func_KNWHAL_udtSamplingWinTrigger|0x05|HEADER|1|NONE||||0|0|0|0||
KNWHAL_udtSetSamplingWinPrms|D|func_KNWHAL_udtSetSamplWinPrms|0x06|HEADER|1|NONE||||0|0|0|0||
KNWHAL_udtWriteInputStageGain|A|func_KNWHAL_udtWriteInputStageGain|0x01|HEADER|1|NONE||||0|0|0|0||
KNWHAL_vidSetSampleTblPrms|D|(argio uint16 *pau16SampleTbl,argin uint32 u32SampleTblMaxSize);|0x04|HEADER|1|NONE||||0|0|0|0||
KNWHAL_vidSetSamplingWinIdxTbl|D|(argio uint32 *pau32SamplingWinIdxTbl);|0x02|HEADER|1|NONE||||0|0|0|0||
KNWHAL_vidWriteAntiAliasingFreq|D|(argin uint16 u16Frequency);|0x01|HEADER|1|NONE||||0|0|0|0||
KNWHAL_vidWriteSamplePeriod|D|(argin uint16 u16SamplePeriod);|0x03|HEADER|1|NONE||||0|0|0|0||
LAMCLMPD_vidInitIndicRichActobd|A|();|FCT1.1|LAMCLMPD|0|V02 NT 09 02030||||0|0|0|0|Fonction qui permet l'initialisation Indicateur de Lambda_feeback en butée basse (mélange riche) et Haute (mélange pauvre).
LAMCLMPD_vidRichCalcIndicators|A|();|FCT1.2|LAMCLMPD|0|V02 NT 09 02030||||0|0|0|0|Fonction qui détermine les indicateurs de richesse.
LAYERSYNC_vidAcq|A|();|FCT2.4|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Afin de délivrer des informations pertinentes et d’économiser de la charge CPU, les booléens d’états et leur flag de validité ne sont acquis que si le capteur arbre à cames admission est présent sur le moteur.
LAYERSYNC_vidAcqExPos|A|();|FCT4.5|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet l'acquisition de l'angle du vilbrequin, la période entre les dents ainsi que l'état du front AAC échappement
LAYERSYNC_vidAcqInPos|A|();|FCT4.6|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet l'acquisition de l'angle du vilbrequin, la période entre les dents ainsi que l'état du front AAC admission
LAYERSYNC_vidAcquiDureeDent|A|();|FCT1.2|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|La durée dent est désormais également calculée sur la tâche calé tournant (Event_tache_cale_tournant)
LAYERSYNC_vidAcquiPeriodeMoteur|A|();|FCT1.3|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet l'aquisition de la période du moteur
LAYERSYNC_vidBwdRotMng|A|();|FCT2.9|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|On autorise la rotation du moteur en sens inverse jusqu’à  un seuil de régime défini par Sync_nEngEnaBwdRotThd_C. Si le régime dépasse ce seuil on appelle alors l’API qui permet de désactiver la rotation en sens inverse.
LAYERSYNC_vidCallAPI|A|();|FCT2.6|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Au reset du calculateur on  fournit  la valeur de régime (Sync_AcvAgEng_C) en dessous duquel la tache CRKHAL_TOOTH_EVENT sera produite.
LAYERSYNC_vidChangeOfMind|A|();|FCT3.7|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet la lecture de ll'état de a position angulaire du moteur sur l’évènement N_Inv_Off.
LAYERSYNC_vidCkOff|A|();|FCT4.1|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Lors de la perte de la synchronisation par le LDB,  ou lors d’un arrêt moteur, sur l’événement Crank Off, on réinitialise SyncAcq_bCalcOk.
LAYERSYNC_vidCtEdgeCmExRstrt|A|();|FCT3.9|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet la lecture de la position angulaire du front AAC échappement
LAYERSYNC_vidCtEdgeCmExStrt|A|();|FCT3.6|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet la lecture de la position angulaire du front AAC échappement
LAYERSYNC_vidCtEdgeCmInRstrt|A|();|FCT3.8|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet la lecture de la position angulaire du front AAC admission.
LAYERSYNC_vidCtEdgeCmInStrt|A|();|FCT3.5|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet la lecture de la position angulaire du front AAC admission.
LAYERSYNC_vidDiagExCm|A|();|FCT1.6|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction responsable du diagnostic.
LAYERSYNC_vidDiagInCm|A|();|FCT2.1|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction responsable du diagnostic.
LAYERSYNC_vidDisBwdRot|A|();|FCT2.10|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|API qui permet de désactiver la rotation en sens inverse.
LAYERSYNC_vidDisQuickSync|A|();|FCT2.8|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|API d’interdiction de synchronisation rapide
LAYERSYNC_vidEnaBwdRot|A|();|FCT3.1|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|API qui autorise la rotation du moteur en sens inverse.
LAYERSYNC_vidEnaQuickSync|A|();|FCT2.7|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|API d’autorisation de synchronisation rapide
LAYERSYNC_vidEngStopPosn|A|();|FCT3.10|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet d'effectuer la lecture de l’API donnant la position  d’arrêt moteur calculée.
LAYERSYNC_vidEngStopPosnAfter|A|();|FCT3.3|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Lors de la détection de la singularité du signal vilebrequin on effectue la lecture de l’API donnant la position d’arrêt du moteur calculée à posteriori.
LAYERSYNC_vidExAcq|A|();|FCT1.9|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Afin de délivrer des informations pertinentes et d’économiser de la charge CPU, les booléens d’états et leurflag de validité ne sont acquis que si le capteur arbre à cames echappement est présent sur le moteur.
LAYERSYNC_vidExCmSt|A|();|FCT1.10|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction de diagnostique du  signal arbre à cames echappement.
LAYERSYNC_vidInCmSt|B|();|FCT2.5|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Ce bloc permet le diagnostic du signal arbre à cames admission
LAYERSYNC_vidIniAcq|A|();|FCT2.2|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Au réveil du calculateur, les booléens d’états et leur indicateur de validité sont forcés à 0
LAYERSYNC_vidIniExAcq|A|();|FCT1.7|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Au réveil du calculateur, les booléens d’états et leur  indicateur de validité sont forcés à 0.
LAYERSYNC_vidIniExAcqPos|A|();|FCT4.3|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction pour le reset du calculateur
LAYERSYNC_vidIniExCmAcq|A|();|FCT1.8|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction d'initialisation de L'API CAMHAL
LAYERSYNC_vidIniInAcqPos|A|();|FCT4.4|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction pour la  reset du calculateur
LAYERSYNC_vidIniInCmAcq|A|();|FCT2.3|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction d'initialisation de L'API CAMHAL
LAYERSYNC_vidInit|A|();|FCT4.2|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet l'initialisation des outputs
LAYERSYNC_vidInitAPI|A|();|FCT1.1|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|L’autorisation de recherche de détection de front du signal vilebrequin se fait uniquement après que les tests  fonctionnels aient été effectués.
LAYERSYNC_vidIniTDCCnt|A|();|FCT3.2|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet la lecture de la position angulaire du moteur lors de la synchronisation moteur.
LAYERSYNC_vidInitOutput|A|();|FCT4.7|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet l'initialisation des sorties
LAYERSYNC_vidPhaseCylEch|A|();|FCT1.5|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet l'acquisition de l'angle du crankshaft
LAYERSYNC_vidReadToothInfo|A|();|FCT3.4|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction de lecture des variables de synchronisation provenant du LdB.
LAYERSYNC_vidTrouverPhaseMoteur|A|();|FCT1.4|LAYERSYNC|0|PTS_DOC_6944973||||0|0|0|0|Fonction qui permet l'acquisition de la valeur du compteur PMH
LIHCHK_vidDeterminer_Limitation|C|();|FCT1.3|LIHCHK|0|V02 NT 10 01261||||0|1|0|0|Cette fonction génère deux informations : une première information, indique si une limitation de régime est en cours , la deuxième détermine le niveau de limitation|
LIHCHK_vidEntryInit|C|();|SCH.1|LIHCHK|1|V02 NT 10 01261||||0|0|0|0|évènement reset du calculateur.|
LIHCHK_vidInitOutput|C|();|FCT1.1|LIHCHK|0|V02 NT 10 01261||||0|0|0|0|initialisation des sorties.|
LIHCHK_vidValider_Limitation|C|();|FCT1.4|LIHCHK|0|V02 NT 10 01261||||0|1|0|0|Cette fonction vérifie que le régime reste inférieur à la limitation plus un seuil.|
LIHCHK_vidValider_Limp_Home|C|();|FCT1.2|LIHCHK|0|V02 NT 10 01261||||0|1|0|0|Cette fonction sécurise l’application des limitations de régime qui sont demandées dans certains modes dégradés moteur.|
Lin_EveRst_IsLinIf|D|();|SCH17.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reset.|
Lin_Init|A|(uint16 *Config);|13|HEADER|1|NONE||||0|0|0|0|
Lin_SdlFast_IsLinIf|B|();|SCH9.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide de la fonction LIN|
LinIf_Init|A|(uint16 *pu16Lin);|14|HEADER|1|NONE||||0|0|0|0|
LinSM_Init|A|();|15|HEADER|1|NONE||||0|0|0|0|
LinSM_ScheduleRequest|A|(uint8 u8ComMChannel, boolean bEna);|20|HEADER|1|NONE||||0|0|0|0|
MATHSRV_u16CalcParaIncAryU16|A|(argin const uint16 kau16BreakpointMap[], argin uint16 u16Value, argin uint8  u8BreakpointNumber);|0x01|HEADER|1|V01 NT 08 02127||||0|0|0|1||
MATHSRV_u16FirstOrderFilterGu8|A|(argin uint8  u8FilterGain,argout uint32 * pu32AccuracyFilterValue,argin uint16 u16MeasuredValue, argret uint16);|0x11|HEADER|1|V01 NT 08 02127||||0|0|0|1||
MATHSRV_u16Interp1d|A|( argin const uint16 kau16Cartography[], argin uint16 u16SiteInterpolation, argret uint16);|0x03|HEADER|1|V01 NT 08 02127||||0|0|0|1||
MATHSRV_u16Interp2d|A|(argin uint16 * pkau16Cartography, argin uint16  u16SiteInterpolationXLine, argin uint16  u16SiteInterpolationYColumn, argin uint8   u8BreakpointNumberYColumn, argret uint16);|0x07|HEADER|1|V01 NT 08 02127||||0|0|0|1||
MATHSRV_udtABS|A|();|0x13|HEADER|1|V01 NT 08 02127||||0|0|0|1||
MATHSRV_udtCLAMP|A|();|0x16|HEADER|1|V01 NT 08 02127||||0|0|0|1||
MATHSRV_udtMAX|A|();|0x15|HEADER|1|V01 NT 08 02127||||0|0|0|1||
MATHSRV_udtMIN|A|();|0x14|HEADER|1|V01 NT 08 02127||||0|0|0|1||
MATHSRV_vidSchmittTriggerU16|A|(argin uint16 u16InputValue,argin uint16 u16HysteresisLowThreshold,argin uint16 u16HysteresisHighTreshold, argin MATHSRV_tenuSchmittTriggerType tenuSchmittTriggerType,argout uint8 * u8OutputValue);|0x02|HEADER|1|V01 NT 08 02127||||0|0|0|1||
MCWDG_bfReadMcwFaultState|A|func_MCWDG_bfReadMcwFaultState|9|HEADER|1|NONE||||0|0|0|0||
MCWDG_bReadInhibitState|B|func_MCWDG_bReadInhibitState|2|HEADER|1|NONE||||0|0|0|0||
MCWDG_vidForceInhibit|A|();|3|HEADER|1|NONE||||0|0|0|0||
MCWDG_vidFunctionalTestExchange|A|(argin Std_ReturnType stdTestStatus);|2|HEADER|1|NONE||||0|0|0|0|Main API FunctionalTestExchange|
MCWDG_vidInhibitDisableRequest|A|();|4|HEADER|1|NONE||||0|0|0|0||
MCWDG_vidResumeSampleCheck|A|();|4|HEADER|1|NONE||||0|0|0|0||
MCWDG_vidStartInhibitState|A|(argin uint8 u8McwInhPin);|0x07|HEADER|1|NONE||||0|0|0|0||
MCWDG_vidStopInhibitState|A|(argin uint8 u8McwInhPin);|0x08|HEADER|1|NONE||||0|0|0|0||
MCWDG_vidWriteMcpFaultState|A|(uint8 bfFaultMask );|6|HEADER|1|NONE||||0|0|0|0||
MEAP_EveRst_ActrTstMEAP|A|();|SCH.1|ACTRTSTMEAP|1|V02 NT 12 05332||||0|0|0|0|ECU reset event|
MEAP_SdlMid_ActrTstMEAP|A|();|SCH.2|ACTRTSTMEAP|1|V02 NT 12 05332||||0|0|0|0|Middle monitoring of MEAP function|
MEM_vidClasFrfInit|B|(argin uint16 u16IdxDft, argin uint32* au32Frf);|1|HEADER|1|HEADER||||0|0|0|0||
MEM_vidF01_DTCRec|G|();|FCT1.02|MEM|0|PTS_DOC_5447179||||0|0|0|0|Tant que le compteur de défauts unitaires apparus successivement n’a pas atteint sa valeur maximale et que la classe de calibration associée l’autorise, le DTC du défaut concerné monte à sa valeur générique associé, autrement il prend la valeur 0xFFFF.|
MEM_vidF01_FrzData|I|(argin uint16 u16IdxDft);|FCT1.03|MEM|0|PTS_DOC_5447179||||0|0|0|0|Cette fonction permet de figer de manière temporaire (uniquement en RAM) les paramètres constituants la Freeze frame et ce, quelque soit le défaut (à condition que la classe associé l’autorise).|
MEM_vidF01_Init|H|();|FCT1.01|MEM|0|PTS_DOC_5447179||||0|0|0|0|Effacement de tous les DTC|
MEM_vidF02_StoreDataFrf|G|(argin uint16 u16IdxDft);|FCT1.04|MEM|0|PTS_DOC_5447179||||0|0|0|0|Enregistrement des données suivant le rang|
MEM_vidF04_RstnoRnkFrf|I|(argin uint16 u16IdxDft);|FCT1.05|MEM|0|PTS_DOC_5447179||||0|0|0|0|Libération du contexte anciennement associé au défaut et effacement du rang de Freeze Frame du défaut concerné|
MEM_vidF04_StoreFrfObd|G|(argin uint16 u16IdxDft);|FCT1.08|MEM|0|PTS_DOC_5447179||||0|0|0|0|Fonction appelée sur événement CALL_StObdRecTypCc_NameVar|
MEM_vidF06_RstDftMng|H|();|FCT1.06|MEM|0|PTS_DOC_5447179||||0|0|0|0|Effacement des défauts standards|
MEM_vidF07_RstDftObdMng|H|();|FCT1.07|MEM|0|PTS_DOC_5447179||||0|0|0|0|Effacement des défauts OBD|
MEM_vidF08_StoreData|F|();|FCT1.09|MEM|0|PTS_DOC_5447179||||0|0|0|0|Enregistrement à la volée sur Eeprom|
MEM_vidMngEveCDThUp|C|(argin uint16 u16IdxDft);|API.05|MEM|1|PTS_DOC_5447179||||0|0|0|0|Evenement GDU notifiant le franchissement du seuil|
MEM_vidMngEveCDThUp_opt|A|(argin sint32 s32IdxDft);|1|HEADER|1|HEADER||||0|0|0|0|header|
MEM_vidMngEveDftClr|F|(argin uint16 u16IdxDft);|API.02|MEM|1|PTS_DOC_5447179||||0|0|0|0|Evenement effacement des paramètres défauts enregistrés|
MEM_vidMngEveDftUnval|A|(argin uint16 u16IdxDft);|1|HEADER|1|HEADER||||0|0|0|0|Evènement entrée de l'automate GDU dans l'état GDU_ST_FUGITIF|
MEM_vidMngEveDtcClr|A|(argin uint16 u16IdxDft);|1|HEADER|1|NONE||||0|0|0|0||
MEM_vidMngEveFrfRec|C|(argin uint16 u16IdxDft);|API.04|MEM|1|PTS_DOC_5447179||||0|0|0|0|Evènement moment de mémorisation de la Freeze Frame|
MEM_vidMngEveFrfRec_opt|A|(argin sint32 s32IdxDft);|1|HEADER|1|HEADER||||0|0|0|0|header|
MEM_vidMngEveInit|B|();|API.01|MEM|1|PTS_DOC_5447179||||0|0|0|0|Effacement de tous les DTC|
MEM_vidMngEveKeyOn|F|();|SCH.01|MEM|1|PTS_DOC_5447179||||0|0|0|0|Evénement clé ON / OFF ou réveil principal de l'ECU|
MEM_vidMngEveRstDft|B|();|SCH.03|MEM|1|PTS_DOC_5447179||||0|0|0|0|Requête d'effacement des défauts avec l'outil APV|
MEM_vidMngEveRstDftCal|C|();|API.03|MEM|1|PTS_DOC_5447179||||0|0|0|0|Demande d'effacement Manuel des défauts|
MEM_vidMngEveRstDftObd|C|();|SCH.02|MEM|1|PTS_DOC_5447179||||0|0|0|0|Demande d'effacement des défauts OBD par le ScanTool|
MEM_vidMngEveStObdRec|B|(argin uint16 u16IdxDft);|API.06|MEM|1|PTS_DOC_5447179||||0|0|0|0|Evènement entrée du Gestionnaire OBD dans l'état GOBD_ST_ENREGISTRE|
MEM_vidMngEveStPres|A|(argin uint16 u16IdxDft);|1|HEADER|1|HEADER||||0|0|0|0|header|
MEMSRV_vidSetU8|A|(argio uint8 *pu8Dest, argin uint8 u8Value, argin uint16 u16ElementNumber);|3|HEADER|1|NONE||||0|0|0|0||
Misf_EveCkSnOf_MisfWinAcq|A|();|SCH.4|MISFWINACQ|1|V02 NT 09 05081||||0|0|0|0|Evénement d'appel de tâche "synchro perdue" du CMM (à la perte de synchro et au calage)|
Misf_EveCkSnOn_MisfWinAcq|A|();|SCH.2|MISFWINACQ|1|V02 NT 09 05081||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise|
Misf_EveCrTR_AvrMisfCnt|A|();|SCH.4|AVRMISFCNT|1|V02 NT 11 05583||||0|0|0|0|Event CRANK To RUN for misfire function|
Misf_EveKOf_AvrMisfCnt|B|();|SCH.3|AVRMISFCNT|1|V02 NT 11 05583||||0|0|0|0|Event key On_Off|
Misf_EveMisf_AvrMisfCnt|B|();|SCH.2|AVRMISFCNT|1|V02 NT 11 05583||||0|0|0|0|Software Interruption event of the misfire acquisition window end.|
Misf_EveMisf_MisfDet|C|();|SCH.2|MISFDET|1|PTS_DOC_5158467||||0|0|0|0|Evènement lié à l'interruption logicielle de fin d'acquisition de la fenêtre misfire|
Misf_EveMisf_MisfDetCfm|B|();|SCH.2|MISFDETCFM|1|PTS_DOC_5198655||||0|0|0|0|Evènement lié à l'interruption logicielle de fin d'acquisition de la fenêtre misfire|
Misf_EveMisf_MisfDetCfmIf|E|();|SCH13.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement lié à l'interruption logicielle de fin d'acquisition de la fenêtre misfire.|
Misf_EveMisf_MisfDetIdle|A|();|SCH.2|MISFDETIDLE|1|PTS_DOC_5198626||||0|0|0|0|Evènement reset calculateur|
Misf_EveMisf_MisfDftLrn|L|();|SCH.3|MISFDFTLRN|1|PTS_DOC_5069555||||0|0|0|0|Evènement lié à l'interruption logicielle de fin d'acquisition de la fenêtre misfire.|
Misf_EveMisf_MisfDiagStabCdn|B|();|SCH.3|MISFDIAGSTABCDN|1|PTS_DOC_5577717||||0|0|0|0|Evènement lié à l'interruption logicielle de fin d'acquisition de la fenêtre misfire|
Misf_EveMisf_MisfFaiCtr|E|();|SCH.2|MISFFAICTR|1|PTS_DOC_5069596||||0|0|0|0|Evènement lié à l'interruption logicielle de fin d'acquisition de la fenêtre misfire.|
Misf_EveMisf_MisfRoughnsRoad|A|();|SCH.2|MISFROUGHNSROAD|1|V02 NT 09 02692||||0|0|0|0|Evènement lié à l'interruption logicielle de fin d'acquisition de la fenêtre misfire.|
Misf_EveMisf_MisfSucDet|B|();|SCH.2|MISFSUCDET|1|PTS_DOC_5198660||||0|0|0|0|Evènement lié à l'interruption logicielle de fin d'acquisition de la fenêtre misfire|
Misf_EveMisf_MisfSucDetIdle|A|();|SCH.2|MISFSUCDETIDLE|1|PTS_DOC_5198644||||0|0|0|0|Evènement lié à l'interruption logicielle de fin d'acquisition de la fenêtre misfire.|
Misf_EveMisf_MisfWinAcq|A|();|SCH.5|MISFWINACQ|1|V02 NT 09 05081||||0|0|0|0|événement misfire pour la stratégie d'acquisition des fenêtres|
Misf_EveMisf_MisfWinAdp|A|();|SCH.2|MISFWINADP|1|V02 NT 09 00776||||0|0|0|0|Evènement lié à l'interruption logicielle de fin d'acquisition de la fenêtre misfire.
Misf_EveRst_AvrMisfCnt|B|();|SCH.1|AVRMISFCNT|1|V02 NT 11 05583||||0|0|0|0|ECU Reset event|
Misf_EveRst_MisfDetIdle|A|();|SCH.1|MISFDETIDLE|1|PTS_DOC_5198626||||0|0|0|0|Evènement de reset calculateur|
Misf_EveRst_MisfDftLrn|G|();|SCH.1|MISFDFTLRN|1|PTS_DOC_5069555||||0|0|0|0|Evènement Reset du calculateur|
Misf_EveRst_MisfDiagStabCdn|C|();|SCH.1|MISFDIAGSTABCDN|1|PTS_DOC_5577717||||0|0|0|0|Evènement lié au reset du calculateur|
Misf_EveRst_MisfFaiCtr|C|();|SCH.1|MISFFAICTR|1|PTS_DOC_5069596||||0|0|0|0|Evénement reset du calculateur.|
Misf_EveRst_MisfSucDetIdle|A|();|SCH.1|MISFSUCDETIDLE|1|PTS_DOC_5198644||||0|0|0|0|Evènement reset calculateur|
Misf_EveRst_MisfWinAcq|A|();|SCH.1|MISFWINACQ|1|V02 NT 09 05081||||0|0|0|0|événement Reset pour la stratégie d'acquisition des fenêtres|
Misf_EveRstDftObd_AvrMisfCnt|A|();|SCH.5|AVRMISFCNT|1|V02 NT 11 05583||||0|0|0|0|Event reset of defaults by the "mode 04"|
Misf_EveRstLrn_MisfDftLrn|A|();|SCH.4|MISFDFTLRN|1|PTS_DOC_5069555||||0|0|0|0|Evènement Reset adaptatifs Misfire|
Misf_SdlFast_MisfRoughnsRoadCan|B|();|SCH.2|MISFROUGHNSROADCAN|1|V02 NT 09 01896||||0|0|0|0|Moniteur rapide pour la fonction Misfire.
Misf_SdlFast_MisfWinAcq|A|();|SCH.3|MISFWINACQ|1|V02 NT 09 05081||||0|0|0|0|Moniteur rapide pour la fonction Misfire|
Misf_SdlMid_MisfDiagStabCdn|C|();|SCH.2|MISFDIAGSTABCDN|1|PTS_DOC_5577717||||0|0|0|0|Moniteur moyen pour la fonction misfire|
Misf_SdlSlow_MisfDftLrn|I|();|SCH.2|MISFDFTLRN|1|PTS_DOC_5069555||||0|0|0|0|Moniteur lent de la fonction Misf|
Misf_SdlSlow_MisfDftLrnOut|A|();|SCH.2|MISFDFTLRNOUT|1|V02 NT 09 00762||||0|0|0|0|Fonction d'accroche au moniteur lent de la fonction Misf.|
Misf_SdlSlow_MisfFaiCtr|B|();|SCH.3|MISFFAICTR|1|PTS_DOC_5069596||||0|0|0|0|Moniteur lent de la fonction MisfFaiCtr.|
MISFDET_vidAlgoConTempo|B|();|FCT2.9|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Ce bloc vérifie si les conditions de stabilité sont vérifiées pour que la stratégie de détection puisse être activée.|
MISFDET_vidAlgoDetCalc|B|();|FCT1.4|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Ce bloc est actif dès lors que les conditions de stabilité et d’autres portant sur divers paramètres sont vérifiées, le booléen Mf_algo_cond_ok_uavb0 étant alors à 1|
MISFDET_vidAlgoOutput|B|();|FCT1.7|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Ce bloc gère la stratégie de détection par l’algorithme combustion selon le régime et la stratégie de détection par l’algorithme P filtre|
MISFDET_vidCalcHalfRev|A|();|FCT2.1|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Le calcul d’une durée moyenne des 4 derniers demi-tours moteur pour un moteur 4 cylindres, 3 derniers demitours moteur pour un moteur 3 cylindres|
MISFDET_vidCombAlgo|B|();|FCT1.6|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Ce bloc calcule la sortie de l’algorithme « combustion », ainsi que l’erreur introduite par les défauts géométriques de la cible régime moteur|
MISFDET_vidCombAlgoThresh|D|();|FCT2.3|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Calcul du seuil de l’algorithme combustion (dépend du couple indiqué et du régime)|
MISFDET_vidCombDet|A|();|FCT2.2|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Calcul de l'indice de confiance en la détection de misfire par l'algorithme combustion|
MISFDET_vidCondGlobalStab|A|();|FCT2.6|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Ce bloc vérifie si les conditions de fonctionnement globales sont vérifiées pour que la stratégie de détection puisse être activée.|
MISFDET_vidCondStabIdle|A|();|FCT2.8|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Ce bloc vérifie si les conditions de fonctionnement spécifiques pour l’algorithme ralenti sont vérifiées pour que la stratégie de détection puisse être activée.|
MISFDET_vidCondStabNormal|A|();|FCT2.7|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Ce bloc vérifie si les conditions de fonctionnement spécifiques pour l’algorithme hors ralenti sont vérifiées pour que la stratégie de détection puisse être activée.|
MISFDET_vidEntryInit|C|();|SCH.1|MISFDET|1|PTS_DOC_5158467||||0|0|0|0|Evènement reset du calculateur|
MISFDET_vidInitOutput|C|();|FCT1.1|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Initialisation des sorties|
MISFDET_vidMisfDet|C|();|FCT1.2|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Les sorties des algorithmes seront calculés dans le cas où les conditions de détection de misfire sont ok ou dans le cas où les conditions d’apprentissage de l’algorithme combustion sont ok|
MISFDET_vidMisfStabCond|I|();|FCT1.3|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Ce bloc vérifie si les conditions de fonctionnement(Tp eau, Tp air, régime, CMI, vitesse véhicule...) et de stabilité sont vérifiées pour que la stratégie de détection puisse être activée|
MISFDET_vidPfiltAlgo|C|();|FCT1.5|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Ce bloc calcul la sortie brute de l’algorithme « P_filtre »|
MISFDET_vidPfiltAlgoThresh|D|();|FCT2.5|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Calcul du seuil de l’algorithme P filtre (dépend du régime et du couple indiqué )|
MISFDET_vidPfiltDet|A|();|FCT2.4|MISFDET|0|PTS_DOC_5158467||||0|0|0|0|Calcul de l'indice de confiance en la détection de misfire par l'algorithme P_filte|
MISFDETCFM_vidDecision|B|();|FCT1.2|MISFDETCFM|0|PTS_DOC_5198655||||0|0|0|0|Ce bloc permet de calculer à récurrence PMH une sortie représentative de l’état (misfire ou non) de la combustion scrutée. Il n’est activé que si les algorithmes ont bien été calculés (condition de détection active) et si la stratégie est autorisée.|
MISFDETCFM_vidDecisionAlgorithm|C|();|FCT1.3|MISFDETCFM|0|PTS_DOC_5198655||||0|0|0|0|Ce bloc permet d’obtenir une sortie unique représentative de la présence ou non d’un misfire sous forme d’un booléen Mf_stat_decision_uavb0. Ce bloc décrit les règles de décision quant à la présence ou non d’un misfire.|
MISFDETCFM_vidInitOutput|B|();|FCT1.1|MISFDETCFM|0|PTS_DOC_5198655||||0|0|0|0|Cette fonction initialise les sorties du module.|
MISFDETIDLE_vidDetAlgoOutIdle|C|();|FCT1.6|MISFDETIDLE|0|PTS_DOC_5198626||||0|0|0|0|Cette Fonction permet de calculer le seuil de l’algorithme IDLE (dépend du régime et du couple indiqué ).|
MISFDETIDLE_vidDetection|A|();|FCT1.4|MISFDETIDLE|0|PTS_DOC_5198626||||0|0|0|0|Cette Fonction permet de Calculer  la sortie de l’algorithme IDLE et de faire une comparaison entre seuils et sorties de l’algorithme.|
MISFDETIDLE_vidDetIdleAlgo|B|();|FCT1.5|MISFDETIDLE|0|PTS_DOC_5198626||||0|0|0|0|Cette Fonction permet de calculer  la sortie brute de l’algorithme « IDLE ».|
MISFDETIDLE_vidInit|B|();|FCT1.2|MISFDETIDLE|0|PTS_DOC_5198626||||0|0|0|0|Initialisation des sorties|
MISFDETIDLE_vidInitOutput|C|();|FCT1.1|MISFDETIDLE|0|PTS_DOC_5198626||||0|0|0|0|Initialisation des variables internes|
MISFDETIDLE_vidMisfDetIdleDet|D|();|FCT1.3|MISFDETIDLE|0|PTS_DOC_5198626||||0|0|0|0|Cette Fonction permet d'activer l’algorithme IDLE quand le moteur est au ralenti et au point neutre.|
MISFDFTLRN_vid1stLwAdapOnBkpt|F|();|FCT4.1|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module écrit le nombre d’apprentissages réalisés sur ce point d’appui .|
MISFDFTLRN_vid1stShrtAdapOnBkpt|F|();|FCT5.1|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module écrit le nombre d’apprentissages réalisés sur ce point d’appui.|
MISFDFTLRN_vidAdapLwNoRlzd|C|();|FCT6.9|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Initialiser l'Indicateur de non apprentissage (en eeprom, fenêtres longues) .|
MISFDFTLRN_vidAdapLwRlzdNoUt|A|();|FCT4.4|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Remise à zero de Mf_adap_lw_no_rlzd_uavb0|
MISFDFTLRN_vidAdapLwRlzdUt|A|();|FCT4.5|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Remise à zero de Mf_adap_lw_no_rlzd_UT_uavb0|
MISFDFTLRN_vidAdapLwRstNoUt|A|();|FCT4.9|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Remise à 1 de Mf_adap_lw_no_rlzd_uavb0|
MISFDFTLRN_vidAdapLwRstUt|A|();|FCT4.10|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Remise à 1 de Mf_adap_lw_no_rlzd_UT_uavb0|
MISFDFTLRN_vidAdapMesLong|G|();|FCT4.3|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module écrit le nombre d’apprentissages réalisés sur ce point d’appui (la valeur est 1 puisque c’est le premier apprentissage, condition d’entrée dans ce module).|
MISFDFTLRN_vidAdapMesShrt|G|();|FCT5.6|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module écrit le nombre d’apprentissages réalisés sur ce point d’appui (la valeur est 1 puisque c’est le premier apprentissage, condition d’entrée dans ce module).|
MISFDFTLRN_vidAdapPrecalLong|G|();|FCT4.2|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Le premier apprentissage sur la fenêtre est commun à tous les points d'appui du cylindre observé : les valeurs de la cartographie de correction de la fenêtre longue Misf_tiDlyLongWinLrn résultent de la cartographie de précalibration.|
MISFDFTLRN_vidAdapPrecalShrt|B|();|FCT5.2|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Apprentissage sur les fenêtres courte détente, courte PMH et courte PMB.|
MISFDFTLRN_vidAdapPrecalShrtBdc|F|();|FCT5.5|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Apprentissage sur la fenêtre courte PMB|
MISFDFTLRN_vidAdapPrecalShrtExp|F|();|FCT5.3|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Apprentisssage sur la fenêtre courte détente.|
MISFDFTLRN_vidAdapPrecalShrtTDC|E|();|FCT5.4|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Apprentissage sur la fenêtre courte PMH|
MISFDFTLRN_vidAdapRlzdCalc|A|();|FCT6.6|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Suite à la création du mode UT, un indicateur d’apprentissage est créé. Celui-ci tient compte des compteurs d’apprentissage des fenêtres longues et courtes.|
MISFDFTLRN_vidAdapRlzdNoUt|A|();|FCT5.7|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Remise à 0 de Mf_adap_shrt_no_rlzd_uavb0|
MISFDFTLRN_vidAdapRlzdUt|A|();|FCT5.8|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|remise à 0 de Mf_adap_shrt_no_rlzd_UT_uavb0|
MISFDFTLRN_vidAdapRstNoUt|A|();|FCT6.5|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Remise à 1 de Mf_adap_shrt_no_rlzd_uavb0|
MISFDFTLRN_vidAdapRstUt|A|();|FCT6.4|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|remise à 1 de Mf_adap_shrt_no_rlzd_UT_uavb0|
MISFDFTLRN_vidAdapShrtNoRlzd|C|();|FCT7.10|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Initialiser l'Indicateur de non apprentissage (fenêtres courtes).|
MISFDFTLRN_vidApplyDeltaLw|D|();|FCT6.8|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet de donner l'Indicateur de non apprentissage (en eeprom, fenêtres longues).|
MISFDFTLRN_vidApplyDeltaPrecal|C|();|FCT6.7|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Lorsque les conditions d’apprentissage ne sont plus remplies, la moyenne de l’offset entre l’erreur filtrée et la précalibration est appliquée sur les adaptatifs dont le point de régime n’a jamais eu d’apprentissage.|
MISFDFTLRN_vidApplyDeltaShrt|D|();|FCT7.9|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet de donner l'Indicateur de non apprentissage (fenêtres courtes).|
MISFDFTLRN_vidAutomateMisfLrn|G|();|FCT1.9|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Automate de la stratégie d'apprentissage des défauts.|
MISFDFTLRN_vidBdcWinVar|H|();|FCT3.3|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module filtre l’erreur brute et calcule l’écart entre les erreurs brute et filtrée des fenêtres courtes PMB|
MISFDFTLRN_vidCalcBdcWinApp|F|();|FCT2.6|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|calcul des erreurs brutes sur les durées des fenêtres courtes Bdc des cylindres 2 et 3 par rapport aux fenêtres du cylindre 1 du même cycle.|
MISFDFTLRN_vidCalcDelta|E|();|FCT5.10|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module calcule la validité des valeurs à apprendre.|
MISFDFTLRN_vidCalcDeltaBdc|D|();|FCT3.8|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce bloc permet de calculer l' Offset moyen entre l'erreur filtrée et la précalibration (fenêtre BDC).|
MISFDFTLRN_vidCalcDeltaExp|D|();|FCT3.6|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|ce bloc permet de calculer l'Offset moyen entre l'erreur filtrée et la précalibration (fenêtre Exp).|
MISFDFTLRN_vidCalcDeltaLw|D|();|FCT3.5|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|ce bloc permet de calculer l'offset moyen appliqué entre l'erreur filtrée et la précalibration (fenêtre Lw).|
MISFDFTLRN_vidCalcDeltaTdc|D|();|FCT3.7|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|ce bloc permet de calculer l'Offset moyen entre l'erreur filtrée et la précalibration (fenêtre TDC).|
MISFDFTLRN_vidCalcExpWinApp|F|();|FCT2.5|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|calcul des erreurs brutes sur les durées des fenêtres courtes Exp des cylindres 2 et 3 par rapport aux fenêtres du cylindre 1 du même cycle.|
MISFDFTLRN_vidCalcIndWinApp|G|();|FCT2.7|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Calcul de l'indice Mf_adap_bkpt_ind_uavn0|
MISFDFTLRN_vidCalcLongWinApp|F|();|FCT2.3|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|calcul des erreurs brutes sur les durées des fenêtres longues des cylindres 2 et 3 par rapport aux fenêtres du cylindre 1 du même cycle.|
MISFDFTLRN_vidCalcLrn|F|();|FCT2.9|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction filtre l’erreur brute et calcule l’écart entre les erreurs brute et filtrée.|
MISFDFTLRN_vidCalcLrnInit|F|();|FCT2.8|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module extrait les valeurs des durées des fenêtres longues et des fenêtres courtes du cylindre 1 afin d'en calculer les variations par rapport au cycle précédent.|
MISFDFTLRN_vidCalcSumDeltaPrecal|C|();|FCT3.4|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce bloc permet de calculer une moyenne de l’erreur filtrée sur tous les cylindres sur toute la plage de régime, et pas uniquement à l’approche d’un point d’appui.|
MISFDFTLRN_vidCalcTDCWinApp|F|();|FCT2.4|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|calcul des erreurs brutes sur les durées des fenêtres courtes TDC des cylindres 2 et 3 par rapport aux fenêtres du cylindre 1 du même cycle.|
MISFDFTLRN_vidCalcWinApp|B|();|FCT2.2|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module calcule les erreurs brutes sur les durées des fenêtres longues et des fenêtres courtes des cylindres 2 et 3 par rapport aux fenêtres du cylindre 1 du même cycle.|
MISFDFTLRN_vidCalcWinDelta|F|();|FCT1.10|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module extrait les valeurs des durées des fenêtres longues et des fenêtres courtes du cylindre 1 afin d'en calculer les variations par rapport au cycle précédent.|
MISFDFTLRN_vidCondAdap|G|();|FCT1.6|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Conditions moteur pour permettre l’apprentissage des défauts misfire|
MISFDFTLRN_vidCorrBkptLw1|D|();|FCT6.10|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|cette fonction permet la Correction de la fenêtre longue (appliqué au demi-tour 2)  dépendant du régime moteur|
MISFDFTLRN_vidCorrBkptLw2|D|();|FCT7.1|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|cette fonction permet la Correction de la fenêtre longue (appliqué au demi-tour 2)  dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptLw3|D|();|FCT7.2|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre longue (appliqué au demi-tour 2) dépendant du régime moteur .|
MISFDFTLRN_vidCorrBkptLw4|D|();|FCT7.3|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre longue (appliqué au demi-tour 2)  dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptLw5|D|();|FCT7.4|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre longue (appliqué au demi-tour 2)  dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptLw6|D|();|FCT7.5|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre longue (appliqué au demi-tour 2)  dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptLw7|D|();|FCT7.6|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre longue (appliqué au demi-tour 2)  dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptLw8|D|();|FCT7.7|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre longue (appliqué au demi-tour 2)  dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptLw9|D|();|FCT7.8|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre longue (appliqué au demi-tour 2)  dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptShrt1|C|();|FCT8.1|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre courte PMB, courte détente et courte PMH dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptShrt2|C|();|FCT8.2|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre courte PMB, courte détente et courte PMH dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptShrt3|C|();|FCT8.3|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre courte PMB, courte détente et courte PMH dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptShrt4|C|();|FCT8.4|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre courte PMB, courte détente et courte PMH dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptShrt5|C|();|FCT8.5|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre courte PMB, courte détente et courte PMH dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptShrt6|C|();|FCT8.6|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre courte PMB, courte détente et courte PMH dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptShrt7|C|();|FCT8.7|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre courte PMB, courte détente et courte PMH dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptShrt8|C|();|FCT8.8|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre courte PMB, courte détente et courte PMH dépendant du régime moteur.|
MISFDFTLRN_vidCorrBkptShrt9|C|();|FCT8.9|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet la Correction de la fenêtre courte PMB, courte détente et courte PMH dépendant du régime moteur.|
MISFDFTLRN_vidEcuRst|C|();|FCT1.2|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Initialisation des conditions remplies pour apprentissage MISFIRE.|
MISFDFTLRN_vidExpWinVar|H|();|FCT3.2|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module filtre l’erreur brute et calcule l’écart entre les erreurs brute et filtrée des fenêtres courtes détentes.|
MISFDFTLRN_vidIniSaveLrn|D|();|FCT9.1|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet d’initialiser la moyenne des échantillons qui est calculée dans le StateFlow Misf_stLrnWin. Cette initialisation est réalisée sur tous les cylindres et sur toutes les fenêtres lorsque les conditions de stabilité sont remplies.|
MISFDFTLRN_vidInitBkptInd|B|();|FCT1.7|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|initialisation de Mf_adap_bkpt_ind_uavn0|
MISFDFTLRN_vidInitOutput|J|();|FCT1.1|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Initialisation des sorties|
MISFDFTLRN_vidInitSortieModeUT|A|();|FCT1.8|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Les compteurs d’apprentissage sont réinitialisés à la sortie du mode UT|
MISFDFTLRN_vidLongWinVar|I|();|FCT2.10|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module filtre l’erreur brute et calcule l’écart entre les erreurs brute et filtrée des fenêtres longues.|
MISFDFTLRN_vidLwAdapRaz|E|();|FCT4.8|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|En cas de panne mémorisée, l’apprentissage des défauts misfire est reseté. Toutes les variables  d’apprentissage prennent les valeurs par défaut.|
MISFDFTLRN_vidLwAdapWrite|E|();|FCT4.7|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module écrit le nombre d’apprentissages dans la cartographie de comptage, et enregistre la valeur apprise dans la cartographie de correction en passant par un filtre.|
MISFDFTLRN_vidManuRst|F|();|FCT1.3|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce bloc permet de réaliser une mise à zéro des adaptatifs, des compteurs d’apprentissages et des booléens indiquant un apprentissage effectué.|
MISFDFTLRN_vidMfAdap|C|();|FCT1.4|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|appel des modules de la fenêtre sur laquelle le calcul va être réalisé, les conditions de stabilité moteur de l’apprentissage et l'automate de la stratégie d'apprentissage des défauts.|
MISFDFTLRN_vidNextLwAdapOnBkpt|G|();|FCT4.6|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Contrôle de la valeur d'apprentissage et déclanchement du panne.|
MISFDFTLRN_vidNextShrtAdapOnBkpt|F|();|FCT5.9|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module contrôle tout d’abord la nouvelle valeur de correction dans le bloc 01_calc_delta.Si l’écart entre la nouvelle valeur et celle déjà apprise est supérieure à un seuil en fonction du régime alors une panne d’apprentissage est relevée.|
MISFDFTLRN_vidRangeControl|C|();|FCT6.1|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module vérifie que les valeurs apprises des fenêtres courtes  ne dépassent pas un seuil max calibrable, sinon un défaut est levée et l’apprentissages des défauts Misfire est inhibé.|
MISFDFTLRN_vidRstCorrDelta|C|();|FCT8.10|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Cette fonction permet d'initialiser le nombre d'échantillons pour le calcul de la correction des précalibrations.|
MISFDFTLRN_vidSampleWin|B|();|FCT9.3|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce bloc permet d’utiliser la table « Misf_noWinSamplePlaMod_T » ou « Misf_noWinSample_T » selon l’activation du Mode UT.|
MISFDFTLRN_vidSaveLrn|L|();|FCT2.1|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Fonction de sauvergade des fenêtres d'apprentissage|
MISFDFTLRN_vidShrtAdapRaz|E|();|FCT6.3|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|En cas de panne mémorisée, l’apprentissage des défauts misfire est reseté. Toutes les variables d’apprentissage prennent les valeurs par défaut.|
MISFDFTLRN_vidShrtAdapWrite|E|();|FCT6.2|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module écrit le nombre d’apprentissages dans la cartographie de comptage, et enregistre la valeur apprise dans la cartographie de correction en passant par un filtre.|
MISFDFTLRN_vidSynchroMfWindow|C|();|FCT1.5|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Calcul du numéro physique du cylindre en cours de diagnostic Misfire.|
MISFDFTLRN_vidTDCWinVar|H|();|FCT3.1|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module filtre l’erreur brute et calcule l’écart entre les erreurs brute et filtrée des fenêtres courtes PMH|
MISFDFTLRN_vidUpdateWinAdap|A|();|FCT9.2|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module est exécuté à la récurrence de la tâche Misf_EveMisf. Il permet de mettre a jour les calcule des adaptations Misf_prm_tiDlyXXXWinLrnCylX qui ont été calculées.|
MISFDFTLRN_vidWinAdap|F|();|FCT3.9|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Ce module réalise la moyenne des erreurs sur la durée de la fenêtre des cylindres 2 et 3 par rapport à la durée de la fenêtre du cylindre 1 lorsque les conditions de stabilité sont remplies et que le régime moteur est proche d’un point d’appui.|
MISFDFTLRN_vidWinAdapSave|E|();|FCT3.10|MISFDFTLRN|0|PTS_DOC_5069555||||0|0|0|0|Extraction du nombre d'apprentissage du point d'appui.|
MISFDFTLRNOUT_vidEntryInit|A|();|SCH.1|MISFDFTLRNOUT|1|V02 NT 09 00762||||0|0|0|0|Fonction d'accroche au RESET.|
MISFDFTLRNOUT_vidInitOutput|A|();|FCT1.1|MISFDFTLRNOUT|0|V02 NT 09 00762||||0|0|0|0|Fonction d'initialisation des sorties|
MISFDFTLRNOUT_vidMfwAdaptCntMin|A|();|FCT1.2|MISFDFTLRNOUT|0|V02 NT 09 00762||||0|0|0|0|Ce module comporte la comparaison des deux vecteurs d’entrée par rapport à Mfw_adapt_zone_ratio_thresh. Chaque composante des vecteurs d’entrée est comparée au seuil. De cette comparaison est extrait un vecteur constitué des plus petites composantes.|
MISFDFTLRNOUT_vidMfwAdaptCZonLev|A|();|FCT1.3|MISFDFTLRNOUT|0|V02 NT 09 00762||||0|0|0|0|Fonction de production de la sortie Mfw_adapt_current_zone_level.|
MISFDFTLRNOUT_vidMfwAdaptZRatio|A|();|FCT1.4|MISFDFTLRNOUT|0|V02 NT 09 00762||||0|0|0|0|Fonction de production de la sortie Mfw_adapt_zones_ratio.|
MISFDIAGSTABCDN_vidChkgearstab|C|();|FCT1.6|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Le critère de stablité est basé sur le changement éventuel  d’un rapport. Si on constate un changement de  rapport, on déclare l’instabilité, sinon on déclare la stabilité après un délai.|
MISFDIAGSTABCDN_vidChkLdAlIdlStb|A|();|FCT4.9|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Fonction de détection de stabilité en couple quand aucun rapport n’est engagé qui s'active quand les conditions d’activation de l’algo Idle sont réunies|
MISFDIAGSTABCDN_vidChkLdAlNrmStb|A|();|FCT4.8|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Fonction de détection de stabilité en couple quand un rapport est engagé active quand les conditions d’activation de l’algo Normal sont réunies.|
MISFDIAGSTABCDN_vidChkLdNotStb|A|();|FCT4.10|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Focntion de diagnostique qui s'active quand les conditions de détection Misf sont pas réunies|
MISFDIAGSTABCDN_vidChkLdStab|B|();|FCT4.7|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Le critère de stablité est basé sur la variation crête à crête du couple indiqué depuis la dernière initialisation.Un seuil a été ajouté pour pouvoir différencier le cas où l’on est au point mort et le cas ou l’on a un rapport engagé.|
MISFDIAGSTABCDN_vidChkLdStabFilt|B|();|FCT4.6|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|La stratégie de détection de stabilité en couple se compose : 01_Mf_check_load_stability : active quand un rapport est engagé, 02_Mf_check_load_stability_noGear : active quand aucun rapport est engagé.|
MISFDIAGSTABCDN_vidChkLoadStab|C|();|FCT1.5|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Condition de stabilité en CMI sur la détection au ralenti, une nouvelle stratégie de détection de stabilité en couple a été développée. Misf_bAcvTqStab_C = 1 : la nouvelle stratégie est active, Misf_bAcvTqStab_C = 0 : l’ancienne stratégie est active.|
MISFDIAGSTABCDN_vidChktrqstab|C|();|FCT1.7|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Le critère de stablité est basé sur la variation crête à crête du couple depuis la dernière initialisation|
MISFDIAGSTABCDN_vidDiagStabCdn|D|();|FCT1.3|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|La condition de couple prend en compte, par l’intermédiaire de la variable TqCmp_tqSumLossCmp , les couples prélevés par  l’alternateur, le GMV, la climatisation, et la direction assistée.|
MISFDIAGSTABCDN_vidEngCdtNotStab|D|();|FCT1.9|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Dans ce bloc on déclare l’instabilité dès que l’une des conditions de stabilité n’est plus vérifiée.|
MISFDIAGSTABCDN_vidEngineCdtStab|C|();|FCT1.10|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Ici on déclare la stabilité si les conditions élémentaires sont vérifiées et si le délai s’est écoulé.|
MISFDIAGSTABCDN_vidEngineCndts|D|();|FCT1.8|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Les conditions de stabilité.|
MISFDIAGSTABCDN_vidGearNotStable|C|();|FCT2.3|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|L’initialisation de la variation est effectuée dès que l’on constate l’instabilité.|
MISFDIAGSTABCDN_vidGearSetStab|C|();|FCT3.3|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsqu’on  est  stable, déclarer  la  stabilité.|
MISFDIAGSTABCDN_vidGearStable|C|();|FCT2.4|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsqu’on  est  stable,  on  attend  un  délai  avant  de  déclarer  la  stabilité  et  on  continue  de  réactualiser  la  variation de couple indiqué.|
MISFDIAGSTABCDN_vidGearWaitStab|C|();|FCT3.4|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsqu’on  est  stable,  on  attend  un  délai  avant  de  déclarer  la  stabilité|
MISFDIAGSTABCDN_vidIgnAdvNotStab|B|();|FCT3.9|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Le système est déclaré non stabe et un compteur (Misf_ctIgAdvStab) est initialisé avec une valeur permettant d’attendre avant de confirmer que le système est redevenu stable|
MISFDIAGSTABCDN_vidIgnAdvStable|B|();|FCT4.1|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|La stabilité ne peut être retrouvée que lorsque le saut d’avance devient inférieur à Misf_agIgAdvStabLim_C et qu’après qu’une durée calibrable ne soit écoulée.|
MISFDIAGSTABCDN_vidInitEngineCnd|D|();|FCT1.2|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|A chaque reset du calculateur, on réinitialise les variables internes et  les sorties.|
MISFDIAGSTABCDN_vidInitOutput|E|();|FCT1.1|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|initialisation des variables internes.|
MISFDIAGSTABCDN_vidLoadNotStable|C|();|FCT2.1|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|L’initialisation de la variation est effectuée dès que l’on constate l’instabilité.|
MISFDIAGSTABCDN_vidLoadSetStab|C|();|FCT3.1|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsqu’on  est  stable, déclarer  la  stabilité.|
MISFDIAGSTABCDN_vidLoadStable|C|();|FCT2.2|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsqu’on  est  stable,  on  attend  un  délai  avant  de  déclarer  la  stabilité  et  on  continue  de  réactualiser  la  variation de couple indiqué.|
MISFDIAGSTABCDN_vidLoadWaitStab|C|();|FCT3.2|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsqu’on  est  stable,  on  attend  un  délai  avant  de  déclarer  la  stabilité|
MISFDIAGSTABCDN_vidMisfdvStabChk|B|();|FCT3.8|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Le saut d’avance est comparé à un seuil calibrable Misf_agIgAdvStabLim_C pour la détection de la stabilité ou non du système|
MISFDIAGSTABCDN_vidMisfIgAdvClcn|B|();|FCT3.7|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Calcul du saut d’avance à l’allumage à chaque événement Misf_EveMisf_MisfDiagStabCdn|
MISFDIAGSTABCDN_vidMisfStbCdLost|B|();|FCT4.4|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsque les conditions de stabilité en couple indiqué, rapport de boîte et couple prélevé sont perdues, la vérification de la condition de stabilité par rapport aux sauts d’avances n’est plus calculée|
MISFDIAGSTABCDN_vidMisIgAdvStNul|B|();|FCT4.5|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsque les conditions de stabilité en couple indiqué, rapport de boîte et couple prélevé sont perdues, la vérification de la condition de stabilité par rapport aux sauts d’avances n’est plus calculée|
MISFDIAGSTABCDN_vidStabChkDly|B|();|FCT4.3|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsque le saut d’avance est au dessous du seuil, le compteur Misf_ctIgAdvStab est décrémenté à chaque fin d’acquisition de la fenêtre Misfire|
MISFDIAGSTABCDN_vidStabSet|B|();|FCT4.2|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsque le compteur Misf_ctIgAdvStab s’annule, la stabilité du système est confirmée|
MISFDIAGSTABCDN_vidTimer|D|();|FCT2.7|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|la variation du couple  indiqué doit rester  inférieure à un seuil pendant un certain  délai.|
MISFDIAGSTABCDN_vidTimerOut|D|();|FCT2.8|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Indicateur de validité des conditions de stabilités spécifiques à la détection de misfires|
MISFDIAGSTABCDN_vidTorqNotStable|C|();|FCT2.5|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|L’initialisation de la variation est effectuée dès que l’on constate l’instabilité.|
MISFDIAGSTABCDN_vidTorqSetStab|C|();|FCT3.5|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsqu’on  est  stable, déclarer  la  stabilité.|
MISFDIAGSTABCDN_vidTorqStable|C|();|FCT2.6|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsqu’on  est  stable,  on  attend  un  délai  avant  de  déclarer  la  stabilité  et  on  continue  de  réactualiser  la  variation de couple indiqué.|
MISFDIAGSTABCDN_vidTorqWaitStab|C|();|FCT3.6|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsqu’on  est  stable,  on  attend  un  délai  avant  de  déclarer  la  stabilité|
MISFDIAGSTABCDN_vidVculeNotRning|C|();|FCT1.4|MISFDIAGSTABCDN|0|PTS_DOC_5577717||||0|0|0|0|Lorsque les conditions qui permettent de juger la stabilité du moteur ne sont pas remplies, on recopie les  variables EngLim_tqIdcEngCur, Gear_engaged, et Torque_deduction dans des plages mémoires qui  permettront ensuite de suivre leur évolution.|
MISFFAICTR_vidCataDamage|C|();|FCT3.1|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Ce bloc permet si de la mauvaise route est détectée(Mf_rough_road_cat_sum_uavn0 > Mf_rough_road_cat_thresh_uacn0) .|
MISFFAICTR_vidCataDamagePerCyl|E|();|FCT2.1|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Ce bloc permet :    D’attribuer les dommages causés au catalyseur par les misfires pour chaque cylindre.   De compter l’ensemble des misfires « destruction catalyseur » qui se sont produits sur l’ensemble des cylindres.|
MISFFAICTR_vidCataDamageSum|G|();|FCT3.4|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction additionne les dommages causés au catalyseur par tous les misfires détectés (sauf en cas de coupure d’injection) sur l’ensemble des cylindres.|
MISFFAICTR_vidCataEmissPerCyl|D|();|FCT5.1|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction permet :  D’attribuer les dommages causés au catalyseur par les misfires pour chaque cylindre.   De compter pour chaque cylindre le nombre de misfires « émission ».|
MISFFAICTR_vidCataRoughRdEmisCnt|C|();|FCT4.8|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction somme le pic lié à la mauvaise route pour la stratégie émission excessive de polluant.|
MISFFAICTR_vidCataRoughRoadCnt|C|();|FCT1.7|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction somme le pic lié à la mauvaise route pour la stratégie dommage catalyseur.|
MISFFAICTR_vidCatDamCylCalc|F|();|FCT4.1|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|En 4 cylindres, il est interdit de couper 2 cylindres consécutifs en cas de panne Dephia ou AAC. Si cela se produit les booléens de défaut dommages catalyseurs sont remis à zéros.|
MISFFAICTR_vidCatDamWghtRealCnt|B|();|FCT3.3|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Dans cette fonction  est réalisée le vecteur somme des poids des misfires réels.|
MISFFAICTR_vidCatDmgCylCutMgt|B|();|FCT1.4|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction effectue la production de Misf_bAcvDetDmgCat qui active le comptage des défauts émissions excessives de polluants.|
MISFFAICTR_vidEmission|C|();|FCT5.6|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction permet si la mauvaise route est détectée  Mf_rough_road_emiss_sum_uavn0 = Mf_rough_road_emiss_thresh_uacn0.|
MISFFAICTR_vidEmissRealCount|B|();|FCT6.9|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Les misfires détectés sur des cylindres dont l’injection est coupée sont écartés afin de ne pas fausser la détection|
MISFFAICTR_vidEmissSum|E|();|FCT6.2|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction fait la somme des misfires « émission » détectés sur l’ensemble des cylindres pour l’horizon « émission » de 2000.|
MISFFAICTR_vidEssenceDefault|F|();|FCT7.2|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Ce bloc détermine la gestion des défauts de ratés de combustion durant le fonctionnement en essence.|
MISFFAICTR_vidFailDetCatDam|F|();|FCT1.3|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|cette fonction effectue ses calculs à récurrence Misf_EveMisf.|
MISFFAICTR_vidFailDetCatDamage|E|();|FCT1.5|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction  effectue ses calculs à récurrence Misf_EveMisf:  Comptage de panne « destruction du catalyseur » dès lors que les conditions d’activations des algorithmes sont vérifiées.|
MISFFAICTR_vidFailDetCatDamage1|F|();|FCT6.8|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction  effectue ses calculs à récurrence Misf_EveMisf:  Comptage de panne « destruction du catalyseur » dès lors que les conditions d’activations des algorithmes sont vérifiées.|
MISFFAICTR_vidFailDetEmiss|H|();|FCT4.5|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction effectue ses calculs à récurrence Misf_EveMisf.|
MISFFAICTR_vidFailDetEmission|G|();|FCT4.6|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction effectue ses calculs à récurrence Misfire_task.|
MISFFAICTR_vidFuelLowLevelComput|D|();|FCT7.4|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Ce bloc calcule l’indicateur de niveau bas réservoir. Suite à la détection d’un seuil minimum de dommages catalyseurs sur les quatre cylindres une temporisation est enclenchée.|
MISFFAICTR_vidGazDefault|F|();|FCT7.3|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Ce bloc détermine la gestion des défauts de ratés de combustion durant le fonctionnement au gaz.|
MISFFAICTR_vidHorizonCalcCatDam|D|();|FCT1.6|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction permet de mettre 1 booléen à 1 dès lors que les horizons définis pour les stratégies « dommages catalyseur » (400 PMH) est atteint.|
MISFFAICTR_vidHorizonsCalcEmiss|D|();|FCT4.7|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction permet de mettre 1 booléen à 1 dès lors que les horizons définis pour les stratégies «émission » excessive de polluant (2000 PMH) sont atteints.|
MISFFAICTR_vidInhDetNoMisfEnable|B|();|FCT7.6|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction inhibe le comptage lorsq'il n'y a pas encore eu de misfire détecté.|
MISFFAICTR_vidInit|G|();|FCT1.1|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Fonction d'initialisation.|
MISFFAICTR_vidInitCatDam|D|();|FCT4.4|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Initialisation des variables relatives au comptage des pannes «dommages catalyseur » dès lors que l’horizon « dommages catalyseur » de 400 PMH est atteint.|
MISFFAICTR_vidInitEmiss|C|();|FCT6.7|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Initialisation des variables relatives au comptage des pannes «émissions » de polluants dès lors que l’horizon « émission » de 2000 PMH est atteint.|
MISFFAICTR_vidInitOutput|J|();|FCT1.2|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Fonction d'initialisation des sorties.|
MISFFAICTR_vidMfCatDamRealSum|B|();|FCT3.5|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Dans cette fonction on réalise la somme des misfires réels sur les PMH relatifs à la stratégie.|
MISFFAICTR_vidMfCyl_1|D|();|FCT2.2|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Fonction permet de compter les dommages catalyseur du 1 cylindre.|
MISFFAICTR_vidMfCyl_1_P2|C|();|FCT5.2|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Fonction permet de compter les dommages catalyseur du 1 cylindre.|
MISFFAICTR_vidMfCyl_2|C|();|FCT2.5|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Fonction permet de compter les dommages catalyseur du 2 cylindre.|
MISFFAICTR_vidMfCyl_2_P2|C|();|FCT5.5|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Fonction permet de compter les dommages catalyseur du 2 cylindre.|
MISFFAICTR_vidMfCyl_3|D|();|FCT2.3|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Fonction permet de compter les dommages catalyseur du 3 cylindre.|
MISFFAICTR_vidMfCyl_3_P2|C|();|FCT5.3|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Fonction permet de compter les dommages catalyseur du 3 cylindre.|
MISFFAICTR_vidMfCyl_4|C|();|FCT2.4|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Fonction permet de compter les dommages catalyseur du 4 cylindre.|
MISFFAICTR_vidMfCyl_4_P2|C|();|FCT5.4|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Fonction permet de compter les dommages catalyseur du 4 cylindre.|
MISFFAICTR_vidMfDet4Cyl|E|();|FCT3.9|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction détermine les cylindres en misfire destruction de catalyseur, pour un fonctionnement en quatre   cylindres. Ainsi en quatre cylindres seul deux défauts cylindre identifié peut être mémorisé.|
MISFFAICTR_vidMfDetected3Cyl|F|();|FCT3.7|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction détermine les cylindres en misfire destruction de catalyseur, pour un fonctionnement en trois cylindres.Ainsi en trois cylindre seul un défaut cylindre identifiés peut être mémorisé.|
MISFFAICTR_vidMfDetected4Cyl|C|();|FCT3.8|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction détermine les cylindres en misfire destruction de catalyseur, pour un fonctionnement en quatre   cylindres. Ainsi en quatre cylindres seul deux défauts cylindre identifié peut être mémorisé.|
MISFFAICTR_vidMfDetectedCatDam|E|();|FCT3.6|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Ce bloc permet de déterminer si les misfires « dommage catalyseur » ont lieu préférentiellement sur un cylindre ou si tous les cylindres sont affectés.|
MISFFAICTR_vidMfDetectedEmiss|C|();|FCT6.3|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Ce bloc effectue ses calculs à récurrence Misfire_task :  Comptage de panne «  émission excessive » dès lors que les conditions d’activations des algorithmes sont vérifiées.|
MISFFAICTR_vidMfEmissCyl|E|();|FCT6.4|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction indique permet d'indiquer s'il ya des des émissions excessives de polluants sont dues par le cylindre1 en misfire.|
MISFFAICTR_vidMisfFaiCtrEnable|B|();|FCT7.5|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction permet d’activer la stratégie de comptage des misfires à partir du moment oùle premier misfire est détecté. Cette solution a été adoptée pour optimiser la chaîne de calcul.|
MISFFAICTR_vidMisfireDefault|B|();|FCT7.1|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Ce bloc détermine la gestion des défauts de ratés de combustion qui doit être distincte entre un fonctionnement au gaz et un fonctionnement en essence.|
MISFFAICTR_vidMisfireRateCatDam|C|();|FCT4.2|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction calcule le taux de misfire  « dommage catalyseur » qui se sont produits sur l’ensemble des cylindres sur l’horizon « dommage catalyseur » de 400 PMH.|
MISFFAICTR_vidMisfireRateEmiss|C|();|FCT6.5|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Calcul du taux de misfires « émission » pour un bloc « émission » de 2000 PMH.|
MISFFAICTR_vidMisfireTotal|C|();|FCT4.9|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Ce bloc détermine, pour les 4 cylindres, un défaut misfire dû à un injecteur ou une bougie défaillante.|
MISFFAICTR_vidRoughRdNoDetCatDam|D|();|FCT3.2|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Cette fonction permet d'Additionner des dommages causés au catalyseur par tous les misfires détectés sur l’ensemble des cylindres.|
MISFFAICTR_vidRoughRdNoDetEmiss|D|();|FCT6.1|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|la détection de ratés liés à une émission excessive de polluant (2000 PMH).|
MISFFAICTR_vidRoughRoadDetCatDam|C|();|FCT4.3|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Si la mauvaise route est détectée (Mf_rough_road_cat_sum_uavn0 = mf_rough_road_cat_thresh_uacn0) alors les variables entrant en compte dans le comptage de pannes sont réinitialisées à 0.|
MISFFAICTR_vidRoughRoadDetEmiss|C|();|FCT6.6|MISFFAICTR|0|PTS_DOC_5069596||||0|0|0|0|Si la mauvaise route est détectée (Mf_rough_road_sum_emiss_uavn0 = Mf_rough_emiss_thresh_uacn0) alors les variables entrant en compte dans le comptage de pannes sont réinitialisées à 0.|
MISFMISFDETCFM_vidEntryInit|B|();|SCH.1|MISFDETCFM|1|PTS_DOC_5198655||||0|0|0|0|Evènement de Reset du module MISFMISFDETCFM|
MISFROUGHNSROAD_vidEntryInit|A|();|SCH.1|MISFROUGHNSROAD|1|V02 NT 09 02692||||0|0|0|0|Fonction d'initialisation des sorties du module MISFROUGHNSROAD.|
MISFROUGHNSROAD_vidInitOutput|A|();|FCT1.1|MISFROUGHNSROAD|0|V02 NT 09 02692||||0|0|0|0|Cette fonction initialise la variable de sortie du module|
MISFROUGHNSROAD_vidRghRoadDetect|A|();|FCT1.3|MISFROUGHNSROAD|0|V02 NT 09 02692||||0|0|0|0|Ce module compare la somme des indices de confiance pondérés avec 2 seuils : Mf_misfire_detected_thresh_uacn0 et un un 2ème seuil plus grand. Dès que des pics se trouvent entre les 2 seuils, un booléen indique qu'il y a risque de mauvaise route.|
MISFROUGHNSROAD_vidRoughRoad|A|();|FCT1.2|MISFROUGHNSROAD|0|V02 NT 09 02692||||0|0|0|0|Cette fonction implémente la stratégie de détection de la mauvaise route dans le cadre de la stratégie générique de détection de misfire.|
MISFROUGHNSROADCAN_vidClcn|A|();|FCT1.2|MISFROUGHNSROADCAN|0|V02 NT 09 01896||||0|0|0|0|Cette stratégie active le mode mauvaise route à partir de la vitesse des roues transmises via l’ISCAN.
MISFROUGHNSROADCAN_vidEntryInit|A|();|SCH.1|MISFROUGHNSROADCAN|1|V02 NT 09 01896||||0|0|0|0|Evénement reset du calculateur.
MISFROUGHNSROADCAN_vidInitOutput|A|();|FCT1.1|MISFROUGHNSROADCAN|0|V02 NT 09 01896||||0|0|0|0|Initialisations des sorties.
MISFSUCDET_vidAlgorithme|B|();|FCT1.5|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc se décompose en 2 sous-blocs : Calcul de l’indice de confiance appliqué au « 1er misfire » scruté. Calcul de l’indice de confiance appliqué au « 2ème misfire » scruté|
MISFSUCDET_vidDecision|B|();|FCT1.6|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc se divise en 2 sous blocs :Le 1er décide si le 1er misfire a effectivement eu lieu. Le 2ème décide si le 2ème misfire a effectivement eu lieu|
MISFSUCDET_vidDetTwoMisfNotChckd|B|();|FCT1.7|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc permet de remettre la variable Mf_2_misfire_detected_uavb0 à 0 dès lors que la détection de 2 misfires successifs n’est pas vérifiée ( à savoir Mf_2_mf_det_ena_uavb0 = 0 )|
MISFSUCDET_vidEntryInit|B|();|SCH.1|MISFSUCDET|1|PTS_DOC_5198660||||0|0|0|0|Evénement reset du calculateur|
MISFSUCDET_vidFirstAlgoTrust|B|();|FCT3.3|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc calcule : l’indice de confiance appliqué au « 1er misfire » scruté et l’indice de confiance appliqué au « 2ième misfire » scruté|
MISFSUCDET_vidFirstCombDetection|B|();|FCT3.4|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Calcul de l’indice de confiance appliqué au « 1er misfire » scruté|
MISFSUCDET_vidFirstFilter|B|();|FCT3.2|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Les algorithmes combustions adaptés à la détection de 2 misfires successifs sont calculés selon deux équations.|
MISFSUCDET_vidFirstFilterMain|B|();|FCT3.1|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc calcule les sorties des algorithmes dédiés à la détection du 1er des 2 misfires|
MISFSUCDET_vidFirstMisfDetection|B|();|FCT2.1|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc calcule : La sortie des algorithmes. Les indices de confiance correspondant|
MISFSUCDET_vidFstMisfDecision|B|();|FCT2.3|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc décide si le 1er misfire a effectivement eu lieu|
MISFSUCDET_vidFstPfiltDetection|B|();|FCT3.5|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Calcul de l’indice de confiance appliqué au « 2ème misfire » scruté|
MISFSUCDET_vidInitOutput|B|();|FCT1.1|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Initialisation des variables de sorties|
MISFSUCDET_vidSecondFilter|B|();|FCT3.7|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Les algorithmes combustions adaptés à la détection du 2ième misfire sont calculés selon deux équations|
MISFSUCDET_vidSndAlgoTrust|B|();|FCT3.8|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc calcule : l’indice de confiance appliqué au « 1er misfire » scruté et l’indice de confiance appliqué au « 2ième misfire » scruté|
MISFSUCDET_vidSndCombDetection|B|();|FCT3.9|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Calcul de l’indice de confiance appliqué au « 1er misfire » scruté|
MISFSUCDET_vidSndFilterMain|B|();|FCT3.6|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc calcule les sorties des algorithmes dédiés à la détection du 2ième misfire|
MISFSUCDET_vidSndMisfDecision|B|();|FCT2.4|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc décide si le 2ème misfire a effectivement eu lieu|
MISFSUCDET_vidSndMisfDetection|B|();|FCT2.2|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc calcule : La sortie des algorithmes. Les indices de confiance correspondant du 2ième misfire|
MISFSUCDET_vidSndPfiltDetect|B|();|FCT3.10|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Calcul de l’indice de confiance appliqué au « 2ème misfire » scruté|
MISFSUCDET_vidSuccessiveMisfires|B|();|FCT1.4|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc permet d’activer la stratégie de détection de 2 misfires successifs dès lors que la sortie unique est supérieure à un seuil calibrable.|
MISFSUCDET_vidSucMisfDetection|B|();|FCT1.3|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|Ce bloc est constitué de 3 modules dont les fonctions sont respectivement: L’activation de la stratégie de détection. Le calcul des nouveaux algorithmes. La décision permettant de dire si 2 misfires successifs se sont produits ou non.|
MISFSUCDET_vidSucMisfDetectMain|B|();|FCT1.2|MISFSUCDET|0|PTS_DOC_5198660||||0|0|0|0|La stratégie de détection de 2 misfires successifs sera calculée si le Booléen ,qui indique que les conditions d'activation des algorithmes sont vérifiées, est mis à '1'|
MISFSUCDETIDLE_vidAlgo1trustSuc|A|();|FCT1.10|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Ce bloc calcule : -  L’indice de confiance correspondant|
MISFSUCDETIDLE_vidAlgo2trustSuc|A|();|FCT2.3|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0| Ce bloc calcule : -  L’indice de confiance correspondant|
MISFSUCDETIDLE_vidAlgoMfSuc|A|();|FCT1.7|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Ce bloc se décompose en 2 sous-blocs :  -  Calcul de l’indice de confiance appliqué au « 1er misfire » scruté  -  Calcul de l’indice de confiance appliqué au « 2ème misfire » scruté|
MISFSUCDETIDLE_vidAutoDetMfSuc|A|();|FCT1.5|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Ce bloc permet d’activer la stratégie de détection de 2 misfires successifs (en IDLE) dès lors que la sortie unique (en IDLE) est supérieure à un seuil calibrable.|
MISFSUCDETIDLE_vidDecisionMfSuc|A|();|FCT2.4|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|e bloc vérifie 2 choses :   -  si le 1er misfire a effectivement eu lieu  -  si le 2ème misfire a effectivement eu lieu|
MISFSUCDETIDLE_vidDetectionMfSuc|A|();|FCT1.6|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Ce bloc est composé 2 deux sous-systèmes :  -  Le calcul des nouveaux algorithmes permettant la détection des 2 misfires (en IDLE)  -  La décision permettant de dire si 2 misfires successifs se sont produits ou non (en IDLE).|
MISFSUCDETIDLE_vidFilter1MfSuc|A|();|FCT1.9|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Ce bloc calcule :  -  La sortie de l’algorithme|
MISFSUCDETIDLE_vidFilter2MfSuc|A|();|FCT2.2|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Ce bloc calcule :  -  La sortie de l’algorithme|
MISFSUCDETIDLE_vidIni|A|();|FCT1.2|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Initialisation des sorties.|
MISFSUCDETIDLE_vidInitOutput|A|();|FCT1.1|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Initialisation des sorties.|
MISFSUCDETIDLE_vidMainMisfSucDet|A|();|FCT1.3|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|En fonction de la calibration MisfDet_noDelaySyncSuc_C il est possible de détecter 2 misfire successif avec un délai souhaité par rapport à MisfDet_bMisfSucDetRaw.|
MISFSUCDETIDLE_vidMisfire1DetMf|A|();|FCT1.8|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Ce bloc calcule :  -  La sortie de l’algorithme  -  L’indice de confiance correspondant|
MISFSUCDETIDLE_vidMisfire2DetMf|A|();|FCT2.1|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Ce bloc calcule :  -  La sortie de l’algorithme  -  L’indice de confiance correspondant|
MISFSUCDETIDLE_vidMisfSucDet|A|();|FCT1.4|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Ce bloc est constitué de 3 modules dont les fonctions sont respectivement:  -  L’activation de la stratégie de détection dédiée à 2 misfires successifs (en IDLE) car celle-ci n’est pas tout le temps active, elle le sera uniquement s’il y a doute.|
MISFSUCDETIDLE_vidMisfSucDetNot|A|();|FCT2.6|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Si les conditions d’activation de la détection ne sont pas atteintes (Mf_algo_cond_ok_uavb0 = 0) alors le booléen de détection est mis à 0.|
MISFSUCDETIDLE_vidNotDetectMfSuc|A|();|FCT2.5|MISFSUCDETIDLE|0|PTS_DOC_5198644||||0|0|0|0|Calcul de boolean de detection|
MISFWINACQ_MisfAcqDesactive|A|();|FCT1.7|MISFWINACQ|0|V02 NT 09 05081||||0|0|0|0|Ce bloc désactive l’API PTMHAL .|
MISFWINACQ_vidAcqLdbWinDuration|A|();|FCT1.9|MISFWINACQ|0|V02 NT 09 05081||||0|0|0|0|Ce bloc récupère le nombre de durées acquises Misf_cntWinAcq, ainsi que les durées de fenêtre mesurées par le LdB, sous forme d’un tableau contenant, dans l’ordre défini par le LdB :|
MISFWINACQ_vidInitOuput|A|();|FCT1.1|MISFWINACQ|0|V02 NT 09 05081||||0|0|0|0|Fonction d'initialisation|
MISFWINACQ_vidinitWintiDly|A|();|FCT1.2|MISFWINACQ|0|V02 NT 09 05081||||0|0|0|0|ce bloc permet  d'intialiser les  durées des fenêtres.|
MISFWINACQ_vidMisfAcqActive|A|();|FCT1.5|MISFWINACQ|0|V02 NT 09 05081||||0|0|0|0|ce bloc permet  l’activation de PTMHAL.|
MISFWINACQ_vidMisfAcqDesactive|A|();|FCT1.6|MISFWINACQ|0|V02 NT 09 05081||||0|0|0|0|Ce bloc désactive l’API PTMHAL si le moteur perd sa synchronisation et que l’API était préalablement activé.|
MISFWINACQ_vidMisfAcqSdlActive|A|();|FCT1.4|MISFWINACQ|0|V02 NT 09 05081||||0|0|0|0|Dans le cas où l’API ne s’est pas activé lors de la synchronisation du moteur, ce bloc permet de relancer, à récurrence temporelle, l’activation de PTMHAL.|
MISFWINACQ_vidMisfAcqSyncActive|A|();|FCT1.3|MISFWINACQ|0|V02 NT 09 05081||||0|0|0|0|Au moment où le moteur se synchronise, on vérifie l’état de l’API : si  E_OK, l’API est activé,  et si E_NOT_OK, l’API n’est pas activé.|
MISFWINACQ_vidReadWintiDly|A|();|FCT1.8|MISFWINACQ|0|V02 NT 09 05081||||0|0|0|0|L’acquisition des fenêtres par le LdB est autorisée si PTMHAL est actif. Les valeurs acquises sont prises en compte sous certaines conditions.|
MISFWINACQ_vidWinDuration|A|();|FCT1.10|MISFWINACQ|0|V02 NT 09 05081||||0|0|0|0|La prise en compte des mesures LdB est soumise à trois conditions :le régime doit être supérieur à un seuil,le statut d’activation renvoyé par le LdB doit être OK, le moteur doit être synchronisé, le nombre de durées acquises doit être égal Misf_win_nbr_c|
MISFWINADP_vidConditionActiv|A|();|FCT1.2|MISFWINADP|0|V02 NT 09 00776||||0|0|0|0|Cette stratégie permet de corriger la durée de chaque fenêtre  d’acquisition à l’aide des valeurs d’adaptatifs,suite à la stratégie d’apprentissage des défauts géométriques de la cible moteur.
MISFWINADP_vidCorrectedWindow|A|();|FCT1.3|MISFWINADP|0|V02 NT 09 00776||||0|0|0|0|Selon le n° du cylindre on détermine sur quel demi- tour de la cible moteur est scruté le misfire et par  conséquent nous pouvons ajouter l’adaptatif correspondant.
MISFWINADP_vidCorrectWin_Calc|A|();|FCT1.5|MISFWINADP|0|V02 NT 09 00776||||0|0|0|0|calcul des variables (Misf_tiDlyLongWinAdp,Misf_tiDlyExpWinAdp,Misf_tiDlyTDCWinAdp,Misf_tiDlyBdcWinAdp)
MISFWINADP_vidCorrectWin_Interp|D|();|FCT1.4|MISFWINADP|0|V02 NT 09 00776||||0|0|0|0|calcul d'interpolation
MISFWINADP_vidEntryInit|A|();|SCH.1|MISFWINADP|1|V02 NT 09 00776||||0|0|0|0|Evénement reset
MISFWINADP_vidInitOutput|A|();|FCT1.1|MISFWINADP|0|V02 NT 09 00776||||0|0|0|0|initialisation des sorties
MNGBRKPED_vidDiagBrkPrdFil|E|();|FCT1.3|MNGBRKPED|0|V02 NT 11 03796||||0|0|0|0|fonction de diagnostic pédale de frein|
MNGBRKPED_vidDiagBVH2p|B|();|FCT1.4|MNGBRKPED|0|V02 NT 11 03796||||0|0|0|0|fonction Software diagnostic BVH2 pour l'information Frein  Secondaire est activée|
MNGBRKPED_vidDiagNoBVH2p|B|();|FCT1.5|MNGBRKPED|0|V02 NT 11 03796||||0|0|0|0|fonction Software diagnostic hors BVH2 pour l'information  Frein Secondaire est activée|
MNGBRKPED_vidFCall|D|();|FCT1.2|MNGBRKPED|0|V02 NT 11 03796||||0|0|0|0|fonction d'appel|
MNGBRKPED_vidInitOutput|E|();|FCT1.1|MNGBRKPED|0|V02 NT 11 03796||||0|0|0|0|fonction d'initialisation|
MONAUTHOSTT_vidArch2004_2010_BVA|B|();|FCT1.7|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Sécurisation de la demande de démarrage en BVA|
MONAUTHOSTT_vidArch2004_2010BVMP|B|();|FCT1.9|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Sécurisation de la demande de démarrage en BVMP|
MONAUTHOSTT_vidArchi2010_et_BVMP|B|();|FCT1.8|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Sécurisation du diagnostic Chaine de traction pour ADML Archi 2010 et BVMP|
MONAUTHOSTT_vidArchi2010et_BVA|B|();|FCT1.6|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Sécurisation du diagnostic Chaine de traction pour ADML Archi 2010 et BVA|
MONAUTHOSTT_vidAutorisationDem|D|();|FCT2.10|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Autorisation de démarrage|
MONAUTHOSTT_vidAutorisRedemSTT|B|();|FCT2.2|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Cette fonction permet de surveiller le démarrage / redémarrage intempestif STT , DAGMP.|
MONAUTHOSTT_vidAutorRedemSansSTT|B|();|FCT2.9|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Pas de sécurisation hors STT|
MONAUTHOSTT_vidCalcul_Defaut_CdT|B|();|FCT2.5|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Définit la condition dans laquelle l’embrayage ou le neutre sont considérés en défaut|
MONAUTHOSTT_vidCompGenDefautSTT|E|();|FCT3.3|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Comparaison de la demande dem / redem sécurisée avec la demande niveau applicatif, filtre anti-rebond et calibration de la remontée du défaut.|
MONAUTHOSTT_vidConfigArchiEEBV|B|();|FCT1.2|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Detecte la configuration BV et Archi EE|
MONAUTHOSTT_vidCoord_defaut_CdT|C|();|FCT2.6|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Calibration de la remontée des défauts et filtres antirebonds.|
MONAUTHOSTT_vidCoordAutDemRedem|D|();|FCT3.1|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Coordination dem / redem sécurisée|
MONAUTHOSTT_vidCoordSecuriADML|C|();|FCT1.10|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Paramétrage de la prise en compte des défauts et filtrage anti-rebond.|
MONAUTHOSTT_vidCrdDemdAutDmRdmN1|C|();|FCT3.2|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Coordination autorisation Dem / redem niveau applicatif (CMM et SEEM)|
MONAUTHOSTT_vidCrdEmbConNeutConf|B|();|FCT2.8|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Merge|
MONAUTHOSTT_vidEntryInit|C|();|SCH.1|MONAUTHOSTT|1|PTS_DOC_5199597||||0|0|0|0|Accroche moniteur de la fonction  Reset|
MONAUTHOSTT_vidInitOutput|D|();|FCT1.1|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Fonction d'initialisation|
MONAUTHOSTT_vidMergeSTTConfig|B|();|FCT3.4|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Synthèse finale du défaut.|
MONAUTHOSTT_vidMiseEnPlaceFRMBVA|B|();|FCT1.5|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Sécurisation de la mise en place du FRM sur le flux de l’état de la chaine de traction|
MONAUTHOSTT_vidSecuEmbConNeutBVA|B|();|FCT2.7|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Pas de sécurisation d’embrayage et neutre en BVA/BVMP|
MONAUTHOSTT_vidSecurEmbrContNeut|B|();|FCT2.4|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Sécurisation de l’embrayage continu, seulement valide en BVM|
MONAUTHOSTT_vidSecurisationADML|B|();|FCT1.4|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Sécurisation de l’ouverture de la chaine de traction en ADML BVA en fonction de l’architecture EE.|
MONAUTHOSTT_vidSecurisationSTTDA|B|();|FCT2.1|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Cette fonction permet de surveiller le démarrage / redémarrage intempestif STT , DAGMP.|
MONAUTHOSTT_vidSecuriser_STT|C|();|FCT2.3|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Cette fonction permet de surveiller le démarrage / redémarrage intempestif STT , DAGMP.|
MONAUTHOSTT_vidSTTConfiguration|E|();|FCT1.3|MONAUTHOSTT|0|PTS_DOC_5199597||||0|0|0|0|Cette fonction permet de bypasser la sécurisation des demandes Démarrage / redémarrage STTd|
Mux_EveRst_MuxDiagOn|A|();|SCH.1|MUXDIAGON|1|V02 NT 08 05997||||0|0|0|0|Reset event handler
Mux_SdlMid_MuxDiagOn|A|();|SCH.2|MUXDIAGON|1|V02 NT 08 05997||||0|0|0|0|Mux_SdlMid_MuxDiagOn event handler
MUXDIAGON_Vid_Init|C|();|FCT1.1|MUXDIAGON|0|V02 NT 08 05997||||0|0|0|0|Initialization function.
MUXDIAGON_Vid_RunDiagOn|D|();|FCT1.2|MUXDIAGON|0|V02 NT 08 05997||||0|0|0|0|Main module function
MUXTQREQ_vidEngSpdLimHiEfc|B|();|FCT1.5|MUXTQREQ|0|V02 NT 11 08258||||0|0|0|0|dans cette fonction On teste ici les conditions pour la limitation de régime.
MUXTQREQ_vidEngSpdLimLoEfc|B|();|FCT1.4|MUXTQREQ|0|V02 NT 11 08258||||0|0|0|0|dans cette fonction on  teste les conditions pour la limitation de régime sévère.
MUXTQREQ_vidEngStOpm|A|();|FCT1.3|MUXTQREQ|0|V02 NT 11 08258||||0|0|0|0|cette fonction permet la synthèse des différentes activations de modes dégradés. Lorsque plusieurs sont actifs simultanément, seul le plus contraignant est pris en compte.
MUXTQREQ_vidInit|A|();|FCT1.1|MUXTQREQ|0|V02 NT 11 08258||||0|0|0|0|fonction d'intialisation des sorties
MUXTQREQ_vidInitOutput|A|();|FCT1.2|MUXTQREQ|0|V02 NT 11 08258||||0|0|0|0|cette fonction permet d'initialiser les sorties de l'hystheresis
MUXTQREQ_vidTqLimEfc|A|();|FCT1.6|MUXTQREQ|0|V02 NT 11 08258||||0|0|0|0|Dans cette fonction On teste ici les conditions pour la limitation de couple.
NeutPosnAcq_SdlSfty_SftyLvl2|B|();|SCH.3|NEUTPOSNACQ|1|PTS_DOC_6533527||||0|0|0|0|Evènement de calcul des fonctions safety de niveau 2.
NEUTPOSNACQ_vidbDgoORngCalcn|D|();|FCT1.8|NEUTPOSNACQ|0|PTS_DOC_6533527||||0|0|0|0|Ce bloc permet de détecter une fréquence du signal capteur de position point mort hors gabarit.
NEUTPOSNACQ_vidbDgoScgCalcn|D|();|FCT1.7|NEUTPOSNACQ|0|PTS_DOC_6533527||||0|0|0|0|Ce bloc permet de détecter un court-circuit au plus du capteur de position point mort.
NEUTPOSNACQ_vidbDgoScpCalcn|D|();|FCT1.6|NEUTPOSNACQ|0|PTS_DOC_6533527||||0|0|0|0|Ce bloc permet de détecter un court circuit à la masse du capteur de position point mort.
NEUTPOSNACQ_vidBneutNom|C|();|FCT2.1|NEUTPOSNACQ|0|PTS_DOC_6533527||||0|0|0|0|En mode nominal, le booléen de position point mort est issu d’un hystérésis sur la valeur du RCO du signal du capteur
NEUTPOSNACQ_vidInitialization|B|();|FCT1.1|NEUTPOSNACQ|0|PTS_DOC_6533527||||0|0|0|0|Ce bloc permet d’initialiser l’information « boîte de vitesse au point mort » au réveil calculateur lorsque le capteur n’est pas encore fonctionnel.
NEUTPOSNACQ_vidInitOutput|B|();|FCT1.2|NEUTPOSNACQ|0|PTS_DOC_6533527||||0|0|0|0|Ce bloc permet l'initialisation des sorties.
NEUTPOSNACQ_vidNeutPosnAcq|D|();|FCT1.4|NEUTPOSNACQ|0|PTS_DOC_6533527||||0|0|0|0|Ce bloc met à la disposition du LDA le rapport cyclique du signal délivré par le capteur de position point mort. Le calcul du rapport cyclique de ce signal est effectué par le LDB.
NEUTPOSNACQ_vidNeutPosnDiag|D|();|FCT1.5|NEUTPOSNACQ|0|PTS_DOC_6533527||||0|0|0|0|Ce bloc permet de vérifier si les conditions de chaque diagnostic sont satisfaites et le cas échéant d’autoriser la détection d’une éventuelle défaillance.
NEUTPOSNACQ_vidNeutPosnTreat|C|();|FCT1.9|NEUTPOSNACQ|0|PTS_DOC_6533527||||0|0|0|0|Ce  bloc  décrit  la  consolidation  du  booléen  position  point mort  en  fonction  des  résultats  des  diagnostics  du capteur.
NEUTPOSNACQ_vidOS|C|();|FCT1.3|NEUTPOSNACQ|0|PTS_DOC_6533527||||0|0|0|0|Le démultiplexage de  l’évènement Gear_SdlFast_NeutPosnAcq est autorisé si et seulement si  le véhicule est équipé d’une boîte de vitesse manuelle et de la fonctionnalité STOP & START.
NEUTPOSNACQ_vidSafetyLevel2|B|();|FCT2.2|NEUTPOSNACQ|0|PTS_DOC_6533527||||0|0|0|0|Cette fonction permet d’effectuer une stratégie safety de niveau 2 sur le signal du capteur de point mort haut.
NM_vidGetCounters|A|(argin uint8 NetId, argout uint8 *au8AbsentCounter);|1.2|HEADER|1|V01 NT 08 05903||||0|0|0|0|
NM_vidSetNodesConfig|A|(argin uint8 NetId, argout tenuNMDiagConfig *aenuDiagConfig);|1.3|HEADER|1|V01 NT 08 05903||||0|0|0|0|
NOPROD_PointeurFonctionNull|A|();|FCT1.3|NOPROD|1|V02 NT 10 01758||||0|0|0|0|Pointeur de focntion NULL.
NOPROD_vidReset|B|();|FCT1.1|NOPROD|0|V02 NT 10 01758||||0|0|0|0|initialise  les variables qui ne sont initialisées qu’au RESET. D’une manière générale il s’agit de variable bouchonnées qui n’ont pas besoin d’être modifiables par calibration.
NOPROD_vidUpdate|B|();|FCT1.2|NOPROD|0|V02 NT 10 01758||||0|0|0|0|la production de variables nécessitant la possibilité d’être « by-passées » par calibration, ce  qui implique une mise à jour temporelle.
NTARIDLCHK_vidEntryInit|B|();|SCH.1|NTARIDLCHK|1|PTS_DOC_5049983||||0|0|0|0|Fonction de reset|
NTARIDLCHK_vidInitOutput|D|();|FCT1.1|NTARIDLCHK|0|PTS_DOC_5049983||||0|0|0|0|Fonction d'initialisation|
NTARIDLCHK_vidValConsigneRalenti|E|();|FCT1.2|NTARIDLCHK|0|PTS_DOC_5049983||||0|0|0|0|Fonction qui permet de valider que la consigne de ralenti statique ne dépasse pas le gradient max d’évolution toléré.|
NVMSRV_bAllSaved|A|()boolean;|5|HEADER|1|NONE||||0|0|0|0||
NVMSRV_bIsOk|A|func_NVMSRV_bIsOk|0x02|HEADER|1|NONE||||0|0|0|0||
NVMSRV_bIsVirgin|A|func_NVMSRV_bIsVirgin|3|HEADER|1|NONE||||0|0|0|0|
NVMSRV_u8GetStatus|D|func_NVMSRV_u8GetStatus|25|HEADER|1|NONE||||0|0|0|0||
NVMSRV_u8WriteStatus|D|func_NVMSRV_u8WriteStatus|23|HEADER|1|NONE||||0|0|0|0||
NVMSRV_vidRead|B|(argin NVMSRV_tudtObjectList udtObject);|0x02|HEADER|1|V03 NT 09 00985||||0|0|0|0||
NVMSRV_vidWrite|A|(argin NVMSRV_tudtObjectList udtObject, argin boolean bMode);|1|HEADER|1|HEADER||||0|0|0|0||
OBD_vidMngEveRstDftCal|A|();|1|HEADER|1|HEADER||||0|0|0|0|header|
OBDMODE1_Pid1F|A|func_Read_OBDMODEXX|MODE1Auto_API1.13|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_00|A|func_Read_OBDMODEXX|MODE1Auto_API2.6|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_03|A|func_Read_OBDMODEXX|MODE1Auto_API1.7|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_04|A|func_Read_OBDMODEXX|MODE1Auto_API2.4|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_05|A|func_Read_OBDMODEXX|MODE1Auto_API1.8|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_06|A|func_Read_OBDMODEXX|MODE1Auto_API1.17|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_07|A|func_Read_OBDMODEXX|MODE1Auto_API1.1|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_0B|A|func_Read_OBDMODEXX|MODE1Auto_API1.16|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_0C|A|func_Read_OBDMODEXX|MODE1Auto_API1.2|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_0D|A|func_Read_OBDMODEXX|MODE1Auto_API1.19|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_0E|A|func_Read_OBDMODEXX|MODE1Auto_API1.3|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_0F|A|func_Read_OBDMODEXX|MODE1Auto_API2.1|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_11|A|func_Read_OBDMODEXX|MODE1Auto_API.12|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_13|A|func_Read_OBDMODEXX|MODE1Auto_API1.20|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_14|A|func_Read_OBDMODEXX|MODE1Auto_API1.11|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_15|A|func_Read_OBDMODEXX|MODE1Auto_API2.7|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_1C|A|func_Read_OBDMODEXX|MODE1Auto_API1.5|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_1F|A|func_Read_OBDMODEXX|MODE1Auto_API1.4|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_20|A|func_Read_OBDMODEXX|MODE1Auto_API2.8|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_21|A|func_Read_OBDMODEXX|MODE1Auto_API2.9|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_23|A|func_Read_OBDMODEXX|MODE1Auto_API2.11|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_2E|A|func_Read_OBDMODEXX|MODE1Auto_API1.22|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_30|A|func_Read_OBDMODEXX|MODE1Auto_API1.12|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_31|A|func_Read_OBDMODEXX|MODE1Auto_API1.9|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_33|A|func_Read_OBDMODEXX|MODE1Auto_API1.14|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_3C|A|func_Read_OBDMODEXX|MODE1Auto_API1.6|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_40|A|func_Read_OBDMODEXX|MODE1Auto_API2.3|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_42|A|func_Read_OBDMODEXX|MODE1Auto_API2.5|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_44|A|func_Read_OBDMODEXX|MODE1Auto_API2.12|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_47|A|func_Read_OBDMODEXX|MODE1Auto_API2.13|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_49|A|func_Read_OBDMODEXX|MODE1Auto_API2.10|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_4A|A|func_Read_OBDMODEXX|MODE1Auto_API1.15|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_4C|A|func_Read_OBDMODEXX|MODE1Auto_API1.18|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_4D|A|func_Read_OBDMODEXX|MODE1Auto_API1.24|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_4E|A|func_Read_OBDMODEXX|MODE1Auto_API1.23|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_4F|A|func_Read_OBDMODEXX|MODE1Auto_API2.2|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_50|A|func_Read_OBDMODEXX|MODE1Auto_API1.10|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_60|A|func_Read_OBDMODEXX|MODE1Auto_API1.21|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE1_Pid_72|A|func_Read_OBDMODEXX|MODE1Manu_API1.1|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE6|A|func_Read_OBDMODEXX|MODE6Manu_API1.1|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE9_Inftyp_00|A|func_Read_OBDMODEXX|MODE9Auto_API1.1|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE9_Inftyp_02|A|func_Read_OBDMODEXX|Mode09Auto_API1.2|OBDSRV|1|V02 NT 11 06099||||0|1|0|0|Function called upon reception of request mode 09 infotype $02|
OBDMODE9_Inftyp_04|A|func_Read_OBDMODEXX_1|MODE9Manu_API1.1|OBDSRV|1|V02 NT 11 06099||||0|1|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDMODE9_Inftyp_08|A|func_Read_OBDMODEXX|MODE9Auto_API1.2|OBDSRV|1|V02 NT 11 06099||||0|0|0|0|Is called from Dcm when OBD service ReadData PID is called|
OBDSRV06_EveRst|A|();|FCT1.3|OBDSRV06|0|V02 NT 11 04787||||0|0|0|0|Fonction appelée par l'Evénement reset de la fonction|
OBDSRV06_EveRstDft|A|();|FCT1.2|OBDSRV06|0|V02 NT 11 04787||||0|1|0|0|Fonction appelée lors de la demande d'effacement Manuel des défauts|
OBDSRV06_NVMSRV_vidInit|A|();|SCH.6|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Evénement init de l'EEPROM de la fonction|
OBDSRV06_pwrl|A|();|FCT1.1|OBDSRV06|0|V02 NT 11 04787||||0|1|0|0|Evènement appelé pour l'écriture au powerlatch|
OBDSRV06_SdlMid|A|();|FCT1.4|OBDSRV06|0|V02 NT 11 04787||||0|0|0|0|fonction appelée par le Cheduler moyen de la fonction|
OFSVLV_vidActAdmission|B|();|FCT3.7|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine les consignes VVT admission après prise en compte de l'activation du système d'actionneur  VVT.|
OFSVLV_vidActEchappement|B|();|FCT3.8|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine les consignes VVT échappement après prise en compte de l'activation du système d'actionneur|
OFSVLV_vidActivation|A|();|FCT3.5|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine les consignes VVT admission et échappement après prise en compte de l'activation du système d'actionneur VVT (autorisation venant de la boucle locale).|
OFSVLV_vidBalayage_maximum|D|();|FCT2.6|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet de déterminer le croisement maximum des VVT respectant le débit d’air balayé maximum|
OFSVLV_vidBalayage_maximumCalc|A|();|FCT2.7|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Production de la variable VlvSys_mfAirScvRed_MP.|
OFSVLV_vidBalayageMaxParDft|A|();|FCT2.8|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet d’attribuer à la valeur de croisement de VVT maximum une valeur constante calibrable dans le cas où les conditions moteurs sont défavorables au calcul nominal ou encore lorsque le mode banc est activé.|
OFSVLV_vidBanc_Admission|A|();|FCT3.3|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine les consignes VVT admission après prise en compte du mode banc.|
OFSVLV_vidBanc_Echappement|A|();|FCT3.4|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine les consignes VVT échappement après prise en compte du mode banc.|
OFSVLV_vidCalcConsigLimit|A|();|FCT2.2|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet de calculer une consigne VVT admission minimum et une consigne VVT échappement maximum à partir d'un débit d'air balayé maximum.|
OFSVLV_vidDefinition_butee|B|();|FCT1.5|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet de déterminer les butées minimum et maximum des actionneurs VVT admission et échappement|
OFSVLV_vidDevectorisation|A|();|FCT2.4|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet de sélectionner, pour chacune des grandeurs en entrée, la composante du vecteur correspondant au numéro de cylindre en phase d’admission.|
OFSVLV_vidInit|B|();|FCT1.3|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Initialisation des consignes VVT à leurs butées de repos|
OFSVLV_vidInitOutput|B|();|FCT1.1|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Initialisation des outputs|
OFSVLV_vidLimitation_consignes|B|();|FCT3.1|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet de saturer les consignes VVT admission et échappement nominales avec la consigne VVT admission minimum et la consigne VVT échappement maximum limitant le balayage.|
OFSVLV_vidLimitation_du_balayage|A|();|FCT2.1|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet la limitation du balayage par les VVT|
OFSVLV_vidMode_banc|A|();|FCT3.2|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine les consignes VVT admission et échappement après prise en compte du mode banc.|
OFSVLV_vidPanne|A|();|FCT4.2|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine les consignes VVT admission et échappement après prise en compte des défauts possibles.|
OFSVLV_vidPanneAdmission|B|();|FCT4.3|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine les consignes VVT admission après prise en compte des défauts possibles.|
OFSVLV_vidPanneEchappement|B|();|FCT4.4|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle  détermine les consignes VVT échappement après prise en compte des défauts possibles.|
OFSVLV_vidPilotAdmission|A|();|FCT3.10|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine les consignes VVT admission après prise en compte de la consigne issue de la boucle locale.|
OFSVLV_vidPilotage_VVT_en_butee|A|();|FCT3.9|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine les consignes VVT admission et échappement après prise en compte de la consigne issue de la  boucle locale.|
OFSVLV_vidPilotageCroimntMaxInit|B|();|FCT1.2|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet l' initialisation de l'automate.|
OFSVLV_vidPilotageCroisemntMax|B|();|FCT2.9|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle  calcule la consigne VVT admission minimum et la consigne VVT  échappement maximum en fonction des différentes conditions moteurs.|
OFSVLV_vidPilotEchappement|A|();|FCT4.1|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine les consignes VVT admission après prise en compte de la consigne issue de la boucle locale.|
OFSVLV_vidSatAdmission|C|();|FCT1.7|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet de limiter les gradients ascendants et descendants de la consigne VVT admission par des facteurs fonction du régime et de la charge|
OFSVLV_vidSatEchappement|C|();|FCT1.9|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|On limite les gradients ascendants et descendants de la consigne VVT échappement par des facteurs fonction du régime et de la charge|
OFSVLV_vidSatNot_Admission|B|();|FCT1.8|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Dans le cas où, le moteur n’est pas équipé d’un VVT admission, la consigne est égale à la butée|
OFSVLV_vidSatNot_Echappement|B|();|FCT1.10|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Dans le cas où, le moteur n’est pas équipé d’un VVT échappement, la consigne est égale à la butée.|
OFSVLV_vidSaturations|A|();|FCT1.6|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle a pour but de limiter les gradients de consigne VVT et de saturer les consignes VVT.|
OFSVLV_vidTranfDebitBalyCroismnt|B|();|FCT2.3|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet de calculer un croisement de soupape maximum à partir du débit d'air balayé maximum issu de la protection composant.|
OFSVLV_vidTransition_activation|B|();|FCT3.6|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle détermine pour les consignes VVT admission  et échappement le facteur de transition|
OFSVLV_vidVerification_balayage|B|();|FCT2.5|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet de vérifier que le moteur se trouve bien dans des conditions favorables au balayage afin de garantir le calcul en aval.|
OFSVLV_vidVlvArb|A|();|FCT1.4|OFSVLV|0|V02 NT 11 02164||||0|0|0|0|Elle permet d'appliquer, aux consignes VVT admission et échappement, des consignes spécifiques en fonctions de plusieurs conditions d'arbitrage.|
Oil_Eve14TDC_AcqAdc|A|();|SCH.7|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|A Quarter TDC crankshaft angular based event|
Oil_Eve14TDC_OilPropPresAcq|D|();|SCH.3|OILPROPPRESACQ|1|PTS_DOC_6978050||||0|0|0|0|Evénement d'appel de tâche "quart de PMH" du CMM.|
Oil_EveKOn_PresDiagCoh|B|();|SCH.2|PRESDIAGCOH|1|V02 NT 12 01298||||0|0|0|0|Key On Event|
Oil_EveOilLvl_OilLvlAcq|E|();|SCH.3|OILLVLACQ|1|PTS_DOC_6872932||||0|0|0|0|Event created by LDB to call the API OILLVHAL_udtGetConversionResult|
Oil_EveOilLvl_OilLvlHalAcq|A|();|SCH.2|OILLVLHALACQ_DT|1|PTS_DOC_6873713||||0|0|0|0|Event created by LDB to call the API OILLVHAL_udtGetConversionResult|
Oil_EveRst_AcqAdc|A|();|SCH.8|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|ECU Event Reset|
Oil_EveRst_ActrTstCtlPmpIf|B|();|SCH18.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reset.|
Oil_EveRst_BlowByCmd|A|();|SCH.1|BLOWBYCMD|1|PTS_DOC_6563717||||0|0|0|0|Reset event for BlowBy command|
Oil_EveRst_OilLvlAcq|D|();|SCH.1|OILLVLACQ|1|PTS_DOC_6872932||||0|0|0|0|Reset Event|
Oil_EveRst_OilPresAcq|C|();|SCH.1|OILPRESACQ|1|PTS_DOC_6563540||||0|0|0|0|Fonction d'accroche à l'événement reset du calculateur|
Oil_EveRst_OilPropPresAcq|G|();|SCH.1|OILPROPPRESACQ|1|PTS_DOC_6978050||||0|0|0|0|ECU Event Reset|
Oil_EveRst_PresDiagCoh|B|();|SCH.1|PRESDIAGCOH|1|V02 NT 12 01298||||0|0|0|0|ECU Event Reset|
Oil_SdlFast_AcqAdc|A|();|SCH.9|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|Fast scheduler|
Oil_SdlFast_OilLvlAcq|E|();|SCH.2|OILLVLACQ|1|PTS_DOC_6872932||||0|0|0|0|Fast scheduler|
Oil_SdlFast_OilLvlAcqDiag|A|();|SCH.7|ACQDGOHAL_DT|1|PTS_DOC_6854092||||0|0|0|0|Fast scheduler|
Oil_SdlFast_OilLvlHalAcq|A|();|SCH.3|OILLVLHALACQ_DT|1|PTS_DOC_6873713||||0|0|0|0|Fast scheduler|
Oil_SdlFast_OilPropPresAcq|G|();|SCH.2|OILPROPPRESACQ|1|PTS_DOC_6978050||||0|0|0|0|Fast scheduler.|
Oil_SdlFast_PresDiagCoh|C|();|SCH.3|PRESDIAGCOH|1|V02 NT 12 01298||||0|0|0|0|Fast scheduler  Event|
Oil_SdlMid_ActrTstCtlPmpIf|B|();|SCH19.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Scheduler moyen.|
Oil_SdlMid_OilPresAcq|C|();|SCH.2|OILPRESACQ|1|PTS_DOC_6563540||||0|0|0|0|Fonction d'accroche à l'événement Oil_SdlMid_OilPresAcq|
Oil_SdlMid_OilPresAcqDio|A|();|SCH3.4|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Moniteur moyen.
Oil_SdlSlow_BlowByCmd|A|();|SCH.2|BLOWBYCMD|1|PTS_DOC_6563717||||0|0|0|0|Slow scheduler for BlowByCmd|
Oil_SdlSlow_BlowByCmdDio|A|();|SCH2.8|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evénement de Reset pour la commande BlowBy.
Oil_SdlSlow_CmdDiagBlowBy1|A|();|SCH1.2|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Moniteur lent pour la comande du réchauffeur BlowBy
Oil_SdlSlow_CmdDiagBlowBy2|A|();|SCH1.3|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Moniteur lent pour la comande du réchauffeur BlowBy.
OILDSP_NVMSRV_vidInit|A|();|FCT1.8|OILDSP|0|PTS_DOC_5377698||||0|0|0|0|Initialization of OilDsp_mFuInOilEstim to OilDsp_mFuInOilEstimInit_C in EEPROM's re-initialization|
OILDSP_vidAbsorption|A|();|FCT1.3|OILDSP|0|PTS_DOC_5377698||||0|0|0|0|The function must detect the beginning and the end of a significative desorption phase  of fuel in oil.|
OILDSP_vidDesorption|A|();|FCT1.5|OILDSP|0|PTS_DOC_5377698||||0|0|0|0|The function detect the start and the end of a significative desorption phase of fuel in oil|
OILDSP_vidDisableAFACanister|A|();|FCT1.7|OILDSP|0|PTS_DOC_5377698||||0|0|0|0|This function produced  2 flags to disable the mixture adaptation when the ratio between the mass of fuel evaporated and the fuel injected is high.|
OILDSP_vidEnaAbsorption|B|();|FCT1.4|OILDSP|0|PTS_DOC_5377698||||0|0|0|0|This funtion calculate estimated mass of fuel in oil.|
OILDSP_vidEnaDesorption|C|();|FCT1.6|OILDSP|0|PTS_DOC_5377698||||0|0|0|0|this function calculate  the estimated mass of fuel in oil|
OILDSP_vidInit|A|();|FCT1.2|OILDSP|0|PTS_DOC_5377698||||0|0|0|0|Initialization of internals and outputs.|
OILDSP_vidInitOutput|A|();|FCT1.1|OILDSP|0|PTS_DOC_5377698||||0|0|0|0|initialization of internals.|
OILLVHAL_udtGetConversionResult|A|func_OILLVHAL_udtGetConversionResult|3|HEADER|1|NONE||||0|0|0|0||
OILLVHAL_vidDisable|A|();|2|HEADER|1|NONE||||0|0|0|0||
OILLVHAL_vidEnable|A|();|1|HEADER|1|NONE||||0|0|0|0||
OILLVLACQ_vidAcqBSW|C|();|FCT1.4|OILLVLACQ|0|PTS_DOC_6872932||||0|0|0|0|The two voltage average are produced by the BSW|
OILLVLACQ_vidAcqMng|D|();|FCT1.5|OILLVLACQ|0|PTS_DOC_6872932||||0|0|0|0|Automate|
OILLVLACQ_vidAcquisition|D|();|FCT1.3|OILLVLACQ|0|PTS_DOC_6872932||||0|0|0|0|The beginning of the measure is based on vehicle request and conditions on engine speed and water temperature. Once the acquisition is completely done, it will not be restarted until the next Key Off.|
OILLVLACQ_vidDiagGrd|D|();|FCT1.8|OILLVLACQ|0|PTS_DOC_6872932||||0|0|0|0|Diagnostic based on voltage difference incoherent (Too smal or too big)|
OILLVLACQ_vidDiagnosis|F|();|FCT1.6|OILLVLACQ|0|PTS_DOC_6872932||||0|0|0|0|Diagnosis are run only when an acquisition has been carried out.|
OILLVLACQ_vidFailures|E|();|FCT1.7|OILLVLACQ|0|PTS_DOC_6872932||||0|0|0|0|Three diagnosis are carried out : short-circuit to ground, short-circuit to “plus”, and voltage difference incoherent (too small or too big).|
OILLVLACQ_vidInit|C|();|FCT1.1|OILLVLACQ|0|PTS_DOC_6872932||||0|0|0|0|The engine oil level is initialized with Ext_uEngOilLvlIp_C.|
OILLVLACQ_vidInitOutput|E|();|FCT1.2|OILLVLACQ|0|PTS_DOC_6872932||||0|0|0|0|fonction d'initialisation des sorties.|
OILLVLACQ_vidSelection|D|();|FCT1.10|OILLVLACQ|0|PTS_DOC_6872932||||0|0|0|0|This block manages the priorities between the computed value, the default value, and the “measure running” value.|
OILLVLACQ_vidTreatment|D|();|FCT1.9|OILLVLACQ|0|PTS_DOC_6872932||||0|0|0|0|Several corrections are done on the raw acquisition. There are corrections depending on oil temperature, current, ECU temperature. A change of scale is also performed in order to respect the BSI range.|
OILLVLHALACQ_DT_vidCdnLvlAcq|A|();|FCT1.2|OILLVLHALACQ_DT|0|PTS_DOC_6873713||||0|0|0|0|The BSW must be informed when the measure is authorized.|
OILLVLHALACQ_DT_vidDisableLvlAcq|A|();|FCT1.3|OILLVLHALACQ_DT|0|PTS_DOC_6873713||||0|0|0|0|Oil level acquisition is disabled when the measure is not authorized.|
OILLVLHALACQ_DT_vidEnableLvlAcq|A|();|FCT1.4|OILLVLHALACQ_DT|0|PTS_DOC_6873713||||0|0|0|0|Oil level acquisition is enabled when the measure is authorized.|
OILLVLHALACQ_DT_vidEntryInit|A|();|SCH.1|OILLVLHALACQ_DT|1|PTS_DOC_6873713||||0|0|0|0|Reset Event|
OILLVLHALACQ_DT_vidInitOutput|A|();|FCT1.1|OILLVLHALACQ_DT|0|PTS_DOC_6873713||||0|0|0|0|Fonction d'initialisation des sorties|
OILLVLHALACQ_DT_vidLvlAcq|A|();|FCT1.5|OILLVLHALACQ_DT|0|PTS_DOC_6873713||||0|0|0|0|Fonction that makes the acquisition of two average measures on the oil level and returns the status of the oil level acquisition.|
OILPRESACQ_vidAcqFil|D|();|FCT1.4|OILPRESACQ|0|PTS_DOC_6563540||||0|0|0|0|Le signal d'acquisition est filtré par un système anti-rebond.|
OILPRESACQ_vidInitialization|C|();|FCT1.2|OILPRESACQ|0|PTS_DOC_6563540||||0|0|0|0|A l'initialisation l'information pression huile doit être à OFF.|
OILPRESACQ_vidInitOutput|B|();|FCT1.1|OILPRESACQ|0|PTS_DOC_6563540||||0|0|0|0|fonction d'initialisation des sorties.|
OILPRESACQ_vidOilPresInfoAcq|C|();|FCT1.3|OILPRESACQ|0|PTS_DOC_6563540||||0|0|0|0|La lecture de l’information OIL_PRESSURE_ACQUISITION_SENSOR provenant du LdB sera réalisée s’il n’y a pas  action  de  reconfiguration  en  cours  suite  à  la  levée  d’un  défaut  pression  huile  moteur (FRM_bAcvDftValOilPresAcq = OFF).|
OILPROPPRESACQ_vidInitialization|E|();|FCT1.2|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|The Output variable Ext_pOilMes is initialized with zero at event reset.|
OILPROPPRESACQ_vidInitOilPrsFilt|A|();|FCT2.3|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|Fonction d'initialisation relative au bloc _Oil_Pressure_Filtering|
OILPROPPRESACQ_vidInitOutput|F|();|FCT1.1|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|Output's initialization|
OILPROPPRESACQ_vidInitPrsAcqMean|A|();|FCT2.2|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|Fonction d'initialisation relative au bloc Oil_Presure_Acquisition_Mean|
OILPROPPRESACQ_vidOilAcqCond|D|();|FCT1.4|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|This function gives different conditions to activate oil pressure acquisition.|
OILPROPPRESACQ_vidOilDiag|E|();|FCT1.10|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|Electrical diagnosis on the ADC output voltage is done to check for: Short circuit to ground or Short circuit to supply.|
OILPROPPRESACQ_vidOilPresAcqMean|C|();|FCT2.1|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|cette focntcion calcule la valeur moyenne de la tension proportionnelle de pression d'huile.|
OILPROPPRESACQ_vidOilPresFilter|C|();|FCT1.8|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|cette fonction calcule le tension de pression d'huile.|
OILPROPPRESACQ_vidOilPresInfoAcq|D|();|FCT1.9|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|The normalized ADC output voltage is converted into pressure using the table Oil_upOilMesLnr_T and clamped  between Oil_pMin_SC and Oil_pMax_SCto produce Ext_pOilMesRaw_bornee.|
OILPROPPRESACQ_vidOilPresMesAcq|E|();|FCT1.7|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|The oil pressure after treatement is calculated in the 3 cases : When there is no electrical faults concerning the oil pressure sensor,If an electrical fault was detected and If a fault was confirmed.|
OILPROPPRESACQ_vidOilPressDiag|D|();|FCT1.5|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|The diagnosis is authorized if there is no electrical failure on the sensor.|
OILPROPPRESACQ_vidOilPressTreat|F|();|FCT1.6|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|Treatment and detection of the oil pressure sensor.|
OILPROPPRESACQ_vidOilSdlFastEna|F|();|FCT1.3|OILPROPPRESACQ|0|PTS_DOC_6978050||||0|0|0|0|Fonction d'activation de l'événement  Oil_SdlFast_OilPropPresAcq|
OilSys_EveRst_OilDsp|A|();|SCH.1|OILDSP|1|PTS_DOC_5377698||||0|0|0|0|Reset event.|
OilSys_EveTDC_OilDsp|A|();|SCH.2|OILDSP|1|PTS_DOC_5377698||||0|0|0|0|TDC event (Top Dead Center)|
OilSys_SdlMid_OilDsp|A|();|SCH.3|OILDSP|1|PTS_DOC_5377698||||0|0|0|0|Middle scheduler.|
OilSysHw_EveRst_CtlPmpReq|D|();|SCH.1|CTLPMPREQ|1|PTS_DOC_6851410||||0|0|0|0|Event reset calculator.|
OilSysHw_SdlFast_CmdPwmAct|A|();|SCH.4|CMDPWMACT_DT|1|PTS_DOC_6913248||||0|0|0|0|Quick Service Monitor of OilSysHw|
OilSysHw_SdlFast_CtlPmpReq|D|();|SCH.2|CTLPMPREQ|1|PTS_DOC_6851410||||0|0|0|0|Quick Service Monitor of OilSysHw.|
OilSysHw_SdlFast_CtlPmpReqDiag|A|();|SCH.6|ACQDGOHAL_DT|1|PTS_DOC_6854092||||0|0|0|0|Quick Service Monitor of OilSysHw|
OSCDET_vidInitOutput|B|();|FCT1.5|OSCDET|0|V02 NT 12 00679||||0|0|0|0|Fonction d'initialisation des variable internes.
OSCDET_vidOscCheckFctCallInit|B|();|FCT1.1|OSCDET|0|V02 NT 12 00679||||0|0|0|0|Ce bloc est appellé lors de la perte des conditions de détection de stabilité
OSCDET_vidOscCheckStabDecision|A|();|FCT2.1|OSCDET|0|V02 NT 12 00679||||0|0|0|0|Ce bloc définit le mode de detection de la stabilité.
OSCDET_vidOscCheckStabIdlSpd|A|();|FCT1.3|OSCDET|0|V02 NT 12 00679||||0|0|0|0|Ce bloc vérifie l'indicateur de la stabilité du régime moteur au ralenti.
OSCDET_vidOscCheckStabilityInit|B|();|FCT1.4|OSCDET|0|V02 NT 12 00679||||0|0|0|0|Bloc d'initialisation.
OSCDET_vidOscChekStabAirLd|A|();|FCT1.2|OSCDET|0|V02 NT 12 00679||||0|0|0|0|Ce bloc vérifie la stabilité de la charge d'air.
OSCDET_vidOscChekStabilityPeriod|A|();|FCT1.6|OSCDET|0|V02 NT 12 00679||||0|0|0|0|Ce bloc verifie la période de stabilité du point de fonctionnement moteur.
OSCDET_vidOscEngAirLoadExtrCmpt|A|();|FCT1.8|OSCDET|0|V02 NT 12 00679||||0|0|0|0|Ce bloc calcule les valeurs maximale et minimale de la charge d'air.
OSCDET_vidOscEngAirLoadStabCompt|A|();|FCT1.7|OSCDET|0|V02 NT 12 00679||||0|0|0|0|Ce bloc calcule la stabilité de la charge d'air.
OSCDET_vidOscEngSpeedExtrCmpt|A|();|FCT1.10|OSCDET|0|V02 NT 12 00679||||0|0|0|0|Ce bloc calcule les valeurs maximale et minimale du régime moteur observées pendant une période.
OSCDET_vidOscEngSpeedStabCmpt|A|();|FCT1.9|OSCDET|0|V02 NT 12 00679||||0|0|0|0|Ce bloc calcule l'indicateur de stabilité du régime moteur au ralenti.
pap_mot_NVMSRV_vidInit|B|();|FCT2.9|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|l’initialisation, on vient lire toutes les données enregistrées en EEPROM. Dans le cas d’une première mise sous tension, on utilise les valeurs par défaut.
PDSTHRCHK_vidCompSecurisation|E|();|FCT1.5|PDSTHRCHK|0|PTS_DOC_5050542||||0|0|0|0|Comparaison entre la pression utilisée en entrée de l’estimateur et la pression  estimée|
PDSTHRCHK_vidEntryInit|C|();|SCH.1|PDSTHRCHK|1|PTS_DOC_5050542||||0|0|0|0|Evenement Reset du calculateur|
PDSTHRCHK_vidEstimOffAppSec|C|();|FCT1.3|PDSTHRCHK|0|PTS_DOC_5050542||||0|0|0|0|Estimation de l’offset de comparaison en fonction du régime moteur et du pourcentage d’ouverture du papillon.|
PDSTHRCHK_vidEstimPresAdmission|D|();|FCT1.2|PDSTHRCHK|0|PTS_DOC_5050542||||0|0|0|0|Estimation de la pression admission en fonction du régime moteur et du pourcentage d’ouverture du papillon.|
PDSTHRCHK_vidInitOutput|E|();|FCT1.1|PDSTHRCHK|0|PTS_DOC_5050542||||0|0|0|0|Initialisation des sorties|
PDSTHRCHK_vidSecurPressSensor|C|();|FCT1.4|PDSTHRCHK|0|PTS_DOC_5050542||||0|0|0|0|Sécurisation des capteurs de pression par gradient et comparaison|
PduR_Init|A|(uint16 *pu16Pdu);|4|HEADER|1|NONE||||0|0|0|0|
PFCHAL_vidDioEnable|A|(argin uint8 u8Channel);|7|HEADER|1|NONE||||0|0|0|0|
PFCHAL_vidPwmEnable|A|(argin uint8 u8Channel);|0x03|HEADER|1|NONE||||0|0|0|0|
PFCMNG_vidCheckpoint|C|(argin WdgM_SupervisedEntityIdType u8LocalSEID, argin WdgM_CheckpointIdType u16LocalCheckpointID);|FCT1.3|PFCMNG|0|V02 NT 11 06115||||0|0|0|0|Cette fonction incrémente le nombre de checkpoints automatiquement après chaque appel de l'événement checkpoint.|
PFCMNG_vidInit|B|();|FCT1.2|PFCMNG|0|V02 NT 11 06115||||0|0|0|0|Cette fonction configure le nombre de SEID, le nombre de checkpoints et le timeout.|
PFCMNG_vidInitOutput|A|();|FCT1.1|PFCMNG|0|V02 NT 11 06115||||0|0|0|0|Initialisation des sorties|
PFCMNG_vidStatus|C|();|FCT1.4|PFCMNG|0|V02 NT 11 06115||||0|0|0|0|A diagnosis concerning the logical sequence errors and sequence timeout errors is realized for each SEID. If the status is NOK, a failure flag is set to 1.|
PFUACQ_vidCoherencyDiagnosis|B|();|FCT2.1|PFUACQ|0|PTS_DOC_6851391||||0|0|0|0|The raw voltage sent by the rail pressure sensor is compared to a high and a low thresholds. If this voltage is not included between these two thresholds, a failure flag is sent.|
PFUACQ_vidElectrical_Diagnosis|E|();|FCT1.6|PFUACQ|0|PTS_DOC_6851391||||0|0|0|0|The raw voltage sent by the rail pressure sensor is compared to a high and a low thresholds. If this voltage is not included between these two thresholds, a failure flag is sent.|
PFUACQ_vidInit|C|();|FCT1.2|PFUACQ|0|PTS_DOC_6851391||||0|0|0|0|All rail pressure information are initialized to atmospheric pressure.|
PFUACQ_vidInitOutputs|D|();|FCT1.1|PFUACQ|0|PTS_DOC_6851391||||0|0|0|0|output's initialization|
PFUACQ_vidInj|E|();|FCT1.3|PFUACQ|0|PTS_DOC_6851391||||0|0|0|0|The rail pressure is realized on SdlFast if the engine is not running or at INJ event when the engine is running. The voltage sent by the sensor is normalized and converted in pressure|
PFUACQ_vidPrevEveInjPressureVal|C|();|FCT1.9|PFUACQ|0|PTS_DOC_6851391||||0|0|0|0|We calculate the previous value of the rail pressure at INJ event and on SdlFast if the engine is not running.|
PFUACQ_vidPrevRailSplPressureVal|C|();|FCT1.10|PFUACQ|0|PTS_DOC_6851391||||0|0|0|0|We calculate the previous value of the rail pressure at « spill event » and on SdlFast if the engine is not synchronized.|
PFUACQ_vidRailInjPressureTreat|D|();|FCT1.7|PFUACQ|0|PTS_DOC_6851391||||0|0|0|0|When there is no failure, the strategy sends the measured and filtered value.  If a failure is detected on the rail pressure information, the acquisition is frozen. The pressure value return by the strategy is the last correct value.|
PFUACQ_vidRailPressureDiagnosis|F|();|FCT1.5|PFUACQ|0|PTS_DOC_6851391||||0|0|0|0|The rail pressure sensor is realized if there is no confirmed failure on the rail pressure.|
PFUACQ_vidRailSplPressureTreat|D|();|FCT1.8|PFUACQ|0|PTS_DOC_6851391||||0|0|0|0|When there is no failure, the strategy sends the measured and filtered value.  If a failure is detected on the rail pressure information, the acquisition is frozen. The pressure value return by the strategy is the last correct value.|
PFUACQ_vidSpill|E|();|FCT1.4|PFUACQ|0|PTS_DOC_6851391||||0|0|0|0|The rail pressure is realized on SdlFast if the engine is not synchronized or at “spill event” when the engine is synchronized. The voltage sent by the sensor is normalized and converted in pressure|
PFuCtl_EveRst_HPPmpActCmd|E|();|SCH.1|HPPMPACTCMD|1|PTS_DOC_6882952||||0|0|0|0|Evénement reset du calculateur|
PFuCtl_EveRst_HPPmpActCmdAcq|A|();|SCH.2|HPPMPACTCMDACQ_DT|1|PTS_DOC_6882935||||0|0|0|0|Reset Event for HPPmpActCmd|
PFuCtl_EveRTSt_HPPmpActCmd|F|();|SCH.3|HPPMPACTCMD|1|PTS_DOC_6882952||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant|
PFuCtl_EveRTSt_HPPmpActCmdAcq|A|();|SCH.1|HPPMPACTCMDACQ_DT|1|PTS_DOC_6882935||||0|0|0|0|Rot-to-Stall Event for HPPmpActCmd|
PFuCtl_EveSpl_HPPmpActCmd|J|();|SCH.4|HPPMPACTCMD|1|PTS_DOC_6882952||||0|0|0|0|Evènement "spill event" pour la commande pompe carburant HP|
PFuCtl_EveSpl_HPPmpActCmdAcq|A|();|SCH.3|HPPMPACTCMDACQ_DT|1|PTS_DOC_6882935||||0|0|0|0|Spill Event for HPPmpActCmd|
PFuCtl_EveStTR_HPPmpActCmd|E|();|SCH.5|HPPMPACTCMD|1|PTS_DOC_6882952||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant|
PFuCtl_EveStTR_HPPmpActCmdAcq|A|();|SCH.4|HPPMPACTCMDACQ_DT|1|PTS_DOC_6882935||||0|0|0|0|Stall-to-Rot Event for HPPmpActCmd|
PFuCtl_SdlFast_HPPmpActCmdAcq|A|();|SCH.5|HPPMPACTCMDACQ_DT|1|PTS_DOC_6882935||||0|0|0|0|Fast scheduler for HPPmpActCmd|
PFuCtl_SdlMid_HPPmpActCmd|D|();|SCH.2|HPPMPACTCMD|1|PTS_DOC_6882952||||0|0|0|0|Moniteur moyen de la fonction de régulation de la pression rail|
PFuCtl_SdlMid_HPPmpActCmdDiag|A|();|SCH.8|ACQDGOHAL_DT|1|PTS_DOC_6854092||||0|0|0|0|Intermediate scheduler for HPPmpActCmd|
PMPHAL_udtEnableSpillCommand|A|func_PMPHAL_udtEnableSpillCommand|11|HEADER|1|NONE||||0|0|0|0||
PMPHAL_udtSwitchHppProfile|A|Func_PMPHAL_udtSwitchHppProfile|6|HEADER|1|NONE||||0|0|0|0||
PMPHAL_udtWriteSpillCmdLevel|A|Func_PMPHAL_udtWriteSpillCmdLevel|10|HEADER|1|NONE||||0|0|0|0||
PMPHAL_vidDisable|A|();|2|HEADER|1|NONE||||0|0|0|0||
PMPHAL_vidEnable|A|();|1|HEADER|1|NONE||||0|0|0|0||
PMPHAL_vidWriteDecelHppProfilDly|A|(argin uint32 u32ProfilSwitchDelay);|8|HEADER|1|NONE||||0|0|0|0||
PMPHAL_vidWriteSpillCmdAngle|A|(argin uint16 u16SpillCmdAngle);|4|HEADER|1|NONE||||0|0|0|0||
PMPHAL_vidWriteSpillCmdTime|A|(argin uint32 u32CommandTime);|5|HEADER|1|NONE||||0|0|0|0||
PMPHAL_vidWriteSpillDecelDly|A|(argin uint32 u32SpillDecelDelay);|6|HEADER|1|NONE||||0|0|0|0||
PMPHAL_vidWriteSpillDecelTime|A|(argin uint32 u32DecelTime);|7|HEADER|1|NONE||||0|0|0|0||
POSTEQUSRV_vidDataVerification|A|();|FCT1.3|POSTEQUSRV|0|PTS_DOC_5074440||||0|0|0|0|ECU checks during the writing request of data in memory that index received matches with the index in memory.|
POSTEQUSRV_vidInfoWrite|A|();|FCT1.5|POSTEQUSRV|0|PTS_DOC_5074440||||0|0|0|0|If the input state is SRV_POSTEQUECU_WRITE, incoming data have been confirmed and can be taken into account.|
POSTEQUSRV_vidInitEEP|A|();|FCT1.2|POSTEQUSRV|0|PTS_DOC_5074440||||0|0|0|0|At init, datas are read from EEPROM|
POSTEQUSRV_vidInitOutput|A|();|FCT1.1|POSTEQUSRV|0|PTS_DOC_5074440||||0|1|0|0|Output initialization function.|
POSTEQUSRV_vidReInit|A|();|FCT1.7|POSTEQUSRV|0|PTS_DOC_5074440||||0|0|0|0|In case of a writing default, the values are set at the default values and saved in EEPROM.|
POSTEQUSRV_vidVarCodMng|A|();|FCT1.4|POSTEQUSRV|0|PTS_DOC_5074440||||0|1|0|0|function describing the post equipment process|
POSTEQUSRV_vidWrite|A|();|FCT1.6|POSTEQUSRV|0|PTS_DOC_5074440||||0|0|0|0|this function save data in EEPROM|
PredEs_Sdl10ms_PredEs|C|();|SCH.2|PREDES|1|PTS_DOC_5141019||||0|0|0|0|Accroche moniteur 10 ms.|
PREDES_vidActCalStrtEngaAuthrEng|B|();|FCT1.3|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block disables the function calculation, if the engine speed is higher than a threshold.|
PREDES_vidCalcCrkPosBfrEngDirChg|C|();|FCT3.5|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block calculates the covered angle between the last crankshaft edge preceding the first predicted crankshaft direction change and the first crankshaft direction change.|
PREDES_vidCalcDlyBtwEngSpdNCrtTi|C|();|FCT2.9|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block evaluates the duration between the last instantaneous engine speed calculation and the current function call (current time).|
PREDES_vidCalcInfEstTiBtwPrdNBfN|D|();|FCT2.7|PREDES|0|PTS_DOC_5141019||||0|0|0|0|The block outputs are used to calculate the delay between the last crankshaft signal falling edge and the current function call.|
PREDES_vidCalcInstEngSpdNFillBfr|C|();|FCT2.5|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block calculates the instantaneous engine speeds (with a range of18°Ck), before records its.|
PREDES_vidCalcPredictionSetpts|C|();|FCT2.6|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block calculates the delay of instantaneous engine speed, due to: The calculation delay of the instantaneous engine speed and  the delay between the last crankshaft signal edge and the engine speed prediction|
PREDES_vidCalcStrtEngaAuthrEng|C|();|FCT1.4|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This bloc calculates the starter engagement authorization.|
PREDES_vidCalcStrtrEngaAfrEngDir|C|();|FCT1.6|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block checks if the engine speed is good to request an engagement during oscillations engine (before final engine stop).|
PREDES_vidCalcStrtrEngaBfrEngDir|C|();|FCT1.9|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block checks during deceleration phase (Before engine direction change), if the engine speed is good to request an engagement.|
PREDES_vidCalculateIncrementStep|B|();|FCT3.3|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block calculates the teeth number to foresee. Also, the increment between two call loop is determined.|
PREDES_vidCalculatPredictionTime|B|();|FCT3.6|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block evaluates:- The instantaneous engine speed and the previous one, - The matching prediction durations|
PREDES_vidCalEngSpdLnkWthWhilInc|B|();|FCT3.4|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block predicts the square engine speed after PredEs_noTrigCor crankshaft signal teeth.|
PREDES_vidChkCondToEngagAreFlfld|E|();|FCT4.4|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block informs that the engine speed will have the aspects to request a starter engagement.|
PREDES_vidChkEngSpdToEngageStrtr|B|();|FCT3.9|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block guarantees the engine speed ranges between 2 threshold engine speed (Minimal and maximal engagement engine speed).|
PREDES_vidChkIfCndToFilbfrRFlfld|C|();|FCT1.10|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block checks if the conditions are present to fill the instantaneous engine speed buffer (mainly during a stop engine STT request).|
PREDES_vidCoordinatWhileLoopPrt1|C|();|FCT3.2|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block creates the flowing information:- The calculation activation of the predicted variables, - The called prediction calculation, - The stop condition of the while loop|
PREDES_vidCoordinatWhileLoopPrt2|C|();|FCT3.7|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block creates the flowing information:- The calculation activation of the predicted variables, - The called prediction calculation, - The stop condition of the while loop|
PREDES_vidCorrectPredictionTime|C|();|FCT2.10|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block corrects the prediction times and engine speed values. Also, the engine speed offset is estimated to correct the engine model.|
PREDES_vidCorrOutIfCalcDisabled|B|();|FCT4.7|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block disables the engagement authorization if the engine speed is higher than a threshold.|
PREDES_vidCreatLvlBtw6DgrVarNFct|D|();|FCT1.5|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block is a layer to check value of the variables updated every crankshaft signal falling edge (With software like INCA).|
PREDES_vidCrtLogDatToCalcInstSpd|D|();|FCT2.4|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block informs if the engine is in the crankshaft signal tooth.|
PREDES_vidCrtNumDatToCalcInstSpd|B|();|FCT2.3|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block gives: - The instantaneous engine speed number to record in the buffer, - The current crankshaft tooth type., - The buffer address to record the engine speed.|
PREDES_vidDetectSmallEngSpdOsc|B|();|FCT1.7|PREDES|0|PTS_DOC_5141019||||0|0|0|0|The maximal engine speed is recorded during the negative oscillations. If the recorded maximal engine speed is slower than maximal engagement engine speed, then an engagement request authorization is valid.|
PredEs_vidEntryInit|C|();|SCH.1|PREDES|1|PTS_DOC_5141019||||0|0|0|0|Événement reset calculateur.|
PREDES_vidEstimatCorrectedEngSpd|B|();|FCT4.3|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block calculates the current engine speed in case of the current engine speed with delay compensation is invalid.|
PREDES_vidEstmTibtwPrdEsNBufNEs|C|();|FCT2.8|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block evaluates the duration between the function call (current time) and the last crankshaft signal falling edge.|
PREDES_vidEvaluatCorEngSpdValdty|C|();|FCT4.2|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block evaluates the current engine speed validity (with delay correction).|
PREDES_vidFillInstanEngSpdBuffer|B|();|FCT2.1|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block creates a buffer of instantaneous engine speed.|
PREDES_vidFormatInformation|C|();|FCT4.1|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block calculates several variables:- The current engine speed, - The current engine speed validity, - The offset time to compensate the prediction setpoints, - And mainly, the engagement authorization before the first engine direction change|
PREDES_vidGlobalView|C|();|FCT1.2|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block indicates if a starter engagement could be requested.|
PREDES_vidInitOutput|F|();|FCT1.1|PREDES|0|PTS_DOC_5141019||||0|0|0|0|Fonction initialisation.|
PREDES_vidMergThe2Authorizations|B|();|FCT4.6|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block merges information:- First one created during the engine stop before the change of the rotation direction, - Second one created during the engine stop after the change of the rotation direction|
PREDES_vidPredictEngineSpeed|C|();|FCT3.1|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block calculates with loop the following variables:- The engine speeds for the current time, - If the engine speed is ranged from the minimal to the maximal engagement engine speed, - If the predicted engine speed with maximal duration has been made|
PREDES_vidPredictEngSpdForDefiTi|B|();|FCT3.8|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block interpolates 3 times the engine speed with:- The engine speed predicts for a time smaller than the setpoint duration, - The predicted engine speed for a time higher than the setpoint duration|
PREDES_vidSetRelSecEngAuthorize|A|();|FCT4.8|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This function verifies the second engagement authorization is correct.|
PREDES_vidSetRlbleEngagemntAuthr|C|();|FCT4.5|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block verifies the engagement authorization is correct.|
PREDES_vidSetSmallEngSpdOscDtct|B|();|FCT1.8|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block checks, if the previous block request is valid. If errors occur, then this starter engagement request during engine oscillations is disabled.|
PREDES_vidSlctTiBtwCrkshftTeeth|B|();|FCT2.2|PREDES|0|PTS_DOC_5141019||||0|0|0|0|This block gives: - The 3 last tooth period, - A counter increasing for every crankshaft signal falling edge|
PREDESCHG_vidEffectCalcRegInsta|C|();|FCT1.4|PREDESCHG|0|V02 NT 10 02549||||0|0|0|0|Ce bloc permet de calculer le régime instantané.|
PREDESCHG_vidEffectSwitchCasVie|A|();|FCT1.5|PREDESCHG|0|V02 NT 10 02549||||0|0|0|0|Ce bloc permet de donner une valeur définie aux variables régime instantané, validité de la variable de régime instantané, angle d’arrêt moteur et son incertitude et validité des variables d’angle d’arrêt moteur selon les informations disponibles.|
PREDESCHG_vidEntry_10ms|B|();|SCH.2|PREDESCHG|1|V02 NT 10 02549||||0|0|0|0|Evènement de récurrence du module PREDESCHG|
PREDESCHG_vidEntryInit|B|();|SCH.1|PREDESCHG|1|V02 NT 10 02549||||0|0|0|0|Evènement de Reset|
PREDESCHG_vidInhibCalcRegHautReg|A|();|FCT1.3|PREDESCHG|0|V02 NT 10 02549||||0|0|0|0|Ce bloc permet d’activer ou pas le calcul du régime rapide. Ce calcul est effectué en  dessous d’un seuil de régime calibrable. Cela permet d’optimiser la fonction en ne  l’activant pas dans les phases de vie non utiles (à haut régime).|
PREDESCHG_vidInitOutput|A|();|FCT1.1|PREDESCHG|0|V02 NT 10 02549||||0|0|0|0|Initialisation des sorties et des variables internes.|
PREDESCHG_vidPredEsChgDraft|A|();|FCT1.2|PREDESCHG|0|V02 NT 10 02549||||0|0|0|0|Cette fonction permet d’effectuer la sélection de l’information dans les différents cas de  vie (Moteur en phase de coupure moteur, moteur à l’arrêt).|
PRESDIAGCOH_vidAtmospherPSDrift|B|();|FCT1.10|PRESDIAGCOH|0|V02 NT 12 01298||||0|0|0|0|Calcule de la dérive négative et positive du capteur de pression atmosphérique.|
PRESDIAGCOH_vidCalcPresureDrifts|A|();|FCT1.8|PRESDIAGCOH|0|V02 NT 12 01298||||0|0|0|0|Calcule des différences absolues entre les trois pressions: Pression d'huile, pression d'étranglement en amont, et la pression atmosphérique.|
PRESDIAGCOH_vidCohDiagEnaCond|A|();|FCT1.6|PRESDIAGCOH|0|V02 NT 12 01298||||0|0|0|0|Calcule de  DgSen_bAcvCohDiagPresSen, booléen d'activation du diagnostic de cohérence de pression|
PRESDIAGCOH_vidCoherenciesDiag|A|();|FCT1.7|PRESDIAGCOH|0|V02 NT 12 01298||||0|0|0|0|Calcule des différences absolues entre les trois pressions.  Détection des dérives des capteurs de pressions|
PRESDIAGCOH_vidCounterKeyOn|A|();|FCT1.3|PRESDIAGCOH|0|V02 NT 12 01298||||0|0|0|0|Incrémentation du compteur  Oil_ctKeyOn_Counter, à chaque KeyOn.|
PRESDIAGCOH_vidInhDiagSecKeyOn|C|();|FCT1.4|PRESDIAGCOH|0|V02 NT 12 01298||||0|0|0|0|Le compteur Oil_ctKeyOn_Counter est initialisé à zéro,lorsque l'état de l'engin est différent de l'état stop. Après un Premier démarrage du moteur, une inhibition est envoyé|
PRESDIAGCOH_vidInitialization|A|();|FCT1.2|PRESDIAGCOH|0|V02 NT 12 01298||||0|0|0|0|Les variables Oil_ctKeyOn, Oil_ctKeyOn_Prev et Oil_bInhDiagSecondKOn sont initialisées à zéro lors de l'événement Reset.|
PRESDIAGCOH_vidInitOutput|B|();|FCT1.1|PRESDIAGCOH|0|V02 NT 12 01298||||0|0|0|0|Initialisation des sorties du module PRESDIAGCOH.|
PRESDIAGCOH_vidOilPSDrift|B|();|FCT1.9|PRESDIAGCOH|0|V02 NT 12 01298||||0|0|0|0|Calcule de la dérive négative et positive du capteur de la pression d'huile.|
PRESDIAGCOH_vidPressureDiagnosis|A|();|FCT1.5|PRESDIAGCOH|0|V02 NT 12 01298||||0|0|0|0|Définition du diagnostic de cohérence de pression.  Activation des capteurs de diagnostic de cohérence de pression correspondants|
PRESDIAGCOH_vidUpstrmThrPSDrift|B|();|FCT2.1|PRESDIAGCOH|0|V02 NT 12 01298||||0|0|0|0|Calcule de la dérive négative et positive  du capteur de pression d'étranglement amont.|
PROPFUPMP_vidCmdPropFuPmp|C|();|FCT1.3|PROPFUPMP|0|PTS_DOC_6562300||||0|0|0|0|The PWM signal request is linearized then sent to the BSW. If the actuator test is in progress, then it’s the actuator test set point value which is sent to the BSW.
PROPFUPMP_vidCmdPropFuPmpNull|C|();|FCT2.1|PROPFUPMP|0|PTS_DOC_6562300||||0|0|0|0|When Ctrl_bAcv_FuTnkPmp = 0  a Null PWM command is sent.
PROPFUPMP_vidDiag_rSt|C|();|FCT1.9|PROPFUPMP|0|PTS_DOC_6562300||||0|0|0|0|The diagnosis results depend on the status of the PWM and on the frequency of diagnosis signal.
PROPFUPMP_vidDiagPropFuPmp|A|();|FCT1.5|PROPFUPMP|0|PTS_DOC_6562300||||0|0|0|0|According to the PWM and the frequency of the diagnosis signal of proportional fuel pump sent by the BSW, we determine the pump status.
PROPFUPMP_vidInit|D|();|FCT1.1|PROPFUPMP|0|PTS_DOC_6562300||||0|0|0|0|The following outputs Ext_rFlowFuTnkPmp and Ext_stDftFuTnkPmp are initialized at event reset. The command frequency of proportional fuel pump is sent to BSW only at reset event of ECU.
PROPFUPMP_vidInitOutput|B|();|FCT1.2|PROPFUPMP|0|PTS_DOC_6562300||||0|0|0|0|initialisation des sorties.
PROPFUPMP_vidPropFuPmp_DiagHw|C|();|FCT1.4|PROPFUPMP|0|PTS_DOC_6562300||||0|0|0|0|The driver electrical diagnosis results are directly sent by the BSW. The authorization flow for the electrical diagnosis are set to 1, if there is no diagnosis inhibition requested and if the power command relay is closed.
PROPFUPMP_vidPropFuPmp_Sel|A|();|FCT1.10|PROPFUPMP|0|PTS_DOC_6562300||||0|0|0|0|If a failure is detected on the diagnosis signal, the pump status is frozen to its last valid value. If a failure is confirmed, the status is set to a recovery value.
PROPFUPMP_vidPropFuPmpDiag_Acq|A|();|FCT1.6|PROPFUPMP|0|PTS_DOC_6562300||||0|0|0|0|The BSW send the value of PWM and the frequency of the diagnosis signal of the proportional fuel pump.
PROPFUPMP_vidPropfuPmpDiag_Conv|A|();|FCT1.7|PROPFUPMP|0|PTS_DOC_6562300||||0|0|0|0|The proportional fuel pump status is built from the PWM sent by the MJP module using the following cartography.
PROPFUPMP_vidPropFuPmpDiag_Diag|A|();|FCT1.8|PROPFUPMP|0|PTS_DOC_6562300||||0|0|0|0|The diagnosis are authorized if there is no inhibition requested and if the power command relay is closed since a calibrated time.
PROTDFTLCLC_vidCoordCouplLimit|A|();|FCT2.4|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc coordonne les limitations. Le couple CoPt_tqEfcMaxProtDftl de sortie de la spécification répond au besoin de protection du différentiel et au besoin de protection contre la surchauffe des freins.|
PROTDFTLCLC_vidDetActLimitCouple|A|();|FCT1.9|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc détermine l’activation de la protection du différentiel. La protection peut être inhibée par une calibration.|
PROTDFTLCLC_vidDetCoupleCouronne|A|();|FCT1.4|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc détermine le couple couronne à partir du taux de conversion de couple et du couple moteur réel.|
PROTDFTLCLC_vidDetCoupleLimitMot|A|();|FCT2.2|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc détermine la limitation de couple moteur pour la protection du différentiel. Il est calculé à partir du couple roue de limitation et du taux de conversion de couple.|
PROTDFTLCLC_vidDetCoupleLimitRou|A|();|FCT2.1|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc détermine le couple roue de limitation à partir du régime différentiel des roues motrices et du taux de sollicitation énergétique du différentiel.|
PROTDFTLCLC_vidDetCoupleProtDiff|A|();|FCT1.10|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc détermine la limitation de couple applicable si la protection du différentiel est  activée. La fonction se décompose en 2 blocs : Calcul de la limitation de couple à la roue, Calcul de la limitation de couple moteur.|
PROTDFTLCLC_vidDetCouplProtFrein|A|();|FCT2.3|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc détermine le couple de protection contre la surchauffe freins. Ce couple est fonction du régime moteur et du rapport de boite engagé. Il est filtré et prend la valeur de 2000 Nm lorsque la protection des freins est inactive.|
PROTDFTLCLC_vidDetEnergieCourant|A|();|FCT1.3|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc détermine les composantes énergétiques. La fonction se décompose en 4 blocs : Déterminer le couple couronne, Estimer le régime différentiel des roues motrices,  Déterminer la puissance, Déterminer l’énergie.|
PROTDFTLCLC_vidDeterminerEnergie|A|();|FCT1.7|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc détermine l’énergie dans le différentiel ainsi que l’énergie « exceptionnelle » du différentiel.|
PROTDFTLCLC_vidDetPuissance|A|();|FCT1.6|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc détermine la puissance fournie par le moteur au différentiel. Cette puissance est égale au produit du couple couronne et du régime différentiel des roues motrices.|
PROTDFTLCLC_vidEntryInit|A|();|SCH.1|PROTDFTLCLC|1|V02 NT 11 04686||||0|0|0|0|Evénement reset du calculateur.|
PROTDFTLCLC_vidEstimerRegimeDiff|A|();|FCT1.5|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc convertit les vitesses roues en régimes roues pour déterminer le régime différentiel des roues motrices ainsi que le régime moyen des roues arrière.|
PROTDFTLCLC_vidEstimSollicit|A|();|FCT1.8|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc calcule la sollicitation énergétique du différentiel.|
PROTDFTLCLC_vidEstimSollicitDiff|A|();|FCT1.2|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Ce bloc estime les sollicitations du différentiel. La fonction se décompose en 2 blocs:Déterminer l’énergie courante dans le différentiel, Estimer la sollicitation énergétique du différentiel par rapport à son énergie maximale admissible.|
PROTDFTLCLC_vidInitOutput|A|();|FCT1.1|PROTDFTLCLC|0|V02 NT 11 04686||||0|0|0|0|Initialisation des sorties|
PROTMANCLU_vidActivationProtect|A|();|FCT3.9|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function enables some clutch protections.|
PROTMANCLU_vidActivOfProtection|A|();|FCT4.4|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function enables 4 clutch protections.|
PROTMANCLU_vidActivProtections|A|();|FCT4.3|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function enables 3 clutch protections and a diagnostic code.|
PROTMANCLU_vidCalcCoefConParm|A|(argin uint16 u16FirstCalib, argin uint16 u16SecondCalib, argin uint8 u8Interp1d)argout uint16 ;|FCT2.6|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This generic function calculates the coefficients of convective heat exchanges.|
PROTMANCLU_vidCalcCoefConvHeatex|A|();|FCT2.5|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function calculates the coefficients of convective heat exchanges.|
PROTMANCLU_vidCalcDelLowHighEngy|A|();|FCT2.4|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function calculates the differences of dissipated energies between the dissipated energies for the lowest gearbox ratio and the dissipated energies for the highest gearbox ratio.|
PROTMANCLU_vidCalcDelLowMidEnrgy|A|();|FCT2.3|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function calculates the differences of dissipated energies between the dissipated energies for the lowest gearbox ratio and the dissipated energies for the middle gearbox ratio.|
PROTMANCLU_vidCalcDisPowerLowRat|A|();|FCT2.2|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function calculates the dissipated powers for the lowest gearbox ratio.|
PROTMANCLU_vidCalcGradclutchTemp|A|();|FCT3.10|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function calculates the gradient of the clutch friction pad temperature.|
PROTMANCLU_vidCalculationOffsets|A|();|FCT4.1|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function calculates 3 negative temperature offsets.|
PROTMANCLU_vidCalculPreviousTemp|A|();|FCT3.7|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function calculates 5 previous estimated temperatures.|
PROTMANCLU_vidCalculPrevTempInit|A|();|FCT3.8|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function calculates 5 estimated initial temperatures.|
PROTMANCLU_vidCalDelEngPrimshaft|A|();|FCT2.1|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function calculates the difference of rotation speed between the primary shaft rotation speed and the engine rotation speed.|
PROTMANCLU_vidClutch_Protection|B|();|FCT1.2|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function contains  4 subsystems.|
PROTMANCLU_vidConvTemperToKelvin|A|();|FCT2.7|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function  converts the temperatures to Kelvin unit.|
PROTMANCLU_vidDeactvEngRotSpdctr|A|();|FCT4.2|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function disables the protection by regulation of the engine rotation speed in two cases: if the ASR controls the engine rotation speed or if the chassis functions controls the engine rotation speed.|
PROTMANCLU_vidDetermStateClutch|A|();|FCT1.5|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This Function determines the different states of the clutch.|
PROTMANCLU_vidDeterStatesClutch|A|();|FCT1.3|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This Function determines the different states of clutch and it calculates the torque transmitted by the clutch.|
PROTMANCLU_vidDeterTripltGearbox|A|();|FCT1.7|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This Function defines three gearbox ratios which are susceptible to be engaged.|
PROTMANCLU_vidEntryInit|A|();|SCH.1|PROTMANCLU|1|V02 NT 11 04687||||0|0|0|0|Initialization function.|
PROTMANCLU_vidEstimClutchBellTmp|B|();|FCT3.4|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function estimates the temperature of the clutch bell.|
PROTMANCLU_vidEstimClutchPlatTmp|B|();|FCT3.2|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function estimates the temperature of the clutch plate.|
PROTMANCLU_vidEstimClutchTemp|A|();|FCT3.1|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function  estimates the temperature of clutch friction pad.|
PROTMANCLU_vidEstimClutchTemper|A|();|FCT1.8|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This Function calculates the temperature of clutch friction pad .|
PROTMANCLU_vidEstimDissipatEnerg|A|();|FCT1.10|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function  calculates the heat around the clutch.it calculates the dissipated energies and the coefficients of convective heat transfers and converts the temperatures to Kelvin unit.|
PROTMANCLU_vidEstimGearboxTemp|B|();|FCT3.6|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function calculates the temperature of the gearbox.|
PROTMANCLU_vidEstimHeatArdClutch|A|();|FCT1.9|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This Function calculates the heat around the clutch.|
PROTMANCLU_vidEstimHousClutchTmp|B|();|FCT3.5|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function estimates the temperature of the clutch housing.|
PROTMANCLU_vidEstimTempOfClutch|B|();|FCT3.3|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function estimates the temperature of the clutch friction pad.|
PROTMANCLU_vidEstimTorqTransClut|A|();|FCT1.4|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This Function calculates the torque transmitted by the clutch.|
PROTMANCLU_vidInitOutput|B|();|FCT1.1|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|Initialization of internals and outputs.|
PROTMANCLU_vidOutput_managment|A|();|FCT4.6|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function manages outputs.|
PROTMANCLU_vidReconfigProtActiv|A|();|FCT4.5|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function reconfigures 4 clutch protections. It also activates: a boolean giving the damaging diagnostic and a boolean for monitoring activation.|
PROTMANCLU_vidReconfTorqTransClu|A|();|FCT1.6|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This Function  reconfigures the torque transmitted by the clutch.|
PROTMANCLU_vidSelectEnergyInject|A|();|FCT2.8|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function  selects the energy to inject.|
PROTMANCLU_vidSelectEnergyToInj|A|();|FCT2.10|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This Function selects the dissipated power to inject.|
PROTMANCLU_vidSelectGearboxRatio|A|();|FCT2.9|PROTMANCLU|0|V02 NT 11 04687||||0|0|0|0|This function selects a gearbox ratio among three gearbox ratios.|
PTMHAL_u8GetAllPacksDuration|A|(argin uint8 u8MaxTableSize,argio uint32 *pau32PacksDurationTable)uint8;|3|HEADER|1|NONE||||0|0|0|0||
PTMHAL_udtDisable|A|()Std_ReturnType;|2|HEADER|1|NONE||||0|0|0|0|API permet de stopper les ressources utilisées pour la fonction. Renvoie toujours E_OK|
PTMHAL_udtEnable|A|()Std_ReturnType;|1|HEADER|1|NONE||||0|0|0|0|API permet de  mettre la fonctionnalité en marche|
PWDHAL_udtWriteTimeoutValue|A|(argin uint8 u8Channel, argin PWDHAL_tudtTimeoutType udtTimeoutValue ) Std_ReturnType;|0x04|HEADER|1|NONE||||0|0|0|0|
PWDHAL_vidEnable|A|(argin uint8 u8Channel);|0x01|HEADER|1|NONE||||0|0|0|0|PWDHAL_vidEnable enables the work of the PWD for demodulating the PWM signal of the <u8Channel>.
PWDHAL_vidGetSignalInfo|A|(uint8 u8Channel, uint32 *pu32Period, uint16 *pu16DutyCycle);|0x02|HEADER|1|NONE||||0|0|0|0|
PWMHAL_udtWriteDutyCycle|A|func_PWMHAL_udtWriteDutyCycle|0x01|PWMHAL|1|PTS_DOC_5139092||||0|0|0|0|Set duty cycle to the value set by upper layer.
PWMHAL_udtWriteFrequency|A|func_PWMHAL_udtWriteFrequency|0x02|PWMHAL|1|PTS_DOC_5139092||||0|0|0|0|Set frequency to the value set by upper layer.
PWMHAL_vidInit|A|();|0x00|PWMHAL|1|PTS_DOC_5139092||||0|0|0|0|Initialization of PWMHAL internal variables and commanding of PWM output using initial settings
PWMHAL_vidWrite|A|(argin PWMHAL_tudtChannel udtChannel, argin PWMHAL_tudtDutyCycle udtDutyCycle);|2|HEADER|1|NONE||||0|0|0|0||
PWMHAL_vidWriteFrequency|A|(argin PWMHAL_tudtChannel udtChannel, argin PWMHAL_tudtFrequency udtFrequency);|1|HEADER|1|NONE||||0|0|0|0||
Pwr_EveInj_BattVotlAcq|C|();|SCH.3|BATTVOLTACQ|1|PTS_DOC_6547150||||0|0|0|0|Evenenement d'injection.
Pwr_EveInj_BattVotlAcqAdc|A|();|SCH1.7|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Evenenement d'injection
Pwr_EveRst_Acq|C|();|SCH.1|PWRSEN_ACQ|1|PTS_DOC_6538484||||0|0|0|0|Evénement reset du calculateur
Pwr_EveRst_AcqAdc|A|();|SCH1.2|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Evénement reset du calculateur
Pwr_EveRst_BattVoltAcq|E|();|SCH.1|BATTVOLTACQ|1|PTS_DOC_6547150||||0|0|0|0|Evènement reset
Pwr_EveRst_BattVoltAcqAdc|A|();|SCH1.5|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Evènement reset
Pwr_EveRst_BattVoltAcqIf|B|();|SCH4.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement reset|
Pwr_EveRst_FuSysBattVoltAcqIf|D|();|SCH4.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset de module d'interface.|
Pwr_Sdl2ms_BattVotlAcq|C|();|SCH.4|BATTVOLTACQ|1|PTS_DOC_6547150||||0|0|0|0|Scheduler à 2ms.
Pwr_Sdl2ms_BattVotlAcqAdc|A|();|SCH1.8|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Scheduler à 2ms
Pwr_SdlFast_Acq|C|();|SCH.2|PWRSEN_ACQ|1|PTS_DOC_6538484||||0|0|0|0|Moniteur rapide de la fonction ALIM capteurs
Pwr_SdlFast_AcqAdc|A|();|SCH1.4|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur rapide de la fonction ALIM capteurs
Pwr_SdlFast_BattVoltAcq|E|();|SCH.2|BATTVOLTACQ|1|PTS_DOC_6547150||||0|0|0|0|Moniteur rapide de la fonction power
Pwr_SdlFast_BattVoltAcqAdc|A|();|SCH1.6|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur rapide de la fonction power
Pwr_SdlFast_BattVoltAcqIf|B|();|SCH10.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide de la fonction power|
Pwr_SdlMid_Acq|C|();|SCH.3|PWRSEN_ACQ|1|PTS_DOC_6538484||||0|0|0|0|Moniteur d'acquistion de la tension ALIM
Pwr_SdlMid_AcqAdc|A|();|SCH1.3|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur d'acquistion de la tension ALIM
Pwr_SdlMid_CmdDiagDmtr|A|();|SCH2.2|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Moniteur moyen de la fonction DMTR.
Pwr_SdlMid_VoltHldDev|B|();|SCH.2|VSSNWDMTRACV|1|PTS_DOC_6525894||||0|0|0|0|Moniteur moyen
Pwr_SdlMid_VoltHldDevDio|A|();|SCH1.7|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Moniteur moyen.
PWRLMRK_vidDiagPwrlMrk|A|();|FCT1.5|PWRLMRK|0|V02 NT 11 04404||||0|0|0|0|Si l'état de marqueur de power latch : EcuSt_SrvPwrlSt est 0 (pas réalisé), alors par défaut un signal est envoyé  pour indiquer que le power latch n'a pas encore été réalisé avec succès, et MIL est allumé.|
PWRLMRK_vidEepromWrOfPwrlMrk|B|();|FCT1.4|PWRLMRK|0|V02 NT 11 04404||||0|0|0|0|Si l'écriture dans l'EEPROM est finie (EcuSt_FinWrEepromTemp = 1), l'état du marqueur de power latch est positionné sur réalisé (Ecust_SrvPwrlSt = 1). Cet état est écrit directement dans la mémoire EEPROM.|
PWRLMRK_vidEveRstPwrlMrk|A|();|FCT1.1|PWRLMRK|0|V02 NT 11 04404||||0|0|0|0|Dans le reset, le diagnostic est déclenché si la valeur écrite dans l'EEPROM du "EcuSt_SrvPwrlSt" est 0 (premier PWL n'est pas réalisé). Si la valeur est définie à 1 (PWL réalisé) le diagnostic ne sera pas lancé.|
PWRLMRK_vidInitPwrlMrk|A|();|FCT1.2|PWRLMRK|0|V02 NT 11 04404||||0|0|0|0|Le drapeau «EcuSt_SrvPwrlSt«  est mis à 0 quand une demande de réinitialiser le marqueur power latch est transmise par l'outil AFT«Srv_EveRcReinit_PwrlMrk '= 1). Sur cet événement,on écrit l'état du le marqueur power latch (0 = Non éalisé) dans l'EEPROM.|
PWRLMRK_vidPwrlMrk|A|();|FCT1.3|PWRLMRK|0|V02 NT 11 04404||||0|0|0|0|L'événement «EcuSt_EveFct_WaitForPwrl« est lancé de manière récurrente lors de la phase de power latch.|
PwrlRly_EveKOf_IfCmdDiag|A|();|SCH.2|PWRLRLY|1|PTS_DOC_6559340||||0|0|0|0|Evènement associé au passage de clef ON à clef OFF
PwrlRly_EveKOf_IfCmdDiagDio|A|();|SCH1.8|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evènement associé au passage de clef ON à clef OFF.
PwrlRly_EveKOn_IfCmdDiag|A|();|SCH.3|PWRLRLY|1|PTS_DOC_6559340||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON
PwrlRly_EveKOn_IfCmdDiagDio|A|();|SCH1.9|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON
PwrlRly_EveRst_IfCmdDiag|A|();|SCH.1|PWRLRLY|1|PTS_DOC_6559340||||0|0|0|0|Evènement reset du calculateur
PwrlRly_EveRst_IfCmdDiagDio|A|();|SCH1.5|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evénement reset du calculateur.
PwrlRly_EveRxnIdDaRcdDml|A|();|SCH.4|PWRLRLY|1|PTS_DOC_6559340||||0|0|0|0|Evénement de réception de la trame des données RCD et DML
PwrlRly_EveRxnIdDaRcdDmlDio|A|();|SCH1.10|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evénement de réception de la trame des données RCD et DML.
PwrlRly_SdlMid_IfCmdDiag|A|();|SCH.5|PWRLRLY|1|PTS_DOC_6559340||||0|0|0|0|Moniteur moyen du relais principal
PwrlRly_SdlMid_IfCmdDiagDio|A|();|SCH2.1|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Moniteur moyen du relais principal.
PWRLRLY_vidCmd|A|();|FCT1.1|PWRLRLY|1|PTS_DOC_6559340||||0|0|0|0|Dès que la ligne RCD passe à l’état haut, le CMM commande la fermeture du relais principal.
PWRLRLY_vidDiag|A|();|FCT1.2|PWRLRLY|1|PTS_DOC_6559340||||0|0|0|0|Le diagnostic du relais principal n’est possible que lorsque celui-ci n’est pas commandé.
PWRLRLY_vidGduCall|A|();|FCT1.3|PWRLRLY|1|PTS_DOC_6559340||||0|0|0|0|Appel au GDU réalisé qu’à la 1ère récurrence temporelle.
PWRLRLY_vidInitialization|A|();|FCT1.4|PWRLRLY|1|PTS_DOC_6559340||||0|0|0|0|Initialisation de PWRLRLY_bActiveGen à 1
PwrRly_EveCkOn_IfCmdDiag|A|();|SCH.4|PWRRLYCMDDIAG|1|PTS_DOC_6561228||||0|0|0|0|Evènement de détection rotation moteur
PwrRly_EveCkOn_IfCmdDiagDio|A|();|SCH2.4|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evènement de détection rotation moteur
PwrRly_EveKOn_IfCmdDiag|B|();|SCH.3|PWRRLYCMDDIAG|1|PTS_DOC_6561228||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON
PwrRly_EveKOn_IfCmdDiagDio|A|();|SCH2.3|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON.
PwrRly_EveRst_IfCmdDiag|B|();|SCH.1|PWRRLYCMDDIAG|1|PTS_DOC_6561228||||0|0|0|0|Evénement reset du calculateur
PwrRly_EveRst_IfCmdDiagDio|A|();|SCH1.4|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evénement reset du calculateur.
PwrRly_SdlFast_IfCmdDiag|C|();|SCH.5|PWRRLYCMDDIAG|1|PTS_DOC_6561228||||0|0|0|0|Moniteur rapide du relais puissance
PwrRly_SdlMid_IfCmdDiag|B|();|SCH.2|PWRRLYCMDDIAG|1|PTS_DOC_6561228||||0|0|0|0|Moniteur moyen du relais puissance
PwrRly_SdlMid_IfCmdDiagDio|A|();|SCH2.2|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Moniteur moyen du relais puissance.
PwrRly_SdlSlow_IfCmdDiag|C|();|SCH.6|PWRRLYCMDDIAG|1|PTS_DOC_6561228||||0|0|0|0|Moniteur lent du relais puissance
PWRRLYCMDDIAG_ActExternalDiag|B|();|FCT1.8|PWRRLYCMDDIAG|0|PTS_DOC_6561228||||0|0|0|0|PWRRLYCMDDIAG_ActExternalDiag
PWRRLYCMDDIAG_InitCountRelay|B|();|FCT1.7|PWRRLYCMDDIAG|0|PTS_DOC_6561228||||0|0|0|0|Initialisation du compteur Diag_relais_bsm_wait_count avant chaque diagnostic actionneurs externe.
PWRRLYCMDDIAG_vidCmd|B|();|FCT1.2|PWRRLYCMDDIAG|0|PTS_DOC_6561228||||0|0|0|0|Bloc d’interface entre le driver commande de l’actionneur sous la responsabilité du LdB et la gestion de l’état de l’actionneur sous la responsabilité du LdA
PWRRLYCMDDIAG_vidDiagAct|D|();|FCT1.3|PWRRLYCMDDIAG|0|PTS_DOC_6561228||||0|0|0|0|Fonction de gestion du diagnostic
PWRRLYCMDDIAG_vidDiagExt|C|();|FCT1.6|PWRRLYCMDDIAG|0|PTS_DOC_6561228||||0|0|0|0|Diagnostic externe des actionneurs
PWRRLYCMDDIAG_vidElDiagAcv|E|();|FCT1.4|PWRRLYCMDDIAG|0|PTS_DOC_6561228||||0|0|0|0|Fonction du diagnostic
PWRRLYCMDDIAG_vidElDiagInh|C|();|FCT1.5|PWRRLYCMDDIAG|0|PTS_DOC_6561228||||0|0|0|0|Lorsque le diagnostic est inhibé, les indicateurs de défauts sont mis à 0.
PWRRLYCMDDIAG_vidInitOutput|C|();|FCT1.1|PWRRLYCMDDIAG|0|PTS_DOC_6561228||||0|0|0|0|Initialisation des output
PWRSEN_ACQ_vidAccP2Cf|B|();|FCT6.4|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Fonction qui calcule la tension d'alimentation du capteur de la pédale d'accélération 2
PWRSEN_ACQ_vidAcqDiagVRawMeas1|E|();|FCT1.1|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Lorsque le défaut sur l'ALIM 1 est détecté, on fige la valeur envoyée au reste du CMM à la  dernière valeur valide.  Aussi, lorsqu'il est confirmé on applique une valeur par défaut est calibrable à la sortie du  module d'acquisition.
PWRSEN_ACQ_vidAcqDiagVRawMeas2|E|();|FCT2.1|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Si la valeur lue n'est pas dans l'intervalle admissible on déclare une panne présente.
PWRSEN_ACQ_vidAcqDiagVRawMeas3|C|();|FCT3.1|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Lorsque le défaut sur l'ALIM 3 est détecté, on fige la valeur envoyée au reste du CMM à la  dernière valeur valide.  Aussi, lorsqu'il est confirmé on applique une valeur par défaut est calibrable à la sortie du  module d'acquisition.
PWRSEN_ACQ_vidAcqDiagVRawMeas4|B|();|FCT4.1|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Lorsque le défaut sur l'ALIM 4 est détecté, on fige la valeur envoyée au reste du CMM à la  dernière valeur valide.  Aussi, lorsqu'il est confirmé on applique une valeur par défaut est calibrable à la sortie du  module d'acquisition.
PWRSEN_ACQ_vidAcquisition1|E|();|FCT1.2|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|La valeur lue sur le convertisseur est mise à l'échelle en fonction de la sortie du TLE 4471 (tension de référence  divisée par 2).
PWRSEN_ACQ_vidAcquisition2|E|();|FCT2.2|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|La valeur lue sur le convertisseur est mise à l'échelle en fonction de la sortie du TLE 4471 (tension de référence  divisée par 2).
PWRSEN_ACQ_vidAcquisition3|C|();|FCT3.2|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|La valeur lue sur le convertisseur est mise à l'échelle en fonction de la sortie du TLE 4471 (tension de référence  divisée par 2).
PWRSEN_ACQ_vidAcquisition4|B|();|FCT4.2|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|La valeur lue sur le convertisseur est mise à l'échelle en fonction de la sortie du TLE 4471 (tension de référence  divisée par 2).
PWRSEN_ACQ_vidAlimAc|C|();|FCT5.2|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Ces switchs servent à redistribuer les valeurs d’acquisitions de la tension d’alimentation pour chaque capteur qui nécessitent un calcul de la tension d’alimentation à une récurrence moyenne.
PWRSEN_ACQ_vidAlimAirPts|C|();|FCT5.3|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Ces switchs servent à redistribuer les valeurs d’acquisitions de la tension d’alimentation pour chaque capteur qui nécessitent un calcul de la tension d’alimentation à une récurrence moyenne.
PWRSEN_ACQ_vidAlimAps|C|();|FCT5.1|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Ces switchs servent à redistribuer les valeurs d’acquisitions de la tension d’alimentation pour chaque capteur qui nécessitent un calcul de la tension d’alimentation à une récurrence moyenne.
PWRSEN_ACQ_vidAlimPmast|C|();|FCT5.4|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Fonction qui calcule la tension d'alimentation du capteur de dépression MASTERVAC.
PWRSEN_ACQ_vidAlimSchSdlFastAcq|C|();|FCT2.9|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Attribution l’acquisition de tension d’alimentation au moniteur rapide pour son utilisation par le capteur de position papillon
PWRSEN_ACQ_vidAlimSchSdlMidAcq|C|();|FCT2.8|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Attribution l’acquisition de tension d’alimentation au moniteur moyen pour son utilisation par le capteur de position papillon
PWRSEN_ACQ_vidAlimSwitchSdlFast|C|();|FCT6.5|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Ce switch sert à redistribuer les valeurs d’acquisitions de la tension d’alimentation sur le capteur de position papillon qui nécessite un calcul de la tension d’alimentation à une récurrence rapide.
PWRSEN_ACQ_vidBoostPresCf|B|();|FCT5.5|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Fonction qui calcule la tension d'alimentation du capteur de la pression de suralimentation
PWRSEN_ACQ_vidCluPosnCf|B|();|FCT6.1|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Fonction qui calcule la tension d'alimentation du capteur de position de l'embrayage
PWRSEN_ACQ_vidDegradModePwSp1Sdf|E|();|FCT1.4|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|C'est cette valeur brute qui est utilisée par la sûreté de fonctionnement. Si elle est hors des seuils tolérables, on fige la valeur à sa valeur précédente. Lorsque la panne est mémorisée, le mode dégradé est assuré par la  sûreté de fonctionnement.
PWRSEN_ACQ_vidDegradModePwSp2Sdf|E|();|FCT2.4|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|C'est cette valeur brute qui est utilisée par la sûreté de fonctionnement. Si elle est hors des seuils tolérables, on fige la valeur à sa valeur précédente. Lorsque la panne est mémorisée, le mode dégradé est assuré par la sûreté de fonctionnement.
PWRSEN_ACQ_vidDegradModePwSp3Sdf|C|();|FCT3.4|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|C'est cette valeur brute qui est utilisée par la sûreté de fonctionnement. Si elle est hors des seuils tolérables, on fige la valeur à sa valeur précédente. Lorsque la panne est mémorisée, le mode dégradé est assuré par la sûreté de fonctionnement.
PWRSEN_ACQ_vidDegradModePwSp4Sdf|B|();|FCT4.4|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|C'est cette valeur brute qui est utilisée par la sûreté de fonctionnement. Si elle est hors des seuils tolérables, on fige la valeur à sa valeur précédente. Lorsque la panne est mémorisée, le mode dégradé est assuré par la sûreté de fonctionnement.
PWRSEN_ACQ_vidDetectFailPwSp1Sdf|E|();|FCT1.3|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|La tension mesurée est comparée aux seuils tolérables pour la SdF (possibilité de  reconstruire les informations papillon et pédale).
PWRSEN_ACQ_vidDetectFailPwSp2Sdf|E|();|FCT2.3|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Cette fonction détecte les éventuels défauts sur l'alimentation 2 pour la sûreté de fonctionnement.
PWRSEN_ACQ_vidDetectFailPwSp3Sdf|C|();|FCT3.3|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|La tension mesurée est comparée aux seuils tolérables pour la SdF (possibilité de reconstruire les informations papillon et pédale).
PWRSEN_ACQ_vidDetectFailPwSp4Sdf|B|();|FCT4.3|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|La tension mesurée est comparée aux seuils tolérables pour la SdF (possibilité de reconstruire les informations papillon et pédale).
PWRSEN_ACQ_vidDiagVRawMes1|C|();|FCT1.5|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|La détection du défaut décrite ici est utilisée pour les capteurs qui ne tolèrent pas d'écart  important de la tension d'alim capteur (mesure pression, ...).
PWRSEN_ACQ_vidDiagVRawMes2|C|();|FCT2.5|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|La détection du défaut décrite ici est utilisée pour les capteurs qui ne tolèrent pas d'écart important de la tension d'alim capteur (mesure pression, ...).
PWRSEN_ACQ_vidDiagVRawMes3|C|();|FCT3.5|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|La détection du défaut décrite ici est utilisée pour les capteurs qui ne tolèrent pas d'écart important de la tension d'alim capteur (mesure pression, ...).
PWRSEN_ACQ_vidDiagVRawMes4|B|();|FCT4.5|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|La détection du défaut décrite ici est utilisée pour les capteurs qui ne tolèrent pas d'écart important de la tension d'alim capteur (mesure pression, ...).
PWRSEN_ACQ_vidExCmCf|B|();|FCT5.10|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Fonction qui calcule la tension d'alimentation du capteur de position arbre à cames (AAC) d'échappement
PWRSEN_ACQ_vidInCmCf|B|();|FCT5.9|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Fonction qui calcule la tension d'alimentation du capteur de position arbre à cames (AAC) d'admission
PWRSEN_ACQ_vidInitVEndValMeas1|E|();|FCT1.6|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Lorsque l’on a une panne présente, la valeur fournie en sortie est la valeur par défaut.
PWRSEN_ACQ_vidInitVEndValMeas2|E|();|FCT2.6|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Lorsque on a un défaut présent au Reset, la valeur fournie en sortie est la valeur par défaut. Cette valeur ne  doit pas être utilisée par les modules liés à la sûreté de fonctionnement.
PWRSEN_ACQ_vidInitVEndValMeas3|C|();|FCT3.6|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Lorsqu’une panne est présente, la valeur fournie en sortie est la valeur par défaut
PWRSEN_ACQ_vidInitVEndValMeas4|B|();|FCT4.6|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Lorsque l’on a une panne présente, la valeur fournie en sortie est la valeur par défaut.
PWRSEN_ACQ_vidnEngCf|B|();|FCT6.3|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Fonction qui calcule la tension d'alimentation du capteur de régime moteur Uni ou bidirectionnelle
PWRSEN_ACQ_vidNeutCf|B|();|FCT6.2|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Fonction qui calcule la tension d'alimentation du capteur de point mort BVM
PWRSEN_ACQ_vidPfuCf|B|();|FCT5.6|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Fonction qui calcule la tension d'alimentation du capteur pression rail
PWRSEN_ACQ_vidptOilCf|B|();|FCT5.8|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Fonction qui calcule la tension d'alimentation du capteur de pression et de température d'huile
PWRSEN_ACQ_vidTrbActCf|B|();|FCT5.7|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Fonction qui calcule la tension d'alimentation du capteur de position de la soupape Wastegate
PWRSEN_ACQ_vidVEndValMeas1|F|();|FCT1.7|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Lorsque le défaut sur l'ALIM 1 est détecté, on fige la valeur envoyée au reste du CMM à la  dernière valeur valide.  Aussi, lorsqu'il est confirmé on applique une valeur par défaut est calibrable à la sortie du  module d'acquisition.
PWRSEN_ACQ_vidVEndValMeas2|F|();|FCT2.7|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Lorsque le défaut sur l'ALIM 2 est détecté, on fige la valeur envoyée au reste du CMM à la  dernière valeur valide.  Aussi, lorsqu'il est confirmé on applique une valeur par défaut est calibrable à la sortie du  module d'acquisition.
PWRSEN_ACQ_vidVEndValMeas3|C|();|FCT3.7|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Ce module spécifie la gestion des modes dégradés.
PWRSEN_ACQ_vidVEndValMeas4|B|();|FCT4.7|PWRSEN_ACQ|0|PTS_DOC_6538484||||0|0|0|0|Lorsque le défaut sur l'ALIM 4 est détecté, on fige la valeur envoyée au reste du CMM à la  dernière valeur valide.  Aussi, lorsqu'il est confirmé on applique une valeur par défaut est calibrable à la sortie du  module d'acquisition.
RBLCRITZONE_vidComputeCritZone|A|();|FCT1.2|RBLCRITZONE|0|V02 NT 12 00518||||0|0|0|0|La KnkTreat_rAirLdAcvRblDet_M représente la zone où il est physiquement possible d’avoir du rumble|
RBLCRITZONE_vidInitialization|A|();|FCT1.1|RBLCRITZONE|0|V02 NT 12 00518||||0|0|0|0|Le paramètre Zone_critique_Rbl est initialisé à 0|
RBLDETBENCH_vidcalc_variables|A|();|FCT1.3|RBLDETBENCH|0|V02 NT 11 02549||||0|0|0|0|Ce module permet de calculer les gains correspondants aux rapports (bruit instantané – offset) / bruit moyen (cylindre à cylindre), utilisés pour la calibration des cartographies des gains de détection.|
RBLDETBENCH_vidEntryInit|A|();|SCH.1|RBLDETBENCH|1|V02 NT 11 02549||||0|0|0|0|initialisation des variables prev.|
RBLDETBENCH_vidInitOutput|A|();|FCT1.1|RBLDETBENCH|0|V02 NT 11 02549||||0|0|0|0|fonction d'initialisation des variables prev.|
RBLDETBENCH_vidRbl_Test_bed|A|();|FCT1.2|RBLDETBENCH|0|V02 NT 11 02549||||0|0|0|0|Ce module permet de calculer le rapport de bruit,créer une voie regroupant les quatre cylindres et  retarder de 1 à 3 pmh la voie qu’il a créée.|
RBLDETBENCH_vidretard|C|();|FCT1.4|RBLDETBENCH|0|V02 NT 11 02549||||0|0|0|0|ce module permet de générer une variable regroupant les signaux des quatre cylindres et d’effectuer un retard sur les voies.|
RC01_vidExitEveStObdRec|A|(argin uint16 u16IdxDft);|SCH1.6|RC01|1|PTS_DOC_5263162||||0|0|0|0|Evènement entrée du Gestionnaire OBD dans l'état GOBD_ST_ENREGISTRE|
RC01_vidF00_Def_Prio_Init|C|();|FCT1.2|RC01|0|PTS_DOC_5263162||||0|0|0|0|Une panne est prioritaire si son RC associé est Catalyseur ou Misfire.|
RC01_vidF01_Rdy_Init|D|();|FCT1.1|RC01|0|PTS_DOC_5263162||||0|0|0|0|récupération de l’EEPROM des états des RC unitaires et familiaux.|
RC01_vidF02_Rdy_ValRdy|D|();|FCT1.3|RC01|0|PTS_DOC_5263162||||0|0|0|0|fonction permettant la validation des RC unitaires|
RC01_vidF03_Rdy_ReinitRdy|D|();|FCT1.4|RC01|0|PTS_DOC_5263162||||0|0|0|0|Réinitialisation des RC sur requêtes APV et SCANTOOL (mode4)|
RC01_vidF04_Rdy_ValClasRdy|D|();|FCT1.5|RC01|0|PTS_DOC_5263162||||0|0|0|0|fonction permettant la validation des RC familiaux|
RC01_vidF06_Rdy_ValClasRdyCfOBD|A|(argin uint16 u16IdxDft);|FCT1.6|RC01|0|PTS_DOC_5263162||||0|0|0|0|Cette fonction vérifie dans le cas ou un défaut OBD si il est présent dans l’une  des famille de readines code et passer le RC01 familial à Etat_FAIT le cas échéant.|
RC01_vidMngEveGlbDCStrt|C|();|SCH.2|RC01|1|PTS_DOC_5263162||||0|0|0|0|Evènement de démarrage d'un nouveau Driving Cycle Global|
RC01_vidMngEveRstDft|C|();|SCH.5|RC01|1|PTS_DOC_5263162||||0|0|0|0|Demande d'effacement Manuel des défauts|
RE_AdvMaxT_001_MSEIf|B|();|SCH4.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset du calculateur.|
RE_AdvMaxT_002_DREIf|D|();|SCH17.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Interruption PMH.|
RE_AdvMinT_005_MSEIf|B|();|SCH.4|IFADV|1|V02 NT 11 07695||||0|0|0|0|Evénement reset du calculateur|
RE_AdvMinT_006_DREIf|A|();|SCH.5|IFADV|1|V02 NT 11 07695||||0|0|0|0|Event TDC|
RE_AirSysAir_001_MSEIf|C|();|SCH4.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset de la fonction AirSysAir.|
RE_AirSysAir_005_TEVIf|C|();|SCH16.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur 10ms de la fonction AirSysAir.|
RE_CoClLASl_001_MSEIf|B|();|SCH5.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement init du module CoClLASl.|
RE_CoGBx_001_MSEIf|C|();|SCH5.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement init du module CoGBx .|
RE_DCM_MANU_StubServiceAftS|B|();|14|HEADER|1|NONE||||0|0|0|0||
RE_EngM_initIf|D|();|SCH1.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset ECU du module d'interface|
RE_ExMGslT2_001_MSEIf|B|();|SCH5.10|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement init du module ExMGslT2 .|
RE_ExMGslT2_001_MSEIfTWC|A|();|SCH.1|IFCATMDLSYS|1|V02 NT 11 06970||||0|0|0|0|Reset event occurring after ExMGslT2 initialisation.|
RE_ExMGslT2_006_TEVIf|C|();|SCH18.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Scheduler du module ExMGslT2.|
RE_FARSp_022_TEVIf|A|();|SCH.2|IFFAR|1|V02 NT 12 01358||||0|0|0|0|Evènement du module d'interfacage en aval du FARSp|
RE_InMdlT_020_TEVIf|C|();|SCH19.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur 5ms de la fonction InMdlT.|
RE_InMdlT_043_MSEIf|C|();|SCH19.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement.|
RE_OEMGsl_001_MSEIf|B|();|SCH6.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement init du module OEMGsl.|
RE_OEMGsl_003_TEVIf|B|();|SCH19.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Scheduler du module OEMGsl .|
RE_ProdElEm_005_MSEIf|D|();|SCH13.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Event Reset|
RE_ProdElEm_006_TEVIf|B|();|SCH9.9|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement permettant l'appel de la fonction IFAIRSYSIGSYS_vidInterfEngStrt.|
RE_StopStrtEm_003_MSEIf|B|();|SCH5.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement init du module StopStrtEm .|
RE_StopStrtEm_004_TEVIf|D|();|SCH17.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Scheduler du module StopStrtEm .|
RE_StopStrtEng_013_MSEIf|C|();|SCH19.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur de module d'interface.|
RE_StopStrtEng_014_TEVIf|C|();|SCH19.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur de module d'interface.|
RE_StopStrtEng_023_MSEIf|B|();|SCH8.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement d'initialisation de StopStrtEng|
RE_StopStrtEng_024_TEVIf|B|();|SCH18.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement de calcul de StopStrtEng|
RE_ThMgt_001_MSEIf|B|();|SCH20.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset du calculateur.|
RE_ThMgt_002_TEVIf|B|();|SCH20.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur 1s de la fonction TSC.|
RE_TPM_001_MSEIf|C|();|SCH20.9|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|evenement Reset.|
RE_TPM_008_TEVIf|C|();|SCH20.10|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Scheduler 100ms|
RE_TqSys_EveSync_CurCorIf|C|();|SCH11.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement synchro|
RE_TqSys_EveSync_IdlCordLimIf|B|();|SCH15.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Scheduler du module CoClLASl.|
RE_TqSys_Sdl10ms_CoPtGearCordIf|B|();|SCH6.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur 10ms|
RE_TqTreat_003_MSEIf|B|();|SCH5.9|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement init du module TqTreat.|
RE_TqTreat_004_TEVIf|B|();|SCH18.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Scheduler du module TqTreat.|
RE_TraBVx_001_MSEIf|B|();|SCH5.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement init du module TraBVx.|
RE_TraBVx_028_TEVIf|B|();|SCH20.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement du module TraBVx .|
ReceiveMessage|A|(argin uint16 Id_msg, argout uint8 *Ptr_msg);|2|HEADER|1|V01 NT 08 05905||||0|0|0|0|
ReceiveMessageFrom|A|func_ReceiveMessageFrom|9|HEADER|1|NONE||||0|0|0|0||
REFIDETA_CheckCondition|A|func_REFIDETA_CheckCondition|FCT1.3|REFIDETA|1|V02 NT 11 00995||||0|0|0|0|Evènement vérifiant les conditions de la Refideta|
REFIDETA_ConditionCheck_ReadData|A|func_checkCondition_ReadData|API.1|REFIDETA|1|V02 NT 11 00995||||0|0|0|0|Evènement vérifiant les conditions de lecture de la Refideta|
REFIDETA_Init|C|();|FCT1.1|REFIDETA|1|V02 NT 11 00995||||0|0|0|0|Initialisation of outputs|
REFIDETA_MainFunction|D|mainFonctionPrototype|API.1|REFIDETA|1|V02 NT 11 00995|VEMS V02 ECU#056261|||0|0|0|0|Fonction gérant l'automate de la ref_ident_etal de façon évènementielle|
REFIDETA_ReadData_Obd|A|func_readData|API.4|REFIDETA|1|V02 NT 11 00995||||0|0|0|0|Fonction de lecture de la REFIDETA via une requete OBDSRV09|
REFIDETA_ReadData_Uds|A|func_readData|API.2|REFIDETA|1|V02 NT 11 00995||||0|0|0|0|Fonction de lecture de la REFIDETA via une requete UDS|
REFIDETA_ReadDataLength|A|func_readdatalength|1|REFIDETA|1|V02 NT 11 00995||||0|0|0|0|Fonction utilisée pour connaître la taille de la donnée REFIDENTETAL|
REFIDETA_sdlFast|A|();|FCT1.2|REFIDETA|1|V02 NT 11 00995||||0|0|0|0|Evènement fast de la Refideta|
REFIDETA_WriteData|A|func_writeData|API.3|REFIDETA|1|V02 NT 11 00995||||0|0|0|0|Fonction d'écriture de la REFIDETA|
RELBRKASIACQ_vidAcqusition|B|();|FCT1.4|RELBRKASIACQ|0|PTS_DOC_6547160||||0|0|0|0|This function makes the acquisition of the relative mastervac pressure sensor voltage.
RELBRKASIACQ_vidCalc|B|();|FCT1.3|RELBRKASIACQ|0|PTS_DOC_6547160||||0|0|0|0|This function calculates the relative mastervac pressure.
RELBRKASIACQ_vidDiagnosis|B|();|FCT1.5|RELBRKASIACQ|0|PTS_DOC_6547160||||0|0|0|0|This function makes the diagnosis of the information. There are 3 different diagnosis, one for the max value of the voltage, another one for the min value and the last one controls the gradient of the measured voltage.
RELBRKASIACQ_vidFiltering|B|();|FCT1.8|RELBRKASIACQ|0|PTS_DOC_6547160||||0|0|0|0|In this function, the raw voltage of the relative mastervac pressure sensor is filtered by a first order filter.
RELBRKASIACQ_vidGrdDiag|B|();|FCT1.7|RELBRKASIACQ|0|PTS_DOC_6547160||||0|0|0|0|In thif function, if the difference between the current voltage and the voltage at previous step is greater than a defined threshold, the Boolean of Grd diagnosis is activated.
RELBRKASIACQ_vidInit|B|();|FCT1.2|RELBRKASIACQ|0|PTS_DOC_6547160||||0|0|0|0|The output of the function is initialized at Ext_pRelBrkAsiIni_C.
RELBRKASIACQ_VidInitOutput|B|();|FCT1.1|RELBRKASIACQ|0|PTS_DOC_6547160||||0|0|0|0|Fonction d'initialisation
RELBRKASIACQ_vidLinearization|B|();|FCT1.9|RELBRKASIACQ|0|PTS_DOC_6547160||||0|0|0|0|In this function, the measured filtered voltage is converted into a pressure information.  This conversion is done by an interpolation between 2 setpoints.
RELBRKASIACQ_vidScpScgDiag|B|();|FCT1.6|RELBRKASIACQ|0|PTS_DOC_6547160||||0|0|0|0|This function checks if the measured voltage is up to a max defined threshold, then it activates the boolean of Scp diagnosis. And if the measured voltage is under a min defined threshold, it activates the boolean of Scg diagnosis.
RELBRKASIACQ_vidSelection|B|();|FCT1.10|RELBRKASIACQ|0|PTS_DOC_6547160||||0|0|0|0|In thid function, if a punctual diagnosis is detected or if the recovery flag to inhibit electrical diagnosis is set then the relative mastervac pressure is frozen to its last valid value.
RELBRKASIACQ_vidSftLvl2|B|();|FCT2.1|RELBRKASIACQ|0|PTS_DOC_6547160||||0|0|0|0|The aim of this function is to satisfy the requirement of safety level 2 for the mastervac relative pressure sensor.
REQADJVLTCTL_vidInitReqAdjVltCtl|A|();|FCT1.1|REQADJVLTCTL|0|V02NT1103742||||0|0|0|0|Initialisation des variables au reset
REQADJVLTCTL_vidTraitReqAdjVltCt|B|();|FCT1.2|REQADJVLTCTL|0|V02 NT 11 03742||||0|0|0|0|Cette fonction permet la demande d’ajustement de la tension de batterie pour les besoins en chauffage des sondes O2 par l'envoi de Requête de boost VoltCtl pour  ces sondes O2.
RICHBOOST_vidCond_Act_OvbPerfo|A|();|FCT2.2|RICHBOOST|0|V02 NT 10 06088||||0|0|0|0|L’activation de la demande d’overboost/perfo est demandée sur 2 conditions : la condition de couple max sans overboost atteint et la condition de position pédale atteinte.|
RICHBOOST_vidCond_act_Richesse|A|();|FCT1.4|RICHBOOST|0|V02 NT 10 06088||||0|0|0|0|L’activation de la demande d’enrichissement est demandée sur 3 conditions : la  condition de couple max atteinte, la condition de position pédale atteinte, la condition de température d’eau atteinte.|
RICHBOOST_vidCond_Reset_Enrich|A|();|FCT1.7|RICHBOOST|0|V02 NT 10 06088||||0|0|0|0|Ce bloc présente les conditions de set/reset de la fonction.|
RICHBOOST_vidCondition_Reset|A|();|FCT2.4|RICHBOOST|0|V02 NT 10 06088||||0|0|0|0|Ce bloc présente les conditions de se/reset de la fonction.|
RICHBOOST_vidDemandePerfoOverbst|A|();|FCT1.2|RICHBOOST|0|V02 NT 10 06088||||0|0|0|0|La fonction se décompose en 2 sous fonctions : une sous fonction de gestion de la demande d’enrichissement et une sous fonction de gestion de la demande du mode performance du moteur.|
RICHBOOST_vidEntry_10ms|A|();|SCH.2|RICHBOOST|1|V02 NT 10 06088||||0|0|0|0|Schéduling de la fonction (10ms).|
RICHBOOST_vidEntryInit|C|();|SCH.1|RICHBOOST|1|V02 NT 10 06088||||0|0|0|0|Fonction d'accroche au moniteur Reset.|
RICHBOOST_vidInitOutput|C|();|FCT1.1|RICHBOOST|0|V02 NT 10 06088||||0|0|0|0|Initialisation des sorties.|
RICHBOOST_vidSyn_Bes_Act_Enrich|A|();|FCT1.3|RICHBOOST|0|V02 NT 10 06088||||0|0|0|0|La fonction se décompose en 3 étapes: l’activation de la demande sur conditions « conducteur », temporisation de cette demande sur des conditions particulières de roulage et coordination de la demande finale avec des conditions de RESET.|
RICHBOOST_vidSyn_Bes_Act_Ovboost|A|();|FCT2.1|RICHBOOST|0|V02 NT 10 06088||||0|0|0|0|La fonction se décompose en 3 étapes : l’activation de la demande sur conditions « conducteur », temporisation de cette demande sur des conditions particulières de roulage et coordination de la demande finale avec des conditions de RESET|
RICHBOOST_vidSyn_tempo_bes_enrch|C|();|FCT1.6|RICHBOOST|0|V02 NT 10 06088||||0|0|0|0|La demande d’enrichissement est temporisée en fonction du régime. Mais s’il y a une demande spécifique on peut la temporiser sur un autre temps spécifique.|
RICHBOOST_vidTempo_glob_hors_LVV|C|();|FCT1.5|RICHBOOST|0|V02 NT 10 06088||||0|0|0|0|Le calcul du retard à appliquer peut être spécifique pour des besoins de performances.|
RICHBOOST_vidTemporisations|A|();|FCT2.3|RICHBOOST|0|V02 NT 10 06088||||0|0|0|0|La demande d’overboost/perfo est temporisée en fonction du régime. Mais s’il y a une demande spécifique on peut la temporiser sur un autre temps spécifique. On calcule également un temps de désactivation pour gérer « l’agrément » en sortie du mode perfo.|
Rly_EveRst_ActTstPwrRly|C|();|SCH.1|RLYACTEST|1|V02 NT 09 00872||||0|0|0|0|Evènement reset du calculateur.|
Rly_SdlFast_ActTstPwrRly|C|();|SCH.2|RLYACTEST|1|V02 NT 09 00872||||0|0|0|0|Moniteur rapide du relais de puissance (actionneurs).|
Rly_SdlFast_CmdDiagRly|A|();|SCH2.3|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Moniteur rapide du relais puissance.
RLYACTEST_vidInitOutput|D|();|FCT1.1|RLYACTEST|0|V02 NT 09 00872||||0|0|0|0|Initialisation des tests actionneurs  du relais de puissance.|
RLYACTEST_vidTimeCmdPwrRly|D|();|FCT1.2|RLYACTEST|0|V02 NT 09 00872||||0|0|0|0|Fonction decrivant le déroulement des tests actionneurs  du relais de puissance.|
RlyPwr_EveKOf_Mng|G|();|SCH.6|RLYPWR|1|PTS_DOC_5137464||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON.|
RlyPwr_EveKOn_Mng|H|();|SCH.3|RLYPWR|1|PTS_DOC_5137464||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON|
RlyPwr_EveRst_CrashVeh|A|();|SCH.1|INFOCRASH|1|V02 NT 08 07842||||0|1|0|0|Fonction d'accroche au moniteur Reset.|
RlyPwr_EveRst_Mng|I|();|SCH.1|RLYPWR|1|PTS_DOC_5137464||||0|0|0|0|Evénement reset du calculateur|
RlyPwr_EveRxn4c8_CrashVeh|A|();|SCH.2|INFOCRASH|1|V02 NT 08 07842||||0|0|0|0|Evènement de réception de la trame 4C8h|
RlyPwr_EveStTR_Mng|H|();|SCH.2|RLYPWR|1|PTS_DOC_5137464||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant|
RlyPwr_SdlFast_CrashVeh|A|();|SCH.3|INFOCRASH|1|V02 NT 08 07842||||0|1|0|0|Moniteur rapide de la fonction RlyPwr|
RlyPwr_SdlFast_Mng|K|();|SCH.4|RLYPWR|1|PTS_DOC_5137464||||0|0|0|0|Moniteur rapide du relais de puissance (actionneurs)|
RlyPwr_SdlMid_Mng|C|();|SCH.7|RLYPWR|1|PTS_DOC_5137464||||0|0|0|0|Moniteur moyen pour la fonction configuration moteur.|
RlyPwr_SdlSlow_Mng|E|();|SCH.5|RLYPWR|1|PTS_DOC_5137464||||0|0|0|0|Moniteur lent de la fonction RlyPwr|
RLYPWR_vidFinMaintRelPrinp|C|();|FCT2.8|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Cette fonction indique que le delai de maintien de la fermeture du relay pricipal est terminé.|
RLYPWR_vidInitbEndDiag|E|();|FCT1.2|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Fonction d'initialisation.|
RLYPWR_vidInitbPwrLong|E|();|FCT1.8|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Le booléen EcuSt_bPwrlLong est réinitialisé sur transition clé off /clé on pour éviter que le relais actionneur soit commandé en ouverture et en continu dans le cas où on revient d’un power-latch très long à POWER_ON sans réinitialisé le calculateur|
RLYPWR_vidInitOutput|I|();|FCT1.1|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Fonction d'initialisation de l'automate|
RLYPWR_vidInitTempo|E|();|FCT2.5|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|La temporisation RlyPwr_tiWaitAcvModEcoBatt est réinitialisée sur transition clé on/clé off|
RLYPWR_vidInitWaitAcvModEcoBatt|E|();|FCT2.1|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Attente du mode d'activation|
RLYPWR_vidInitWaitPwrlEnd|E|();|FCT2.3|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Condition sur la durée du Power-Latch|
RLYPWR_vidPrevEcuStPwrlLong|B|();|FCT2.9|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Le booléen EcuSt_bPwrlLong est réinitialisé sur transition clef off clef on|
RLYPWR_vidRlyMngHldReq|C|();|FCT2.7|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Cette fonction sert à demander un maintien du réveil UCE.|
RLYPWR_vidRlyPwrActrTst|H|();|FCT1.7|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|En cas de test actionneur sur le relais de puissance (PwrRly_btstInProgress = 1), on applique la commande spécifique au test (PwrRly_bActrTstCmd).|
RLYPWR_vidRlyPwrAcvCond|F|();|FCT1.3|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Le relais de puissance se ferme soit dès l'entrée en réveil principal, soit dès que la commande de la pompe à essence est demandée soit dès qu'une session de diagnostic est requise. Il est réouvert si KEY ON et moteur non tournant après un certain temps.|
RLYPWR_vidRlyPwrAcvModEcoBatt|K|();|FCT1.10|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Afin de limiter la consommation électrique batterie au sein du véhicule, le relais est ouvert au bout d'une certaine durée, dans le cas où le client entre dans la voiture, met le contact, mais ne démarre pas.|
RLYPWR_vidRlyPwrCtlMng|Q|();|FCT1.6|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Conditions d'ouverture et de fermeture du relais.|
RLYPWR_vidRlyPwrDiagActif|C|();|FCT1.4|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Dés l’ouverture d’une session de diagnostique,  le relais de puissance doit être fermé. A la fin de la session de diag, le relais de puissance s’ouvre au bout d’une temporisation (RlyPwr_tiAftEndDiag).|
RLYPWR_vidRlyPwrDiagInh|A|();|FCT3.1|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Afin d’éviter une remontée de défauts circuit ouvert à l'ouverture du relais actionneurs, le booléen EcuSt_bInhDiagOcCmdActr désactive ces diag lorsqu’on ouvre le relais.|
RLYPWR_vidRlyPwrDiagNotInh|A|();|FCT3.2|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Afin d’éviter une remontée de défauts circuit ouvert à la fermeture du relais actionneurs, le booléen EcuSt_bInhDiagOcCmdActr maintien la désactivation pendant une temporisation calibrable après sa fermeture.|
RLYPWR_vidRlyPwrEcoBatt|I|();|FCT1.9|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Ouverture du relais au bout d'un certain temps si son maintien en position fermée n'est pas justifié.|
RLYPWR_vidRlyPwrMngDiagNotInh|A|();|FCT3.3|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Permet d’éviter une remontée de défauts circuit ouvert à la fermeture et ouverture du relais actionneurs|
RLYPWR_vidRlyPwrTestPwrlLong|K|();|FCT1.5|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Condition sur la durée du Power-Latch|
RLYPWR_vidWaitAcvModEcoBatt|G|();|FCT2.2|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Attente du mode d'activation|
RLYPWR_vidWaitAcvModEcoBattCalib|F|();|FCT2.6|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Si la calibration RlyPwr_bModEcoBatt_Inh_C qui permet d’inhiber la stratégie d’économie batterie est égale à 1 il faut mettre la variable RlyPwr_bAcvModEcoBatt à 1|
RLYPWR_vidWaitPwrlEnd|G|();|FCT2.4|RLYPWR|0|PTS_DOC_5137464||||0|0|0|0|Attente de la fin de l'action du relais|
RND_vidReadRandomNumber|A|( argio uint32 * pu32RandomNumber);|1.1|RND|1|V02 NT 09 03939||||0|0|0|0|Génération de valeur aleatoire
RSTSRV_udtReadResetState|A|(void)uint8;|1|HEADER|1|NONE||||0|0|0|0|RSTSRV_tudtResetType RSTSRV_udtReadResetState(void)|
RSTSRV_vidPerformReset|A|func_RSTSRV_vidPerformReset|0x10|HEADER|1|V03 NT 11 02058||||0|0|0|0||
Rte_Call_R_AFAMgtT_SessionControl_ChangeIndication|B|func_OP_ChangeIndication|81|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_AFAMgtT_SessionControl_GetSesChgPermission|B|func_OP_GetSesChgPermission|84|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID01_ConditionCheckRead|B|func_rte_conditionCheckXXX|91|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID01_ConditionCheckWrite|B|func_rte_conditionCheckXXX|92|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID01_ReadDataLength|B|func_Dlt_ReadDataLength_XXXX|103|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID02_ConditionCheckRead|B|func_rte_conditionCheckXXX|93|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID02_ConditionCheckWrite|B|func_rte_conditionCheckXXX|94|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID02_ReadDataLength|B|func_Dlt_ReadDataLength_XXXX|100|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID05_ConditionCheckRead|B|func_rte_conditionCheckXXX|96|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID05_ConditionCheckWrite|B|func_rte_conditionCheckXXX|97|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID05_ReadDataLength|B|func_Dlt_ReadDataLength_XXXX|101|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID06_ConditionCheckRead|B|func_rte_conditionCheckXXX|98|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID06_ConditionCheckWrite|B|func_rte_conditionCheckXXX|98|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_MPM_NVMID06_ReadDataLength|B|func_Dlt_ReadDataLength_XXXX|102|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_TrbActSys_NVMID01_ConditionCheckRead|B|func_rte_conditionCheckXXX|107|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_TrbActSys_NVMID01_ConditionCheckWrite|B|func_rte_conditionCheckXXX|90|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_DidServices_TrbActSys_NVMID01_ReadDataLength|B|func_Dlt_ReadDataLength_XXXX|99|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_MPM_SessionControl_ChangeIndication|B|func_OP_ChangeIndication|79|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_MPM_SessionControl_GetSesChgPermission|B|func_OP_GetSesChgPermission|78|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_TrbActSys_SessionControl_ChangeIndication|B|func_OP_ChangeIndication|83|HEADER|1|NONE||||0|0|0|0||
Rte_Call_R_TrbActSys_SessionControl_GetSesChgPermission|B|func_OP_GetSesChgPermission|82|HEADER|1|NONE||||0|0|0|0||
rte_MainFunction|A|();|SCH.9|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache MainFunction
rte_RE_ACCmd_001_MSE|A|();|SCH.10|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ACCmd_001_MSE
rte_RE_ACCmd_002_TEV|A|();|SCH.11|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ACCmd_002_TEV
rte_RE_ACCmd_003_DRE|A|();|SCH.12|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ACCmd_003_DRE
rte_RE_ACCmd_004_TEV|A|();|SCH.13|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ACCmd_004_TEV
rte_RE_AdvCordT_001_MSE|A|();|SCH.14|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvCordT_001_MSE
rte_RE_AdvCordT_002_DRE|A|();|SCH.15|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvCordT_002_DRE
rte_RE_AdvCordT_003_MSE|A|();|SCH.16|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvCordT_003_MSE
rte_RE_AdvCordT_005_DRE|A|();|SCH.17|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvCordT_005_DRE
rte_RE_AdvCordT_007_DRE|A|();|SCH.18|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvCordT_007_DRE
rte_RE_AdvMaxT_001_MSE|A|();|SCH.19|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvMaxT_001_MSE
rte_RE_AdvMaxT_002_DRE|A|();|SCH.20|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvMaxT_002_DRE
rte_RE_AdvMinT_001_MSE|A|();|SCH.21|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvMinT_001_MSE
rte_RE_AdvMinT_002_DRE|A|();|SCH.22|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvMinT_002_DRE
rte_RE_AdvMinT_005_MSE|A|();|SCH.23|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvMinT_005_MSE
rte_RE_AdvMinT_006_DRE|A|();|SCH.24|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvMinT_006_DRE
rte_RE_AdvMinT_008_DRE|A|();|SCH.25|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvMinT_008_DRE
rte_RE_AdvOptmT_001_MSE|A|();|SCH.26|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvOptmT_001_MSE
rte_RE_AdvOptmT_002_DRE|A|();|SCH.27|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvOptmT_002_DRE
rte_RE_AdvOptmT_003_DRE|A|();|SCH.28|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvOptmT_003_DRE
rte_RE_AdvOptmT_004_MSE|A|();|SCH.29|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvOptmT_004_MSE
rte_RE_AdvPrevKnkT_001_MSE|A|();|SCH.30|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvPrevKnkT_001_MSE
rte_RE_AdvPrevKnkT_002|A|();|SCH.31|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvPrevKnkT_002
rte_RE_AdvSpT_001_MSE|A|();|SCH.32|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvSpT_001_MSE
rte_RE_AdvSpT_002_DRE|A|();|SCH.33|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvSpT_002_DRE
rte_RE_AdvSpT_003_MSE|A|();|SCH.34|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvSpT_003_MSE
rte_RE_AdvSpT_004_DRE|A|();|SCH.35|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvSpT_004_DRE
rte_RE_AdvSpT_005_MSE|A|();|SCH.36|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvSpT_005_MSE
rte_RE_AdvSpT_006_DRE|A|();|SCH.37|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AdvSpT_006_DRE
rte_RE_AFAMgtT_001_MSE|A|();|SCH.38|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAMgtT_001_MSE
rte_RE_AFAMgtT_002_MSE|A|();|SCH.39|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAMgtT_002_MSE
rte_RE_AFAMgtT_003_TEV|A|();|SCH.40|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAMgtT_003_TEV
rte_RE_AFAMgtT_004_MSE|A|();|SCH.41|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAMgtT_004_MSE
rte_RE_AFAMgtT_007_TEV|A|();|SCH.42|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAMgtT_007_TEV
rte_RE_AFAMgtT_AftrsInit|A|();|SCH.43|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAMgtT_AftrsInit
rte_RE_AFAMgtT_AftsNvm|A|();|SCH.44|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAMgtT_AftsNvm
rte_RE_AFAT_001_MSE|A|();|SCH.45|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAT_001_MSE
rte_RE_AFAT_002_MSE|A|();|SCH.46|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAT_002_MSE
rte_RE_AFAT_003_MSE|A|();|SCH.47|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAT_003_MSE
rte_RE_AFAT_004_TEV|A|();|SCH.48|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAT_004_TEV
rte_RE_AFAT_005_TEV|A|();|SCH.49|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAT_005_TEV
rte_RE_AFAT_006_TEV|A|();|SCH.50|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAT_006_TEV
rte_RE_AFAT_007_TEV|A|();|SCH.51|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AFAT_007_TEV
rte_RE_AirSysAir_001_MSE|A|();|SCH.52|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysAir_001_MSE
rte_RE_AirSysAir_002_TEV|A|();|SCH.53|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysAir_002_TEV
rte_RE_AirSysAir_003_TEV|A|();|SCH.54|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysAir_003_TEV
rte_RE_AirSysAir_004_TEV|A|();|SCH.55|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysAir_004_TEV
rte_RE_AirSysAir_005_TEV|A|();|SCH.56|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysAir_005_TEV
rte_RE_AirSysAir_006_TEV|A|();|SCH.57|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysAir_006_TEV
rte_RE_AirSysAir_007_TEV|A|();|SCH.58|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysAir_007_TEV
rte_RE_AirSysTrb_001_MSE|A|();|SCH.59|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysTrb_001_MSE
rte_RE_AirSysTrb_002_TEV|A|();|SCH.60|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysTrb_002_TEV
rte_RE_AirSysTrb_003_TEV|A|();|SCH.61|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysTrb_003_TEV
rte_RE_AirSysTrb_004_TEV|A|();|SCH.62|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysTrb_004_TEV
rte_RE_AirSysTrb_005_TEV|A|();|SCH.63|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_AirSysTrb_005_TEV
rte_RE_ASE_001_MSE|A|();|SCH.64|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_001_MSE
rte_RE_ASE_002_TEV|A|();|SCH.65|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_002_TEV
rte_RE_ASE_003_MSE|A|();|SCH.66|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_003_MSE
rte_RE_ASE_004_TEV|A|();|SCH.67|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_004_TEV
rte_RE_ASE_005_MSE|A|();|SCH.68|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_005_MSE
rte_RE_ASE_006_TEV|A|();|SCH.69|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_006_TEV
rte_RE_ASE_007_MSE|A|();|SCH.70|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_007_MSE
rte_RE_ASE_008_TEV|A|();|SCH.71|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_008_TEV
rte_RE_ASE_009_MSE|A|();|SCH.72|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_009_MSE
rte_RE_ASE_010_TEV|A|();|SCH.73|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_010_TEV
rte_RE_ASE_011_MSE|A|();|SCH.74|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_011_MSE
rte_RE_ASE_012_TEV|A|();|SCH.75|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ASE_012_TEV
rte_RE_CatMon_EveRst_CatAcvDiag|A|();|SCH.2|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CatMon_EveRst_CatAcvDiag
rte_RE_CatMon_EveRst_CatPasDiag|A|();|SCH.6|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CatMon_EveRst_CatPasDiag
rte_RE_CatMon_SdlFast_CatAcvDiag|A|();|SCH.3|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CatMon_SdlFast_CatAcvDiag
rte_RE_CatMon_SdlMid_CatAcvDiag|A|();|SCH.4|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CatMon_SdlMid_CatAcvDiag
rte_RE_CatMon_SdlMid_CatPasDiag|A|();|SCH.7|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CatMon_SdlMid_CatPasDiag
rte_RE_CatMon_SdlSlow_CatAcvDiag|A|();|SCH.5|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CatMon_SdlSlow_CatAcvDiag
rte_RE_CoClLASl_001_MSE|A|();|SCH.76|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoClLASl_001_MSE
rte_RE_CoEmSTT_001_MSE|A|();|SCH.86|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoEmSTT_001_MSE
rte_RE_CoEmSTT_002_TEV|A|();|SCH.87|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoEmSTT_002_TEV
rte_RE_CoGBx_001_MSE|A|();|SCH.88|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoGBx_001_MSE
rte_RE_CoStopStart_003_MSE|A|();|SCH.96|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_003_MSE
rte_RE_CoStopStart_004_TEV|A|();|SCH.97|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_004_TEV
rte_RE_CoStopStart_007_MSE|A|();|SCH.98|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_007_MSE
rte_RE_CoStopStart_008_TEV|A|();|SCH.99|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_008_TEV
rte_RE_CoStopStart_009_MSE|A|();|SCH.100|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_009_MSE
rte_RE_CoStopStart_010_TEV|A|();|SCH.101|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_010_TEV
rte_RE_CoStopStart_011_MSE|A|();|SCH.102|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_011_MSE
rte_RE_CoStopStart_012_TEV|A|();|SCH.103|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_012_TEV
rte_RE_CoStopStart_013_MSE|A|();|SCH.104|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_013_MSE
rte_RE_CoStopStart_014_TEV|A|();|SCH.105|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_014_TEV
rte_RE_CoStopStart_015_MSE|A|();|SCH.106|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_015_MSE
rte_RE_CoStopStart_016_TEV|A|();|SCH.107|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_016_TEV
rte_RE_CoStopStart_017_MSE|A|();|SCH.108|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_017_MSE
rte_RE_CoStopStart_018_TEV|A|();|SCH.109|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_018_TEV
rte_RE_CoStopStart_019_MSE|A|();|SCH.110|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_019_MSE
rte_RE_CoStopStart_020_TEV|A|();|SCH.111|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_020_TEV
rte_RE_CoStopStart_021_MSE|A|();|SCH.112|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_021_MSE
rte_RE_CoStopStart_022_TEV|A|();|SCH.113|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_022_TEV
rte_RE_CoStopStart_023_MSE|A|();|SCH.114|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_023_MSE
rte_RE_CoStopStart_024_TEV|A|();|SCH.115|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_024_TEV
rte_RE_CoStopStart_025_MSE|A|();|SCH.116|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_025_MSE
rte_RE_CoStopStart_026_TEV|A|();|SCH.117|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_026_TEV
rte_RE_CoStopStart_027_MSE|A|();|SCH.118|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_027_MSE
rte_RE_CoStopStart_028_TEV|A|();|SCH.119|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_028_TEV
rte_RE_CoStopStart_029_MSE|A|();|SCH.120|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_029_MSE
rte_RE_CoStopStart_030_TEV|A|();|SCH.121|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_030_TEV
rte_RE_CoStopStart_031_MSE|A|();|SCH.122|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_031_MSE
rte_RE_CoStopStart_032_TEV|A|();|SCH.123|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoStopStart_032_TEV
rte_RE_CoTq_001_MSE|A|();|SCH.124|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoTq_001_MSE
rte_RE_CoTq_002_TEV|A|();|SCH.125|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoTq_002_TEV
rte_RE_CoTq_003_MSE|A|();|SCH.126|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoTq_003_MSE
rte_RE_CoTq_004_TEV|A|();|SCH.127|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoTq_004_TEV
rte_RE_CoTq_005_MSE|A|();|SCH.128|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoTq_005_MSE
rte_RE_CoTq_006_TEV|A|();|SCH.129|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoTq_006_TEV
rte_RE_CoTq_007_MSE|A|();|SCH.130|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoTq_007_MSE
rte_RE_CoTq_008_TEV|A|();|SCH.131|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoTq_008_TEV
rte_RE_CoTq_009_MSE|A|();|SCH.132|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoTq_009_MSE
rte_RE_CoTq_010_TEV|A|();|SCH.133|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoTq_010_TEV
rte_RE_CoTq_011_DRE|A|();|SCH.134|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CoTq_011_DRE
rte_RE_CurDrivFil_001_MSE|A|();|SCH.135|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_CurDrivFil_001_MSE
rte_RE_DCM_MANU_StubServiceAftS|A|();|SCH.8|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_DCM_MANU_StubServiceAftS
rte_RE_DfwCtl_001_MSE|A|();|SCH.142|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_DfwCtl_001_MSE
rte_RE_DfwCtl_002_TEV|A|();|SCH.143|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_DfwCtl_002_TEV
rte_RE_DmpVlv_H_001_MSE|A|();|SCH.144|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_DmpVlv_H_001_MSE
rte_RE_DmpVlv_H_002_TEV|A|();|SCH.145|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_DmpVlv_H_002_TEV
rte_RE_EBStub_001_MSE|A|();|SCH.146|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EBStub_001_MSE
rte_RE_EngLim_001_MSE|A|();|SCH.147|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLim_001_MSE
rte_RE_EngLimTqT_001_MSE|A|();|SCH.150|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_001_MSE
rte_RE_EngLimTqT_002_DRE|A|();|SCH.151|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_002_DRE
rte_RE_EngLimTqT_003_MSE|A|();|SCH.152|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_003_MSE
rte_RE_EngLimTqT_004_DRE|A|();|SCH.153|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_004_DRE
rte_RE_EngLimTqT_005_MSE|A|();|SCH.154|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_005_MSE
rte_RE_EngLimTqT_006_DRE|A|();|SCH.155|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_006_DRE
rte_RE_EngLimTqT_007_MSE|A|();|SCH.156|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_007_MSE
rte_RE_EngLimTqT_008_DRE|A|();|SCH.157|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_008_DRE
rte_RE_EngLimTqT_009_MSE|A|();|SCH.158|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_009_MSE
rte_RE_EngLimTqT_010_TEV|A|();|SCH.159|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_010_TEV
rte_RE_EngLimTqT_011_MSE|A|();|SCH.160|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_011_MSE
rte_RE_EngLimTqT_012_DRE|A|();|SCH.161|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_012_DRE
rte_RE_EngLimTqT_013_MSE|A|();|SCH.162|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_013_MSE
rte_RE_EngLimTqT_014_DRE|A|();|SCH.163|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngLimTqT_014_DRE
rte_RE_EngMGslLim_001_MSE|A|();|SCH.164|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslLim_001_MSE
rte_RE_EngMGslLim_002_TEV|A|();|SCH.165|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslLim_002_TEV
rte_RE_EngMGslLim_003_TEV|A|();|SCH.166|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslLim_003_TEV
rte_RE_EngMGslT_001_MSE|A|();|SCH.167|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslT_001_MSE
rte_RE_EngMGslT_002_TEV|A|();|SCH.168|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslT_002_TEV
rte_RE_EngMGslT_004_TEV|A|();|SCH.169|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslT_004_TEV
rte_RE_EngMGslT_008_TEV|A|();|SCH.170|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslT_008_TEV
rte_RE_EngMGslT_012_TEV|A|();|SCH.171|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslT_012_TEV
rte_RE_EngMGslT_018_TEV|A|();|SCH.172|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslT_018_TEV
rte_RE_EngMGslT_020_TEV|A|();|SCH.173|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslT_020_TEV
rte_RE_EngMGslT_022_TEV|A|();|SCH.174|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslT_022_TEV
rte_RE_EngMGslT_024_TEV|A|();|SCH.175|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslT_024_TEV
rte_RE_EngMGslT_026_TEV|A|();|SCH.176|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EngMGslT_026_TEV
rte_RE_EOMGsl_001_MSE|A|();|SCH.177|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EOMGsl_001_MSE
rte_RE_EOMGsl_002_TEV|A|();|SCH.178|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EOMGsl_002_TEV
rte_RE_EOMGsl_003_TEV|A|();|SCH.179|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EOMGsl_003_TEV
rte_RE_EOMGsl_004_TEV|A|();|SCH.180|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_EOMGsl_004_TEV
rte_RE_ExMGslT1_002_TEV|A|();|SCH.181|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ExMGslT1_002_TEV
rte_RE_ExMGslT1_003_TEV|A|();|SCH.182|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ExMGslT1_003_TEV
rte_RE_ExMGslT1_004_MSE|A|();|SCH.183|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ExMGslT1_004_MSE
rte_RE_ExMGslT1_005_MSE|A|();|SCH.184|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ExMGslT1_005_MSE
rte_RE_ExMGslT2_001_MSE|A|();|SCH.185|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ExMGslT2_001_MSE
rte_RE_ExMGslT2_006_TEV|A|();|SCH.186|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ExMGslT2_006_TEV
rte_RE_ExMGslT2_007_TEV|A|();|SCH.187|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ExMGslT2_007_TEV
rte_RE_FARSp_001_MSE|A|();|SCH.188|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_001_MSE
rte_RE_FARSp_002_TEV|A|();|SCH.189|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_002_TEV
rte_RE_FARSp_003_MSE|A|();|SCH.190|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_003_MSE
rte_RE_FARSp_004_TEV|A|();|SCH.191|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_004_TEV
rte_RE_FARSp_005_MSE|A|();|SCH.192|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_005_MSE
rte_RE_FARSp_006_TEV|A|();|SCH.193|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_006_TEV
rte_RE_FARSp_007_MSE|A|();|SCH.194|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_007_MSE
rte_RE_FARSp_008_TEV|A|();|SCH.195|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_008_TEV
rte_RE_FARSp_009_MSE|A|();|SCH.196|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_009_MSE
rte_RE_FARSp_010_TEV|A|();|SCH.197|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_010_TEV
rte_RE_FARSp_011_MSE|A|();|SCH.198|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_011_MSE
rte_RE_FARSp_012_TEV|A|();|SCH.199|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_012_TEV
rte_RE_FARSp_013_MSE|A|();|SCH.200|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_013_MSE
rte_RE_FARSp_014_TEV|A|();|SCH.201|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_014_TEV
rte_RE_FARSp_015_MSE|A|();|SCH.202|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_015_MSE
rte_RE_FARSp_016_TEV|A|();|SCH.203|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_016_TEV
rte_RE_FARSp_017_MSE|A|();|SCH.204|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_017_MSE
rte_RE_FARSp_018_TEV|A|();|SCH.205|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_018_TEV
rte_RE_FARSp_021_MSE|A|();|SCH.206|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_021_MSE
rte_RE_FARSp_022_TEV|A|();|SCH.207|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_022_TEV
rte_RE_FARSp_023_MSE|A|();|SCH.208|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_023_MSE
rte_RE_FARSp_024_TEV|A|();|SCH.209|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_024_TEV
rte_RE_FARSp_025_MSE|A|();|SCH.210|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_025_MSE
rte_RE_FARSp_026_TEV|A|();|SCH.211|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FARSp_026_TEV
rte_RE_FISA_CrankSync|A|();|SCH.212|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FISA_CrankSync
rte_RE_FISA_init|A|();|SCH.213|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_FISA_init
rte_RE_GSI_001_MSE|A|();|SCH.214|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_GSI_001_MSE
rte_RE_GSI_002_TEV|A|();|SCH.215|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_GSI_002_TEV
rte_RE_InMdlT_001_MSE|A|();|SCH.216|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_001_MSE
rte_RE_InMdlT_002_TEV|A|();|SCH.217|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_002_TEV
rte_RE_InMdlT_004_TEV|A|();|SCH.218|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_004_TEV
rte_RE_InMdlT_006_TEV|A|();|SCH.219|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_006_TEV
rte_RE_InMdlT_008_TEV|A|();|SCH.220|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_008_TEV
rte_RE_InMdlT_010_TEV|A|();|SCH.221|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_010_TEV
rte_RE_InMdlT_012_TEV|A|();|SCH.222|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_012_TEV
rte_RE_InMdlT_013_DRE|A|();|SCH.223|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_013_DRE
rte_RE_InMdlT_014_TEV|A|();|SCH.224|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_014_TEV
rte_RE_InMdlT_015_DRE|A|();|SCH.225|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_015_DRE
rte_RE_InMdlT_016_TEV|A|();|SCH.226|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_016_TEV
rte_RE_InMdlT_018_TEV|A|();|SCH.227|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_018_TEV
rte_RE_InMdlT_020_TEV|A|();|SCH.228|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_020_TEV
rte_RE_InMdlT_022_TEV|A|();|SCH.229|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_022_TEV
rte_RE_InMdlT_024_DRE|A|();|SCH.230|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_024_DRE
rte_RE_InMdlT_026_TEV|A|();|SCH.231|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_026_TEV
rte_RE_InMdlT_027_TEV|A|();|SCH.232|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_027_TEV
rte_RE_InMdlT_028_TEV|A|();|SCH.233|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_028_TEV
rte_RE_InMdlT_029_TEV|A|();|SCH.234|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_029_TEV
rte_RE_InMdlT_031_TEV|A|();|SCH.235|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_031_TEV
rte_RE_InMdlT_032_TEV|A|();|SCH.236|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_032_TEV
rte_RE_InMdlT_033_TEV|A|();|SCH.237|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_033_TEV
rte_RE_InMdlT_034_TEV|A|();|SCH.238|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_034_TEV
rte_RE_InMdlT_035_MSE|A|();|SCH.239|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_035_MSE
rte_RE_InMdlT_036_MSE|A|();|SCH.240|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_036_MSE
rte_RE_InMdlT_037_MSE|A|();|SCH.241|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_037_MSE
rte_RE_InMdlT_037_TEV|A|();|SCH.242|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_037_TEV
rte_RE_InMdlT_038_MSE|A|();|SCH.243|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_038_MSE
rte_RE_InMdlT_039_MSE|A|();|SCH.244|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_039_MSE
rte_RE_InMdlT_040_MSE|A|();|SCH.245|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_040_MSE
rte_RE_InMdlT_041_MSE|A|();|SCH.246|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_041_MSE
rte_RE_InMdlT_042_MSE|A|();|SCH.247|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_042_MSE
rte_RE_InMdlT_043_MSE|A|();|SCH.248|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_043_MSE
rte_RE_InMdlT_044_MSE|A|();|SCH.249|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_044_MSE
rte_RE_InMdlT_045_MSE|A|();|SCH.250|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_045_MSE
rte_RE_InMdlT_046_MSE|A|();|SCH.251|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_046_MSE
rte_RE_InMdlT_047_MSE|A|();|SCH.252|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InMdlT_047_MSE
rte_RE_InThMdlT_001_MSE|A|();|SCH.253|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InThMdlT_001_MSE
rte_RE_InThMdlT_002_TEV|A|();|SCH.254|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InThMdlT_002_TEV
rte_RE_InThMdlT_004_TEV|A|();|SCH.255|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InThMdlT_004_TEV
rte_RE_InThMdlT_005_TEV|A|();|SCH.256|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InThMdlT_005_TEV
rte_RE_InThMdlT_006_TEV|A|();|SCH.257|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InThMdlT_006_TEV
rte_RE_InThMdlT_007_TEV|A|();|SCH.258|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InThMdlT_007_TEV
rte_RE_InThMdlT_008_TEV|A|();|SCH.259|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_InThMdlT_008_TEV
rte_RE_MPM_001_MSE|A|();|SCH.260|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_MPM_001_MSE
rte_RE_MPM_002_TEV|A|();|SCH.261|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_MPM_002_TEV
rte_RE_MPM_003_TEV|A|();|SCH.262|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_MPM_003_TEV
rte_RE_MPM_004_TEV|A|();|SCH.263|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_MPM_004_TEV
rte_RE_MPM_005_TEV|A|();|SCH.264|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_MPM_005_TEV
rte_RE_MPM_006_DRE|A|();|SCH.265|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_MPM_006_DRE
rte_RE_MPM_007_TEV|A|();|SCH.266|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_MPM_007_TEV
rte_RE_MPM_AftrsInit|A|();|SCH.267|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_MPM_AftrsInit
rte_RE_MPM_AftsNvm|A|();|SCH.268|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_MPM_AftsNvm
rte_RE_OilSys_001_MSE|A|();|SCH.269|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_OilSys_001_MSE
rte_RE_OilSys_002_TEV|A|();|SCH.270|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_OilSys_002_TEV
rte_RE_PFilFast_001_MSE|A|();|SCH.271|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_PFilFast_001_MSE
rte_RE_PFilSlow_008_MSE|A|();|SCH.274|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_PFilSlow_008_MSE
rte_RE_PnmAct_001_MSE|A|();|SCH.277|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_PnmAct_001_MSE
rte_RE_PnmAct_002_TEV|A|();|SCH.278|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_PnmAct_002_TEV
rte_RE_ProdElEm_001_MSE|A|();|SCH.279|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEm_001_MSE
rte_RE_ProdElEm_002_TEV|A|();|SCH.280|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEm_002_TEV
rte_RE_ProdElEm_003_MSE|A|();|SCH.281|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEm_003_MSE
rte_RE_ProdElEm_004_TEV|A|();|SCH.282|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEm_004_TEV
rte_RE_ProdElEm_005_MSE|A|();|SCH.283|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEm_005_MSE
rte_RE_ProdElEm_006_TEV|A|();|SCH.284|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEm_006_TEV
rte_RE_ProdElEng_001_MSE|A|();|SCH.285|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_001_MSE
rte_RE_ProdElEng_002_TEV|A|();|SCH.286|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_002_TEV
rte_RE_ProdElEng_003_MSE|A|();|SCH.287|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_003_MSE
rte_RE_ProdElEng_004_TEV|A|();|SCH.288|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_004_TEV
rte_RE_ProdElEng_005_MSE|A|();|SCH.289|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_005_MSE
rte_RE_ProdElEng_006_TEV|A|();|SCH.290|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_006_TEV
rte_RE_ProdElEng_007_MSE|A|();|SCH.291|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_007_MSE
rte_RE_ProdElEng_008_TEV|A|();|SCH.292|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_008_TEV
rte_RE_ProdElEng_009_MSE|A|();|SCH.293|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_009_MSE
rte_RE_ProdElEng_010_TEV|A|();|SCH.294|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_010_TEV
rte_RE_ProdElEng_011_MSE|A|();|SCH.295|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_011_MSE
rte_RE_ProdElEng_012_TEV|A|();|SCH.296|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_012_TEV
rte_RE_ProdElEng_013_MSE|A|();|SCH.297|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_013_MSE
rte_RE_ProdElEng_014_TEV|A|();|SCH.298|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_014_TEV
rte_RE_ProdElEng_015_MSE|A|();|SCH.299|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_015_MSE
rte_RE_ProdElEng_016_TEV|A|();|SCH.300|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ProdElEng_016_TEV
rte_RE_RCD_001_MSE|A|();|SCH.301|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_RCD_001_MSE
rte_RE_RCD_002_TEV|A|();|SCH.302|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_RCD_002_TEV
rte_RE_StopStrtEm_001_MSE|A|();|SCH.303|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEm_001_MSE
rte_RE_StopStrtEm_002_TEV|A|();|SCH.304|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEm_002_TEV
rte_RE_StopStrtEm_003_MSE|A|();|SCH.305|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEm_003_MSE
rte_RE_StopStrtEm_004_TEV|A|();|SCH.306|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEm_004_TEV
rte_RE_StopStrtEm_005_MSE|A|();|SCH.307|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEm_005_MSE
rte_RE_StopStrtEm_006_TEV|A|();|SCH.308|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEm_006_TEV
rte_RE_StopStrtEng_003_MSE|A|();|SCH.309|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_003_MSE
rte_RE_StopStrtEng_004_TEV|A|();|SCH.310|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_004_TEV
rte_RE_StopStrtEng_005_MSE|A|();|SCH.311|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_005_MSE
rte_RE_StopStrtEng_006_TEV|A|();|SCH.312|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_006_TEV
rte_RE_StopStrtEng_007_MSE|A|();|SCH.313|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_007_MSE
rte_RE_StopStrtEng_008_TEV|A|();|SCH.314|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_008_TEV
rte_RE_StopStrtEng_009_MSE|A|();|SCH.315|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_009_MSE
rte_RE_StopStrtEng_010_TEV|A|();|SCH.316|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_010_TEV
rte_RE_StopStrtEng_011_MSE|A|();|SCH.317|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_011_MSE
rte_RE_StopStrtEng_012_TEV|A|();|SCH.318|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_012_TEV
rte_RE_StopStrtEng_013_MSE|A|();|SCH.319|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_013_MSE
rte_RE_StopStrtEng_014_TEV|A|();|SCH.320|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_014_TEV
rte_RE_StopStrtEng_015_MSE|A|();|SCH.321|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_015_MSE
rte_RE_StopStrtEng_016_TEV|A|();|SCH.322|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_016_TEV
rte_RE_StopStrtEng_017_MSE|A|();|SCH.323|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_017_MSE
rte_RE_StopStrtEng_018_TEV|A|();|SCH.324|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_018_TEV
rte_RE_StopStrtEng_019_MSE|A|();|SCH.325|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_019_MSE
rte_RE_StopStrtEng_020_TEV|A|();|SCH.326|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_020_TEV
rte_RE_StopStrtEng_021_MSE|A|();|SCH.327|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_021_MSE
rte_RE_StopStrtEng_022_TEV|A|();|SCH.328|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_022_TEV
rte_RE_StopStrtEng_023_MSE|A|();|SCH.329|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_023_MSE
rte_RE_StopStrtEng_024_TEV|A|();|SCH.330|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_StopStrtEng_024_TEV
rte_RE_ThMgt_001_MSE|A|();|SCH.331|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ThMgt_001_MSE
rte_RE_ThMgt_002_TEV|A|();|SCH.332|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ThMgt_002_TEV
rte_RE_ThMgt_003_TEV|A|();|SCH.333|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ThMgt_003_TEV
rte_RE_ThMgt_004_TEV|A|();|SCH.334|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ThMgt_004_TEV
rte_RE_ThrSpT_001_MSE|A|();|SCH.335|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ThrSpT_001_MSE
rte_RE_ThrSpT_002_TEV|A|();|SCH.336|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ThrSpT_002_TEV
rte_RE_ThrSpT_003_TEV|A|();|SCH.337|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_ThrSpT_003_TEV
rte_RE_TPM_001_MSE|A|();|SCH.338|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TPM_001_MSE
rte_RE_TPM_002_TEV|A|();|SCH.339|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TPM_002_TEV
rte_RE_TPM_003_TEV|A|();|SCH.340|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TPM_003_TEV
rte_RE_TPM_004_TEV|A|();|SCH.341|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TPM_004_TEV
rte_RE_TPM_005_TEV|A|();|SCH.342|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TPM_005_TEV
rte_RE_TPM_006_TEV|A|();|SCH.343|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TPM_006_TEV
rte_RE_TPM_007_TEV|A|();|SCH.344|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TPM_007_TEV
rte_RE_TPM_008_TEV|A|();|SCH.345|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TPM_008_TEV
rte_RE_TPM_009_DRE|A|();|SCH.346|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TPM_009_DRE
rte_RE_TqAdp_Sdl10ms_TqAdpLossClc|A|();|SCH.348|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqAdp_Sdl10ms_TqAdpLossClc
rte_RE_TqAdpCmp_001_MSE|A|();|SCH.347|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqAdpCmp_001_MSE
rte_RE_TqDem_001_MSE|A|();|SCH.359|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqDem_001_MSE
rte_RE_TqDem_002_TEV|A|();|SCH.360|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqDem_002_TEV
rte_RE_TqDem_003_TEV|A|();|SCH.361|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqDem_003_TEV
rte_RE_TqDem_004_TEV|A|();|SCH.362|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqDem_004_TEV
rte_RE_TqDem_005_TEV|A|();|SCH.363|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqDem_005_TEV
rte_RE_TqDem_006_TEV|A|();|SCH.364|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqDem_006_TEV
rte_RE_TqDem_007_TEV|A|();|SCH.365|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqDem_007_TEV
rte_RE_TqDem_008_TEV|A|();|SCH.366|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqDem_008_TEV
rte_RE_TqEM_001_MSE|A|();|SCH.367|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqEM_001_MSE
rte_RE_TqEM_002_TEV|A|();|SCH.368|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqEM_002_TEV
rte_RE_TqEM_004_TEV|A|();|SCH.369|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqEM_004_TEV
rte_RE_TqEM_006_DRE|A|();|SCH.370|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqEM_006_DRE
rte_RE_TqSys_EveSync_AntiStallReg|A|();|SCH.77|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_AntiStallReg
rte_RE_TqSys_EveSync_AOS|A|();|SCH.136|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_AOS
rte_RE_TqSys_EveSync_CoPtAntiStall|A|();|SCH.78|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_CoPtAntiStall
rte_RE_TqSys_EveSync_CurCor|A|();|SCH.137|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_CurCor
rte_RE_TqSys_EveSync_CurCord|A|();|SCH.79|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_CurCord
rte_RE_TqSys_EveSync_CurDrivFil|A|();|SCH.138|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_CurDrivFil
rte_RE_TqSys_EveSync_CurStCalc|A|();|SCH.139|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_CurStCalc
rte_RE_TqSys_EveSync_CutDyn|A|();|SCH.140|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_CutDyn
rte_RE_TqSys_EveSync_IdlCordLim|A|();|SCH.80|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_IdlCordLim
rte_RE_TqSys_EveSync_TqCll|A|();|SCH.81|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_TqCll
rte_RE_TqSys_EveSync_TqClrCros|A|();|SCH.141|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_TqClrCros
rte_RE_TqSys_EveSync_TqCordLim|A|();|SCH.82|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_TqCordLim
rte_RE_TqSys_EveSync_Tra|A|();|SCH.91|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_Tra
rte_RE_TqSys_EveSync_VarAntiStall|A|();|SCH.83|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSync_VarAntiStall
rte_RE_TqSys_EveSyncFrame30D_Tra|A|();|SCH.89|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSyncFrame30D_Tra
rte_RE_TqSys_EveSyncFrame38D_Tra|A|();|SCH.90|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_EveSyncFrame38D_Tra
rte_RE_TqSys_Sdl100ms_TqCmpTAir|A|();|SCH.349|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl100ms_TqCmpTAir
rte_RE_TqSys_Sdl10ms_CluPCord|A|();|SCH.92|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_CluPCord
rte_RE_TqSys_Sdl10ms_CoCha|A|();|SCH.272|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_CoCha
rte_RE_TqSys_Sdl10ms_CoChaTqSlow|A|();|SCH.275|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_CoChaTqSlow
rte_RE_TqSys_Sdl10ms_CoPtGearCord|A|();|SCH.93|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_CoPtGearCord
rte_RE_TqSys_Sdl10ms_EfcAirFil|A|();|SCH.276|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_EfcAirFil
rte_RE_TqSys_Sdl10ms_EngLimStat|A|();|SCH.148|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_EngLimStat
rte_RE_TqSys_Sdl10ms_IdlCordLim|A|();|SCH.84|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_IdlCordLim
rte_RE_TqSys_Sdl10ms_TqCmpAccCord|A|();|SCH.350|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_TqCmpAccCord
rte_RE_TqSys_Sdl10ms_TqCmpEngLoss|A|();|SCH.351|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_TqCmpEngLoss
rte_RE_TqSys_Sdl10ms_TqCmpGlbCord|A|();|SCH.352|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_TqCmpGlbCord
rte_RE_TqSys_Sdl10ms_TqCmpTqAC|A|();|SCH.353|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_TqCmpTqAC
rte_RE_TqSys_Sdl10ms_TqCmpTqAC3|A|();|SCH.354|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_TqCmpTqAC3
rte_RE_TqSys_Sdl10ms_TqCmpTqAC4|A|();|SCH.355|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_TqCmpTqAC4
rte_RE_TqSys_Sdl10ms_TqCmpTqAlt|A|();|SCH.356|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_TqCmpTqAlt
rte_RE_TqSys_Sdl10ms_TqCmpTqCnv|A|();|SCH.357|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_TqCmpTqCnv
rte_RE_TqSys_Sdl10ms_TqCmpTqStg|A|();|SCH.358|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_TqCmpTqStg
rte_RE_TqSys_Sdl10ms_TqCordLim|A|();|SCH.85|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_TqCordLim
rte_RE_TqSys_Sdl10ms_tqEfcFil|A|();|SCH.273|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_tqEfcFil
rte_RE_TqSys_Sdl10ms_TqLimFwdRvs|A|();|SCH.149|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_TqLimFwdRvs
rte_RE_TqSys_Sdl10ms_Tra|A|();|SCH.94|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl10ms_Tra
rte_RE_TqSys_Sdl20ms_Tra|A|();|SCH.95|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqSys_Sdl20ms_Tra
rte_RE_TqTreat_001_MSE|A|();|SCH.371|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqTreat_001_MSE
rte_RE_TqTreat_002_TEV|A|();|SCH.372|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqTreat_002_TEV
rte_RE_TqTreat_003_MSE|A|();|SCH.373|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqTreat_003_MSE
rte_RE_TqTreat_004_TEV|A|();|SCH.374|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqTreat_004_TEV
rte_RE_TqTreat_005_MSE|A|();|SCH.375|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqTreat_005_MSE
rte_RE_TqTreat_006_DRE|A|();|SCH.376|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqTreat_006_DRE
rte_RE_TqTreat_007_MSE|A|();|SCH.377|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqTreat_007_MSE
rte_RE_TqTreat_008_DRE|A|();|SCH.378|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqTreat_008_DRE
rte_RE_TqTreat_009_MSE|A|();|SCH.379|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqTreat_009_MSE
rte_RE_TqTreat_010_TEV|A|();|SCH.380|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TqTreat_010_TEV
rte_RE_TraBVx_001_MSE|A|();|SCH.381|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TraBVx_001_MSE
rte_RE_TraBVx_016_DRE|A|();|SCH.382|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TraBVx_016_DRE
rte_RE_TraBVx_018_DRE|A|();|SCH.383|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TraBVx_018_DRE
rte_RE_TraBVx_020_DRE|A|();|SCH.384|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TraBVx_020_DRE
rte_RE_TraBVx_028_TEV|A|();|SCH.385|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TraBVx_028_TEV
rte_RE_TraBVx_030_TEV|A|();|SCH.386|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TraBVx_030_TEV
rte_RE_TraBVx_032_TEV|A|();|SCH.387|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TraBVx_032_TEV
rte_RE_TrbActGsl_001_MSE|A|();|SCH.388|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActGsl_001_MSE
rte_RE_TrbActGsl_002_TEV|A|();|SCH.389|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActGsl_002_TEV
rte_RE_TrbActGsl_003_TEV|A|();|SCH.390|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActGsl_003_TEV
rte_RE_TrbActGsl_004_TEV|A|();|SCH.391|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActGsl_004_TEV
rte_RE_TrbActMgt_001_MSE|A|();|SCH.392|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActMgt_001_MSE
rte_RE_TrbActMgt_002_TEV|A|();|SCH.393|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActMgt_002_TEV
rte_RE_TrbActMgt_003_TEV|A|();|SCH.394|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActMgt_003_TEV
rte_RE_TrbActSys_001_MSE|A|();|SCH.395|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActSys_001_MSE
rte_RE_TrbActSys_002_TEV|A|();|SCH.396|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActSys_002_TEV
rte_RE_TrbActSys_003_TEV|A|();|SCH.397|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActSys_003_TEV
rte_RE_TrbActSys_004_TEV|A|();|SCH.398|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActSys_004_TEV
rte_RE_TrbActSys_005_TEV|A|();|SCH.399|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActSys_005_TEV
rte_RE_TrbActSys_AftrsInit|A|();|SCH.400|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActSys_AftrsInit
rte_RE_TrbActSys_AftsNvm|A|();|SCH.401|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_TrbActSys_AftsNvm
rte_RE_UsThrMT_001_MSE|A|();|SCH.402|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_001_MSE
rte_RE_UsThrMT_002_TEV|A|();|SCH.403|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_002_TEV
rte_RE_UsThrMT_004_MSE|A|();|SCH.404|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_004_MSE
rte_RE_UsThrMT_005_TEV|A|();|SCH.405|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_005_TEV
rte_RE_UsThrMT_006_TEV|A|();|SCH.406|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_006_TEV
rte_RE_UsThrMT_007_TEV|A|();|SCH.407|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_007_TEV
rte_RE_UsThrMT_008_DRE|A|();|SCH.408|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_008_DRE
rte_RE_UsThrMT_008_TEV|A|();|SCH.409|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_008_TEV
rte_RE_UsThrMT_009_DRE|A|();|SCH.410|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_009_DRE
rte_RE_UsThrMT_010_TEV|A|();|SCH.411|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_010_TEV
rte_RE_UsThrMT_011_TEV|A|();|SCH.412|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_011_TEV
rte_RE_UsThrMT_012_TEV|A|();|SCH.413|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_UsThrMT_012_TEV
rte_RE_VSCo_001_MSE|A|();|SCH.414|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSCo_001_MSE
rte_RE_VSCo_002_TEV|A|();|SCH.415|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSCo_002_TEV
rte_RE_VSInfo_001_MSE|A|();|SCH.416|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSInfo_001_MSE
rte_RE_VSInfo_002_TEV|A|();|SCH.417|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSInfo_002_TEV
rte_RE_VSInfo_003_TEV|A|();|SCH.418|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSInfo_003_TEV
rte_RE_VSInfo_004_TEV|A|();|SCH.419|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSInfo_004_TEV
rte_RE_VSLim_001_MSE|A|();|SCH.420|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSLim_001_MSE
rte_RE_VSLim_002_TEV|A|();|SCH.421|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSLim_002_TEV
rte_RE_VSMax_001_MSE|A|();|SCH.422|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSMax_001_MSE
rte_RE_VSMax_002_TEV|A|();|SCH.423|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSMax_002_TEV
rte_RE_VSReg_001_MSE|A|();|SCH.424|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSReg_001_MSE
rte_RE_VSReg_002_TEV|A|();|SCH.425|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSReg_002_TEV
rte_RE_VSSp_001_MSE|A|();|SCH.426|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSSp_001_MSE
rte_RE_VSSp_002_TEV|A|();|SCH.427|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSSp_002_TEV
rte_RE_VSSp_003_TEV|A|();|SCH.428|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSSp_003_TEV
rte_RE_VSSp_004_MSE|A|();|SCH.429|IFRTE|1|NONE||||0|0|0|0|Gestion de l'inhibition de la tache RE_VSSp_004_MSE
RTMTSK_vidTaskTimeMeasure|C|();|0x02|RTMTSK|1|V03 NT 10 08733||||0|0|0|0||
RTMTSK_vidTaskTimeMeasureInit|B|();|0x00|RTMTSK|1|V03 NT 10 08733||||0|0|0|0||
RTMTSK_vidTaskTimeMeasureStart|B|();|0x01|RTMTSK|1|V03 NT 10 08733||||0|0|0|0||
RVSSTDIAG_vidCheckDiagRvs|A|();|FCT1.3|RVSSTDIAG|0|V02 NT 09 01180||||0|0|0|0|Cette fonction permet de sécuriser l'entrée Gear_bRvsRaw : si on reçoit du CAN l’information « MAR engagée » et qu'on sait que la chaine de traction est fermée (embrayage non appuyé) et qu’on roule sur des rapports élevés, un défaut est levé.
RVSSTDIAG_vidDiagMng|A|();|FCT1.2|RVSSTDIAG|0|V02 NT 09 01180||||0|0|0|0|cette fonction permet l'activation et la déactivation  du diagnostic fonctionnel " marche arrière"
RVSSTDIAG_vidEntryInit|C|();|SCH.1|RVSSTDIAG|1|V02 NT 09 01180||||0|0|0|0|Acroche moniteur pour l'initailisation des sorties
RVSSTDIAG_vidInitOutput|A|();|FCT1.1|RVSSTDIAG|0|V02 NT 09 01180||||0|0|0|0|Cette fonction initialise la sortie et le booléen de signalisation  de panne  du module RVSSTDIAG
SAIMMO_CODE__nvmini|F|();|FCT5.2|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Init the EEPROM object SAIMMO_CODE if it is in default and if the first init has never been done.|
SAIMMO_ETAT__nvmini|F|();|FCT5.1|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|init the EEPROM object SAIMMO_ETAT if it is in default and if the first init has never been done.|
SAIMMO_EveRst|G|();|SCH.1|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Function called on reset. It calls IMMO's function (if necessary) and intializes the internal SAIMMO data.|
SAIMMO_EveRxn0A8|F|();|FCT2.2|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Function called by the ISCAN on the frame 0A8 reception.|
SAIMMO_EveRxn0E0|F|();|FCT2.1|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Function called by the ISCAN on the frame 0E0 reception.|
SAIMMO_init|D|();|FCT5.3|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Call the IMMO module function if the module hanve not been already activated.|
SAIMMO_SdlMid|G|();|SCH.2|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Call on event "sdlMid". It sequences the IMMO tasks at the Sdl_Mid recurence.|
SAIMMO_vidCallIsCanTx|E|();|FCT2.5|SAIMMO|0|PTS_DOC_5060905||||0|0|0|0|Call the right function (client or PSA) to send data on ISCAN.|
SAIMMO_vidChkWrEep|G|();|FCT1.1|SAIMMO|0|PTS_DOC_5060905||||0|0|0|0|check the EEPROM object writing and send the status to IMMO.|
SAIMMO_vidSdlFast|H|();|SCH.3|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0|Call on event "sdlFast". It sequences the IMMO tasks at the Sdl_fast recurence.|
SAIMMO_vidSendCAN|E|();|FCT1.3|SAIMMO|0|PTS_DOC_5060905||||0|0|0|0|Management of the periodic emission of CAN frames.|
SAIMMO_vidUpdateSaimmoExit|F|();|FCT1.2|SAIMMO|0|PTS_DOC_5060905||||0|0|0|0|Update the SAIMMO exit data with the value get from IMMO.|
SBPAGEN_vidCalculer_niveau|B|();|FCT1.3|SBPAGEN|0|V02 NT 08 07560||||0|0|0|0|effectue  les opérations dans  le  registre de décalage, produit  la valeur du compteur de période et commande la valeur du niveau de sortie du signal
SBPAGEN_vidCalculer_SBPA|A|();|FCT1.2|SBPAGEN|0|V02 NT 08 07560||||0|0|0|0|Cette fonction génère une SBPA utilisée pour l’identification de système.
SBPAGEN_vidDecaler_registre|B|();|FCT1.5|SBPAGEN|0|V02 NT 08 07560||||0|0|0|0|La  fonction  « mod »  effectue  la  remise  à  zéro  du  compteur  lorsque  celui-ci atteint  la valeur définie par le paramètre TqSys_noPerSBPA_C, ce qui a pour effet de générer un front montant de la sortie TqSys_bAcvChgLvl.
SBPAGEN_vidEffectuer_traitements|B|();|FCT1.4|SBPAGEN|0|V02 NT 08 07560||||0|0|0|0|applique  les  valeurs  de  couple  à  la  SBPA  selon  le  niveau demandé par le registre de décalage et renvoie la valeur du compteur de cycles ainsi que la somme entre les niveaux de couple haut et bas.
SBPAGEN_vidEntryInit|B|();|SCH.1|SBPAGEN|1|V02 NT 08 07560||||0|0|0|0|Fonction d'accroche moniteur Reset.
SBPAGEN_vidInitOutput|B|();|FCT1.1|SBPAGEN|0|V02 NT 08 07560||||0|0|0|0|Initialisation des variables de sortie
SBPAGEN_vidModifier_niveau|B|();|FCT1.6|SBPAGEN|0|V02 NT 08 07560||||0|0|0|0|L’ordre TqSys_bAcvChgLvl active  le  rafraîchissement des calculs du  registre de décalage à 9 états, qui  déterminent la consigne de commutation du niveau de la SBPA (TqSys_bLvlSBPA).
SECUBV_vidAL4AT8Presente|A|();|FCT4.2|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Ce bloc traite AL4/AT8  présente .|
SECUBV_vidAutre|A|();|FCT4.3|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Ce bloc traite le cas où AL4/AT8 non présente.|
SECUBV_vidBVABVMPConfiguration|B|();|FCT1.4|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Cette fonction effectue la synthèse des défauts CMM boite.|
SECUBV_vidBVConfiguration|A|();|FCT1.2|SECUBV|0|V02 NT 10 01251||||0|0|0|0|fonction qui assure le Test de la configuration définissant le code à compiler|
SECUBV_vidBVMConfiguration|A|();|FCT1.3|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Cette fonction permet de bypasser la sécurisation dans le cas d’une BVM|
SECUBV_vidCalculSIPOutOfRange|C|();|FCT3.3|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Ce Bloc Vérifie que la demande de SIP CMM boite est inférieure à un seuil.|
SECUBV_vidComparaisonSeuilSIP|A|();|FCT3.6|SECUBV|0|V02 NT 10 01251||||0|0|0|0|cette fonction precise que Lorsque le compteur dépasse un seuil. Un défaut est remonté.|
SECUBV_vidCompSeuilIntegrSurcple|A|();|FCT4.8|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Le résultat de l’intégrale de surcouple est comparé à un seuil dépendant de la vitesse véhicule.|
SECUBV_vidCompteurSIP|B|();|FCT3.5|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Ce Bloc effectue le calcul du compteur de temps passé pour la variable SIP égale à 1|
SECUBV_vidConfiguationAL4|A|();|FCT4.1|SECUBV|0|V02 NT 10 01251||||0|0|0|0|en attendant le SIQ|
SECUBV_vidCoordDebounceSIPErreur|E|();|FCT3.4|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Ce bloc effectue la synthèse des défauts CMM boite génériques.|
SECUBV_vidCoordinationAL4Erreur|A|();|FCT4.6|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Coordination des erreurs spécifiques AL4.|
SECUBV_vidCoordinationDefautsAL4|A|();|FCT5.1|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Coordination des erreurs spécifiques AL4.|
SECUBV_vidDebounDefDeltaAirAvAl4|D|();|FCT4.9|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Debounce défaut couple lent / couple rapide|
SECUBV_vidDebounDefIntSurcpleAL4|D|();|FCT4.10|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Débounce défaut Intégrale de surcouple|
SECUBV_vidDetectErrCplLentCplRap|A|();|FCT4.4|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Surveillance du couple lent par rapport au couple rapide.|
SECUBV_vidDetectErrIntegrSurcple|A|();|FCT4.5|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Surveillance de l’integrale de surcouple rapide/volonte conducteur du Niveau 1.|
SECUBV_vidDetectionSIPInvalide|C|();|FCT3.2|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Ce Bloc teste la cohérence de la demande de SIP CMM boite (SftyMgt_bSIPCoPt) avec le flux provenant du parametre sécurisé (SftyMgt_bSIPGBx).|
SECUBV_vidEntryInit|C|();|SCH.1|SECUBV|1|V02 NT 10 01251||||0|0|0|0|évènement reset du calculateur.|
SECUBV_vidIFTHENCompteurSIP|A|();|FCT3.7|SECUBV|0|V02 NT 10 01251||||0|0|0|0|la fonction permet de définir la mise en marche  et l'arret du compteur|
SECUBV_vidIFTHENIntegraleSurcple|A|();|FCT5.2|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Le compteur est mis en marche lorsque SftyMgt_bSIPCoPt est égal à 1.  Le compteur  est remis à 0 lorsque  SftyMgt_bSIPCoPt est égal à 0.  On change de rapport cible (prise en compte calibrable).|
SECUBV_vidIncrementeCompteurSIP|A|();|FCT3.9|SECUBV|0|V02 NT 10 01251||||0|0|0|0|ce bloc permet l'Incrémentation du compteur.|
SECUBV_vidInitOutput|F|();|FCT1.1|SECUBV|0|V02 NT 10 01251||||0|0|0|0|initialisation des sorties.|
SECUBV_vidIntegraleSurcouple|A|();|FCT4.7|SECUBV|0|V02 NT 10 01251||||0|0|0|0|cette fonction calcule l'integrale sur couple|
SECUBV_vidIntegraleSurcple|D|();|FCT5.4|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Intégrale de surcouple.|
SECUBV_vidRAZCompteurSIP|A|();|FCT3.8|SECUBV|0|V02 NT 10 01251||||0|0|0|0|cette fonction permet de remmetre a 0 le compteur|
SECUBV_vidRAZCompteursSurChange|A|();|FCT1.5|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Cette fonction détecte un chgt de rapport ou une entrée en régulation de régime alors qu’un SIP est engagé et en fonction de la configuration boite choisit de reseter ou non le compteur de temps.|
SECUBV_vidRAZIntegraleSurcouple|A|();|FCT5.3|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Compteur à 0|
SECUBV_vidSecurisaMiseEnPlaceFRM|C|();|FCT3.1|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Ce bloc Coordonne sécurise la mise en place du FRM d’inhibition de SIP|
SECUBV_vidSecurisationGBxActive|D|();|FCT1.9|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Ce bloc désactive le 0 torque lorsqu’il sécurise de manière active le couple|
SECUBV_vidSecurisationSpecifAL4|A|();|FCT1.7|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Ce bloc effectue l’analyse de la prise en main du couple moteur par l’AL4|
SECUBV_vidSecurisationTempsSIP|A|();|FCT1.6|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Cette fonction effectue l’analyse de la prise en main du couple moteur par les BVMP/BVA|
SECUBV_vidStrategieRAZFctBoite|C|();|FCT2.1|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Cette fonction décrit la stratégie de reset pour la fonction boite.|
SECUBV_vidSyntheseDefaut|C|();|FCT1.8|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Cette fonction effectue la synthèse entre les défauts CMM boite et l’état de la chaine de traction.|
SECUBV_vidTraiChgRapInCpleNiv1V2|C|();|FCT2.3|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Cette fonction gère la dynamique d’activation du niveau 1 qui a lieu lors de deux appels de la fonction de surveillance au niveau 2.|
SECUBV_vidTraiChgRapInCpleRst|C|();|FCT2.8|SECUBV|0|V02 NT 10 01251||||0|0|0|0|remise à zéro de SftyMgt_bNbTarGearChgTqIRst.|
SECUBV_vidTraiChgRapInCpleRun|C|();|FCT2.7|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Ce bloc compare les valeurs de rapport 1 à 1 pour détecter un changement|
SECUBV_vidTraiChgRapSIPRst|C|();|FCT2.6|SECUBV|0|V02 NT 10 01251||||0|0|0|0|remise à zéro de SftyMgt_bNbTarGearChgSIPRst.|
SECUBV_vidTraiChgRapSIPRun|C|();|FCT2.5|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Ce bloc compare les valeurs de raport 1 à 1 pour détecter une différence|
SECUBV_vidTraiChgRapSIPSdlNiv1V2|C|();|FCT2.2|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Cette fonction gère la dynamique d’activation du niveau 1 qui a lieu lors de deux appels de la fonction de surveillance au niveau 2.|
SECUBV_vidTrRegulRegAM6Rst|C|();|FCT2.10|SECUBV|0|V02 NT 10 01251||||0|0|0|0|remise à zéro de SftyMgt_bNRegReqChgSIPRst|
SECUBV_vidTrRegulRegAM6Run|D|();|FCT2.9|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Compare les valeurs de régul de régime AM6 1 à 1 pour détecter un changement.|
SECUBV_vidTrRegulRegAM6SdlNiv1V2|C|();|FCT2.4|SECUBV|0|V02 NT 10 01251||||0|0|0|0|Cette fonction gère la dynamique d’activation du niveau 1 qui a lieu lors de deux appels de la fonction de surveillance au niveau 2.|
SECUR_vidInit|D|(const uint16 AppliKey, const uint32 SeedRead, const uint32 SeedWrite);|28|HEADER|1|NONE||||0|0|0|0||
SenAct_EveCrTR_AcqAdc|A|();|SCH.10|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|CRANK to RUN event|
SenAct_EveCrTR_tECUAcq|B|();|SCH.3|TECUACQ|1|PTS_DOC_6851405||||0|0|0|0|CRANK to RUN event|
SenAct_EveCrTR_tECUAcqIf|B|();|SCH9.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Évènement passage CRANK vers RUN|
SenAct_EveRst_tECUAcq|B|();|SCH.1|TECUACQ|1|PTS_DOC_6851405||||0|0|0|0|EveRst for TECUACQ|
SenAct_EveRst_tECUAcqIf|B|();|SCH11.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Évènement reset|
SenAct_EveRst_tIGBTAcq|A|();|SCH.1|TIGBTACQ|1|PTS_DOC_5257921||||0|0|0|0|Reset event|
SenAct_EveRTSt_AcqAdc|A|();|SCH.11|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|RUN to STALL event|
SenAct_EveRTSt_tECUAcq|B|();|SCH.4|TECUACQ|1|PTS_DOC_6851405||||0|0|0|0|RUN to STALL event|
SenAct_EveRTSt_tECUAcqIf|B|();|SCH9.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Évènement passage RUN vers STALL|
SenAct_SdlMid_AcqAdc|A|();|SCH.12|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|Middle scheduler|
SenAct_SdlMid_tECUAcq|B|();|SCH.2|TECUACQ|1|PTS_DOC_6851405||||0|0|0|0|Middle scheduler|
SenAct_SdlMid_tECUAcqIf|B|();|SCH11.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur moyen|
SenAct_SdlSlow_AcqAdc|A|();|SCH.13|ACQADC_DT|1|PTS_DOC_6913284||||0|0|0|0|Slow scheduler|
SenAct_SdlSlow_tIGBTAcq|A|();|SCH.2|TIGBTACQ|1|PTS_DOC_5257921||||0|0|0|0|Slow scheduler|
SendMessage|A|(argin uint16 Id_msg, argio uint8 *Ptr_msg);|1|HEADER|1|V01 NT 08 05905||||0|0|0|0|
SENO2DLYGENR_vidEntryInit|A|();|SCH.1|SENO2DLYGENR|1|V02 NT 09 06150||||0|0|0|0|Evenement reset du calculateur
SENO2DLYGENR_vidInitOutput|A|();|FCT1.1|SENO2DLYGENR|0|V02 NT 09 06150||||0|0|0|0|Initialisation des sorties
SENO2DLYGENR_vidLeanRichInit|A|();|FCT2.1|SENO2DLYGENR|0|V02 NT 09 06150||||0|0|0|0|trasition from lean to rich
SENO2DLYGENR_vidLeanRichInitDly|B|();|FCT1.4|SENO2DLYGENR|0|V02 NT 09 06150||||0|0|0|0|At transition from lean to rich of the original signal, we initialise the delay before transition from lean to rich of the generated signal.While the previous delay is not elapsed, the transition is not carried out.
SENO2DLYGENR_vidLeanStatus|B|();|FCT2.4|SENO2DLYGENR|0|V02 NT 09 06150||||0|0|0|0|function of Lean status
SENO2DLYGENR_vidRichLeanInit|A|();|FCT2.2|SENO2DLYGENR|0|V02 NT 09 06150||||0|0|0|0|transition from rich to lean
SENO2DLYGENR_vidRichLeanInitDly|B|();|FCT1.5|SENO2DLYGENR|0|V02 NT 09 06150||||0|0|0|0|At transition from rich to lean of the original signal, we initialise the delay before transition from rich to lean of the generated signal. While the previous delay is not elapsed, the transition is not carried out.
SENO2DLYGENR_vidRichStatus|B|();|FCT2.3|SENO2DLYGENR|0|V02 NT 09 06150||||0|0|0|0|function of rich status
SENO2DLYGENR_vidStatusLean|A|();|FCT1.7|SENO2DLYGENR|0|V02 NT 09 06150||||0|0|0|0|function of status Lean
SENO2DLYGENR_vidStatusRich|A|();|FCT1.6|SENO2DLYGENR|0|V02 NT 09 06150||||0|0|0|0|function of status Rich
SENO2DLYGENR_vidUpOxyTestBed|A|();|FCT1.2|SENO2DLYGENR|0|V02 NT 09 06150||||0|0|0|0|The strategy is activated in case the Boolean calibration ‘Up_oxy_cfg_test_bed_enable_c0’ is set to ‘1’
SENO2DLYGENR_vidUpOxyTestBedMode|B|();|FCT1.3|SENO2DLYGENR|0|V02 NT 09 06150||||0|0|0|0|From the original upstream oxygen sensor voltage, we create a new square signal that we can delay. The maximum delay corresponds to one signal period.
SenO2Ds_EveCrTR_DsLsAcq|C|();|SCH.5|DSO2SEN|1|PTS_DOC_6563982||||0|0|0|0|Evénement CRANKING vers RUNNING|
SenO2Ds_EvePwrl_SigGrdDiag|D|();|SCH.4|HEATSENO2DSDERIDIAG|1|PTS_DOC_5012852||||0|0|0|0|Evènement powerlatch du calculateur|
SenO2Ds_EveRst_DsLsAcq|C|();|SCH.1|DSO2SEN|1|PTS_DOC_6563982||||0|0|0|0|Reset CMM|
SenO2Ds_EveRst_DsPlaus|G|();|SCH.1|HEATSENO2DSFONCDIAG|1|V02 NT 11 07942||||0|0|0|0|Evènement reset du calculateur pour la fonction SenO2Ds|
SenO2Ds_EveRst_SigGrdDiag|G|();|SCH.1|HEATSENO2DSDERIDIAG|1|PTS_DOC_5012852||||0|0|0|0|Evènement reset du calculateur pour la fonction SenO2Ds|
SenO2Ds_SdlFast_DsLsAcq|C|();|SCH.4|DSO2SEN|1|PTS_DOC_6563982||||0|0|0|0|Moniteur rapide pour la fonction sonde aval|
SenO2Ds_SdlFast_DsLsAcqAdc|A|();|SCH1.10|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur rapide pour la fonction sonde aval
SenO2Ds_SdlFast_DsLsAcqIf|C|();|SCH10.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide pour la fonction sonde aval|
SenO2Ds_SdlFast_SigGrdDiag|H|();|SCH.3|HEATSENO2DSDERIDIAG|1|PTS_DOC_5012852||||0|0|0|0|Moniteur rapide de la fonction SenO2Ds|
SenO2Ds_SdlLow_DsLsAcq|C|();|SCH.2|DSO2SEN|1|PTS_DOC_6563982||||0|0|0|0|Moniteur lent pour la fonction sonde aval|
SenO2Ds_SdlMid_DsLsAcq|C|();|SCH.3|DSO2SEN|1|PTS_DOC_6563982||||0|0|0|0|Moniteur moyen pour la fonction papillon|
SenO2Ds_SdlMid_DsPlaus|H|();|SCH.2|HEATSENO2DSFONCDIAG|1|V02 NT 11 07942||||0|0|0|0|Moniteur moyen pour la fonction SenO2Ds|
SenO2Ds_SdlMid_DsPlausIf|A|();|SCH.3|IFFAR|1|V02 NT 12 01358||||0|0|0|0|Moniteur du module d'interfacage en aval du SenO2Ds|
SenO2Ds_SdlMid_SigGrdDiag|H|();|SCH.2|HEATSENO2DSDERIDIAG|1|PTS_DOC_5012852||||0|0|0|0|Moniteur moyen de la fonction SenO2Ds|
SENO2DSACTEST_vidInitOutput|C|();|FCT1.1|SENO2DSACTEST|0|V02 NT 09 01049||||0|0|0|0|Initialisation des sorties|
SENO2DSACTEST_vidSO2DsTst|D|();|FCT1.2|SENO2DSACTEST|0|V02 NT 09 01049||||0|0|0|0|Déroulement des tests actionneurs  de la sonde aval|
SenO2Us_EveCrTR_UpLsAcq|B|();|SCH.2|UPLSACQ|1|PTS_DOC_6562315||||0|0|0|0|Fonction d'accroche moniteur à l'evenement SenO2Us_EveCrTR_UpLsAcq
SenO2Us_EveRst_PerDiag|H|();|SCH.1|HEATSENO2UPPERDDIAG|1|PTS_DOC_5012863||||0|0|0|0|Evènement reset du calculateur pour la fonction Sen02Us|
SenO2Us_EveRst_UpLsAcq|B|();|SCH.1|UPLSACQ|1|PTS_DOC_6562315||||0|0|0|0|Fonction d'accroche moniteur à l'evenement SenO2Us_EveRst_UpLsAcq
SenO2Us_EveRst_UsPlaus|H|();|SCH.1|HEATSENO2UPFONCDIAG|1|PTS_DOC_5482727||||0|0|0|0|Evènement reset du calculateur pour la fonction SenO2Us|
SenO2Us_EveTDC_UpLsAcq|A|();|SCH.3|UPLSACQ|1|PTS_DOC_6562315||||0|0|0|0|Fonction d'accroche moniteur à l'evenement SenO2Us_EveTDC_UpLsAcq
SenO2Us_SdlFast_PerDiag|I|();|SCH.2|HEATSENO2UPPERDDIAG|1|PTS_DOC_5012863||||0|0|0|0|Moniteur rapide de la fonction SenO2Us|
SenO2Us_SdlFast_SenO2DlyGenr|A|();|SCH.2|SENO2DLYGENR|1|V02 NT 09 06150||||0|0|0|0|Moniteur rapide de la fonction SenO2DlyGenr
SenO2Us_SdlFast_UpLsAcq|A|();|SCH.4|UPLSACQ|1|PTS_DOC_6562315||||0|0|0|0|Fonction d'accroche moniteur à l'evenement SenO2Us_SdlFast_UpLsAcq
SenO2Us_SdlFast_UpLsAcqAdc|A|();|SCH1.9|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Moniteur rapide pour la fonction sonde amont
SenO2Us_SdlFast_UpLsAcqIf|C|();|SCH2.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide pour la fonction sonde amont|
SenO2Us_SdlFast_UsPlaus|H|();|SCH.2|HEATSENO2UPFONCDIAG|1|PTS_DOC_5482727||||0|0|0|0|Moniteur rapide pour la fonction SenO2Us|
SenO2Us_SdlMid_UpLsAcq|A|();|SCH.5|UPLSACQ|1|PTS_DOC_6562315||||0|0|0|0|Fonction d'accroche moniteur à l'evenement SenO2Us_SdlMid_UpLsAcq
SenO2Us_SdlSlow_UpLsAcq|A|();|SCH.6|UPLSACQ|1|PTS_DOC_6562315||||0|0|0|0|Fonction d'accroche moniteur à l'evenement SenO2Us_SdlSlow_UpLsAcq
SENO2USACTEST_vidInitOutput|C|();|FCT1.1|SENO2USACTEST|0|V02 NT 08 08131||||0|0|0|0|Initialisation des sorties|
SENO2USACTEST_vidSO2UsTst|D|();|FCT1.2|SENO2USACTEST|0|V02 NT 08 08131||||0|0|0|0|Déroulement des tests actionneurs  de la sonde amont|
Sfty_EveInitCnt_TaskOvrrunCnt|A|();|8|HEADER|1|PTS_DOC_5074350||||0|0|0|0|Fonction appelée sur réception de la routine Init du compteur de défauts temps réel.|
Sfty_EveRst_DiagCpuSfty|E|();|SCH.1|SFTYCPUDIAG|1|PTS_DOC_5711967||||0|0|0|0|Evenement Reset.|
Sfty_EveRst_PfcMng|C|();|SCH.1|PFCMNG|1|V02 NT 11 06115||||0|0|0|0|Reset event|
Sfty_SdlFast_DiagCpuSfty|F|();|SCH.2|SFTYCPUDIAG|1|PTS_DOC_5711967||||0|0|0|0|Moniteur rapide de la fonction Sfty|
Sfty_SdlMid_PfcMng|D|();|SCH.2|PFCMNG|1|V02 NT 11 06115||||0|0|0|0|Middle scheduler of the function|
Sfty_SdlMid_PfcMng_Chk|D|(argin WdgM_SupervisedEntityIdType u8LocalSEID,argin WdgM_CheckpointIdType u16LocalCheckpointID);|SCH.3|PFCMNG|1|V02 NT 11 06115||||0|0|0|0|Actual SEID and checkpoint call event|
Sfty_SdlSlow_DiagCpuSfty|F|();|SCH.3|SFTYCPUDIAG|1|PTS_DOC_5711967||||0|0|0|0|Moniteur lent de la fonction Safety.|
SFTYCPUDIAG_vidDiagRomChecksum|D|();|FCT1.6|SFTYCPUDIAG|0|PTS_DOC_5711967||||0|0|0|0|Ce service permet de lire la valeur du checksum ROM du MCW.|
SFTYCPUDIAG_vidInitOutput|F|();|FCT1.1|SFTYCPUDIAG|0|PTS_DOC_5711967||||0|0|0|0|Initialisation des sorties du module SFTYCPUDIAG.|
SFTYCPUDIAG_vidMcwdgDiagnosesMCP|D|();|FCT1.3|SFTYCPUDIAG|0|PTS_DOC_5711967||||0|0|0|0|Ce block décrit la remontée du LDB vers le LDA des defauts qui sont détectés par le microcontrolleur principal.Le service utilisé est DGOHAL.|
SFTYCPUDIAG_vidMcwdgReadMCWFltSt|E|();|FCT1.4|SFTYCPUDIAG|0|PTS_DOC_5711967||||0|0|0|0|L’appel à MCWDG_u8ReadMcwFaultState retourne le status des défaillance  côté Watchdog Microcontrolleur (filtré par le gestionnaire de defaut du microcontrolleur watchdog et coherent avec la calibration du masque de configuration).|
SFTYCPUDIAG_vidMcwdgSampleCheck|D|();|FCT1.2|SFTYCPUDIAG|0|PTS_DOC_5711967||||0|0|0|0|Ce block permet d’activer la surveillance des échantillons de test.|
SFTYCPUDIAG_vidMcwdgWritMCPFltSt|D|();|FCT1.5|SFTYCPUDIAG|0|PTS_DOC_5711967||||0|0|0|0|Ce service permet de transmettre au microcontrolleur Watchdog les defaut safety remonté par le microcontrolleur principal.|
SftyMgt_EveChkLih_ifTqMon|D|();|SCH.3|SFTYMGTIFTQ|1|PTS_DOC_5147394||||0|0|0|0|Evènement d'autorisation des tests fonctionnels d'inhibition|
SftyMgt_EveRst_DiagSftyLvl2|C|();|SCH.1|DIAGSFTYLVL2|1|PTS_DOC_5147426||||0|0|0|0|Evènement reset|
SftyMgt_EveRst_ifTqMon|F|();|SCH.1|SFTYMGTIFTQ|1|PTS_DOC_5147394||||0|0|0|0|Evènement reset de la fonction ifTqMon|
SftyMgt_EveRst_SpdVehSecu|B|();|SCH.1|SPDVEHSECU|1|PTS_DOC_5664717||||0|0|0|0|Evenement d'initialisation.|
SftyMgt_EveRxn329_DiagSftyLvl2|C|();|SCH.3|DIAGSFTYLVL2|1|PTS_DOC_5147426||||0|0|0|0|Evénement de réception de la trame 329h|
SftyMgt_EveRxn329_ifTqMon|B|();|SCH.6|SFTYMGTIFTQ|1|PTS_DOC_5147394||||0|0|0|0|Evénement de réception de la trame 329h|
SftyMgt_EveRxn349_DiagSftyLvl2|C|();|SCH.4|DIAGSFTYLVL2|1|PTS_DOC_5147426||||0|0|0|0|Evenement de reception de la trame 349h|
SftyMgt_EveRxn349_ifTqMon|B|();|SCH.7|SFTYMGTIFTQ|1|PTS_DOC_5147394||||0|0|0|0|Evenement de reception de la trame 349|
SftyMgt_EveRxn34D_DiagSftyLvl2|C|();|SCH.5|DIAGSFTYLVL2|1|PTS_DOC_5147426||||0|0|0|0|Evénement de réception de trame 34Dh|
SftyMgt_EveRxn34D_ifTqMon|C|();|SCH.8|SFTYMGTIFTQ|1|PTS_DOC_5147394||||0|0|0|0|Evénement d'interface (réception de trame 34Dh).|
SftyMgt_EveRxn38D_DiagSftyLvl2|C|();|SCH.6|DIAGSFTYLVL2|1|PTS_DOC_5147426||||0|0|0|0|Evénement de réception de la trame 38Dh|
SftyMgt_EveRxn38D_ifTqMon|B|();|SCH.9|SFTYMGTIFTQ|1|PTS_DOC_5147394||||0|0|0|0|Evénement de réception de la trame 38Dh|
SftyMgt_EveTDC_ifTqMon|E|();|SCH.2|SFTYMGTIFTQ|1|PTS_DOC_5147394||||0|0|0|0|Evènement TDC|
SftyMgt_Sdl10ms_IfTMS|B|();|SCH.2|IFTQSTRUCT_TQMON|1|PTS_DOC_5050415||||0|0|0|0|evenement pour le contrôle de la fonction :Generer_info_10ms|
SftyMgt_Sdl40ms_GBxChk|C|();|SCH.2|SECUBV|1|V02 NT 10 01251||||0|0|0|0|L’évènement d’appel des fonctions permettants de sécuriser les demandes de couple boites BVA ou BVMP|
SftyMgt_Sdl40ms_IfTMS|B|();|SCH.3|IFTQSTRUCT_TQMON|1|PTS_DOC_5050415||||0|0|0|0|evenement pour le contrôle de la fonction :Generer_info_40ms|
SftyMgt_Sdl40ms_tqCkEfc|B|();|SCH.2|TQDRIVMON|1|V02 NT 10 01230||||0|0|0|0|Fonction d'accroche au moniteur moyen|
SftyMgt_SdlFast_ifTqMon|E|();|SCH.4|SFTYMGTIFTQ|1|PTS_DOC_5147394||||0|0|0|0|Evènement SdlFast.|
SftyMgt_SdlFast_SpdVehSecu|B|();|SCH.2|SPDVEHSECU|1|PTS_DOC_5664717||||0|0|0|0|Moniteur rapide de la fonction SftyMgt.|
SftyMgt_SdlMid_bEnaTqOfs|D|();|SCH.4|IFTQSTRUCT_TQMON|1|PTS_DOC_5050415||||0|0|0|0|evenement pour le contrôle de la fonction :Generer_info_tolerance|
SftyMgt_SdlMid_bInjCutOff|D|();|SCH.5|IFTQSTRUCT_TQMON|1|PTS_DOC_5050415||||0|0|0|0|evenement pour le contrôle de la fonction :gerer coupure injection|
SftyMgt_SdlMid_DftMgt|D|();|SCH.2|DFTMGT|1|PTS_DOC_5402500||||0|0|0|0|déclancher l'evenement SftyMgt_SdlMid_DftMgt|
SftyMgt_SdlMid_DiagSftyLvl2|C|();|SCH.2|DIAGSFTYLVL2|1|PTS_DOC_5147426||||0|0|0|0|Moniteur moyen de la fonction|
SftyMgt_SdlMid_FrfGen|A|();|SCH.2|FFGEN|1|V02 NT 10 01258||||0|0|0|0|L'évènement de déclanchement du module.|
SftyMgt_SdlMid_IdlChk|A|();|SCH.4|TQIDLCHK|1|V02 NT 10 01242||||0|0|0|0|Fonction d'accroche à l'evenement SftyMgt_SdlMid_IdlChk
SftyMgt_SdlMid_IfSftyMgtSTT|C|();|SCH.2|IFAUTHDFTSTT|1|V02 NT 11 01213||||0|0|0|0|Evennement de déclenchement de la  fonction  de sécurisation  les demandes Démarrage / redémarrage STTd.|
SftyMgt_SdlMid_ifTqMon|E|();|SCH.5|SFTYMGTIFTQ|1|PTS_DOC_5147394||||0|0|0|0|Evènement SdlMid.|
SftyMgt_SdlMid_LiHChk|C|();|SCH.2|LIHCHK|1|V02 NT 10 01261||||0|1|0|0|L’évènement d’appel de la fonction de sécurisation de l’application des limitations de régime.|
SftyMgt_SdlMid_nOfsIdlTakeOff|A|();|SCH.2|TQIDLCHK|1|V02 NT 10 01242||||0|0|0|0|Fonction d'accroche à l'evenement SftyMgt_SdlMid_nOfsIdlTakeOff
SftyMgt_SdlMid_nTarIdlChk|E|();|SCH.2|NTARIDLCHK|1|PTS_DOC_5049983||||0|0|0|0|Fonction d'accroche au moniteur SftyMgt_SdlMid_nTarIdlChk|
SftyMgt_SdlMid_pDsThrChk|C|();|SCH.2|PDSTHRCHK|1|PTS_DOC_5050542||||0|0|0|0|Cette fonction est appelée sur l'évènement SftyMgt_SdlMid_pDsThrChk|
SftyMgt_SdlMid_SftyMgr|B|();|SCH.2|SFTYMNGR|1|PTS_DOC_5199559||||0|0|0|0|fonction d'accroche de l'evenement SftyMgt_SdlMid_SftyMgr|
SftyMgt_SdlMid_STTDrvTra|B|();|SCH.2|MONAUTHOSTT|1|PTS_DOC_5199597||||0|0|0|0|Moniteur Moyen du module MONAUTHOSTT|
SftyMgt_SdlMid_tqAuxSumLoss|B|();|SCH.2|TQLOSSMON|1|V02 NT 10 01233||||0|0|0|0|SftyMgt_SdlMid_tqAuxSumLoss|
SftyMgt_SdlMid_tqCkEfcFil|B|();|SCH.2|TQCKEFCFIL|1|V02 NT 10 01236||||0|0|0|0|Evennement de déclenchement de la fonction qui décrit l' enveloppe max simplifiée de la partie applicative et la fonction de validation des signaux de la partie applicative  préventif|
SftyMgt_SdlMid_tqCkEngLossAdp|B|();|SCH.4|TQLOSSMON|1|V02 NT 10 01233||||0|0|0|0|SftyMgt_SdlMid_tqCkEngLossAdp|
SftyMgt_SdlMid_tqCkFricLoss|B|();|SCH.3|TQLOSSMON|1|V02 NT 10 01233||||0|0|0|0|SftyMgt_SdlMid_tqCkFricLoss|
SftyMgt_SdlMid_tqCnvLoss|B|();|SCH.5|TQLOSSMON|1|V02 NT 10 01233||||0|0|0|0|SftyMgt_SdlMid_tqCnvLoss|
SftyMgt_SdlMid_tqComp|D|();|SCH.2|TQCOMP|1|PTS_DOC_5050623||||0|0|0|0|Fonction d'accroche au moniteur 40ms.|
SftyMgt_SdlMid_tqCoVSCtl|A|();|SCH.2|TQCOMON|1|V02 NT 10 01231||||0|0|0|0|Fonction d'accroche moniteur SftyMgt_SdlMid_tqCoVSCtl.
SftyMgt_SdlMid_tqEfcCoGBx|A|();|SCH.5|TQCOMON|1|V02 NT 10 01231||||0|0|0|0|Fonction d'accroche moniteur SftyMgt_SdlMid_tqEfcCoGBx.
SftyMgt_SdlMid_tqEfcFilCo|A|();|SCH.3|TQCOMON|1|V02 NT 10 01231||||0|0|0|0|Fonction d'accroche moniteur SftyMgt_SdlMid_tqEfcFilCo.
SftyMgt_SdlMid_tqEfcReqCoCha|A|();|SCH.4|TQCOMON|1|V02 NT 10 01231||||0|0|0|0|Fonction d'accroche moniteur SftyMgt_SdlMid_tqEfcReqCoCha.
SftyMgt_SdlMid_tqIdcCoGBx|A|();|SCH.6|TQCOMON|1|V02 NT 10 01231||||0|0|0|0|Fonction d'accroche moniteur SftyMgt_SdlMid_tqIdcCoGBx.
SftyMgt_SdlMid_tqIdcCoNReg|A|();|SCH.7|TQCOMON|1|V02 NT 10 01231||||0|0|0|0|Fonction d'accroche moniteur SftyMgt_SdlMid_tqIdcCoNReg.
SftyMgt_SdlMid_tqIdcEngLimCo|A|();|SCH.8|TQCOMON|1|V02 NT 10 01231||||0|0|0|0|Fonction d'accroche moniteur SftyMgt_SdlMid_tqIdcEngLimCo.
SftyMgt_SdlMid_tqIdcEngReal|A|();|SCH.2|TQIDCENGREAL|1|V02 NT 10 01238||||0|0|0|0|Evenement du déclenchement de la fonction d'estimation du couple réel|
SftyMgt_SdlMid_tqIdl|A|();|SCH.3|TQIDLCHK|1|V02 NT 10 01242||||0|0|0|0|Fonction d'accroche à l'evenement SftyMgt_SdlMid_tqIdl
SftyMgt_SdlMid_tqSumLossCmp|B|();|SCH.7|TQLOSSMON|1|V02 NT 10 01233||||0|0|0|0|SftyMgt_SdlMid_tqSumLossCmp|
SftyMgt_SdlMid_tqSumLossCord|B|();|SCH.6|TQLOSSMON|1|V02 NT 10 01233||||0|0|0|0|SftyMgt_SdlMid_tqSumLossCord|
SftyMgt_SdlMid_TqVSCtlChk|B|();|SCH.2|TQVSCTLCHK|1|V02 NT 11 01190||||0|0|0|0|évenement de déclenchement de la fonction de surveillance de  la pédale de frein|
SFTYMGTIFTQ_vidAccPAcquiSftyLvl2|B|();|FCT3.1|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce bloc décrit l’acquisition sans filtrage de l’information des capteurs de la pédale d’accélération.|
SFTYMGTIFTQ_vidAcPInpChkSftyLvl2|B|();|FCT1.8|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce bloc produit le résultat des diagnostics safety level 2 réalisés sur les entrées sécuritaires provenantes des capteurs de la pédale Accel.|
SFTYMGTIFTQ_vidBrkAcquiSftyLvl2|B|();|FCT3.2|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce bloc décrit l’acquisition sans filtrage de l’information des capteurs de la pédale de frein.|
SFTYMGTIFTQ_vidBrkInpChkSftyLvl2|B|();|FCT1.9|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce block produit le résultat des diagnostics safety level 2 réalisés sur les entrées sécuritaires provenantes des capteurs de la pédale de Frein|
SFTYMGTIFTQ_vidCluAcquiSftyLvl2|C|();|FCT3.4|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce bloc décrit l’acquisition sans filtrage de l’information des capteurs de la pédale d’embrayage|
SFTYMGTIFTQ_vidCluInpChkSftyLvl2|B|();|FCT2.2|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce block produit le résultat des diagnostics safety level 2 réalisés sur les entrées sécuritaires provenantes des capteurs de la pédale d’Embrayage.|
SFTYMGTIFTQ_vidDftAutChkIni|F|();|FCT2.5|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Lecture du défaut init safety par l’intermédiaire d’un API.|
SFTYMGTIFTQ_vidDiagInpLvl2An|F|();|FCT2.8|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|diagnostique InpLvl2An|
SFTYMGTIFTQ_vidDiagInpLvl2An_1|G|();|FCT2.9|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|diagnostique InpLvl2An|
SFTYMGTIFTQ_vidDiagSensAcquiLvl2|B|();|FCT2.10|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce bloc décrit l’acquisition des capteurs pour le Safety niveau 2|
SFTYMGTIFTQ_vidEeprom|H|();|FCT1.6|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Eeprom update|
SFTYMGTIFTQ_vidEnabEngStopReq|B|();|FCT4.10|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|DEMANDE D'ARRET MOTEUR SFTY NIVEAU 3|
SFTYMGTIFTQ_vidF329RxLvl2|B|();|FCT4.3|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce bloc décrit la production du message et de la longueur de la trame 329. Les 2 variables SftyMgt_F329MsgData et SftyMgt_F329LocalLength sont utilisées pour vérifier le Checksum de la trame|
SFTYMGTIFTQ_vidF329SftyLevel2|B|();|FCT4.4|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce block produit le résultat des diagnostics safety level 2 réalisés sur les entrées sécuritaires provenantes de la Trame CAN 329.|
SFTYMGTIFTQ_vidF349RxLvl2|B|();|FCT4.5|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce bloc décrit la production du message et de la longueur de la trame 349. Les 2 variables SftyMgt_F349MsgData et SftyMgt_F349LocalLength sont utilisées pour vérifier le Checksum de la trame|
SFTYMGTIFTQ_vidF349SftyLevel2|B|();|FCT4.6|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce block produit le résultat des diagnostics safety level 2 réalisés sur les entrées sécuritaires provenantes de la Trame CAN 349.|
SFTYMGTIFTQ_vidF34DSftyLevel2|C|();|FCT4.7|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce block produit le résultat des diagnostics safety level 2 réalisés sur les entrées sécuritaires provenantes de la Trame CAN 34D.|
SFTYMGTIFTQ_vidF38DRxLvl2|B|();|FCT4.8|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce bloc décrit la production du message et de la longueur de la trame 38D. Les 2 variables SftyMgt_F38DMsgData et SftyMgt_F38DLocalLength sont utilisées pour vérifier le Checksum de la trame|
SFTYMGTIFTQ_vidF38DSftyLevel2|C|();|FCT4.9|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce block produit le résultat des diagnostics safety level 2 réalisés sur les entrées sécuritaires provenantes de la Trame CAN 38D.|
SFTYMGTIFTQ_vidFstftLvl3|H|();|FCT3.6|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Panne relative au code et à la calibration de la TMS|
SFTYMGTIFTQ_vidInerface|F|();|FCT4.2|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Le booléen Sfty3_bRstEndRcvRun permet de forcer la variable Sfty3_bEndRcvRun à 0.|
SFTYMGTIFTQ_vidInhSftylvl2Afts|F|();|FCT1.5|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Inhibition de Safety niveau 2 en mode APV : Si le mode APV est activé, on inhibe la Safty niveau 2.|
SFTYMGTIFTQ_vidInitOutput|J|();|FCT1.1|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Fonction d'initialisation des sorties du module SFTYMGTIFTQ|
SFTYMGTIFTQ_vidInitOutput1|D|();|FCT1.2|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Fonction d'initialisation des sorties du module SFTYMGTIFTQ|
SFTYMGTIFTQ_vidInpChkLvl2|B|();|FCT2.4|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce bloc décrit la consolidation de tous les résultats des diagnostics en un booléen : SftyMgt_bInpChk|
SFTYMGTIFTQ_vidInpIgTqRelzd|G|();|FCT1.3|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Mise a jour de SftyMgt_agIgAdvCur|
SFTYMGTIFTQ_vidInpInjTqRelzd|G|();|FCT2.7|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Il n’existe pas dans le calculateur la lecture d’une grandeur physique permettant de donner le status d’un injecteur (actif ou coupé).|
SFTYMGTIFTQ_vidNeutPosnAqSftLvl2|C|();|FCT3.5|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce bloc décrit l’acquisition sans filtrage de l’information des capteurs de la position point mort.|
SFTYMGTIFTQ_vidNeutPosnSftyLvl2|B|();|FCT2.3|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce block produit le résultat des diagnostics safety level 2 réalisés sur les entrées sécuritaires provenantes du capteur de la Position Point Mort|
SFTYMGTIFTQ_vidNoProdTqMon|F|();|FCT1.4|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce block décrit les variables d’entrée d’une TMS non produites dans un système V.E.E.S|
SFTYMGTIFTQ_vidRam_uncleared|G|();|FCT3.7|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Mettre a jour les variables prev de bDgo|
SFTYMGTIFTQ_vidRst|G|();|FCT3.8|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce module fait le lien entre les booléens de demande de reset et les services correspondant (les APIs) au niveau du LDB.|
SFTYMGTIFTQ_vidRstHw|G|();|FCT3.9|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Reset du hard|
SFTYMGTIFTQ_vidRstSw|F|();|FCT4.1|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Reset du soft|
SFTYMGTIFTQ_vidSensInpCkSftyLvl2|B|();|FCT1.7|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce block produit le résultat des diagnostics safety level 2 réalisés sur les entrées sécuritaires provenantes des capteurs des pédales Accel, Frien et Embrayage, Vitesse Vehicule, Papillon et Position Point Mort|
SFTYMGTIFTQ_vidSndDftLvl3|F|();|FCT2.6|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Le Gestionnaire de Diagnostics  ne faisant pas partie de la TMS, on ne peut transmettre au safety manager (qui est le Gestionnaire des Actions de Reconfiguration propre à la TMS) les défaut filtrés et confirmés par ce dernier.|
SFTYMGTIFTQ_vidThrAcquiSftyLvl2|C|();|FCT3.3|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce bloc décrit l’acquisition sans filtrage de l’information des capteurs du papillon.|
SFTYMGTIFTQ_vidThrInpChkSftyLvl2|B|();|FCT2.1|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce block produit le résultat des diagnostics safety level 2 réalisés sur les entrées sécuritaires provenantes du Papillon.|
SFTYMGTIFTQ_vidVehSpdInpSftyLvl2|B|();|FCT1.10|SFTYMGTIFTQ|0|PTS_DOC_5147394||||0|0|0|0|Ce block produit le résultat des diagnostics safety level 2 réalisés sur les entrées sécuritaires provenantes de la Vitesse Vehicule.|
SFTYMNGR_vidAdaptationEdge|D|();|FCT1.10|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|détection des fronts montants|
SFTYMNGR_vidAppliqueInhiDefaut|D|();|FCT1.9|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|appliquer Inhibition des Defauts|
SFTYMNGR_vidCalcCompteurEscalade|C|();|FCT1.5|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|calcul du Compteur de l'echelle des défauts ECU|
SFTYMNGR_vidCalculeMiseEnVeille|C|();|FCT1.6|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Gere l’inhibition de l’écoute des défauts|
SFTYMNGR_vidCalculeSeuilRPM|D|();|FCT1.8|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Calcul du seuil RPM|
SFTYMNGR_vidCasDefaut|C|();|FCT3.2|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|gérer le cas de déclanchement de l’évènement d’écriture en mémoire sauvegardée sur défaut.|
SFTYMNGR_vidCasKeyOff|C|();|FCT3.7|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|gérer le cas de déclanchement de l’évènement d’écriture en mémoire sauvegardée sur keyOff.|
SFTYMNGR_vidCasSaturaEcritureMem|C|();|FCT4.4|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|gérer le cas de déclanchement de l’évènement de défaut d’écriture sur Mem Saturée.|
SFTYMNGR_vidCondEcriMemSurDefaut|C|();|FCT3.3|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|calculer la condition d'écriture sur mémoire sur defaut|
SFTYMNGR_vidConditionSatMem|C|();|FCT4.5|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|calculer la condition de déclanchement de l’évènement de défaut d’écriture sur Mem Saturée.|
SFTYMNGR_vidConstrTramMemKeyoff|D|();|FCT4.2|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Construire la trame pour la mémoire sauvegardée sur KeyOff.|
SFTYMNGR_vidConstruitTrameDft|F|();|FCT3.5|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Construire la trame pour la mémoire sauvegardée sur Défaut|
SFTYMNGR_vidCoordDefautEdgeECU|C|();|FCT2.9|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|synthétiser les demande d’inhibition après action de recouvrement et/ou de reset provenant des blocs escalade globale, VSCtl, STT et EM et les demandes d'écritures mémoire sauvegardée|
SFTYMNGR_vidCoordinatDefautDgo|C|();|FCT2.8|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|synthétisés les demande d’inhibition après action de recouvrement et/ou de reset provenant des blocs escalade globale, VSCtl, STT et EM|
SFTYMNGR_vidCoordinationDiagECU|C|();|FCT2.5|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|synthétiser les défauts remontant de l’escalade VSCtl, STT et EM|
SFTYMNGR_vidDetDftPresentInit|C|();|FCT6.1|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Detection d’un défaut présent à l’initialisation de la fonction|
SFTYMNGR_vidEcritMem|C|();|FCT4.7|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Merge les données provenant des 3 cas possibles d’évènements :Défaut,KeyOff et Nb d’écriture de mémoire sauvegardée saturée. Et Provoque l’écriture en mémoire sauvegardée ( sur évènements et non powerlatch)|
SFTYMNGR_vidEcritMemEEP|D|();|FCT4.9|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Ecrit en mémoire sauvegardée sur évènements.|
SFTYMNGR_vidEcritMemSat|C|();|FCT4.6|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Remonte un défaut de nombre d'écriture Mémoire sauvegardée dépassé|
SFTYMNGR_vidEcriTramMemSurDefaut|C|();|FCT3.4|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|ecriture pour la mémoire sauvegardée sur Défaut|
SFTYMNGR_vidEcrTramMemSurKeyoff|C|();|FCT4.1|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|écriture de la trame pour la mémoire sauvegardée sur KeyOff.|
SFTYMNGR_vidEnFormeContexteGD|D|();|FCT6.5|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Mets en forme le champs de bit en variables de 2 octets pour être compatible avec GD / APV.|
SFTYMNGR_vidEntryInit|C|();|SCH.1|SFTYMNGR|1|PTS_DOC_5199559||||0|0|0|0|evenement reset du calculateur|
SFTYMNGR_vidEscaladeAttenteECU|D|();|FCT2.7|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|gèrer la priorisation des défauts ECU|
SFTYMNGR_vidEscaladeDftECU|D|();|FCT2.6|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|gèrer l’escalade et la priorisation des défauts ECU et safety 3|
SFTYMNGR_vidEscaladeEM|C|();|FCT2.4|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|gérer le mode de recouvrement local VSCtl|
SFTYMNGR_vidEscaladeSTT|C|();|FCT2.3|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|gérer le mode de recouvrement local STT|
SFTYMNGR_vidEscaladeVSCtl|C|();|FCT2.2|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|gérer le mode de recouvrement local VSCtl|
SFTYMNGR_vidEvenementEcritMem|C|();|FCT4.8|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|calculer la conditon d’écriture en mémoire sauvegardée ( sur évènements et non powerlatch)|
SFTYMNGR_vidExtraitMem|E|();|FCT1.3|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|extraire les données de la mémoire|
SFTYMNGR_vidGereEscalade|E|();|FCT2.1|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|gèrer l’escalade des défauts ECU et des modes de recouvrement locaux VSCtl, STT et EM|
SFTYMNGR_vidIFTHENELSEWrMem|C|();|FCT3.8|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|calculer la conditions de déclanchement de l’évènement d’écriture en mémoire sauvegardée sur keyOff.|
SFTYMNGR_vidInitOutput|L|();|FCT1.1|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Fonction d'initialisation des sorties au reset|
SFTYMNGR_vidMemSansDefaut|C|();|FCT4.3|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|calcul de nb d'écriture mémoire sauvegardée|
SFTYMNGR_vidMemSansDefautEveDft|C|();|FCT3.6|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|calculer le nombre d'écriture mémoire sauvegardée|
SFTYMNGR_vidMergeTrameCtxtGD|B|();|FCT6.2|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Gère les trames de contexte vers le GD|
SFTYMNGR_vidSyntheseDefautECU|D|();|FCT5.9|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|synthétise les fronts de demande de défauts provenant de l’escalade globale, de la gestion des défauts locaux VSCtl, STT et EM, et de l’ écriture de la mémoire sauvegardée en défaut.|
SFTYMNGR_vidSyntheseDefauts|C|();|FCT5.1|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|traiter les évènements provenant de la gestion de l’escalade, les transforme en diagnostique pour le GD et produit le booléen constant positionné à 1 en interface du GD (bMonRun).|
SFTYMNGR_vidTraitDelaiRecAntiEsc|F|();|FCT1.7|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|traitement du Dela de iRecouvrement AntiEscalade|
SFTYMNGR_vidTraiteMem1|C|();|FCT1.2|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|traiter  le nombre d’écriture effectuées dans la mémoire sauvegardée|
SFTYMNGR_vidTraiteMem2|C|();|FCT3.1|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|gèrer l’écriture de la mémoire sauvegardée et les évènements provoquant cette écriture.|
SFTYMNGR_vidTraiteNbEcritures|C|();|FCT1.4|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Comparer le nombre d’écriture effectuées dans la mémoire sauvegardée à un seuil d’écriture autorisées.|
SFTYMNGR_vidTraitEnvoiDgoArreMot|C|();|FCT5.8|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|traiter le mode mode de recouvrement arrêt moteur|
SFTYMNGR_vidTraitEnvoiDgoEM|C|();|FCT5.4|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|sauvegarde de défaut montant vers le GD provenant de EM|
SFTYMNGR_vidTraitEnvoiDgoLimpHom|C|();|FCT5.5|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|traiter le mode de recouvrement LimpHome|
SFTYMNGR_vidTraitEnvoiDgoSTT|C|();|FCT5.3|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|sauvegarde de défaut montant vers le GD provenant de STT|
SFTYMNGR_vidTraitEnvoiDgoVSCtl|C|();|FCT5.2|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|sauvegarde de défaut montant vers le GD provenant de VSCtl|
SFTYMNGR_vidTraitEnvoiResetHard|E|();|FCT5.7|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|etarder la emande d’un nombre de pas d’échantillonnage égal à sftyMgt_noSdlOnRstHw_C.|
SFTYMNGR_vidTraitEnvoiResetSoft|E|();|FCT5.6|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|retarder la demande d’un nombre de pas d’échantillonnage égal à sftyMgt_noSdlOnRstSw_C|
SFTYMNGR_vidTrmCtxtVrGDDefaut|D|();|FCT6.4|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Trame vers GD sur nouveau Défaut|
SFTYMNGR_vidTrmCtxtVrGDInit|C|();|FCT6.3|SFTYMNGR|0|PTS_DOC_5199559||||0|0|0|0|Trame vers GD à l’Init|
SODTC_CDThd|B|(argin uint16 u16DftIdx);|FCT1.4|STATUSOFDTC|0|PTS_DOC_5446103||||0|0|0|0||
SODTC_DftClr|B|(argin uint16 u16DftIdx);|FCT1.8|STATUSOFDTC|0|PTS_DOC_5446103||||0|0|0|0||
SODTC_EveRst_StatusOfDTC|B|();|FCT1.1|STATUSOFDTC|0|PTS_DOC_5446103||||0|0|0|0||
SODTC_EveRstDft_StatusOfDTC|B|();|FCT1.6|STATUSOFDTC|0|PTS_DOC_5446103||||0|0|0|0||
SODTC_EveRstDftObd_StatusOfDTC|B|();|FCT1.7|STATUSOFDTC|0|PTS_DOC_5446103||||0|0|0|0||
SODTC_GlbDCStrt|B|();|FCT1.5|STATUSOFDTC|0|PTS_DOC_5446103||||0|0|0|0||
SODTC_StGDU|B|(argin uint16 u16DftIdx);|FCT1.2|STATUSOFDTC|0|PTS_DOC_5446103||||0|0|0|0||
SODTC_StGOBD|B|(argin uint16 u16DftIdx);|FCT1.3|STATUSOFDTC|0|PTS_DOC_5446103||||0|0|0|0||
SPDHAL_vidDisable|A|();|2|HEADER|1|NONE||||0|0|0|0||
SPDHAL_vidEnable|A|();|1|HEADER|1|NONE||||0|0|0|0||
SPDHAL_vidGetPulseInformation|A|(argout uint16 *pu16PulseCounter, argout uint32 *pu32LastPulseDate);|3|HEADER|1|NONE||||0|0|0|0||
SPDVEHSECU_vidIni|B|();|FCT1.2|SPDVEHSECU|0|PTS_DOC_5664717||||0|0|0|0|Fonction d'initialisation des variables au Reset|
SPDVEHSECU_vidInitOutput|B|();|FCT1.1|SPDVEHSECU|0|PTS_DOC_5664717||||0|0|0|0|Fonction permettant l'initialisation de certaines variables au début du calcul|
SPDVEHSECU_vidSecuredSpeedInfo|C|();|FCT1.3|SPDVEHSECU|0|PTS_DOC_5664717||||0|0|0|0|Fonction permettant la determination d'une information sécurisée de la vitesse véhicule, à partir des vitesses de chacune des quatre roues|
SpgPresAcq_vidBoost_Pressure_Acq|F|();|FCT1.2|SPGPRESACQ|0|PTS_DOC_6851381||||0|0|0|0|La tension brute renvoyée par le capteur est normalisée en fonction de la tension d’alimentation du capteur, avant d’être envoyée au LdA.|
SpgPresAcq_vidBoost_Pressure_Arb|E|();|FCT1.6|SPGPRESACQ|0|PTS_DOC_6851381||||0|0|0|0|En présence de défauts, la valeur de la pression de suralimentation n’est plus acquise mais figée à sa dernière valeur valide. Si le défaut est confirmée la pression est égale à  une valeur de repli dépendant de la synchronisation du moteur.|
SpgPresAcq_vidBoostPressureDiag|D|();|FCT1.3|SPGPRESACQ|0|PTS_DOC_6851381||||0|0|0|0|Les diagnostics éléctriques pour les valeurs haute et basse sur signal de pression de suralimentation sont  ctivés lorsque la chaîne d’acquisition est activée et si aucun défaut n’est confirmé.|
SpgPresAcq_vidBoostPressureForm|E|();|FCT1.5|SPGPRESACQ|0|PTS_DOC_6851381||||0|0|0|0|La tension renvoyée par le capteur est convertie en pression de suralimentation. Cette  pression est ensuite filtrée.|
SpgPresAcq_vidInitOutput|F|();|FCT1.1|SPGPRESACQ|0|PTS_DOC_6851381||||0|0|0|0|Fonction d'initialisation des sorties.|
SpgPresAcq_vidPressElectDiag|D|();|FCT1.4|SPGPRESACQ|0|PTS_DOC_6851381||||0|0|0|0|A chaque acquisition de la tension de suralimentation, un diagnostic est effectué sur la validité de la nouvelle mesure, à l’aide de seuils calibrables, permettant  l’actualisation des indicateurs de défauts.|
SpgPresSp_vidCalcSpgPresSpBenchMod|C|();|FCT1.4|SPGPRESSP|0|V02 NT 09 08194||||0|0|0|0|In bench mode, the boost pressure setpoint is computed using a map depending on the engine speed and the final torque (average indicated torque) setpoint for the air path. The rate of change of the boost pressure setpoint is controlled.|
SpgPresSp_vidCmuSpgPresSp|B|();|FCT1.3|SPGPRESSP|0|V02 NT 09 08194||||0|0|0|0|The boost pressure setpoint is put at a calibration value when the boost pressure bench mode enable is wrong.|
SpgPresSp_vidMng_CalcSpgPresSpBenchMod|B|();|FCT1.2|SPGPRESSP|0|V02 NT 09 08194||||0|0|0|0|Enable the computation of the bench mode boost pressure setpoint only when the boost pressure bench mode enable is true.|
SpgPresSp_vidSpgPresSpIni|B|();|FCT1.1|SPGPRESSP|0|V02 NT 09 08194||||0|0|0|0|The bench mode boost pressure setpoint is initialized at reset with a calibration value.|
SPTMOD_vidEng_State_Treatment|A|();|FCT1.7|SPTMOD|0|V02 NT 11 04668||||0|0|0|0|The interfaces torque, power and boost pressure are only calculated during the engine running state, otherwise they are forced to zero.|
SPTMOD_vidEntryInit|A|();|SCH.1|SPTMOD|1|V02 NT 11 04668||||0|0|0|0|Événement reset calculateur.|
SPTMOD_vidInitOutputs|A|();|FCT1.1|SPTMOD|0|V02 NT 11 04668||||0|0|0|0|Fonction initialisation.|
SPTMOD_vidRatio_Calculation|A|();|FCT1.5|SPTMOD|0|V02 NT 11 04668||||0|0|0|0|Each information for posting are calculated twice, one in percentage and one in absolute value. The calculation of the boost pressure takes in consideration the maximum torque without turbine effect.|
SPTMOD_vidSportMode_State|A|();|FCT1.6|SPTMOD|0|V02 NT 11 04668||||0|0|0|0|The overall activation of the sport mode depends on several parameters, the request coming from the BSI and its diagnostic associated are taken into account.|
SPTMOD_vidSuperviseurModeSport|A|();|FCT1.2|SPTMOD|0|V02 NT 11 04668||||0|0|0|0|The function supervisor of the sport mode discusses the requests coming from the BSI to activate the dynamic mode. It calculates also interfaces: power, torque and boost pressure to inform the driver.|
SPTMOD_vidTorque_Selection|A|();|FCT1.3|SPTMOD|0|V02 NT 11 04668||||0|0|0|0|The basic driver torque used for calculations of interfaces to inform the driver can be selected in different manner. It dissociates the coordination of xVV, or LVV or idle governor.|
SPTMOD_vidTrqLimitationFiltering|A|();|FCT1.4|SPTMOD|0|V02 NT 11 04668||||0|0|0|0|Interfaces (torque, power, and boost pressure) for posting are calculated with  the driver torque selected and  the maximum power delivered by the engine.These calculated informations are filtered to reproduce the response of the engine.|
SPYEMSTT_NVMSRV_vidInit|A|();|FCT1.6|SPYEMSTT|0|V02 NT 10 05852||||0|0|0|0|Valeurs par defaut des variables EEPROM.|
SPYEMSTT_vidInitialization|B|();|FCT1.2|SPYEMSTT|0|V02 NT 10 05852||||0|0|0|0|En sortie d’usine (équivalent à la 1ère initialisation du CMM), les vecteurs de la pile sont initialisés avec des valeurs nulles.|
SPYEMSTT_vidInitOutput|A|();|FCT1.1|SPYEMSTT|0|V02 NT 10 05852||||0|0|0|0|Initialisation des variables produites du module SPYEMSTT|
SPYEMSTT_vidRecHisNotStopCase|A|();|FCT1.5|SPYEMSTT|0|V02 NT 10 05852||||0|0|0|0|Quand le kilométrage dépasse la valeur calibrée, le 3eme vecteur est effacé, le 2eme est enregistré dans le 3eme, et le 1er vecteur est enregistré dans le 2eme. Le 1er vecteur est remis à 0, et compte les causes de non arrêt|
SPYEMSTT_vidRecNotStopCase|B|();|FCT1.3|SPYEMSTT|0|V02 NT 10 05852||||0|0|0|0|Causes de non arrêt dues au SEEM.|
SPYEMSTT_vidRecNotStopCase1|B|();|FCT1.4|SPYEMSTT|0|V02 NT 10 05852||||0|0|0|0|Les 7 valeurs de ce vecteur sont booléennes et chacune correspond à une cause de non arrêt. L’ordre des causes de non arrêt doit être respecté, c’est-à-dire que la nième valeur du vecteur doit correspondre à la nième cause listée.|
SPYSTT_NVMSRV_vidInit|B|();|FCT1.8|SPYSTT|0|V02 NT 10 02508||||0|0|0|0|Fonction d'initialisation  pour pour les variables Eeprom.|
SPYSTT_vidCutCaseRec|D|();|FCT1.6|SPYSTT|0|V02 NT 10 02508||||0|0|0|0|La fonction permet de sauvegarder la cause de coupure active et cause de coupure présente.|
SPYSTT_vidCutCasRstFaiRec|C|();|FCT1.5|SPYSTT|0|V02 NT 10 02508||||0|0|0|0|L'utilité de cette fonction est d'enregistrer la cause initiale ayant généré le dernier passage en coupé – calé sur demande du superviseur.|
SPYSTT_vidInitOutput|B|();|FCT1.1|SPYSTT|0|V02 NT 10 02508||||0|0|0|0|fonction d'initialisation des outputs|
SPYSTT_vidRecHisNotStopCase|B|();|FCT1.4|SPYSTT|0|V02 NT 10 02508||||0|0|0|0|cette fonction permet l’implémentation des enregistrements des causes de non arrêt|
SPYSTT_vidRecNotStopCase|C|();|FCT1.2|SPYSTT|0|V02 NT 10 02508||||0|0|0|0|cette fonction permet d'emettre en sortie un vecteur renfermant les causes de non arrêt et d'enregistrer une matrice renfermant l'historique de ces causes|
SPYSTT_vidRecNotStopCase1|C|();|FCT1.3|SPYSTT|0|V02 NT 10 02508||||0|0|0|0|cette fonction permet d' enregistrer une matrice renfermant l'historique des causes de non arrêt par tranches kilométriques.|
SPYSTT_vidRstrtFaiRec|C|();|FCT1.7|SPYSTT|0|V02 NT 10 02508||||0|0|0|0|La fonction permet l'enregistrement la cause de coupure liées à un échec de redémarrage.|
Srv_Eve14TDC_ObdSrvPid|C|();|SCH.4|INTOBDSRV|1|V02 NT 11 05149||||0|0|0|0|Evénement d'appel de tâche "quart de PMH" du CMM|
Srv_EveAckActrTstDmd_ActrTstMng|A|();|SCH.3|DCM_MANU|1|PTS_DOC_5074350||||0|0|0|0|Fonction appelée par le Manager des test actionneurs pour initialiser certaines variables.|
Srv_EveBDC_ObdSrvPid|C|();|SCH.6|INTOBDSRV|1|V02 NT 11 05149||||0|0|0|0|Evénement Point mort bas|
Srv_EveCrcChkEnd_ObdSrv|A|();|SCH.1|OBDSRV|1|V02 NT 11 06099||||0|1|0|0|Evènement vérification du CRC Data de l'IET terminée (OK ou pas OK)|
Srv_EveCrcChkEnd_RefIdEta|A|();|.3|HEADER|1|NONE||||0|0|0|0||
Srv_EveErrInjrChrnWr_InjrChrn|A|();|FCT1.x|NOPROD|1|V02 NT 10 01758||||0|0|0|0|Patch suite a desintegration de INJRCHRN
Srv_EveErrPostEquWr_PostEquSrv|A|();|API.1|POSTEQUSRV|1|PTS_DOC_5074440||||0|1|0|0|Evénément mauvaise écriture du Post Equipement en eeprom|
Srv_EveErrTeleWr_TeleSrv|B|();|API.1|TELECODAGE|1|PTS_DOC_5074365||||0|0|0|0|Evénément mauvaise écriture du télécodage en eeprom|
Srv_EveFirstInitDone_NvmDiag|A|();|HD_9|HEADER|1|HEADER||||0|0|0|0||
Srv_EveInitSa_DiagSrv|C|();|Sa_API.5|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Requête d'initialisation du Security Access|
Srv_EveInitWdbi_DiagSrv|C|();|WDATAAUTO_API1.2|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Requête d'initialisation pour l'écriture (fonctionnel à lancer avant de lancer la procédure d'écriture)|
Srv_EveInjrChrn_InjrChrn|A|();|FCT1.x|NOPROD|1|V02 NT 10 01758||||0|0|0|0|Patch suite a desintegration de INJRCHRN
Srv_EvePostEqu_PostEquSrv|A|();|SCH.3|POSTEQUSRV|1|PTS_DOC_5074440||||0|0|0|0|Runnable de la fonction Post Equipement|
Srv_EvePwrl_ObdSrv06|A|();|SCH.1|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Evènement d'écriture au powerlatch|
Srv_EvePwrl_SrvRc|B|();|SCH.6|DCM_MANU|1|PTS_DOC_5074350||||0|0|0|0|Powerlatch event for the SRV function|
Srv_EveRcChkCodProg|B|();|FCT3.4|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0||
Srv_EveRcMatch|B|();|FCT3.3|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0||
Srv_EveRcReinit_PwrlMrk|A|();|SCH.2|PWRLMRK|1|V02 NT 11 04404||||0|0|0|0|Reset event of the powerlatch marker sent by a diagnostic tool.|
Srv_EveRcWrCodProg|B|();|FCT3.2|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0||
Srv_EveRdByDidADC|B|();|FCT3.1|SAIMMO|1|PTS_DOC_5060905||||0|0|0|0||
Srv_EveRefIdOk_RefIdEta|A|();|.1|HEADER|1|NONE||||0|0|0|0||
Srv_EveRst_ActrTstMng|A|();|SCH.1|SRVACTESTMNG|1|PTS_DOC_5074355||||0|0|0|0|Evènement reset du calculateur.|
Srv_EveRst_ObdSrv06|A|();|SCH.4|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Evénement reset de la fonction|
Srv_EveRst_ObdSrvPid|A|();|SCH.1|INTOBDSRV|1|V02 NT 11 05149||||0|0|0|0|Evénement reset|
Srv_EveRst_PostEqu|A|();|SCH.1|POSTEQUSRV|1|PTS_DOC_5074440||||0|0|0|0|Evénement reset du calculateur|
Srv_EveRst_PwrlMrk|A|();|SCH.1|PWRLMRK|1|V02 NT 11 04404||||0|0|0|0|Event Reset for power latch.|
Srv_EveRst_RefIdEta|B|();|SCH.1|REFIDETA|1|V02 NT 11 00995||||0|0|0|0|Function called at the initialisation|
Srv_EveRst_TeleSrv|F|();|SCH.1|TELECODAGE|1|PTS_DOC_5074365||||0|0|0|0|Evénement reset du calculateur|
Srv_EveRstDft_ObdSrv06|A|();|SCH.3|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Evènement indiquant la demande d'effacement des défauts par l'outil APV|
Srv_EveRstDftObd_ObdSrv06|A|();|SCH.2|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Evènement d'effacement des pannes OBD|
Srv_EveSa_PostEquSrv|A|();|SCH.4|POSTEQUSRV|1|PTS_DOC_5074440||||0|0|0|0|Runnable des fonctions de Security Access|
Srv_EveSa_TeleSrv|D|();|SCH.3|TELECODAGE|1|PTS_DOC_5074365||||0|0|0|0|Runnable des fonctions de Security Access|
Srv_EveTDC_ObdSrvPid|C|();|SCH.5|INTOBDSRV|1|V02 NT 11 05149||||0|0|0|0|Evénement point mort haut|
Srv_EveTele_DiagSrv|C|();|21|HEADER|1|NONE||||0|0|0|0||
Srv_EveTele_TeleSrv|F|();|SCH.4|TELECODAGE|1|PTS_DOC_5074365||||0|0|0|0|Runnable de la fonction de télécodage|
Srv_EveTxSrv09_RefIdEta|A|();|.2|HEADER|1|NONE||||0|0|0|0||
Srv_SdlFast_ObdSrvPid|C|();|SCH.3|INTOBDSRV|1|V02 NT 11 05149||||0|0|0|0|Moniteur rapide|
Srv_SdlFast_PostEquSrv|A|();|SCH.2|POSTEQUSRV|1|PTS_DOC_5074440||||0|0|0|0|Moniteur rapide de la fonction service|
Srv_SdlFast_PwrlMrk|A|();|SCH.4|PWRLMRK|1|V02 NT 11 04404||||0|0|0|0|Fast scheduler for Srv.|
Srv_SdlFast_RefIdEta|B|();|SCH.2|REFIDETA|1|V02 NT 11 00995||||0|0|0|0|fonction call at the Fast KRN event|
Srv_SdlFast_TeleSrv|F|();|SCH.2|TELECODAGE|1|PTS_DOC_5074365||||0|0|0|0|Moniteur rapide de la fonction service|
Srv_SdlMid_ActrTstMng|A|();|SCH.2|SRVACTESTMNG|1|PTS_DOC_5074355||||0|0|0|0|Moniteur moyen de la fonction test actionneur|
Srv_SdlMid_ObdSrv06|A|();|SCH.5|OBDSRV06|1|V02 NT 11 04787||||0|0|0|0|Cheduler moyen de la fonction|
Srv_SdlMid_ObdSrvPid|C|();|SCH.2|INTOBDSRV|1|V02 NT 11 05149||||0|0|0|0|Moniteur moyen|
SRVACTESTMNG_CtlPmpReq|A|();|FCT3.7|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|fonction de test de du défaut court circuit à l'alimentation sur la pompe a l'huile.|
SRVACTESTMNG_HPPmpTst|A|();|FCT4.8|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|fonction de test du défaut court circuit à l'alimentation HPPmpTst.|
SRVACTESTMNG_PropFuPmp|A|();|FCT3.8|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|fonction de test du défaut court circuit à l'alimentation sur la pompe de gavage|
SRVACTESTMNG_ThMgtECTTst|A|();|FCT4.7|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|fonction de test du  défaut court circuit à l'alimentation|
SRVACTESTMNG_vidActrTst1Res|C|();|FCT4.1|SRVACTESTMNG|0|PTS_DOC_5074355||||0|1|0|0|Fonction qui permet la gestion des tests actionneurs.|
SRVACTESTMNG_vidActrTst2Res|B|();|FCT4.2|SRVACTESTMNG|0|PTS_DOC_5074355||||0|1|0|0|Fonction qui permet la gestion des tests actionneurs.|
SRVACTESTMNG_vidActrTst3Res|C|();|FCT4.3|SRVACTESTMNG|0|PTS_DOC_5074355||||0|1|0|0|Fonction qui permet la gestion des tests actionneurs.|
SRVACTESTMNG_vidActrTst4Res|B|();|FCT4.4|SRVACTESTMNG|0|PTS_DOC_5074355||||0|1|0|0|Permet la détection des défauts lors du dernier test actionneur.|
SRVACTESTMNG_vidActrTstAcvChart|G|();|FCT1.4|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction decrivant le gestionnaire des tests actionneurs.|
SRVACTESTMNG_vidActrTstCdn|K|();|FCT1.2|SRVACTESTMNG|0|PTS_DOC_5074355||||0|1|0|0|Fonction qui décrit les conditions externes au test actionneur nécessaires pour son lancement.|
SRVACTESTMNG_vidActrTstCmpfollow|A|();|FCT4.6|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Suite de fonction qui permet en cas de front montant sur un des bits  de confirmation de test, d'achever le test actionneur.|
SRVACTESTMNG_vidActrTstCmpl|C|();|FCT1.3|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction qui permet en cas de front montant sur un des bits de confirmation de test, d'achever le test actionneur.|
SRVACTESTMNG_vidActrTstRes|F|();|FCT1.5|SRVACTESTMNG|0|PTS_DOC_5074355||||0|1|0|0|Fonction qui permet la gestion des tests actionneurs.|
SRVACTESTMNG_vidB2FanHiSpdTst|D|();|FCT2.7|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction permettant le test des tensions hautes GMV1 et GMV2.|
SRVACTESTMNG_vidB2FanLoSpdTst|D|();|FCT2.8|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction permettant le test des tensions basses GMV 1 et GMV 2.|
SRVACTESTMNG_vidBlowBy1|A|();|FCT3.4|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction test pour défaut court circuit à l'alimentation sur le Blowby1|
SRVACTESTMNG_vidBlowBy2|A|();|FCT3.5|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de test pour  défaut court circuit à l'alimentation sur le Blowby2|
SRVACTESTMNG_vidCFanTst|D|();|FCT2.9|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction qui permet le test des tensions hautes et basses GMV1 et GMV2.|
SRVACTESTMNG_vidCoil_1Tst|C|();|FCT1.9|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de test de la bobine 1.|
SRVACTESTMNG_vidCoil_2Tst|C|();|FCT1.10|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de test de la bobine 2.|
SRVACTESTMNG_vidCoil_3Tst|D|();|FCT2.1|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de test de la bobine 3..|
SRVACTESTMNG_vidCoil_4Tst|B|();|FCT3.3|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de test de la bobine 4.|
SRVACTESTMNG_vidCstrTst|D|();|FCT2.5|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction du test actionneur purge canister.|
SRVACTESTMNG_vidCTPtst|A|();|FCT4.10|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de detection d'un défaut circuit ouvert sur les CTP 2 lors du  dernier test actionneur .|
SRVACTESTMNG_vidDumpValveTst|A|();|FCT5.1|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de detection d'un défaut court circuit à la masse sur GMV grande  vitesse lors du dernier test actionneur|
SRVACTESTMNG_vidExVVTTst|B|();|FCT3.1|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction permettant la détection des problèmes rencontrées en phase de test actionneur VVT|
SRVACTESTMNG_vidFarSpTst|A|();|FCT4.9|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction indiquant l'etat de  blocage  riche et pauvre lors d'un TA FarSp.|
SRVACTESTMNG_vidHeatSenO2DsTst|B|();|FCT2.2|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction qui permet le test actionneur sonde aval.|
SRVACTESTMNG_vidHeatSenO2UsTst|D|();|FCT2.3|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction qui permet le test actionneur sonde amont.|
SRVACTESTMNG_vidInitOutput|G|();|FCT1.1|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction d'initialisation des variables produites par le module SRVACTESTMNG.|
SRVACTESTMNG_vidInj1Tst|C|();|FCT1.6|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction qui permet le test de l'injecteur 1.|
SRVACTESTMNG_vidInj2Tst|C|();|FCT1.7|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de test de l'injecteur 2.|
SRVACTESTMNG_vidInj3Tst|C|();|FCT1.8|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de test de l'injecteur 3.|
SRVACTESTMNG_vidInj4Tst|B|();|FCT3.2|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de test de l'injecteur 4|
SRVACTESTMNG_vidInVVTTst|B|();|FCT2.10|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction permettant la détection des problèmes rencontrées en phase de test actionneur VVT|
SRVACTESTMNG_vidMEAPtst|A|();|FCT5.2|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de détection d'un défaut volet lors du dernier test actionneur .|
SRVACTESTMNG_vidPwrRlyTst|D|();|FCT2.4|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction qui permet le test actionneur relais de puissance.|
SRVACTESTMNG_vidTestDftCdn|E|();|FCT4.5|SRVACTESTMNG|0|PTS_DOC_5074355||||0|1|0|0|Production des motifs d'arrêt ou de non lancement du test actionneur moteur non tournant et tournant.|
SRVACTESTMNG_vidTestDftCdnRun|B|();|FCT4.2|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Production du motif d'arrêt ou de non lancement du test actionneur moteur tournant.|
SRVACTESTMNG_vidThMgt|A|();|FCT3.6|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction de Test de défaut court circuit à la masse pompe à eau|
SRVACTESTMNG_vidThrTst|E|();|FCT2.6|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fonction permettant le test actionneur papillon.|
SRVACTESTMNG_vidTstCdnClcn|C|();|FCT3.10|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|Fcontion de calcul de Srv_bActrTstCndClcd|
SRVACTESTMNG_WgcCmd|B|();|FCT3.9|SRVACTESTMNG|0|PTS_DOC_5074355||||0|0|0|0|fonction de test du  défaut court circuit à l'alimentation wastegate.|
SrvRc_SdlFast_DiagSrv|B|();|SCH.5|DCM_MANU|1|PTS_DOC_5074345||||0|0|0|0|Moniteur rapide de la fonction Srv|
SrvRc_SdlMid_RcRst|B|();|SCH.4|DCM_MANU|1|PTS_DOC_5074350||||0|0|0|0|Scheduler Mid for the service Routine Control reset of adaptatives|
StartNM|A|(argin uint8 NetId);|1.1|HEADER|1|V01 NT 08 05903||||0|0|0|0|
StatusOfDtc_StGDU|B|(argin uint16 u16DftIdx);|API.1|STATUSOFDTC|1|PTS_DOC_5446103||||0|0|0|0|Event indicating a changing state for the considered single failure|
StatusOfDtc_StGOBD|B|(argin uint16 u16DftIDx);|API.2|STATUSOFDTC|1|PTS_DOC_5446103||||0|0|0|0|Event indicating a changing OBD state for the considered single failure|
StatusOfDtc_StGOBD_opt|A|(argin uint16 u16IdxDft);|1|HEADER|1|NONE||||0|0|0|0||
StraMon_EveCrTR_FarStraMon|C|();|SCH.3|FARSTRAMON|1|PTS_DOC_5147156||||0|0|0|0|Evénement CRANKING vers RUNNING|
StraMon_EveRst_FarStraMon|D|();|SCH.1|FARSTRAMON|1|PTS_DOC_5147156||||0|0|0|0|Fonction Reset calculateur|
StraMon_SdlMid_FarStraMon|E|();|SCH.2|FARSTRAMON|1|PTS_DOC_5147156||||0|0|0|0|Fonction du Moniteur moyen de la fonction Cstr|
STRTLOCKACQ_vidDefautStrtLock|E|();|FCT1.5|STRTLOCKACQ|0|PTS_DOC_6530087||||0|0|0|0|Fonction de production de Ext_bDgoCoh_StrtLock.
STRTLOCKACQ_vidDiagnostic|B|();|FCT1.4|STRTLOCKACQ|0|PTS_DOC_6530087||||0|0|0|0|Si le signal du capteur Start Lock n’est pas cohérent avec le paramètre CAN associé alors un défaut de type cohérence apparaît.
STRTLOCKACQ_vidInitialisation|E|();|FCT1.1|STRTLOCKACQ|0|PTS_DOC_6530087||||0|0|0|0|Au réveil calculateur, on interdit le démarrage.
STRTLOCKACQ_vidOS|B|();|FCT1.2|STRTLOCKACQ|0|PTS_DOC_6530087||||0|0|0|0|Ce bloc génère les évènements permettant le calcul de l’information du capteur Start-Lock uniquement dans le cas d’une boite de vitesse automatique ou d’une boite de vitesse manuelle pilotée.
STRTLOCKACQ_vidStrtLockAcq|F|();|FCT1.3|STRTLOCKACQ|0|PTS_DOC_6530087||||0|0|0|0|Ce bloc calcule la valeur physique de la variable Ext_bStrtLockAcq. Quand Ext_bStrtLockAcq =1, il n’y a pas de démarrage possible. Le signal du capteur passe par un filtrage anti rebond avec seuils calibrables.
Strtr_EveRst_IfCmdDiag|C|();|SCH.1|STRTRCMDDIAG|1|PTS_DOC_6528767||||0|0|0|0|Fonction d'accroche à l'événement reset du calculateur|
Strtr_EveRst_IfCmdDiagDio|A|();|SCH1.1|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Evénement reset du calculateur
Strtr_SdlMid_IfCmdDiag|D|();|SCH.2|STRTRCMDDIAG|1|PTS_DOC_6528767||||0|0|0|0|Fonction d'accroche à l'événement Strtr_SdlMid_IfCmdDiag|
Strtr_SdlMid_IfCmdDiagDio|A|();|SCH2.5|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Recurence du diagnostic électrique du DML.
STRTRCMDDIAG_vidCmdStrtrRly|D|();|FCT1.1|STRTRCMDDIAG|0|PTS_DOC_6528767||||0|0|0|0|Le pilotage de la Dml doit être Low Side Tout Ou Rien (TOR)|
STRTRCMDDIAG_vidCondResetTempo|D|();|FCT1.7|STRTRCMDDIAG|0|PTS_DOC_6528767||||0|0|0|0|Fonction d'initialisation du trigger du bloc reset_tempo|
STRTRCMDDIAG_vidDiagBlockedStEna|B|();|FCT1.8|STRTRCMDDIAG|0|PTS_DOC_6528767||||0|0|0|0|Le défaut Démarreur bloqué est détecté quand il n’y a pas de défaut sur le capteur régime et au démarrage, sur commande démarreur, il y a absence du signal régime .|
STRTRCMDDIAG_vidDiagBlockedStrtr|G|();|FCT1.4|STRTRCMDDIAG|0|PTS_DOC_6528767||||0|0|0|0|Le défaut Démarreur bloqué est détecté quand il n’y a pas de défaut sur le capteur régime et au démarrage, sur commande démarreur, il y a absence du signal régime|
STRTRCMDDIAG_vidDiagElec|C|();|FCT1.3|STRTRCMDDIAG|0|PTS_DOC_6528767||||0|0|0|0|Trois types de diagnostic de pannes sont traités: panne circuit ouvert/panne Court-circuit à la masse/panne Court-circuit à la batterie|
STRTRCMDDIAG_vidDiagStrtrRly|F|();|FCT1.2|STRTRCMDDIAG|0|PTS_DOC_6528767||||0|0|0|0|Ce bloc permet de faire les diagnostics électriques liés au DML (court-circuit à l’alimentation, court-circuit à la masse, circuit ouvert) ainsi que le diagnostic lié au défaut blocage du démarreur.|
STRTRCMDDIAG_vidIni|B|();|FCT1.9|STRTRCMDDIAG|0|PTS_DOC_6528767||||0|0|0|0|L’initialisation de la variable Dml_diag_cmd_blocage_sta_count  avec Dml_diag_blocage_sta_delay|
STRTRCMDDIAG_vidResetTempo|E|();|FCT1.5|STRTRCMDDIAG|0|PTS_DOC_6528767||||0|0|0|0|La tempo Dml_diag_blocage_sta_count est réinitialisée quand: 1) la commande n’est pas active. 2) le moteur est non tournant alors que la commande est active.|
STRTRCMDDIAG_vidRunTempo|E|();|FCT1.6|STRTRCMDDIAG|0|PTS_DOC_6528767||||0|0|0|0|Ce bloc permet de calculer de Dml_diag_blocage_sta_count qui est décrémentée tant que la commande de démarrage est active.|
STT_EveRst_KeyPushInfo|A|();|SCH.1|KEYPUSHINFO|1|PTS_DOC_6543971||||0|0|0|0|Evènement reset.
STT_EveRst_SpyEmSTT|A|();|SCH.1|SPYEMSTT|1|V02 NT 10 05852||||0|0|0|0|Evènement reset du calculateur.|
STT_EveRst_SpySTT|D|();|SCH.1|SPYSTT|1|V02 NT 10 02508||||0|0|0|0|évènement d'initialisation|
STT_EveRst_STTmO2Clc|B|();|SCH.1|STTMO2CLC|1|V02 NT 11 05704||||0|0|0|0|Evènement reset du calculateur
STT_EveTDC_STTmO2Clc|B|();|SCH.2|STTMO2CLC|1|V02 NT 11 05704||||0|0|0|0|Evènement TDC
STT_SdlFast_KeyPushInfo|A|();|SCH.2|KEYPUSHINFO|1|PTS_DOC_6543971||||0|0|0|0|Moniteur rapide.
STT_SdlFast_KeyPushInfoDio|A|();|SCH3.7|ACQCMDDIO|1|PTS_DOC_6509298||||0|0|0|0|Moniteur rapide.
STT_SdlFast_STTmO2Clc|B|();|SCH.3|STTMO2CLC|1|V02 NT 11 05704||||0|0|0|0|Moniteur rapide de la fonction STT
STT_SdlMid_SpyEmSTT|A|();|SCH.2|SPYEMSTT|1|V02 NT 10 05852||||0|0|0|0|Moniteur moyen de la fonction SpySTT|
STT_SdlMid_SpySTT|D|();|SCH.2|SPYSTT|1|V02 NT 10 02508||||0|0|0|0|évenement d'appel aux fonctionalités du module SPYSTT|
STTIF_vidInjCutOff|B|();|FCT1.1|STTIF|0|PTS_DOC_5199315||||0|0|0|0|Fonction pour produite la sortie Ext_bAcvInjCutOff.|
STTIF_vidOutput_nEng|B|();|FCT1.2|STTIF|0|PTS_DOC_5199315||||0|0|0|0|Fonction pour produite la sortie Ext_nEngToothClc.|
STTMO2CLC_vidAct_tens_sond_basse|B|();|FCT2.1|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Conditions de l'activation de la sonde à basse tension
STTMO2CLC_vidAct_tens_sond_haute|B|();|FCT2.3|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Conditions de l'activation de la sonde à haute tension
STTMO2CLC_vidCal_cond_tens_sonde|B|();|FCT1.8|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Ce bloc détermine si la valeur de tension de la sonde aval se trouve dans une plage de fonctionnement « correcte »
STTMO2CLC_vidCalcul_mO2_cata|B|();|FCT1.4|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|calcul des conditions d'activation du bloc Calcul_mO2cat
STTMO2CLC_vidCalcul_mO2cat|B|();|FCT1.5|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Ce bloc permet d’effectuer le calcul de la masse d’O2 dans le catalyseur en fonctionnement normal
STTMO2CLC_vidCalcul_mO2cat_final|B|();|FCT1.9|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Ce bloc permet de mettre à jour et de saturer la variable de sortie donnant la masse d’oxygène stockée par le catalyseur qui sera utilisée par les autres fonctions du contrôle moteur.
STTMO2CLC_vidCompteur_TDC_STT|B|();|FCT1.3|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Lors d’un redémarrage STT on calcule le nombre de PMH écoulés durant la phase de cranking.
STTMO2CLC_vidDesac_tens_sond_bas|B|();|FCT2.2|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Conditions de la désactivation de la sonde à basse tension
STTMO2CLC_vidDesac_tens_sond_hau|B|();|FCT2.4|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Conditions de la désactivation de la sonde à haute tension
STTMO2CLC_vidInit|B|();|FCT1.2|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Initialisation des variables de sorties
STTMO2CLC_vidInitOutput|B|();|FCT1.1|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Initialisation des variables intermédiaires.
STTMO2CLC_vidMasse_stockee_STT|B|();|FCT1.10|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Ce bloc permet de mettre à jour la variable ExM_mO2StgEngStop à la fin de la phase d’arrêt, lorsque le moteur passe à moteur tournant.
STTMO2CLC_vidMoteur_non_tournant|B|();|FCT1.7|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Dans la phase moteur non tournant, la masse d’oxygène stockée dans le catalyseur est calculée à partir de la dernière valeur actualisée en phase moteur tournant pondérée par un offset calibrable.
STTMO2CLC_vidMoteur_tournant|B|();|FCT1.6|STTMO2CLC|0|V02 NT 11 05704||||0|0|0|0|Dans le cas où le moteur est tournant, la masse d’oxygène stockée dans le catalyseur est calculée à partir del’intégrale du débit d’air cylindre converti en masse d’oxygène.
STTRALD_vidEntryInit|A|();|SCH.1|STTRALD|1|V02 NT 09 04622||||0|0|0|0|Fonction d'accroche au moniteur reset.|
STTRALD_vidInitOutputs|B|();|FCT1.1|STTRALD|0|V02 NT 09 04622||||0|0|0|0|Fonctin qui initialise les sorties|
STTRALD_vidLoadTransDetectStMach|A|();|FCT1.2|STTRALD|0|V02 NT 09 04622||||0|0|0|0|Fonction principale qui fait appel au fonctions associées au sous blocs|
STTRALD_vidResetManifoldState|A|();|FCT1.3|STTRALD|0|V02 NT 09 04622||||0|0|0|0|Initialisation des variables de l'automate de transitoire lorsque l'on n'est pas dans l'état RUNNING|
STTRALD_vidStateMachine|B|();|FCT1.5|STTRALD|0|V02 NT 09 04622||||0|0|0|0|Fonction qui représente l'automate de transitoire de charges|
STTRALD_vidTransientState|A|();|FCT1.4|STTRALD|0|V02 NT 09 04622||||0|0|0|0|Cette fonction permet de détecter les transitoires de l'état collecteur. La détection se fait par un indicateur de transitoire basé sur la comparaison entre le débit d'air entrant dans le collecteur et le débit d'air pompé par le moteur.|
SUMRAT_vidF01|A|();|FCT1.1|SUMRAT|0|V02 NT 10 06202||||0|0|0|0|Call on ECU reset event
SUMRAT_vidF02|A|();|FCT1.2|SUMRAT|0|V02 NT 10 06202||||0|0|0|0|Call on slow event
SUPSRV_u16ECUIdentification|D|func_SUPSRV_u16ECUIdentification|45|HEADER|1|NONE||||0|0|0|0||
SUPSRV_u16ReadAppliKey|A|func_SUPSRV_u16ReadAppliKey|0x01|HEADER|1|NONE||||0|0|0|0||
SUPSRV_u16ReadFuncProdNr|C|func_SUPSRV_u16ReadFuncProdNr|0x08|HEADER|1|V03 NT 11 02058||||0|0|0|0||
SUPSRV_u16ReadFuncSchemNr|C|func_SUPSRV_u16ReadFuncSchemNr|0x09|HEADER|1|V03 NT 11 02058||||0|0|0|0||
SUPSRV_u16ReadHistoryArea|E|func_SUPSRV_u16ReadHistoryArea|0x02|HEADER|1|V03 NT 11 02058||||0|0|0|0||
SUPSRV_u16ReadManufacturingDate|C|func_SUPSRV_u16ReadManufacturingDate|0x0F|HEADER|1|V03 NT 11 02058||||0|0|0|0||
SUPSRV_u8UnlockAlgorithm|B|func_SUPSRV_u8UnlockAlgorithm|0x0E|HEADER|1|V03 NT 11 02058||||0|0|0|0||
SUPSRV_udtJumpToIdentTest|A|func_SUPSRV_udtJumpToIdentTest|0x0F|HEADER|1|V03 NT 11 02058||||0|0|0|0||
SUPSRV_vidEnterReprogMode|D|(argin uint16 u16MicroControllerTemp);|0x04|HEADER|1|V03 NT 11 02058||||0|0|0|0||
SUPSRV_vidRstrtProtectedOutputs|A|();|4|HEADER|1|NONE||||0|0|0|0||
SWFAIL_vidSoftwareErrorHook|A|();|1|HEADER|1|NONE||||0|0|0|0||
Sync_EveBDC_AcqCkMngIf|A|();|SCH1.6|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evénement Point Mort Bas (PMB / BDC)
Sync_EveBDC_CkMngIf|E|();|SCH1.8|CKMNGIF|1|PTS_DOC_6884590||||0|0|0|0|Fonction d'accroche à l'evenement Sync_EveBDC_CkMngIf
Sync_EveBDC_CkMngIfIf_2|B|();|SCH.8|STTIF|1|PTS_DOC_5199315||||0|0|0|0|Interruption PMB.|
Sync_EveBDC_IfNEngClc|B|();|SCH.3|IFNENGCLC|1|V02 NT 11 03031||||0|0|0|0|Evénement Point Mort Bas (PMB / BDC).|
Sync_EveBDC_NEngClc|A|();|SCH.6|SYNCENGCLC|1|V02 NT 09 06456||||0|0|0|0|Evènement Point Mort Bas (PMB / BDC)
Sync_EveCkLTo1_SyncSTT|F|();|SCH.11|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Evènement indiquant la première détection de la singularité vilebrequin
Sync_EveCkLTo_AcqSyncSTT|A|();|SCH2.7|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement dent longue
Sync_EveCkLTo_CkDiagSts|C|();|SCH.6|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|Evénement correspondant au passage de la dent longue|
Sync_EveCkLTo_SyncCkDiagDiag|A|();|SCH.2|SYNCCKDIAGDIAG|1|PTS_DOC_6977224||||0|0|0|0|Evénement correspondant au passage de la dent longue
Sync_EveCkLTo_SyncSTT|G|();|SCH.1|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Evènement correspondant au passage de la dent longue du vilebrequin
Sync_EveCkOf_CkDiagSts|B|();|SCH.13|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|EveCkOff|
Sync_EveCkOf_CkMngIf|D|();|SCH2.1|CKMNGIF|1|PTS_DOC_6884590||||0|0|0|0|Détection fin de rotation moteur
Sync_EveCkOff_AcqSyncSTT|A|();|SCH2.3|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement  Crk off
Sync_EveCkOff_SyncSTT|E|();|SCH.2|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Evènement correspondant à la détection de l'arrêt moteur
Sync_EveCkOn_CkMngIf|D|();|SCH2.2|CKMNGIF|1|PTS_DOC_6884590||||0|0|0|0|Détection rotation moteur
Sync_EveCkOn_SyncSTT|D|();|SCH.3|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Evènement correspondant à la détection de la rotation du moteur
Sync_EveCkSnOf_AcqSyncSTT|A|();|SCH2.4|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement synchronisation perdue
Sync_EveCkSnOf_CkDiagSts|C|();|SCH.7|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|Evénement d'appel de tâche "synchro perdue" du CMM (à la perte de synchro et au calage)|
Sync_EveCkSnOf_EngSyncMng|A|();|SCH.3|SYNCENGMNG|1|V02 NT 09 03299||||0|0|0|0|Evennement perte de synchronisation
Sync_EveCkSnOf_SyncCkDiagDiag|A|();|SCH.3|SYNCCKDIAGDIAG|1|PTS_DOC_6977224||||0|0|0|0|Evènement détection fin de rotation moteur.
Sync_EveCkSnOf_SyncSTT|C|();|SCH.4|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Evènement synchronisation perdue
Sync_EveCkSnOn_AcqCkMngIf|A|();|SCH1.1|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement Synchro trouvée
Sync_EveCkSnOn_CkDiagSts|C|();|SCH.5|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise|
Sync_EveCkSnOn_CkMngIf|H|();|SCH1.5|CKMNGIF|1|PTS_DOC_6884590||||0|0|0|0|Fonction d'accroche à l'evenement Sync_EveCkSnOn_CkMngIf
Sync_EveCkSnOn_CkMngIfIf|B|();|SCH16.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise.|
Sync_EveCkSnOn_CkMngIfIf_2|B|();|SCH.7|STTIF|1|PTS_DOC_5199315||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise.|
Sync_EveCkSnOn_EngSyncMng|A|();|SCH.2|SYNCENGMNG|1|V02 NT 09 03299||||0|0|0|0|Evénnement synchronisation trouvée
Sync_EveCkSnOn_FuSysCkMngIf|D|();|SCH10.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise|
Sync_EveCkSnOn_IfAirSysIgSys|E|();|SCH8.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_synchronise|
Sync_EveCkSnOn_SyncCkDiagDiag|A|();|SCH.4|SYNCCKDIAGDIAG|1|PTS_DOC_6977224||||0|0|0|0|Evénement d'appel de tâche "synchro perdue" du CMM (à la perte de synchro  et au calage)
Sync_EveCkTo_AcqSyncSTT|A|();|SCH2.2|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement dent vilebrequin activé si le régime est inférieur à un seuil
Sync_EveCkTo_SyncSTT|E|();|SCH.5|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Evènement dent vilebrequin activé si le régime est inférieur à un seuil
Sync_EveCrTSt_CkDiagSts|C|();|SCH.9|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|Evénement CRANKING vers STALL|
Sync_EveExCamEdge_AcqSyncSTT|A|();|SCH2.1|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement détection d'un front arbre à cames échappement pour la fonction Synchro
Sync_EveExCamEdge_SyncSTT|G|();|SCH.6|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Evènement détection d'un front arbre à cames échappement pour la fonction  Synchro
Sync_EveExCmToo_AcqExCmSts|A|();|SCH1.8|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement Dent AAC
Sync_EveExCmToo_ExCmSts|A|();|SCH.2|SYNCEXCMDIAG|1|PTS_DOC_6884540||||0|0|0|0|Fonction d'accroche au moniteur Sync_EveExCmToo_Acq
Sync_EveInCamEdge_AcqSyncSTT|A|();|SCH1.14|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement détection d'un front arbre à cames admission pour la fonction Synchro
Sync_EveInCamEdge_SyncSTT|G|();|SCH.7|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Evènement détection d'un front arbre à cames admission pour la fonction  Synchro
Sync_EveInCmToo_AcqInCmSts|A|();|SCH1.11|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement arbre à cames admission
Sync_EveInCmToo_CmCkMon|A|();|SCH.4|SYNCCKCMMONDIAG|1|V02 NT 09 04208||||0|0|0|0|Evènement arbre à cames admission
Sync_EveInCmToo_InCmSts|A|();|SCH.2|SYNCINCMDIAG|1|PTS_DOC_6884534||||0|0|0|0|Evènement arbre à cames admission
Sync_EveKOf_EngSyncMng|A|();|SCH.5|SYNCENGMNG|1|V02 NT 09 03299||||0|0|0|0|Evènement clé On -> Off
Sync_EveKOn_AcqCkMngIf|A|();|SCH1.4|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement clé Off -> On
Sync_EveKOn_CkDiagSts|B|();|SCH.11|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|Evènement associé au passage de clef OFF à clef ON|
Sync_EveKOn_CmCkMon|A|();|SCH.2|SYNCCKCMMONDIAG|1|V02 NT 09 04208||||0|0|0|0|Evènement associé au passage de clef OFF à clef ON
Sync_EveKOn_EngSyncMng|A|();|SCH.4|SYNCENGMNG|1|V02 NT 09 03299||||0|0|0|0|Evènement clé Off -> On
Sync_EveKOn_ExCmSts|A|();|SCH.3|SYNCEXCMDIAG|1|PTS_DOC_6884540||||0|0|0|0|Fonction d'accroche au moniteur Sync_EveKOn_ExDiag
Sync_EveKOn_InCmSts|A|();|SCH.3|SYNCINCMDIAG|1|PTS_DOC_6884534||||0|0|0|0|Evènement associé au passage de clef OFF à clef ON
Sync_EveNInvOff_AcqSyncSTT|A|();|SCH2.8|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evénement indiquant le retour à une rotation en sens avant du moteur
Sync_EveNInvOff_SyncSTT|C|();|SCH.12|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Evénement indiquant le retour à une rotation en sens avant du moteur
Sync_EveRst_AcqSyncSTT|A|();|SCH2.5|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement reset
Sync_EveRst_CkDiagSts|C|();|SCH.2|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|fonction  Reset|
Sync_EveRst_CkMngIf|E|();|SCH1.1|CKMNGIF|1|PTS_DOC_6884590||||0|0|0|0|Fonction reset calculateur
Sync_EveRst_CkMngIfIf|C|();|SCH4.8|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset du calculateur.|
Sync_EveRst_CkMngIfIf_2|B|();|SCH.4|STTIF|1|PTS_DOC_5199315||||0|0|0|0|Evénement reset du calculateur.|
Sync_EveRst_CkMngIfIfAir|D|();|SCH1.13|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Evénement reset du calculateur|
Sync_EveRst_CmCkMon|A|();|SCH.1|SYNCCKCMMONDIAG|1|V02 NT 09 04208||||0|0|0|0|Evènement reset du calculateur
Sync_EveRst_EngSyncMng|B|();|SCH.1|SYNCENGMNG|1|V02 NT 09 03299||||0|0|0|0|Fonction d'accroche au moniteur reset.
Sync_EveRst_ExCmSts|A|();|SCH.1|SYNCEXCMDIAG|1|PTS_DOC_6884540||||0|0|0|0|Fonction d'accroche au moniteur Sync_EveRst_ExAcq
Sync_EveRst_ExCmStsIf|A|();|SCH1.9|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement reset du calculateur
Sync_EveRst_FuSysCkMngIf|E|();|SCH4.9|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset de module d'interface.|
Sync_EveRst_IfAirSysIgSys|C|();|SCH5.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement reset du calculateur|
Sync_EveRst_InCmSts|B|();|SCH.1|SYNCINCMDIAG|1|PTS_DOC_6884534||||0|0|0|0|Evènement reset du calculateur
Sync_EveRst_InCmStsIf|A|();|SCH1.12|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement reset du calculateur
Sync_EveRst_NEngClc|A|();|SCH.1|SYNCENGCLC|1|V02 NT 09 06456||||0|0|0|0|Evénement reset du calculateur
Sync_EveRst_SyncSTT|E|();|SCH.8|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Evènement reset du calculateur
Sync_EveRTCr_CkDiagSts|C|();|SCH.8|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|Evénement RUNNING vers CRANKING|
Sync_EveRTSt_CkMngIf|E|();|SCH1.2|CKMNGIF|1|PTS_DOC_6884590||||0|0|0|0|Fonction d'accroche à l'evenement Sync_EveRTSt_CkMngIf
Sync_EveRTSt_CkMngIfIf|B|();|SCH16.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant .|
Sync_EveRTSt_CkMngIfIf_2|B|();|SCH.5|STTIF|1|PTS_DOC_5199315||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant.|
Sync_EveRTSt_FuSysCkMngIf|D|();|SCH10.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant.|
Sync_EveRTSt_IfAirSysIgSys|E|();|SCH8.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant|
Sync_EveRTSt_InCmSts|A|();|SCH.4|SYNCINCMDIAG|1|PTS_DOC_6884534||||0|0|0|0|Evénement correspondant au passage à 0 de la variable Moteur_tournant
Sync_EveStTCr_CkDiagSts|C|();|SCH.3|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|Evenement correspondante à l'évenement STALL vers CRANKING|
Sync_EveStTR_AcqCkMngIf|A|();|SCH1.5|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement Stall To Rot
Sync_EveStTR_CkDiagSts|C|();|SCH.4|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant|
Sync_EveStTR_CkMngIf|E|();|SCH1.3|CKMNGIF|1|PTS_DOC_6884590||||0|0|0|0|Fonction d'accroche à l'evenement Sync_EveStTR_CkMngIf
Sync_EveStTR_FuSysCkMngIf|D|();|SCH10.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement correspondant au passage à 1 de la variable Moteur_tournant.|
Sync_EveSyncAccu_AcqSyncSTT|A|();|SCH2.9|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evénement indiquant le passage en synchronisation précise du moteur
Sync_EveSyncAccu_SyncSTT|A|();|.12|HEADER|1|NONE||||0|0|0|0|
Sync_EveSyncNotAccu_SyncSTT|A|();|.13|HEADER|1|NONE||||0|0|0|0|
Sync_EveTDC_AcqCkMngIf|A|();|SCH1.2|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Interruption PMH
Sync_EveTDC_CkMngIf|G|();|SCH1.6|CKMNGIF|1|PTS_DOC_6884590||||0|0|0|0|Fonction d'accroche à l'evenement Sync_EveTDC_CkMngIf
Sync_EveTDC_CkMngIf3|A|();|SCH1.9|CKMNGIF|1|PTS_DOC_6884590||||0|0|0|0|Interruption PMH après calcul durée dent
Sync_EveTDC_CkMngIfIf|C|();|SCH14.3|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Interruption PMH.|
Sync_EveTDC_CkMngIfIf_2|B|();|SCH.6|STTIF|1|PTS_DOC_5199315||||0|0|0|0|Interruption PMH.|
Sync_EveTDC_FuSysCkMngIf|D|();|SCH10.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur de module d'interface.|
Sync_EveTDC_IfAirSysIgSys|E|();|SCH8.7|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Interruption PMH|
Sync_EveTDC_IfNEngClc|B|();|SCH.2|IFNENGCLC|1|V02 NT 11 03031||||0|0|0|0|Interruption PMH.|
Sync_EveTDC_NEngClc|B|();|SCH.4|SYNCENGCLC|1|V02 NT 09 06456||||0|0|0|0|Interruption PMH.
Sync_EveTDC_SyncSTT|D|();|SCH.9|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Interruption PMH
Sync_EveTestEnd_AcqCkMngIf|A|();|SCH1.3|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement indiquant la fin des tests fonctionnels
Sync_EveWrAdaptSpdTar_NEngClc|A|();|SCH.5|SYNCENGCLC|1|V02 NT 09 06456||||0|0|0|0|Évènement demande de mise à jour des données adaptatives cible régime suite à une requête d'écriture des outils APV.
Sync_SdlFast_AcqCkMngIf|A|();|SCH1.7|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Moniteur rapide de la fonction Sync
Sync_SdlFast_CkDiagSts|B|();|SCH.12|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|Moniteur rapide de la fonction Sync|
Sync_SdlFast_CkMngIf|E|();|SCH1.7|CKMNGIF|1|PTS_DOC_6884590||||0|0|0|0|Fonction d'accroche à l'evenement Sync_SdlFast_CkMngIf
Sync_SdlFast_SyncSTT|D|();|SCH.13|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Moniteur rapide de la fonction Sync
Sync_SdlMid_AcqSyncSTT|A|();|SCH2.6|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Moniteur moyen
Sync_SdlMid_CkDiagSts|C|();|SCH.1|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|Monitor moyen de la fonction Sync|
Sync_SdlMid_CkMngIf|F|();|SCH1.4|CKMNGIF|1|PTS_DOC_6884590||||0|0|0|0|Fonction d'accroche à l'evenement Sync_SdlMid_CkMngIf
Sync_SdlMid_NEngClc|A|();|SCH.2|SYNCENGCLC|1|V02 NT 09 06456||||0|0|0|0|Scheduler moyen de la fonction Sync.
Sync_SdlMid_SyncCkDiagDiag|A|();|SCH.1|SYNCCKDIAGDIAG|1|PTS_DOC_6977224||||0|0|0|0|Monitor moyen de la fonction Sync
Sync_SdlMid_SyncSTT|D|();|SCH.10|SYNCSTT|1|PTS_DOC_6912870||||0|0|0|0|Moniteur moyen de la fonction Sync
Sync_SdlSlow_AcqExCmSts|A|();|SCH1.10|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Moniteur lent de la fonction Sync
Sync_SdlSlow_AcqInCmSts|A|();|SCH1.13|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Moniteur lent de la fonction Sync
Sync_SdlSlow_CkDiagSts|C|();|SCH.10|SYNCCKDIAG|1|PTS_DOC_6886036||||0|0|0|0|Moniteur lent de la fonction Sync|
Sync_SdlSlow_CmCkMon|A|();|SCH.3|SYNCCKCMMONDIAG|1|V02 NT 09 04208||||0|0|0|0|Moniteur lent de la fonction Sync
Sync_SdlSlow_MonEngSpd|C|();|SCH.2|SYNCCKCMCOHDIAG|1|V02 NT 09 04172||||0|0|0|0|Moniteur lent du diagnostic de cohérence des régimes
Sync_SdlSlow_NEngClc|A|();|SCH.3|SYNCENGCLC|1|V02 NT 09 06456||||0|0|0|0|Scheduler lent de la fonction Sync.
SYNCCKCMCOHDIAG_vidCondMonitor|B|();|FCT1.6|SYNCCKCMCOHDIAG|0|V02 NT 09 04172||||0|0|0|0|Fonction qui décrit la logique de détection des défauts régime vilebrequin, régime AAC échappement et régime AAC admission.
SYNCCKCMCOHDIAG_vidEntryInit|C|();|SCH.1|SYNCCKCMCOHDIAG|1|V02 NT 09 04172||||0|0|0|0|Fonction Reset du calculateur
SYNCCKCMCOHDIAG_vidExCm|A|();|FCT1.4|SYNCCKCMCOHDIAG|0|V02 NT 09 04172||||0|0|0|0|Ce bloc évalue les écarts possibles entre les régimes AAC échappement et vilebrequin. Ce calcul n’est autorisé que si le capteur AAC échappement est présent.
SYNCCKCMCOHDIAG_vidInCm|A|();|FCT1.5|SYNCCKCMCOHDIAG|0|V02 NT 09 04172||||0|0|0|0|Ce bloc évalue les écarts possibles entre les régimes AAC admission et vilebrequin. Ce calcul n’est autorisé que si le capteur AAC admission est présent.
SYNCCKCMCOHDIAG_vidInCmExCm|A|();|FCT1.3|SYNCCKCMCOHDIAG|0|V02 NT 09 04172||||0|0|0|0|Ce bloc évalue les écarts possibles entre les régimes AAC admission et AAC échappement. Le calcul ne se fait que si les capteurs AAC échappement et admission sont présents.
SYNCCKCMCOHDIAG_vidInitOutput|B|();|FCT1.1|SYNCCKCMCOHDIAG|0|V02 NT 09 04172||||0|0|0|0|Fonction d'initialisation des variables du module SYNCCKCMCOHDIAG.
SYNCCKCMCOHDIAG_vidMonEngSpd|C|();|FCT1.2|SYNCCKCMCOHDIAG|0|V02 NT 09 04172||||0|0|0|0|Les tests de cohérence de régime ne sont autorisés que s'il n'y a aucune demande de reconfiguration n’est présente et que le moteur soit synchronisé avec un retard d’une récurrence de calcul sur de la détection de la synchronisation.
SYNCCKCMMONDIAG_vidCkMonRst|B|();|FCT3.2|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Lorsqu’il  n’y  a  plus d’évènement  arbre  à  cames  admission,  les  conditions  de  diagnostics de  l’absence  et  de perte du signal vilebrequin doivent être remises à zéro. Cette opération est effectuée à travers l’évènement CALL_MonRunCkRst.
SYNCCKCMMONDIAG_vidClcDgoNoSigCk|A|();|FCT4.4|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Une panne élémentaire est détectée si les conditions de diagnostic sont remplies (Sync_bCmnCdnCkDiag = ON) et qu’il n’ y a pas de mouvement détecté sur le vilebrequin (Acq_crk_tooth_det_upvb0 = OFF).
SYNCCKCMMONDIAG_vidClDgoLossCk|A|();|FCT4.8|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Une panne élémentaire est détectée si les conditions de diagnostic sont remplies (Sync_bCmnCdnCkDiag = ON) et qu’il n’ y a pas de mouvement détecté sur le vilebrequin (Acq_crk_tooth_det_upvb0 = OFF).
SYNCCKCMMONDIAG_vidClDgoLossExCm|A|();|FCT6.7|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Une panne élémentaire est détectée si les conditions de diagnostic sont remplies (Sync_bCmnCdnExCmDiag = ON) et qu’il n’ y a pas de mouvement détecté sur l’arbre à cames échappement (Acq_excam_tooth_det_upvb0 = OFF).
SYNCCKCMMONDIAG_vidClDgoLossInCm|A|();|FCT5.7|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Une panne élémentaire est détectée si les conditions de diagnostic sont remplies (Sync_bCmnCdnInCmDiag = ON) et qu’il n’ y a pas de mouvement détecté sur l’arbre à cames admission (Acq_incam_tooth_det_upvb0 = OFF).
SYNCCKCMMONDIAG_vidClDgoNoSgExCm|A|();|FCT6.4|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Une panne élémentaire est détectée si les conditions de diagnostic sont remplies (Sync_bCmnCdnExCmDiag = ON) et qu’il n’ y a pas de mouvement détecté sur l’arbre à cames échappement (Acq_excam_tooth_det_upvb0 = OFF).
SYNCCKCMMONDIAG_vidClDgoNoSgInCm|A|();|FCT5.4|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Une panne élémentaire est détectée si les conditions de diagnostic sont remplies (Sync_bCmnCdnInCmDiag = ON) et qu’il n’ y a pas de mouvement détecté sur l’arbre à cames admission (Acq_incam_tooth_det_upvb0 = OFF).
SYNCCKCMMONDIAG_vidClEnaDgoNoSg|C|();|FCT1.3|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Dès que le signal à diagnostiquer est synchronisé alors le test de perte de signal est activé. Dès que la synchronisation du signal à diagnostiquer et la synchronisation du signal de référence sont perdues alors on active le test d’absence du signal.
SYNCCKCMMONDIAG_vidClEveCkMonRst|B|();|FCT3.3|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Function-Call Generator
SYNCCKCMMONDIAG_vidCmnCdnCkDiag|A|();|FCT3.1|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Ce bloc génère le booléen Sync_bCmnCdnCkDiag qui indique, lorsqu’il est à ON, que les conditions communes de test de perte ou d’absence du signal vilebrequins sont remplies
SYNCCKCMMONDIAG_vidCmnCdnExCmDgo|B|();|FCT6.1|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Ce  bloc  génère  le  booléen  Sync_bCmnCdnExCmDiag  qui  indique,  lorsqu’il  est  à  ON,  que  les  conditions communes de test de perte ou d’absence du signal arbre à cames échappements sont remplies
SYNCCKCMMONDIAG_vidCmnCdnInCmDgo|B|();|FCT5.1|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Ce  bloc  génère  le  booléen  Sync_bCmnCdnInCmDiag  qui  indique,  lorsqu’il  est  à  ON,  que  les  conditions communes de test de perte ou d’absence du signal arbre à cames admissions sont remplies
SYNCCKCMMONDIAG_vidGenrCkDiagEve|B|();|FCT1.4|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Ce module a pour vocation d’émettre les évènements qui déclenchent les calculs de la perte et de l’absence du signal vilebrequin.
SYNCCKCMMONDIAG_vidGenrCmDiagEve|B|();|FCT1.5|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Ce module a pour vocation d’émettre  les évènements qui déclenchent  les calculs de  la perte et de  l’absence des signaux vilebrequin et arbres à cames (admission et échappement)
SYNCCKCMMONDIAG_vidGenrLossExCm|B|();|FCT2.6|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Function-Call Generator
SYNCCKCMMONDIAG_vidGenrLossInCm|B|();|FCT2.4|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Function-Call Generator
SYNCCKCMMONDIAG_vidGenrNoSigCk|B|();|FCT2.1|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Function-Call Generator
SYNCCKCMMONDIAG_vidGenrNoSigExCm|B|();|FCT2.5|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Function-Call Generator
SYNCCKCMMONDIAG_vidGenrNoSigInCm|B|();|FCT2.3|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Function-Call Generator
SYNCCKCMMONDIAG_vidGenrSigLossCk|B|();|FCT2.2|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Function-Call Generator
SYNCCKCMMONDIAG_vidIniEnaDgoNoSg|B|();|FCT1.2|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Au réveil calculateur et au KEY ON, on autorise les diagnostics d’absence du signal vilebrequin et des signaux arbre à cames
SYNCCKCMMONDIAG_vidInitOutput|B|();|FCT1.1|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Initialisation des variables au reset de l’ECU
SYNCCKCMMONDIAG_vidLossCkMonCl|A|();|FCT4.6|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|En cas de perte des conditions de diagnostic, le flag de détection de la panne élémentaire est figé à sa dernière valeur valide
SYNCCKCMMONDIAG_vidLossCkMonIni|A|();|FCT4.5|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Au réveil ECU et à chaque KEY OFF  ON, la panne élémentaire et les conditions de diagnostics sont remises à zéro.
SYNCCKCMMONDIAG_vidLossCkMonRst|A|();|FCT4.7|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Lorsqu’il n’y a plus d’évènement arbre à cames admission, les conditions de diagnostics de l’absence et de perte du signal vilebrequin doivent être remises à zéro. Cette action est effectuée sur l’évènement CALL_MonRunCkRst.
SYNCCKCMMONDIAG_vidLossExCmCl|A|();|FCT6.6|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|En cas de perte des conditions de diagnostic, le flag de détection de la panne élémentaire est figé à sa dernière valeur valide.
SYNCCKCMMONDIAG_vidLossExCmIni|A|();|FCT6.5|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Au réveil ECU et à chaque KEY OFF  ON, la panne élémentaire et les conditions de diagnostics sont remises à zéro.
SYNCCKCMMONDIAG_vidLossInCmCl|A|();|FCT5.6|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|En cas de perte des conditions de diagnostic, le flag de détection de la panne élémentaire est figé à sa dernière valeur valide.
SYNCCKCMMONDIAG_vidLossInCmIni|A|();|FCT5.5|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Au réveil ECU et à chaque KEY OFF   ON, la panne élémentaire et les conditions de diagnostics sont remises  à zéro.
SYNCCKCMMONDIAG_vidNoSgCkMonClcn|A|();|FCT4.2|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|En cas de perte des conditions de diagnostic, le flag de détection de la panne élémentaire est figé à sa dernière valeur valide.
SYNCCKCMMONDIAG_vidNoSgExCmIni|A|();|FCT6.2|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Au réveil ECU et à chaque KEY OFF  ON, la panne élémentaire et les conditions de diagnostics sont remises à zero
SYNCCKCMMONDIAG_vidNoSgExCmMonCl|A|();|FCT6.3|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|En cas de perte des conditions de diagnostic, le flag de détection de la panne élémentaire est figé à sa dernière valeur valide.
SYNCCKCMMONDIAG_vidNoSgInCmCl|A|();|FCT5.3|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|En cas de perte des conditions de diagnostic, le flag de détection de la panne élémentaire est figé à sa dernière valeur valide.
SYNCCKCMMONDIAG_vidNoSgInCmIni|A|();|FCT5.2|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Au réveil ECU et à chaque KEY OFF  ON, la panne élémentaire et les conditions de diagnostics sont remises à zéro.
SYNCCKCMMONDIAG_vidNoSigCkMonIni|A|();|FCT4.1|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Au réveil ECU et à chaque KEY OFF  ON, la panne élémentaire et les conditions de diagnostics sont remises à zéro.
SYNCCKCMMONDIAG_vidNoSigCkMonRst|A|();|FCT4.3|SYNCCKCMMONDIAG|0|V02 NT 09 04208||||0|0|0|0|Lorsqu’il n’y a plus d’évènement arbre à cames admission, les conditions de diagnostics de l’absence et de perte du signal vilebrequin doivent être remises à zéro. Cette action est effectuée sur l’évènement CALL_MonRunCkRst
SYNCCKDIAG_vidAcvDwgMode|B|();|FCT2.6|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|Appel de l’API permettant le changement de mode|
SYNCCKDIAG_vidBackUpMode|B|();|FCT2.1|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|En cas de demande d’activation du back-up mode vilebrequin, on effectue une  préparation pour le passage en mode dégradé, puis on vient lire le mode de fonctionnement en cours et on active enfin le mode de back-up.|
SYNCCKDIAG_vidCkAcqVld|C|();|FCT1.10|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|cette fonction spécifie la validité de l’acquisition du capteur vilebrequin.|
SYNCCKDIAG_vidCkStsAcq|E|();|FCT1.6|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|L’appel au service CrkHALRead nous retourne des booléens pour : le signal vilebrequin détecté,  le passage à moteur tournant via le signal vilebrequin, la synchronisation du moteur.|
SYNCCKDIAG_vidCrkDgnUpdateInReq|C|();|FCT1.3|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|Le composant DGO possède quatre voies qui permettent de diagnostiquer quatre défaillances|
SYNCCKDIAG_vidCrkInvalTeethDiag|C|();|FCT1.8|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|fonction de a non détection de la dent longue ou de plusieurs dents consécutives dans un tour vilebrequin|
SYNCCKDIAG_vidCrkInvalToothDiag|C|();|FCT1.7|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|fonction de la non détection d’une dent dans un tour vilebrequin|
SYNCCKDIAG_vidCrkLngLtoo1Diag|C|();|FCT1.9|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|fonction de la non reconnaissance de la dent longue lors de la synchronisation moteur, le défaut NoGap et l’autorisation de diagnostic sont calculés à l’événement Event_crk_dgn_no_gap_det|
SYNCCKDIAG_vidCrkLngToothTmpDiag|C|();|FCT1.4|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|fonction de la non reconnaissance de la dent longue lors de la synchronisation moteur, le défaut NoGap et l’autorisation de diagnostic sont calculés à l’événement Event_crk_dgn_no_gap_t_det|
SYNCCKDIAG_vidEventGeneration|C|();|FCT1.2|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|cette fonction  génère les évènements selon quand le moteur n’est pas synchronisé.|
SYNCCKDIAG_vidExCamSig|B|();|FCT2.4|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|utiliser le signal échappement qui définit le signal arbre à cames.|
SYNCCKDIAG_vidInCamSig|B|();|FCT2.3|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|utiliser le signal admission  qui définit le signal arbre à cames|
SYNCCKDIAG_vidInitOutput|C|();|FCT1.1|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|fonction d'initialisation des sorties.|
SYNCCKDIAG_vidInitSelectCkMode|B|();|FCT2.7|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|Initialisation du mode de selection|
SYNCCKDIAG_vidReadCkMode|B|();|FCT2.5|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|lire le mode vilebrequin qui est actif|
SYNCCKDIAG_vidResetDiag|C|();|FCT1.5|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|cette fonction initialise les défauts et les autorisations de diagnostic à 0 au Reset.|
SYNCCKDIAG_vidSetEdgePos|B|();|FCT2.2|SYNCCKDIAG|0|PTS_DOC_6886036||||0|0|0|0|Lorsqu’une demande de passage en mode de back-up vilebrequin est activée on envoie au LDB la position apprise des fronts arbre à cames.|
SYNCENGCLC_vidActLearningCorr|A|();|FCT1.3|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|L’apprentissage des corrections est réalisé sur des décélérations naturelles du véhicule en coupure d’injection.
SYNCENGCLC_vidApplication|A|();|FCT3.3|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Ce sous-système sélectionne et applique la correction (apprise ou non) au régime courant en fonction du numéro de cylindre en phase de combustion. De plus si le régime de ralenti est dans la zone active on applique zéro en correction.
SYNCENGCLC_vidApplicationCorr|B|();|FCT1.6|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Ce sous-système effectue l’application des corrections au régime courant.
SYNCENGCLC_vidAppliCor|A|();|FCT1.10|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Cette fonction permet d'appliquer les corrections au régime courant.
SYNCENGCLC_vidAssigEngSpdArea|A|();|FCT2.2|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Détermine, en fonction des indicateurs de présence, le numéro de la plage active ainsi que le numéro du groupe de correction à saturer pour le régime recentré.
SYNCENGCLC_vidCalculAreaEngClc|A|();|FCT1.4|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|On définit 20 plages de régimes moteur contiguës calibrables (équi-réparties et bornées Sync_ThdnEngClcMax_C et Sync_ThdnEngClcMin_C).
SYNCENGCLC_vidCalculCorrection|A|();|FCT2.9|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Ce sous-système détermine les corrections par cylindre à apporter au régime courant. Ces corrections sont bornées par 5 saturations par groupe de 4 plages.
SYNCENGCLC_vidCalculCorrEngClc|C|();|FCT1.5|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Cet ensemble effectue l’apprentissage des corrections par zone et par cylindre.
SYNCENGCLC_vidCalculMean|A|();|FCT2.8|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Si le nombre d'échantillon pour la plage de régime donnée est inférieur à une valeur mini Sync_NrSampleMin_C, on ne tient alors pas en compte du calcul de la moyenne en cours.
SYNCENGCLC_vidContinuityRules|B|();|FCT3.2|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Application des règles de continuité pour les valeurs de correction.
SYNCENGCLC_vidCorrectAssignment|B|();|FCT2.10|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Le principe de ce sous-système est d’affecter les corrections et le booléen d’apprentissage à leurs vecteurs correspondants.
SYNCENGCLC_vidCorrectionArea|A|();|FCT1.9|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Cette fonction calcule la moyenne des sommes et détermine les corrections par cylindre à apporter au régime courant et permet d’affecter ces corrections et le booléen d’apprentissage à leurs vecteurs correspondants.
SYNCENGCLC_vidEchtSumCyl_1_Areas|A|();|FCT2.5|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Calcul de la somme des régimes et du nombre d’échantillon du premier cylindre.
SYNCENGCLC_vidEchtSumCyl_2_Areas|A|();|FCT2.6|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Calcul de la somme des régimes et du nombre d’échantillon du deuxième cylindre.
SYNCENGCLC_vidEchtSumCyl_3_Areas|A|();|FCT2.7|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Calcul de la somme des régimes et du nombre d’échantillon du troisième cylindre.
SYNCENGCLC_vidEchtSumCylAllAreas|A|();|FCT1.8|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Ces 3 blocs effectuent, pour chaque cylindre, les sommes des régimes avec leur nombre d’échantillon.
SYNCENGCLC_vidEcritureAdapt|B|();|FCT3.5|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Fonction de mise à jour des données adaptatives
SYNCENGCLC_vidEngineSpeedMemr|C|();|FCT1.7|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Ce sous système permet de déterminer la zone où se situe le régime moteur courant et le numéro de la plage active ainsi que le numéro du groupe de correction et de mémoriser le régime moteur par cylindre correspondant à la phase de combustion.
SYNCENGCLC_vidEngSpdInsideArea|B|();|FCT2.1|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Ce sous système envoie un indicateur de présence du régime moteur dans la plage de régime correspondante. Par ailleurs ce sous système est activé lorsque que le régime moteur se situe dans la plage calibrable Sync_ThdnEngClcMax_C et Sync_ThdnEngClcMin_C.
SYNCENGCLC_vidEngSpdMemrCylMot|B|();|FCT2.3|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Le principe de ce bloc est de mémoriser le régime moteur par cylindre correspondant à la phase de combustion, et mise à jour à la fin de chaque cycle moteur.
SYNCENGCLC_vidInitOutput|A|();|FCT1.2|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Initialisation des variables produites dans le module.
SYNCENGCLC_vidMngIdlSpdInsidArea|A|();|FCT3.1|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Ce bloc test la présence du régime de ralenti dans la zone active.
SYNCENGCLC_vidProtectCalcSomme|A|();|FCT2.4|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Cette fonction permet de protéger le calcul de chaque somme et nombres d’échantillons lors de décélérations lentes contre le dépassement de leur dynamique.
SYNCENGCLC_vidResetnEngClc|A|();|FCT1.1|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Au reset calculateur, le régime recentré est égal au régime moteur.
SYNCENGCLC_vidSelectCorrection|A|();|FCT3.4|SYNCENGCLC|0|V02 NT 09 06456||||0|0|0|0|Selection de la correction en fonction du numéro de cylindre en phase de combustion.
SYNCENGMNG_vidEngSyncLost|A|();|FCT1.4|SYNCENGMNG|0|V02 NT 09 03299||||0|0|0|0|Fonction qui permet la recherche de synchronisation
SYNCENGMNG_vidEngSyncVld|A|();|FCT1.3|SYNCENGMNG|0|V02 NT 09 03299||||0|0|0|0|Fonction d'autorisation de détection de fronts
SYNCENGMNG_vidIniAPI|D|();|FCT1.2|SYNCENGMNG|0|V02 NT 09 03299||||0|0|0|0|Fonction de demande synchronisation moteur
SYNCENGMNG_vidIniExCmSen|A|();|FCT1.6|SYNCENGMNG|0|V02 NT 09 03299||||0|0|0|0|initialisation de CAMHAL_udtEnableSynchronisation (pour l’échappement)
SYNCENGMNG_vidIniInCmSen|A|();|FCT1.5|SYNCENGMNG|0|V02 NT 09 03299||||0|0|0|0|initialisation de CAMHAL_udtEnableSynchronisation (pour l'admission)
SYNCENGMNG_vidInitDesync|A|();|FCT1.8|SYNCENGMNG|0|V02 NT 09 03299||||0|0|0|0|La recherche de synchronisation moteur est désactivée sur l’évènement KOf pour prévenir des risques de détection de rotation moteur voire de synchronisation moteur lors de l’arrêt (et des rebonds) moteur.
SYNCENGMNG_vidInitOutput|A|();|FCT1.1|SYNCENGMNG|0|V02 NT 09 03299||||0|0|0|0|Fonction d'initialisation des sorties
SYNCENGMNG_vidInitSync|A|();|FCT1.7|SYNCENGMNG|0|V02 NT 09 03299||||0|0|0|0|La recherche de synchronisation moteur est désactivée sur l’évènement KOf pour prévenir des risques de détection de rotation moteur voire de synchronisation moteur lors de l’arrêt (et des rebonds) moteur.
SYNCEXCMDIAG_vidDiag|B|();|FCT1.3|SYNCEXCMDIAG|0|PTS_DOC_6884540||||0|0|0|0|En cas de perte des conditions de diagnostic, le flag de détection de la panne élémentaire est figé à sa dernière valeur valide.
SYNCEXCMDIAG_vidDiagExCmAcq|B|();|FCT1.4|SYNCEXCMDIAG|0|PTS_DOC_6884540||||0|0|0|0|Fonction responsable du diagnostic.
SYNCEXCMDIAG_vidExCmAcqVld|B|();|FCT1.5|SYNCEXCMDIAG|0|PTS_DOC_6884540||||0|0|0|0|L’acquisition du signal arbre à cames échappement est considérée comme valide si aucune panne élémentaire  sur le profil du signal arbre à cames échappement n’est détectée et si les conditions de diagnostics sont remplies.
SYNCEXCMDIAG_vidIniDiag|B|();|FCT1.2|SYNCEXCMDIAG|0|PTS_DOC_6884540||||0|0|0|0|Au réveil ECU et à chaque KEY OFF-ON, la panne élémentaire et les conditions de diagnostics sont remises à zéro
SYNCEXCMDIAG_vidInitOutput|B|();|FCT1.1|SYNCEXCMDIAG|0|PTS_DOC_6884540||||0|0|0|0|Fonction d'initialisation
SYNCINCMDIAG_vidCntFrnt|A|();|FCT1.7|SYNCINCMDIAG|0|PTS_DOC_6884534||||0|0|0|0|Cette fonction autorisera l’injection seulement si on détecte un nombre suffisant et calibrable de fronts AAC.
SYNCINCMDIAG_vidDiag|B|();|FCT1.3|SYNCINCMDIAG|0|PTS_DOC_6884534||||0|0|0|0|En cas de perte des conditions de diagnostic, le flag de détection de la panne élémentaire est figé à sa dernière valeur valide.
SYNCINCMDIAG_vidDiagInCmAcq|B|();|FCT1.4|SYNCINCMDIAG|0|PTS_DOC_6884534||||0|0|0|0|Fonction responsable du diagnostic.
SYNCINCMDIAG_vidInCmAcqVld|B|();|FCT1.5|SYNCINCMDIAG|0|PTS_DOC_6884534||||0|0|0|0|L’acquisition du signal arbre à cames admission est considérée comme valide si aucune panne élémentaire sur le profil du signal arbre à cames admission n’est détectée et si les conditions de diagnostics sont remplies.
SYNCINCMDIAG_vidInCmCntFrnt|A|();|FCT1.6|SYNCINCMDIAG|0|PTS_DOC_6884534||||0|0|0|0|Cette fonction appelle la fonction qui autorisera l’injection sous une condition.
SYNCINCMDIAG_vidIniDiag|B|();|FCT1.2|SYNCINCMDIAG|0|PTS_DOC_6884534||||0|0|0|0|Au réveil ECU et à chaque KEY OFF - ON, la panne élémentaire et les conditions de diagnostics sont remises à zéro.
SYNCINCMDIAG_vidInitOutput|B|();|FCT1.1|SYNCINCMDIAG|0|PTS_DOC_6884534||||0|0|0|0|Fonction d'initialisation
SYNCINCMDIAG_vidStopEng|D|();|FCT1.8|SYNCINCMDIAG|0|PTS_DOC_6884534||||0|0|0|0|initialisation de la sortie Sync_bAcvInjIgDrv.
SYNCSTT_vidBackUpAcv|A|();|FCT1.5|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Il permet de générer les booléens d’activation des back-up mode vilebrequin et arbre à cames.
SYNCSTT_vidBackUpCk|A|();|FCT1.6|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Active  la demande de passage en mode de back-up vilebrequin.
SYNCSTT_vidBackUpCm|A|();|FCT1.7|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Active  la demande de passage en mode de back-up du signal arbre à cames.
SYNCSTT_vidChangeOfMind|C|();|FCT3.7|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Sur l’évènement N_Inv_Off on vient vérifier si la position angulaire du moteur est connue. Si c’est le cas alors es variables de synchronisation reste à 1.
SYNCSTT_vidCkOff|E|();|FCT4.6|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Lors de la perte de la synchronisation par le LDB,  ou lors  d’un arrêt moteur, sur l’événement Crank Off, on réinitialise les variables de synchronisation.
SYNCSTT_vidCkOn|B|();|FCT2.1|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Fonction pour remise à zero du Sync_bDetEs
SYNCSTT_vidCnt|C|();|FCT3.3|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|On incrémente le compteur de dents vilebrequin sur l’évènement dent vilebrequin.
SYNCSTT_vidctEdgeCmExRstrt|C|();|FCT4.2|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|A chaque détection de front AAC échappement, la fonction vérifie que la position de ce front est située à moins de Sync_agWinAgCmThLrn_C de sa position apprise.  Si c’est le cas on incrémente le compteur de fronts AAC correspondant à ce critère.
SYNCSTT_vidctEdgeCmExStrt|C|();|FCT3.6|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|A chaque détection de front AAC échappement, la fonction vérifie que la position de ce front est située à moins de Sync_agWinAgCmTh_C de sa position théorique.  Si c’est le cas on incrémente le compteur de fronts AAC correspondant à ce critère.
SYNCSTT_vidctEdgeCmInRstrt|C|();|FCT4.1|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|A chaque détection de front AAC admission, la fonction vérifie que la position de ce front est située à moins de Sync_agWinAgCmThLrn_C de sa position apprise.  Si c’est le cas on incrémente le compteur de fronts AAC correspondant à ce critère.
SYNCSTT_vidctEdgeCmInStrt|C|();|FCT3.5|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|A chaque détection de front AAC admission, la fonction vérifie que la position de ce front est située à moins de Sync_agWinAgCmTh_C de sa position théorique.  Si c’est le cas on incrémente le compteur de fronts AAC correspondant à ce critère.
SYNCSTT_vidDetLTo|B|();|FCT3.1|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Lors de la détection de la singularité vilebrequin, on passe les variables Sync_bDetLTo et Sync_bDetLTo2  à 1.
SYNCSTT_vidDiag|B|();|FCT2.5|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|fonction de calcul de defaut DistSig
SYNCSTT_vidDiagAuth|B|();|FCT2.3|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|fonction de calcul de Sync_bMonRunDistSig
SYNCSTT_vidDiagResult|B|();|FCT2.4|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|fonction de calcul de Sync_bDgoDistSig
SYNCSTT_vidEngStopPosn|C|();|FCT4.4|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Lors de la détection d’arrêt moteur on force la variable Sync_bVldAgEs à la valeur de Sync_bEngSyncAccu.  On effectue également la lecture de l’API donnant la position d’arrêt moteur calculée.
SYNCSTT_vidEngStopPosnAfter|D|();|FCT2.6|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Lors de la détection de la singularité du signal vilebrequin on effectue la lecture de l’API donnant la position d’arrêt du moteur calculée à posteriori.
SYNCSTT_vidEveProd|C|();|FCT4.7|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|On crée un évènement lorsque la synchro non précise est trouvée pour permettre l’autorisation d’injection, ainsi qu’un évènement lorsque la synchro précise est trouvée pour permettre l’autorisation de l’allumage.
SYNCSTT_vidForcSyncOff|C|();|FCT4.5|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Fonction permettant en cas de défaillance du signal vilebrequin ou sur demande de désynchronisation forcée, on passe les  variables de synchronisation à 0.
SYNCSTT_vidInit|D|();|FCT1.3|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|fonction d'initialisation des variables au reset du calculateur
SYNCSTT_vidIniTDCCnt|D|();|FCT2.2|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Lors de la synchronisation moteur, .on vient lire la position angulaire du moteur. A partir de la position d’arrêt moteur on détermine l’angle moteur parcouru entre la position d’arrêt et la position de synchronisation.
SYNCSTT_vidInitOutput|D|();|FCT1.4|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|focntion d'initialisation des varaibles produites
SYNCSTT_vidOS1|B|();|FCT1.1|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|On crée 2 évènements qui permettent d’activer soit la stratégie en cas de premier démarrage soit la stratégie en cas de redémarrage après un arrêt sans coupure du calculateur et lorsque le signal AAC admission est valide.
SYNCSTT_vidOS2|B|();|FCT1.2|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|On crée 2 évènements qui permettent d’activer soit la stratégie en cas de premier démarrage soit la stratégie en cas de redémarrage après un arrêt sans coupure du calculateur et lorsque le signal AAC échappement est valide.
SYNCSTT_vidReadToothInfo|D|();|FCT2.7|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Fonction de lecture des variables de synchronisation provenant du LdB.
SYNCSTT_vidRstSyncVar|B|();|FCT3.8|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Si la position angulaire du moteur n’est plus connue par le LDB, on force les variables de synchronisation à 0
SYNCSTT_vidRstTeethCnt|B|();|FCT3.4|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Lorsqu’on a détecté la dent longue de la cible vilebrequin, on effectue un reset du compteur de dent vilebrequin et de la variable permettant la détection de la singularité vilebrequin dès la dent suivante.
SYNCSTT_vidSync_SdlMid_SyncSTT|C|();|FCT4.8|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Fonction d'appel de l' événement Sync_SdlMid_SyncSTT
SYNCSTT_vidSyncCalcRstrt|D|();|FCT4.3|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Après un redémarrage, la variable Sync_bEngSyncAccu prend la valeur 1 dans le cas ou on a détecté la  singularité vilebrequin ou si on a comptabilisé au moins Sync_noEdgeCmAccuRstrt_C fronts AAC à une  position proche de leur valeur théorique.
SYNCSTT_vidSyncCalcStrt|C|();|FCT3.9|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|Ce bloc permet de calculer les variables de synchronisation précise et imprécise après un démarrage. Il est  appelé par un évènement interne qui dépend de différentes conditions d’activatio
SYNCSTT_vidTDCCnt|C|();|FCT2.8|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|On incrémente le compteur de PMH à chaque évènement PMH, uniquement à partir du moment où la position, de ceux-ci est connue, c'est-à-dire lorsque la synchro est OK.
SYNCSTT_vidTeethCnt|B|();|FCT3.2|SYNCSTT|0|PTS_DOC_6912870||||0|0|0|0|donction de compteur de dents vilebrequin
TARIDLSTA_vidCalc_Idl_tar|B|();|FCT3.8|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Ce bloc calcule la consigne de régime de ralenti à partir de tous les besoins moteurs, boite de vitesse, accessoires et safety.|
TARIDLSTA_vidCalc_Idl_tar_ac|B|();|FCT2.6|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Fonction qui permet de calculer TqSys_nTarIdlAC: le régime de ralenti cible requis par la climatisation (AC).|
TARIDLSTA_vidCalc_Idl_tar_alt|C|();|FCT2.7|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|TqSys_nTarIdlAlt est un régime de ralenti demandé qui est utilisé quand la demande externe AltCtl_bCmpReq est vraie. Cette demande peut être annulée si : TqSys_bTarIdlSpd est vrai et que la demande spécifique de ralenti  Alt_bCmpReq est fausse.|
TARIDLSTA_vidCalc_Idl_tar_AT|B|();|FCT3.2|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Cette sous-fonction fait la synthèse des consignes de régime de ralenti spécifique à une boite de vitesse automatique.|
TARIDLSTA_vidCalc_Idl_tar_AT_bas|B|();|FCT3.4|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|La consigne minimale de ralenti BVA est déterminée en fonction des conditions de la chaine de traction : si on est à vide ou en entrainé, si le convertisseur de couple est fermé ou ouvert, et suivant le régime de rotation de l’arbre en sortie de boite.|
TARIDLSTA_vidCalc_Idl_tar_AT_Cun|A|();|FCT3.7|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|La fonction Demande de régime de consigne de ralenti BVA détermine le besoin en consommation d'une boite de vitesse automatique en termes de régime de ralenti de consigne. L’activation se fait via un seuil de vitesse et d’un booléen calibrable.|
TARIDLSTA_vidCalc_Idl_tar_AT_inc|B|();|FCT3.5|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|La consigne de régime de ralenti accélérée est activée sur une demande de la BVA.|
TARIDLSTA_vidCalc_Idl_tar_consum|C|();|FCT2.4|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Les différents consommateurs qui peuvent modifier la consigne : L’air conditionné, Les thermoplongeurs pour chauff habitacle, Le soutien de l’alternateur, La direction assistée, La tension de batterie, Le soutien pour UH, Le chauff de l’habitacle.|
TARIDLSTA_vidCalc_Idl_tar_Dsl|B|();|FCT1.10|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|La consigne de régime de ralenti spécifique diesel n’est actuellement pas utilisée.|
TARIDLSTA_vidCalc_Idl_tar_engine|A|();|FCT1.9|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Ce bloc calcule la consigne de ralenti pour les différents besoins du moteur. Il prend en compte le type de carburant, les modes de combustion, ainsi que la température d’huile moteur.|
TARIDLSTA_vidCalc_Idl_tar_fault|B|();|FCT1.6|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Ce bloc calcule la consigne de régime de ralenti en cas de mode dégradé.|
TARIDLSTA_vidCalc_Idl_tar_Gsl|B|();|FCT2.1|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|La consigne de régime de ralenti essence se décompose en 1 sous-bloc : Une consigne de régime de ralenti pour la purge canister.|
TARIDLSTA_vidCalc_Idl_tar_lo_bat|B|();|FCT2.9|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Fonction qui calcule TqSys_nTarIdlBatt: régime de ralenti demandé qui s’active si la tension de batterie est basse.|
TARIDLSTA_vidCalc_Idl_tar_normal|B|();|FCT1.7|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|La consigne de régime de ralenti de base est calculée à partir des informations rapport de boite de vitesse et température moteur.|
TARIDLSTA_vidCalc_Idl_tar_spd_ex|B|();|FCT2.5|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Ce bloc définit une condition qui permet de supprimer la modification du régime de ralenti cible demandée par les consommateurs.|
TARIDLSTA_vidCalc_Idl_tar_ss|B|();|FCT3.1|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Fonction qui calcule TqSys_nTarIdlStgPmp: régime de ralenti requis par la direction assistée (SS).|
TARIDLSTA_vidCalc_Idl_tar_thp|B|();|FCT2.10|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Fonction du calcule de TqSys_nTarIdlWaHt: régime de ralenti demandé si au moins un des thermoplongeurs est actif (pour le chauffage de l’habitacle).|
TARIDLSTA_vidCalc_Idl_tar_Toil|B|();|FCT2.3|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Ce bloc calcule une consigne de régime de ralenti en fonction de la température d’huile moteur.|
TARIDLSTA_vidCalc_Idl_tar_UH|B|();|FCT2.8|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Fonction de calcul de TqSys_nTarIdl_bUHCtl  : régime de ralenti demandé qui est utilisé quand la demande externe CoPtUH_bEngAsiReq est vrai.|
TARIDLSTA_vidCalc_idl_target_ext|C|();|FCT3.9|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|La consigne de ralenti finale est la consigne de ralenti calculée précédemment ou bien une consigne issue d’une fonction externe.|
TARIDLSTA_vidCalc_Idl_target_max|B|();|FCT1.4|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Dans ce bloc, on calcule les différents régimes cible de ralenti en fonction : des erreurs systèmes, des consommateurs, de la température d’eau moteur, du rapport de boite, de la pression atmosphérique, des requêtes externes.|
TARIDLSTA_vidCalc_Idl_trq_req|B|();|FCT1.3|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Le flag de sortie de ce bloc peut être utilisé pour arrêter le contrôleur de ralenti à haut régime, mais c’est optionnel. 2 seuils de régime sont utilisés pour éviter des oscillations à la limite entre la zone de ralenti et la zone hors ralenti.|
TARIDLSTA_vidCalc_Idlle_target|B|();|FCT1.2|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|La fonction de consigne de régime de ralenti se décompose en 3 sous-blocs : Calcul de l’activation de la régulation de ralenti, Calcul de la consigne de régime de ralenti, de by-pass de la consigne de régime de ralenti pour des besoins extérieurs.|
TARIDLSTA_vidCalc_info|B|();|FCT1.5|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Ce bloc calcule le rapport de boite en ajoutant le cas neutre roulant pour la BVM, et en prenant en compte les états boîte pour les BVA/BVMP. Ce bloc calcule aussi la valeur de l’appui frein interne à la fonction.|
TARIDLSTA_vidCalc_spd_gbx_output|C|();|FCT3.3|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Dans ce bloc, on vient sélectionner l’information nécessaire pour calculer le régime en sortie de boîte. Soit à partir de l’information régime moyen roue avant Ext_nAvrFrntWhlCAN, soit à partir de la vitesse véhicule Veh_spdVeh.|
TARIDLSTA_vidCalcTarNorSlewInput|C|();|FCT1.8|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Calcul des entrées du bloc RateLimiter (Norm et Neut)|
TARIDLSTA_vidClc_Idl_tar_vac_pmp|B|();|FCT3.10|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Dans ce Bloc, TqSys_nTarIdlVacPmp est un régime de ralenti qui est demandé lorsque la pression mastervac est trop faible pour assurer un freinage afin d’éviter des phénomènes d’oscillations de la consigne de ralenti.|
TARIDLSTA_vidEntryInit|C|();|SCH.1|TARIDLSTA|1|V02 NT 10 08533||||0|0|0|0|Fonction Reset|
TARIDLSTA_vidFrze_Idl_tar_AT_eng|A|();|FCT3.6|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Lorsque l’on détecte un engagement (c'est-à-dire TqSys_bDragRed passe à 2), on fige la consigne de ralenti de base à la dernière valeur calculée, pendant une durée calibrable.|
TARIDLSTA_vidIdl_tar_Canister|B|();|FCT2.2|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|La fonction de consigne de régime de ralenti purge canister est fonction du facteur filtré d’adaptation pour purge canister. Cette consigne est inhibée ou activée par CanPurg_bTarIdlCanPurg et inhibé lorsque le rapport de boite est supérieur à 0.|
TARIDLSTA_vidInitOutput|C|();|FCT1.1|TARIDLSTA|0|V02 NT 10 08533||||0|0|0|0|Fonction d'initialisation des variables produites par la spec.|
TCOREGKNK_vidActiv_Condition|A|();|FCT1.3|TCOREGKNK|0|V02 NT 11 04673||||0|0|0|0|In this block, the condition activation:  - Not Cat Heating  - Activation of the knock control  - Inhibition calibration  The knock control activation KnkMgt_bAcvKnkReg is a boolean which is activated when the knock control is activated.|
TCOREGKNK_vidCool_Req_Coord|A|();|FCT1.4|TCOREGKNK|0|V02 NT 11 04673||||0|0|0|0|In this block the request coordination:  The request is activated when:  - Primary flag is generated  - Condition activation is equal to one  - The calibration temporisation is not finished|
TCOREGKNK_vidEntryInit|A|();|SCH.1|TCOREGKNK|1|V02 NT 11 04673||||0|0|0|0|reset du calculateur|
TCOREGKNK_vidFlag_Generation|B|();|FCT1.2|TCOREGKNK|0|V02 NT 11 04673||||0|0|0|0|In this block, the flag generation.  The flag is activated when the difference between Optimum ignition angle and knock limit ignition angle (with a low pass filter) is superior in a calibration level with hysteresis.|
TCOREGKNK_vidInitOutput|A|();|FCT1.1|TCOREGKNK|0|V02 NT 11 04673||||0|0|0|0|Initialisation des sorties|
TDCHAL_udtGetCounter|D|func_TDCHAL_udtGetCounter|0x03|TDCHAL|1|PTS DOC 5038320||||0|0|0|0|Get the current TDC Counter|
TDCHAL_udtGetPeriod|D|func_TDCHAL_udtGetPeriod|0x04|TDCHAL|1|PTS DOC 5038320||||0|0|0|0|Get latest calculated TDC period|
TDCHAL_udtReadCounter|C|func_TDCHAL_udtGetCounter|e.0x00|TDCHAL|1|PTS DOC 5038320||||0|0|0|1|Backward compatibility. (same functionality like TDCHAL_udtGetCounter)|
TDCHAL_udtReadPeriod|C|func_TDCHAL_udtGetPeriod|e.3|TDCHAL|1|PTS DOC 5038320||||0|0|0|1|Backward compatibility. (same functionality like TDCHAL_udtGetPeriod)|
TDCHAL_udtReadRawCounter|C|func_TDCHAL_udtGetCounter|e.0x01|TDCHAL|1|PTS DOC 5038320||||0|0|0|1|Backward compatibility. (same functionality like TDCHAL_udtGetCounter)|
TDCHAL_vidApproximatePeriod|E|();|1.0x03|TDCHAL|0|PTS DOC 5038320||||0|0|0|0|Approximates TDC period based on last tooth duration.|
TDCHAL_vidDisable|D|();|0x02|TDCHAL|1|PTS DOC 5038320||||0|0|0|0|Disable TDCHAL component|
TDCHAL_vidDriverInitialisation|E|();|1.0x04|TDCHAL|0|PTS DOC 5038320||||0|0|0|0|Internal initialization of TDCHAL component|
TDCHAL_vidEnable|E|();|0x01|TDCHAL|1|PTS DOC 5038320||||0|0|0|0|Enable TDCHAL component|
TDCHAL_vidFIND_LAST_SETPOINT|D|();|i.0x01|TDCHAL|0|PTS DOC 5038320||||0|0|0|1|Find setpoint preceding the current angular position.|
TDCHAL_vidGET_TDC_COUNTER|D|(argout uint8 u8Counter);|i.0x00|TDCHAL|0|PTS DOC 5038320||||0|0|0|1|Get TDC counter for current setpoint|
TDCHAL_vidInit|D|();|0x00|TDCHAL|1|PTS DOC 5038320||||0|0|0|0|Initialize TDCHAL component|
TDCHAL_vidInterrupt|D|();|1.0x00|TDCHAL|1|PTS DOC 5038320||||0|0|0|0|Interrupt handler of crank TDC alarm|
TDCHAL_vidNEXT_SETPOINT|D|();|i.0x03|TDCHAL|0|PTS DOC 5038320||||0|0|0|1|Update the current setpoint to next position.|
TDCHAL_vidON_SETPOINT|D|();|i.0x02|TDCHAL|0|PTS DOC 5038320||||0|0|0|1|Calls the callback function associated to current setpoint.|
TDCHAL_vidOnBDC|F|();|1.0x02|TDCHAL|0|PTS DOC 5038320||||0|0|0|0|Configured handler of BDC events|
TDCHAL_vidOnTDC|E|();|1.0x01|TDCHAL|0|PTS DOC 5038320||||0|0|0|0|Configured handler of TDC events.|
TDCHAL_vidPROGRAM_SETPOINT|D|();|i.0x04|TDCHAL|0|PTS DOC 5038320||||0|0|0|1|Program crank alarm to fire at currently desired setpoint.|
TECUACQ_vidAcquisition|C|();|FCT1.2|TECUACQ|0|PTS_DOC_6851405||||0|0|0|0|The voltage sent by the sensor is converted into the ECU temperature with a linear interpolation based on the characteristic behavior of the sensor.|
TECUACQ_vidDiagnosis|B|();|FCT1.3|TECUACQ|0|PTS_DOC_6851405||||0|0|0|0|The ECU temperature electrical diagnoses are carried out if there is no downgraded mode inhibition.|
TECUACQ_vidElectrical_Diagnosis|B|();|FCT1.4|TECUACQ|0|PTS_DOC_6851405||||0|0|0|0|The electrical diagnosis is managed in this sub-system.|
TECUACQ_vidInit|B|();|FCT1.1|TECUACQ|0|PTS_DOC_6851405||||0|0|0|0|ECU temperature is set to a configurable initialization value at the reset.|
TELECODAGE_NVMSRV_vidInit|E|();|FCT2.1|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|A l’initialisation, on vient lire toutes les données enregistrées en EEPROM. Dans le cas d’une première mise sous tension (et pour toutes les autres mises sous tension avant le premier télécodage), on utilise les valeurs par défaut.|
TELECODAGE_vidAddHeatConfVerif|C|();|FCT1.10|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|Le calculateur effectue la vérification de l'équations logique suivante : configuration possible OU configuration programmée = configuration programmée, pour la variante Chauffage Additionnel|
TELECODAGE_vidAlternConfVerif|C|();|FCT1.8|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|Le calculateur effectue la vérification de l'équations logique suivante : configuration possible OU configuration programmée = configuration programmée, pour la variante Classe Alternateur|
TELECODAGE_vidCarConfVerif|C|();|FCT1.9|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|Le calculateur effectue la vérification de l'équations logique suivante : configuration possible OU configuration programmée = configuration programmée, pour la variante Carosserie|
TELECODAGE_vidDataVerification|H|();|FCT1.4|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|Calcul de la sortie Srv_bDaVld|
TELECODAGE_vidFricConfVerif|C|();|FCT1.5|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|Le calculateur effectue la vérification de l'équations logique suivante : configuration possible OU configuration programmée = configuration programmée, pour la variante Fric|
TELECODAGE_vidGearBoxConfVerif|C|();|FCT1.7|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|Le calculateur effectue la vérification de l'équations logique suivante : configuration possible OU configuration programmée = configuration programmée, pour la variante Boite de vitesse|
TELECODAGE_vidInfoWrite|E|();|FCT2.3|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|A l’entrée de l’état SRV_TELEECU_WRITE, les informations ayant été confirmées, elles peuvent être prises en compte.|
TELECODAGE_vidInitDftBeforeTel|F|();|FCT1.2|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|A l’initialisation, on vient lire toutes les données enregistrées en EEPROM. Dans le cas d’une première mise sous tension (et pour toutes les autres mises sous tension avant le premier télécodage), on utilise les valeurs par défaut.|
TELECODAGE_vidInitOutput|E|();|FCT1.1|TELECODAGE|0|PTS_DOC_5074365||||0|1|0|0|Initialisation des sorties|
TELECODAGE_vidPressClimConfVerif|C|();|FCT1.6|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|Le calculateur effectue la vérification de l'équations logique suivante : configuration possible OU configuration programmée = configuration programmée, pour la variante Pression Clim|
TELECODAGE_vidReInit|E|();|FCT2.5|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|En cas de mauvaise écriture en eeprom l’ensemble des données de télécodage reprennent les valeurs par défauts, le nombre de télécodage est aussi réinitalisé à zéro ce qui permet de monter la panne telecodage.|
TELECODAGE_vidVarCodDftMng|E|();|FCT1.3|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|Un défaut de télécodage est enregistré tant qu’aucun télécodage n’a été réalisé.|
TELECODAGE_vidVarCodMng|G|();|FCT2.2|TELECODAGE|0|PTS_DOC_5074365||||0|1|0|0|A  l’initialisation,  l’état SRV_TELEECU_IDLE est activé en attendant de déterminer s’il est nécessaire d’utiliser les  processus  de  protection  en  écriture  (si  au  moins  un télécodage  a  déjà  été  réalisé)  ou  non.|
TELECODAGE_vidWrite|I|();|FCT2.4|TELECODAGE|0|PTS_DOC_5074365||||0|0|0|0|Les informations reçues sont prises en compte dans le calculateur. Le compteur du nombre de télécodage est incrémenté de 1.|
test_func|A|();|1.1.1|TQSYSSPBENCHMOD|0|V02NT091234||||0|0|0|0|
ThMgt_EveRst_ActrTstECT|A|();|SCH.1|ACTRTSTECT|1|V02 NT 11 06916||||0|0|0|0|ECU reset event.|
ThMgt_SdlMid_ActrTstECT|A|();|SCH.2|ACTRTSTECT|1|V02 NT 11 06916||||0|0|0|0|Middle monitoring of the function.|
Thr_EveChkLih_MngServo|A|();|6|HEADER|1|NONE||||0|0|0|0||
Thr_EveChkLih_MngServo_ThrStopClcn|A|();|SCH.6|THRSTOPCLCN|1|V02 NT 08 04799||||0|0|0|0|Demande de vérification de la position de repos du papillon
Thr_EveChkLih_ThrSftyMng|A|();|SCH.5|THRSFTYMNG|1|V02 NT 11 03549||||0|0|0|0|Demande de vérification de la position de repos du papillon|
Thr_EveClcnServo_AcqAdcThr|A|();|SCH4.1|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Evenement de calcul de l'asservissement papillon motorisé (front montant du signal PWM de commande).
Thr_EveClcnServo_CmdDiagThrCmd|A|();|SCH2.7|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Evenement ClcnServo de la fonction Thr.
Thr_EveClcnServo_CmdPwmThrCmd|A|();|SCH.7|CMDPWM|1|PTS_DOC_6669891||||0|0|0|0|Evénement de calcul de l'asservissement papillon motorisé (front montant du signal PWM de commande)
Thr_EveClcnServo_CorrdPosn|A|();|SCH.2|THRCORRDPOSN|1|V02 NT 08 05172||||0|0|0|0|Moniteur rapide de la fonction papillon.
Thr_EveClcnServo_CorrdPosnIf2|D|();|SCH1.4|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|Moniteur de module d'interface.|
Thr_EveClcnServo_Diag|C|();|SCH.2|THRSERVODIAG|1|V02 NT 08 04530||||0|0|0|0|Evénement de calcul de l'asservissement papillon  motorisé (front montant du signal PWM de commande)|
Thr_EveClcnServo_mCut|D|();|SCH.2|THRMCUT|1|V02 NT 08 04513||||0|0|0|0|Evénement de calcul de l'asservissement papillon motorisé (front montant du signal PWM de commande)
Thr_EveClcnServo_PosnMes|G|();|SCH.2|THRPOSMES|1|PTS_DOC_6658623||||0|0|0|0|Fonction d'accroche à l'évenement de calcul de l'asservissement papillon motorisé (front montant du signal PWM de commande).|
Thr_EveClcnServo_SecuMng|A|();|SCH.2|THRSECUMNG|1|V02 NT 08 05135||||0|0|0|0|Evénement de calcul de l'asservissement papillon motorisé
Thr_EveClcnServo_Servo|B|();|SCH.3|THRSERVO|1|V02 NT 08 04514||||0|0|0|0|Evenement de calcul de l'asservissement papillon motorisé (front montant du signal PWM de commande)|
Thr_EveClcnServo_StopClcn|B|();|SCH.3|THRSTOPCLCN|1|V02 NT 08 04799||||0|0|0|0|Evénement de calcul de l'asservissement papillon motorisé (front montant du signal PWM de commande)
Thr_EveClcnServo_ThermoProt|A|();|SCH.2|THRTHERMOPROT|1|V02 NT 10 00381||||0|0|0|0|Evènement de calcul de la fonction papillon.
Thr_EveClcnServo_ThrCmd|A|();|SCH.2|THRCMD|1|PTS_DOC_6587801||||0|0|0|0|function which allows to make the some calculation for the throttle.|
Thr_EveClcnServo_ThrSftyMng|C|();|SCH.4|THRSFTYMNG|1|V02 NT 11 03549||||0|0|0|0|Evénement de calcul de l'asservissement papillon motorisé.|
Thr_EveFRMUpd_SecuMng|A|();|SCH.4|THRSECUMNG|1|V02 NT 08 05135||||0|0|0|0|Evénement de mise à jour du GAR.
Thr_EveFRMUpd_ThrSecuMngIf|D|();|SCH9.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evénement de mise à jour du GAR|
Thr_EveIniLrnLih_StopClcn|A|();|SCH.9|THRSTOPCLCN|1|V02 NT 08 04799||||0|0|0|0|Evénement de l'initialisation du flag d'apprentissage au power on suivant en cas de dérive de limp-home.
Thr_EveIniStop_MngServo|B|();|SCH.2|THRSTOPCLCN|1|V02 NT 08 04799||||0|0|0|0|Demande d'initialisation des valeurs maximales lues sur les deux capteurs de position papillon
Thr_EveOplCllEna_ThrAbsSpPosn|A|();|SCH.4|THRABSSPPOSN|1|V02 NT 08 04493||||0|0|0|0|Evenement de passage d'une commande en boucle ouverte à une commande  en boucle ferme du papillon.
Thr_EveOplCllEna_ThrSpPosn|B|();|SCH.3|THRSPPOSN|1|PTS_DOC_6095099||||0|0|0|0|Evenement de passage d'une commande en boucle ouverte à une commande en boucle ferme du papillon|
Thr_EveRst_AbsSpPosn|B|();|SCH.1|THRABSSPPOSN|1|V02 NT 08 04493||||0|0|0|0|Sched reset
Thr_EveRst_AcqAdcThr|A|();|SCH4.2|ACQADC|1|PTS_DOC_6669203||||0|0|0|0|Evènement reset de la fonction Thr.
Thr_EveRst_ActrTstThr|A|();|SCH.1|THRACTEST|1|V02 NT 09 00783||||0|0|0|0|Evénement reset du calculateur|
Thr_EveRst_BenchAut|A|();|SCH.1|THRBENCHAUT|1|V02 NT 08 04529||||0|0|0|0|Sched reset|
Thr_EveRst_BoostSp|B|();|SCH.1|THRBOOSTSP|1|V02 NT 08 04489||||0|0|0|0|Evénement reset du calculateur
Thr_EveRst_CmdPwmThrCmd|A|();|SCH.8|CMDPWM|1|PTS_DOC_6669891||||0|0|0|0|Evènement reset du calculateur
Thr_EveRst_IfInhThrCpuSfty|F|();|SCH.1|THRSFTYCPUIFINH|1|PTS_DOC_5060895||||0|0|0|0|Evènement Reset de la fonction Thr.|
Thr_EveRst_mCut|C|();|SCH.1|THRMCUT|1|V02 NT 08 04513||||0|0|0|0|Evénement reset du calculateur
Thr_EveRst_MngServo|E|();|SCH.1|THRMNGSERVO|1|V02 NT 08 04528||||0|0|0|0|Evénement reset du calculateur|
Thr_EveRst_OplCtl|B|();|SCH.1|THROPLCTL|1|V02 NT 08 04793||||0|0|0|0|Evénement reset du calculateur.
Thr_EveRst_PosnMes|F|();|SCH.1|THRPOSMES|1|PTS_DOC_6658623||||0|0|0|0|Fonction d'accroche à l'événement reset du calculateur|
Thr_EveRst_SecuMng|C|();|SCH.1|THRSECUMNG|1|V02 NT 08 05135||||0|0|0|0|Evénement reset du calculateur
Thr_EveRst_Servo|B|();|SCH.1|THRSERVO|1|V02 NT 08 04514||||0|0|0|0|Evénement reset du calculateur|
Thr_EveRst_SpBenchMod|A|();|SCH.1|THRBENCHMODE|1|V02 NT 09 07776||||0|0|0|0|Evénement reset du calculateur|
Thr_EveRst_SpPosn|D|();|SCH.1|THRSPPOSN|1|PTS_DOC_6095099||||0|0|0|0|Evénement reset du calculateur.|
Thr_EveRst_StopClcn|C|();|SCH.1|THRSTOPCLCN|1|V02 NT 08 04799||||0|0|0|0|Evénement reset du calculateur
Thr_EveRst_ThermoProt|A|();|SCH.1|THRTHERMOPROT|1|V02 NT 10 00381||||0|0|0|0|Evènement de reset de la fonction papillon.
Thr_EveRst_ThrCmd|A|();|SCH.1|THRCMD|1|PTS_DOC_6587801||||0|0|0|0|Function call on the reset CMM.|
Thr_EveRst_ThrCpuSftyMng|A|();|SCH.1|THRSFTYMNG|1|V02 NT 11 03549||||0|0|0|0|Evènement reset du calculateur|
Thr_EveRst_ThrPosnSpSpc|B|();|SCH.1|THRPOSNSPLRN|1|V02 NT 11 00303||||0|0|0|0|Evènement reset|
Thr_EveRstThr_MngServo|B|();|SCH.3|THRMNGSERVO|1|V02 NT 08 04528||||0|0|0|0|Evèvenement de requête de recentrage des adaptatifs papillon|
Thr_EveRstThr_stopClcn|B|();|SCH.8|THRSTOPCLCN|1|V02 NT 08 04799||||0|0|0|0|Evèvenement de requête de recentrage des adaptatifs papillon.
Thr_EveStoreHiStop_MngServo|B|();|SCH.4|THRSTOPCLCN|1|V02 NT 08 04799||||0|0|0|0|Demande de mémorisation de la butée haute du papillon
Thr_EveStoreLih_SecuMng|A|();|SCH.3|THRSECUMNG|1|V02 NT 08 05135||||0|0|0|0|Demande de mémorisation de la position de repos du papillon
Thr_EveStoreLih_StopClcn|D|();|SCH.7|THRSTOPCLCN|1|V02 NT 08 04799||||0|0|0|0|Demande de mémorisation de la position de repos du papillon
Thr_EveStoreLoStop_MngServo|B|();|SCH.5|THRSTOPCLCN|1|V02 NT 08 04799||||0|0|0|0|Demande de mémorisation de la butéee basse du papillon
Thr_EveTDC_PosnMes|F|();|SCH.3|THRPOSMES|1|PTS_DOC_6658623||||0|0|0|0|Fonction d'accroche à l'interruption PMH (TDC)|
Thr_EveTestAbort_IfInhThrCpuSfty|B|();|SCH.3|THRSFTYCPUIFINH|1|PTS_DOC_5060895||||0|0|0|0|Evènement d'abandon des tests fonctionnels d'inhibition|
Thr_EveTestAbort_ThrSftyMng|A|();|SCH.6|THRSFTYMNG|1|V02 NT 11 03549||||0|0|0|0|Evènement d'abandon des tests fonctionnels d'inhibition|
Thr_EveTestEnd_IfInhThrCpuSfty|B|();|SCH.4|THRSFTYCPUIFINH|1|PTS_DOC_5060895||||0|0|0|0|Evènement de fin des tests fonctionnels d'inhibition|
Thr_EveTestStart_ThrSftyMng|C|();|SCH.3|THRSFTYMNG|1|V02 NT 11 03549||||0|0|0|0|Evènement d'autorisation des tests fonctionnels d'inhibition.|
Thr_SdlFast_IfInhThrCpuSfty|F|();|SCH.2|THRSFTYCPUIFINH|1|PTS_DOC_5060895||||0|0|0|0|Moniteur rapide de la fonction papillon.|
Thr_SdlFast_OplCtl|B|();|SCH.2|THROPLCTL|1|V02 NT 08 04793||||0|0|0|0|Moniteur rapide pour la fonction papillon
Thr_SdlFast_ThrSftyMng|C|();|SCH.2|THRSFTYMNG|1|V02 NT 11 03549||||0|0|0|0|Moniteur rapide de la fonction papillon.|
Thr_SdlMid_AbsSpPosn|A|();|SCH.3|THRABSSPPOSN|1|V02 NT 08 04493||||0|0|0|0|Moniteur moyen pour la fonction papillon
Thr_SdlMid_ActrTstThr|A|();|SCH.2|THRACTEST|1|V02 NT 09 00783||||0|0|0|0|Moniteur moyen de la fonction Thr.|
Thr_SdlMid_BenchAut|A|();|SCH.2|THRBENCHAUT|1|V02 NT 08 04529||||0|0|0|0|Moniteur moyen pour la fonction papillon|
Thr_SdlMid_BoostSp|A|();|SCH.2|THRBOOSTSP|1|V02 NT 08 04489||||0|0|0|0|Moniteur moyen pour la fonction papillon
Thr_SdlMid_CmdPwmThrCmd|A|();|SCH.9|CMDPWM|1|PTS_DOC_6669891||||0|0|0|0|Moniteur moyen de la fonction papillon
Thr_SdlMid_FullRngPosn|B|();|SCH.2|THRFULLRNGPOSN|1|V02 NT 09 08266||||0|0|0|0|Middle monitor function for throttle|
Thr_SdlMid_MngServo|F|();|SCH.2|THRMNGSERVO|1|V02 NT 08 04528||||0|0|0|0|Moniteur moyen de la fonction papillon|
Thr_SdlMid_MngServoIf|E|();|SCH8.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur de module d'interface|
Thr_SdlMid_OplCtl|F|();|SCH.3|THROPLCTL|1|V02 NT 08 04793||||0|0|0|0|Moniteur moyen pour la fonction papillon
Thr_SdlMid_Servo|B|();|SCH.2|THRSERVO|1|V02 NT 08 04514||||0|0|0|0|Moniteur moyen pour le papillon|
Thr_SdlMid_SpBenchMod|A|();|SCH.2|THRBENCHMODE|1|V02 NT 09 07776||||0|0|0|0|Moniteur moyen de la fonction papillon|
Thr_SdlMid_SpPosn|B|();|SCH.2|THRSPPOSN|1|PTS_DOC_6095099||||0|0|0|0|Moniteur moyen pour la fonction papillon|
Thr_SdlMid_ThermoProt|A|();|SCH.3|THRTHERMOPROT|1|V02 NT 10 00381||||0|0|0|0|Moniteur moyen de la fonction papillon.
Thr_SdlMid_ThrCmd|B|();|SCH.3|THRCMD|1|PTS_DOC_6587801||||0|0|0|0|Moniteur moyen de la fonction papillon|
Thr_SdlMid_ThrPosnSpSpc|B|();|SCH.2|THRPOSNSPLRN|1|V02 NT 11 00303||||0|0|0|0|Evènement de moniteur moyen de la fonction|
Thr_SdlSfty_ThrPosnMes|B|();|SCH.4|THRPOSMES|1|PTS_DOC_6658623||||0|0|0|0|Evènement de calcul des fonctions safety de niveau 2|
Thr_SdlSlow_AbsSpPosn|B|();|SCH.2|THRABSSPPOSN|1|V02 NT 08 04493||||0|0|0|0|Moniteur lent pour la fonction papillon
THRABSSPPOSN_vidCompOpenThresh|C|();|FCT1.3|THRABSSPPOSN|0|V02 NT 08 04493||||0|0|0|0|Le seuil maximal de position de consigne papillon est soumis à deux contraintes : garde par rapport à la butée  haute et consommation de courant pour des températures ECU extrêmes.
THRABSSPPOSN_vidComputeAbsRef|D|();|FCT1.4|THRABSSPPOSN|0|V02 NT 08 04493||||0|0|0|0|Ce processus est calculé chaque 8ms ou sur front descendant de  Tpac_open_loop_control et  fourni la consigne absolue de position papillon en fonction de la garde à la butée basse, de la garde à la butée haute et de l’état de l’automate d'asservissement.
THRABSSPPOSN_vidInitOutput|B|();|FCT1.1|THRABSSPPOSN|0|V02 NT 08 04493||||0|0|0|0|Module initialization
THRABSSPPOSN_vidInitThrotPosRef|B|();|FCT1.2|THRABSSPPOSN|0|V02 NT 08 04493||||0|0|0|0|Sur Reset, on initialise la consigne absolue à la somme de la consigne relative et de la position de la butée basse. La consigne relative étant initialisée à la position corrigée, on démarre ainsi l’asservissement à partir de la position papillon.
THRABSSPPOSN_vidModifThrustPos|B|();|FCT1.5|THRABSSPPOSN|0|V02 NT 08 04493||||0|0|0|0|Apprentissage en boucle fermée, les valeurs des butées haute et basse sont modifiées afin de pouvoir générer une consigne en dehors de la zone délimitée. Cela permet d’assurer le contact et de contrôler le « couple appliqué » sur la butée concernée.
THRACTEST_vidDiffPosnClcn|B|();|FCT2.3|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|L’écart de boucle locale (consigne – mesure) est calculé tout au long du test actionneur.|
THRACTEST_vidDynTst|B|();|FCT1.5|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Fonction du test dynamique. Le test consiste à compter le temps que met le papillon à rejoindre sa consigne.|
THRACTEST_vidDynTstEna|A|();|FCT1.4|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Fonction qui permet, à chaque changement de consigne, le lancement du test dynamique (compteur). Lorsque la position du papillon est suffisamment proche de sa consigne, on arrête le test.|
THRACTEST_vidDynTstResClcn|A|();|FCT1.8|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Pendant le test actionneur, si le temps que met le papillon à atteindre sa consigne est supérieur à un seuil, alors le papillon est détecté encrassé, et le bit de résultat Thr_bDynActrTst est alors maintenu à 1.|
THRACTEST_vidDynTstResInit|A|();|FCT1.6|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Au début de chaque test actionneur, le bit de résultat Thr_bDynActrTst est initialisé à 0.|
THRACTEST_vidDynTstSpeed|E|();|FCT1.3|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Le test dynamique consiste à vérifier la vitesse de réaction du papillon à un échelon de consigne pour détecter un éventuel encrassement.|
THRACTEST_vidGapTest|C|();|FCT2.4|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Un temps calibrable est laissé au papillon pour atteindre sa consigne (phase 1), puis si le papillon reste trop distant de sa consigne pendant un temps calibrable, alors on détecte un papillon collé.|
THRACTEST_vidGapTestMain|D|();|FCT2.1|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Le test écart de boucle consiste à vérifier que le papillon atteint bien sa consigne|
THRACTEST_vidGapTstEna|A|();|FCT2.2|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Le test écart de boucle est lancé à chaque changement de consigne.|
THRACTEST_vidGapTstResClcn|B|();|FCT2.7|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|A cours du test actionneur, dès qu’un écart de boucle est détecté, le bit de résultat Thr_bGapActrTst est maintenu à 1.|
THRACTEST_vidGapTstResInit|A|();|FCT2.5|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Au début de chaque test actionneur, le bit de résultat Thr_bGapActrTst est initialisé à 0.|
THRACTEST_vidInitDynTst|A|();|FCT1.7|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Fonction de mise à zéro du résultat du test dynamique(Thr_bDynActrTst).|
THRACTEST_vidInitGapTst|A|();|FCT2.6|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|fonction de mise à zéro de résultat du test écart de boucle (Thr_bGapActrTst).|
THRACTEST_vidInitOutput|A|();|FCT1.1|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Initialisation des sorties et des tests actionneurs.|
THRACTEST_vidThrTstSpChart|F|();|FCT1.2|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|Quand un test actionneur papillon est lancé, une consigne spécifique à 5 paliers est appliquée au papillon pendant le test actionneur. Si le test se déroule entièrement, le bit Thr_bTstCmpl passe à 1.|
THRACTEST_vidUpdateGapTst|A|();|FCT2.8|THRACTEST|0|V02 NT 09 00783||||0|0|0|0|le bit de résultat Thr_bGapActrTst est maintenu à 1|
THRBENCHAUT_vidCalcAngleEval|C|();|FCT2.9|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Calcul de l'angle eval|
THRBENCHAUT_vidCompSinAngleEval|C|();|FCT2.7|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|A partir du temps Tpac_sin_time, on va calculer sin (Tpac_sin_time) d'après une cartographie à 7 points d'appuis.|
THRBENCHAUT_vidComputeAbsolutRef|C|();|FCT1.9|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Ce sous-système calcule la valeur de la consigne ramenée  par rapport à la butée basse. Un offset est ajoutée à la valeur de consigne relative.|
THRBENCHAUT_vidComputeAbsRefIncr|A|();|FCT1.8|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Ce sous-système calcule les valeurs de consigne par rapport à la butée basse de l’index de plage courant et suivant.|
THRBENCHAUT_vidComputeIncrement|B|();|FCT1.10|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Calcul de l'incrément|
THRBENCHAUT_vidComputeReference|C|();|FCT2.1|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Ce sous-système calcule  la consigne toutes  les 8 ms, à partir de  la valeur de consigne absolue de l’index en cours.|
THRBENCHAUT_vidComputeSignal|C|();|FCT2.5|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Ce bloc calcule le signal sinusoïdal brut à la fréquence désirée, le multiplie par l'amplitude associée et ajoute l'amplitude et un offset calibrable au signal final.|
THRBENCHAUT_vidControlPart|E|();|FCT1.4|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Partie contrôle faite avec un automate|
THRBENCHAUT_vidCurrentIndex|D|();|FCT1.6|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Définir l'index actuel de la calibration utilisée|
THRBENCHAUT_vidDynMode_1|A|();|FCT1.3|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Le mode créneaux/rampes paramétrables (mode 1) est gérée par un Stateflow et Le Stateflow commande une partie opérative qui a pour but de calculer la consigne.|
THRBENCHAUT_vidDynMode_2|C|();|FCT2.2|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Ce sous-système réalise la recopie brute sur la consigne du signal de tension présent sur l’entrée pédale 1.|
THRBENCHAUT_vidDynMode_3|A|();|FCT2.3|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Génération de consignes en sinus paramétrables|
THRBENCHAUT_vidGenerateSignal|A|();|FCT2.6|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|A partir du temps Tpac_sin_time, on va calculer sin (Tpac_sin_time) d'après une cartographie à 7 points d'appuis.|
THRBENCHAUT_vidIncrGenTimeCount|D|();|FCT3.6|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Ce bloc réinitialise Tpac_sin_time et Tpac_sin_func_entry à leur valeur de départ. Afin de commencer le cycle du sinus avec les bonnes valeurs, on n'effectue pas l'addition de 0.008s sur Tpac_sin_time lorsque ce bloc est exécuté|
THRBENCHAUT_vidIncrSignalCount|C|();|FCT3.7|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Ce bloc incrémente de 1 le numéro du signal utilisé (Tpac_sin_signal_count) quand la durée de ce signal est écoulée.|
THRBENCHAUT_vidIncSinTime|D|();|FCT2.8|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Ce bloc incrémente la valeur Tpac_sin_time après que celle-ci ait été utilisée pour la génération de Tpac_sin_func_entry.|
THRBENCHAUT_vidInitOutput|C|();|FCT1.1|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Fonction d'initialisation des paramètres produits|
THRBENCHAUT_vidMotThrAutBenchMod|B|();|FCT1.2|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Le mode banc automatique présente deux modes de fonctionnement :Un mode génération de consignes en créneaux/rampes paramétrables et Un mode génération de consignes en sinus paramétrables|
THRBENCHAUT_vidNextIndex|B|();|FCT1.7|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Determiner l'index suivant|
THRBENCHAUT_vidNextSignal|C|();|FCT3.8|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Calcul du numéro du signal sinus en cours d'émission|
THRBENCHAUT_vidResetSinTime|B|();|FCT3.5|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Ce bloc réinitialise Tpac_sin_time et Tpac_sin_func_entry à leur valeur de départ. Afin de commencer le cycle du sinus avec les bonnes valeurs, on n'effectue pas l'addition de 0.008s sur Tpac_sin_time lorsque ce bloc est exécuté|
THRBENCHAUT_vidSelectFrequency|A|();|FCT2.4|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Ce bloc sélectionne la fréquence utilisée pour générer le signal sinusoïdal.|
THRBENCHAUT_vidSinTimeFirstQuad|D|();|FCT3.2|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Calcul de l'angle eval premier quadrant|
THRBENCHAUT_vidSinTimeFourthQuad|D|();|FCT3.1|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Calcul de l'angle eval quatrième quadrant|
THRBENCHAUT_vidSinTimeSecondQuad|D|();|FCT3.3|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Calcul de l'angle eval deuxième quadrant|
THRBENCHAUT_vidSinTimeThirdQuad|D|();|FCT3.4|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Calcul de l'angle eval troisième quadrant|
THRBENCHAUT_vidUserCalibrations|A|();|FCT1.5|THRBENCHAUT|0|V02 NT 08 04529||||0|0|0|0|Ce sous-système définit les cartographies à partir desquelles l’utilisateur définit le cycle d’actionnement désiré.|
THRBENCHMODE_vidInitOutput|C|();|FCT1.1|THRBENCHMODE|0|V02 NT 09 07776||||0|0|0|0|Output initialization|
THRBENCHMODE_vidNormFunc|C|();|FCT1.2|THRBENCHMODE|0|V02 NT 09 07776||||0|0|0|0|Fonction pour produite la sortie Thr_posnSpBenchMod.|
THRBOOSTSP_ActivationTest|B|();|FCT1.3|THRBOOSTSP|0|V02 NT 08 04489||||0|0|0|0|Le boost n’est appliqué que si la variation de la consigne est supérieure à un seuil (Si elle est du même ordre de grandeur que la  précision du capteur, elle sera considérée comme nulle).
THRBOOSTSP_BoostMode|B|();|FCT1.5|THRBOOSTSP|0|V02 NT 08 04489||||0|0|0|0|Lorsque les conditions d’activation de boost sont remplies, on ajoute à la consigne « brute » une valeur calculée  à partir de sa variation et d’un gain qui lui est relatif.
THRBOOSTSP_BoostSetPointStrategy|B|();|FCT1.2|THRBOOSTSP|0|V02 NT 08 04489||||0|0|0|0|La stratégie comporte 3 parties principales : (1) Test des conditions d’activation  (2) Application du boost  (3) Mode nominal, c’est-à-dire, recopie de la consigne issue de la structure couple.
THRBOOSTSP_InitReset|B|();|FCT1.1|THRBOOSTSP|0|V02 NT 08 04489||||0|0|0|0|La stratégie est inhibée au reset. Le booléen d’activation est ainsi initialisé à zéro et la consigne à celle de la  structure couple.
THRBOOSTSP_NominalMode|B|();|FCT1.4|THRBOOSTSP|0|V02 NT 08 04489||||0|0|0|0|Dans ce mode, la consigne issue de la structure couple est recopiée directement dans la consigne finale à  appliquer.
THRCMD_vidCommandTpac|C|();|FCT1.4|THRCMD|0|PTS_DOC_6587801||||0|0|0|0|function which gives the command to the throttle.|
THRCMD_vidComptagePanne|B|();|FCT1.3|THRCMD|0|PTS_DOC_6587801||||0|0|0|0|function which manages the default of the throttle.|
THRCMD_vidDriverInh|D|();|FCT1.2|THRCMD|0|PTS_DOC_6587801||||0|0|0|0|Ce bloc décrit l’activation et la désactivation par le LDA du composant LDB qui pilote le Hbridge HBHAL.Par la même, cela gère la pin d’inhibition du pont en H par le MCP( pin DIS).|
THRCMD_vidInitOutput|A|();|FCT1.1|THRCMD|0|PTS_DOC_6587801||||0|0|0|0|THRCMD Initialization function|
THRCORRDPOSN_vidEntryInit|A|();|SCH.1|THRCORRDPOSN|1|V02 NT 08 05172||||0|0|0|0|Evènement Reset ECU
THRCORRDPOSN_vidInitOutput|B|();|FCT1.1|THRCORRDPOSN|0|V02 NT 08 05172||||0|0|0|0|Initialisation des variables produites par le module.
THRCORRDPOSN_vidThrottlePosCorr|C|();|FCT1.2|THRCORRDPOSN|0|V02 NT 08 05172||||0|0|0|0|La position papillon corrigée est calculée à partir de la position brute en retranchant la valeur de la butée basse. La butée est choisie selon le mode de fonctionnement de l'acquisition. Celle-ci est utilisée pour le calcul des gains de l'asservissement.
THRFULLRNGPOSN_vidComput|B|();|FCT1.2|THRFULLRNGPOSN|0|V02 NT 09 08266||||0|0|0|0||
THRFULLRNGPOSN_vidEntryInit|A|();|SCH.1|THRFULLRNGPOSN|1|V02 NT 09 08266||||0|0|0|0|Reset event management|
THRFULLRNGPOSN_vidInitOutput|B|();|FCT1.1|THRFULLRNGPOSN|0|V02 NT 09 08266||||0|0|0|0|Output initialization|
THRMCUT_vidDetection|C|();|FCT1.2|THRMCUT|0|V02 NT 08 04513||||0|0|0|0|Détection de Micro-coupures sur la piste 1.
THRMCUT_vidInit|D|();|FCT1.1|THRMCUT|0|V02 NT 08 04513||||0|0|0|0|Initialisation des variables.
THRMCUT_vidManager|C|();|FCT1.3|THRMCUT|0|V02 NT 08 04513||||0|0|0|0|Production de l’indicateur de l'inhibition du figeage de la consigne papillon en cas de détection d'une micro-coupure.
THRMCUT_vidMicroCutBmpFuncInhib|C|();|FCT1.9|THRMCUT|0|V02 NT 08 04513||||0|0|0|0|Inhibition of the micro cut functionnality
THRMCUT_vidPiste1Mng|B|();|FCT1.5|THRMCUT|0|V02 NT 08 04513||||0|0|0|0|Management of the Piste 1
THRMCUT_vidPiste2Mng|B|();|FCT1.7|THRMCUT|0|V02 NT 08 04513||||0|0|0|0|Management of the Piste 2
THRMCUT_vidSwitchManagementPiste1|B|();|FCT1.6|THRMCUT|0|V02 NT 08 04513||||0|0|0|0|Estimation of the micro cut for the piste 1
THRMCUT_vidSwitchManagementPiste2|B|();|FCT1.8|THRMCUT|0|V02 NT 08 04513||||0|0|0|0|Estimation of the micro cut for the piste 2
THRMCUT_vidThrSpLrnDeac|A|();|FCT2.1|THRMCUT|0|V02 NT 08 04513||||0|0|0|0|Cette stratégie permet d’abandonner le process d’apprentissage en cas de détection de microcoupures.
THRMCUT_vidThrSpLrnDeacEna|A|();|FCT2.2|THRMCUT|0|V02 NT 08 04513||||0|0|0|0|Process d’apprentissage, production de Thr_bDeacThrStopLrn.
THRMCUT_vidTpsRatioMeasPosEnab|D|();|FCT1.4|THRMCUT|0|V02 NT 08 04513||||0|0|0|0|Determination conditions for normal use of tracks 1 and 2 of the position BFM
THRMNGSERVO_LearningStopsAndStop|G|();|FCT2.9|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|focntion d'apprentissage butées et arret|
THRMNGSERVO_vidCalInhibInjection|C|();|FCT1.8|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Le manager du Thr a la posibilité d’inhiber l’injection lors de sa procédure d’apprentissage à l’init.|
THRMNGSERVO_vidCalTempCleoff|D|();|FCT1.4|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|fonction de calcul Tempo_Cleoff|
THRMNGSERVO_vidDownThrustEnable|A|();|FCT3.5|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Le booleen Tpac_thrusts_enable passe à OFF lorsqu’un apprentissage des butées a été réalisé avec succès|
THRMNGSERVO_vidEndThrLrn|C|();|FCT3.7|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|En cas de détection d’une dérive de position Limp Home, il est possible de forcer un apprentissage des butées basses au prochain power-latch.|
THRMNGSERVO_vidEntryNodeInitSdf|F|();|FCT2.2|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Condition de transition du noeud NodInitSdf|
THRMNGSERVO_vidFClnReset|A|();|FCT3.10|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|A la fin du cycle de nettoyage, le booléen d’activation de cette fonction ainsi que le compteur de cycles de roulage sont remis à zéro.|
THRMNGSERVO_vidForceLrnRst|C|();|FCT3.8|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|En cas de détection d’une dérive de position Limp Home ou en cas de défaillance système, il est possible de forcer un apprentissage des butées basses au prochain Reset.|
THRMNGSERVO_vidInitOutput|G|();|FCT1.1|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|fonction d'initialisation des variables produites.|
THRMNGSERVO_vidManager|D|();|FCT1.3|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Gestionnaire des différents modes de fonctionnement/asservissement du papillon|
THRMNGSERVO_vidManagerTransition|E|();|FCT1.5|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Partie de contrôle de l'automate des transitions|
THRMNGSERVO_vidManagerTreatment|E|();|FCT1.6|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Partie de contrôle de l'automate des traitements|
THRMNGSERVO_vidPowrLatchCountMng|F|();|FCT1.2|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Comptage des passages en Power-Latch de manière à pouvoir gérer l’espacement entre les apprentissages des butées. Le comptage n’a pas lieu si une demande d’apprentissage des butées est déjà active ou une demande de nettoyage est en cours.|
THRMNGSERVO_vidSrvTran|A|();|FCT1.9|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Ce bloc permet de gérer la transition d’inhibition vers réhabilitation par les routines du  papillon motorisé via un booléen passant à 1 lors de la descente du flag d’inhibition si les conditions sont réunies|
THRMNGSERVO_vidThrIniAftsStopCln|A|();|FCT3.9|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Commande de l'initialisation de Tpac_FCln_powerlatch_counter et Tpac_FCln_enable à la fin de du cycle de nettoyage.|
THRMNGSERVO_vidThrIniAftsStopLrn|C|();|FCT3.6|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Un service APV permet de placer la fonction dans le même état qu’au premier Key-on|
THRMNGSERVO_vidThrServoInh|E|();|FCT1.7|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Control: Dans cet état, Thr_bInhMngThrServo est calculé. Il regroupe FRM_bInhMngThrServo et L’état d’automate de la position papillon.|
THRMNGSERVO_vidTransClosingRamp|H|();|FCT2.6|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Condition de transition de l'etat TPAC_CLOSING_RAMP|
THRMNGSERVO_vidTransControl|I|();|FCT2.4|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Condition de transition de l'etat TPAC_CONTROL|
THRMNGSERVO_vidTransExitLowThrus|G|();|FCT2.7|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Condition de transition de l'etat TPAC_EXIT_LOW_THRUST|
THRMNGSERVO_vidTransHighThSearch|G|();|FCT2.5|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Condition de transition de l'etat TPAC_HIGH_THRUST_SEARCH|
THRMNGSERVO_vidTransLimpHome|J|();|FCT2.8|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Condition de transition de l'etat TPAC_LIMP_HOME|
THRMNGSERVO_vidTransMcwInhibTest|G|();|FCT2.3|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Condition de transition de l'etat TPAC_MCW_INHIBIT_TEST|
THRMNGSERVO_vidTransRestorMobil|A|();|FCT2.10|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Condition de transition de l'etat TPAC_RESTOR_MOBILITY.|
THRMNGSERVO_vidTransWaitForAdc|E|();|FCT2.1|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|Condition de transition de l'etat TPAC_WAIT_FOR_ADC|
THRMNGSERVO_vidTreatClosingRamp|B|();|FCT3.2|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|During de l'etat TPAC_CLOSING_RAMP|
THRMNGSERVO_vidTreatExitLowThrus|B|();|FCT3.3|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|During de l'etat TPAC_EXIT_LOW_THRUST|
THRMNGSERVO_vidTreatHighThSearch|B|();|FCT3.1|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|During de l'etat TPAC_HIGH_THRUST_SEARCH|
THRMNGSERVO_vidTreatLimpHome|C|();|FCT3.4|THRMNGSERVO|0|V02 NT 08 04528||||0|0|0|0|During de l'etat TPAC_LIMP_HOME|
THROPLCTL_CalcWaitAdc|A|();|FCT2.4|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|Lorsque le système entre en limp-home, on initialise la tension en boucle ouverte de commande. On applique  0 V pour avoir un couple nul.
THROPLCTL_vidCalcClosingRamp|E|();|FCT2.2|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|La tension appliquée pour sortir de la butée haute est une rampe décroissante calibrée, de manière à contrôler la vitesse d’accostage sur butée, et saturée de manière à maîtriser le couple appliqué sur la butée basse mécanique.
THROPLCTL_vidCalcExitLowThrust|E|();|FCT2.3|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|On pourra appliquer une pente élevée pendant un délai courtde sorte que la tension de commande corresponde à une impulsion; ou bien la pente sera plus lente pour « accompagner» le volet jusqu’au limp-home.
THROPLCTL_vidCalcMcwInh|B|();|FCT1.8|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|Pour test 1 de « l’inhibit » du microcontrôleur secondaire, on applique 0 V.Pour test 2, on applique une tension calibrable de manière à faire dévier le papillon de sa position  d’équilibre.
THROPLCTL_vidCalcOpeningRamp|E|();|FCT2.1|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|Pendant la recherche de butées, la tension appliquée est une rampe calibrable, de manière à contrôler la vitesse d’accostage sur butée, et saturée de manière à maîtriser le couple appliqué sur la butée.
THROPLCTL_vidConditions|E|();|FCT1.3|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|Bloc permettant la genération du flag de commande en boucle ouverte du PAPMOT et l'appel des deux événements de passage d'une commande en boucle ouverte à une commande en boucle fermée du papillon
THROPLCTL_vidInit|A|();|FCT1.2|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|Lors de la recherche de butée, la tension de commande est initialisée à une valeur correspondant à la butée  haute lorsque le contact entre le volet et la butée haute est autorisé
THROPLCTL_vidInitClosingRamp|E|();|FCT1.5|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|Lors de la recherche de butée, la tension de commande est initialisée à une valeur de la butée haute lorsque le contact entre le volet et la butée haute est autorisé.Lorsque la recherche de butée haute est inhibé on initialise la tension de commande à 0.
THROPLCTL_vidInitExitLowThrust|E|();|FCT1.6|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|Lors de la sortie de butée basse, la tension de commande est initialisée à la valeur correspondant à la butée basse. On initialise aussi la temporisation de sortie de butée basse.
THROPLCTL_vidInitMcpInh|F|();|FCT1.9|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|Lorsque le système entre en limp-home, on initialise la tension en boucle ouverte de commande.
THROPLCTL_vidInitMcwInh|F|();|FCT1.7|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|Pour le test de «l’inhibit» du microcontrôleur secondaire, on applique une tension calibrable de manière à faire dévier le papillon de sa position d’équilibre. Si «l’inhibit» est opérationnel, le papillon doit être en position limphome.
THROPLCTL_vidInitOpeningRamp|E|();|FCT1.4|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|Lors de la recherche de butée haute, la tension de commande est initialisée à une valeur nulle de manière à appliquer un couple nul.
THROPLCTL_vidInitOutput|E|();|FCT1.1|THROPLCTL|0|V02 NT 08 04793||||0|0|0|0|Initialisation des sorties du composant software ThrOplCtl
THRPOSMES_vidAcqPosition1|G|();|FCT1.3|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|Valeur de l'angle d'ouverture du papillon donnée par la voie 1 du/des capteurs. La position papillon 1 est obtenue par une conversion ratiométrique avec la tension d'alimentation du capteur.|
THRPOSMES_vidAcqPosition2|G|();|FCT1.4|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|Valeur de l'angle d'ouverture du papillon donnée par la voie 2 du/des capteurs. La position papillon 2 est obtenue par une conversion ratiométrique avec la tension d'alimentation du capteur puis redressée.|
THRPOSMES_vidCohPosnSnsrSafetyL2|B|();|FCT2.1|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|Le but de cette stratégie est de sécuriser la cohérence des entrées de mesure de la position papillon (capteur 1 et capteur 2) via une stratégie de niveau 2 afin de se prémunir contre les fautes latentes.|
THRPOSMES_vidDbleDefaillanceThr|B|();|FCT2.4|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|Gestion du défaut relatif à la double défaillance THR|
THRPOSMES_vidDiagDisable|C|();|FCT1.8|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|Lorsque le diagnostique doit être desactiver du fait d’un defaut en amont, on positionne Thr_bMonRunXXX à 0 de manière à ce que le GD n’incrémente pas les compteurs de pannes|
THRPOSMES_vidDiagElec|F|();|FCT1.7|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|Détection des défauts de plage de mesure, Test de la cohérence électrique|
THRPOSMES_vidDiagElecCohPosSnsr|F|();|FCT1.6|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|L'erreur entre les deux mesures papillon est filtrée avant le test de cohérence pour s'affranchir des dispersions de constantes de temps de filtrage des acquisitions.|
THRPOSMES_vidDiagElecPosRange|F|();|FCT1.9|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|Le test est effectué si le booléen d’inhibition est positionné à 0. Le capteur 1 est déclaré en c-c à la Tbat si la mesure ratiométrique est supérieure à un seuil; en c-o ou en c-c à la masse si cette mesure est inférieure à un second seuil|
THRPOSMES_vidDiagOcPosSnsr2|F|();|FCT1.10|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|De plus, le fait d’être lié à deux microcontrôleurs interdit les diagnostics de court-circuit à la masse et de circuit ouvert à cause des courants de fuite dans la résistance de polarisation en entrée des microcontrôleurs.|
THRPOSMES_vidFilterU32|C|(argin uint8 u8FilterGain,argout uint32 *pu32AccuracyFilterValue,argin uint32 u32MeasuredValue);|FCT2.3|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|First order filter executed on a uint32 value with an uint8 gain|
THRPOSMES_vidInitOutput|E|();|FCT1.1|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|Module initialization|
THRPOSMES_vidSafetyLevel2|B|();|FCT2.2|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|Le but de cette stratégie est de sécuriser les entrées de mesure de la position papillon (capteur 1 et capteur 2) via une stratégie de niveau 2 afin de se prémunir contre les fautes latentes.|
THRPOSMES_vidTpsPosTolerance|D|();|FCT1.5|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|La tolérance de la panne de cohérence est fonction du régime moteur par le biais de la cartographie Tps_position_tolerance_map.|
THRPOSMES_vidVoltageFilter|E|();|FCT1.2|THRPOSMES|0|PTS_DOC_6658623||||0|0|0|0|Ce bloc effectue le filtrage de la tension d'alimentation des capteurs de position papillon, afin d'éliminer les oscillations de position liées aux petites oscillations à hautes fréquences de cette tension.|
THRPOSNSPLRN_vidAutomate|D|();|FCT2.1|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Fonction de management.|
THRPOSNSPLRN_vidCalibration|A|();|FCT2.8|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Cette fonction permet de différencier les calibrations de la fonction nettoyage de celle utilisées par la fonction d’apprentissage.|
THRPOSNSPLRN_vidCmptTemps|A|();|FCT1.6|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Au-delà d’un durée maximale autorisée, la fonction de restauration de la mobilité du papillon est arrêtée par l’envoi d’un flag au gestionnaire de l’asservissement papillon.|
THRPOSNSPLRN_vidCntrndRstrMbilit|A|();|FCT1.9|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Des contraintes d’amplitude et de dynamique (pentes) sont appliquées au signal de consigne brute de commande du papillon pour la restauration de sa mobilité.|
THRPOSNSPLRN_vidDurExitLowThrust|C|();|FCT2.6|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Fonction gérant les actions pendant l'état Exit Low Trust.|
THRPOSNSPLRN_vidDuringHighThrust|C|();|FCT2.2|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Fonction gérant les actions durant l'état High_Thrust_Search.|
THRPOSNSPLRN_vidDuringLimpHome|C|();|FCT2.5|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|fonction gérant les actions pendant l'état Limp Home.|
THRPOSNSPLRN_vidDuringLowThrust|C|();|FCT2.3|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Fonction gérant les actions durant l'état Low Thrust Search.|
THRPOSNSPLRN_vidDuringMcwInhTest|B|();|FCT2.4|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Fonction gérant les actions durant l'état McwInhibitTest|
THRPOSNSPLRN_vidFinalSpcSp|A|();|FCT2.10|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Une consigne spécifique correspondant à l’une des fonctions (apprentissage, nettoyage ou restauration de la mobilité) est calculée.|
THRPOSNSPLRN_vidInit|D|();|FCT1.1|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Fonction initialisant les paramètres du module.|
THRPOSNSPLRN_vidMobiltRestorat|A|();|FCT1.2|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Cette fonction permet de restaurer la mobilité du papillon lors du réveil partiel du CMM.|
THRPOSNSPLRN_vidRawSpRstrMoblit|A|();|FCT1.8|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Cette fonction permet de définir la forme brute du signal de consigne de commande du papillon pour la restauration de sa mobilité.|
THRPOSNSPLRN_vidResMblitFuncEnb|A|();|FCT1.3|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Cette fonction permet d’activer la fonction de la restauration de la mobilité du papillon si toutes les conditions nécessaires sont réunies.|
THRPOSNSPLRN_vidRstrMblitSetPnt|A|();|FCT1.5|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Cette fonction permet de calibrer le profil du signal de commande du papillon permettant la restauration de sa mobilité.|
THRPOSNSPLRN_vidRstRstrMblitSetP|A|();|FCT1.4|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Lorsque la fonction de restauration de la mobilité du papillon est inactive, Thr_bMblRstorInProgs prend la valeur 0 et la consigne de position correspond à un retour au limp-home.|
THRPOSNSPLRN_vidSglPapilBrisGlac|A|();|FCT1.7|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Cette fonction permet de calibrer le profil du signal de commande du papillon permettant la restauration de sa mobilité.|
THRPOSNSPLRN_vidSlewRate|D|();|FCT2.9|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|La consigne de position papillon pour l’apprentissage des butées (ou pour le nettoyage du BPM) est appliquée dès que Thr_FLrnClCtl_bAcv passe à 1.|
THRPOSNSPLRN_vidTransFromCenter|E|();|FCT2.7|THRPOSNSPLRN|0|V02 NT 11 00303||||0|0|0|0|Fonction gérant les transitions.|
THRSECUMNG_vidSelectLimpHome|D|();|FCT1.4|THRSECUMNG|0|V02 NT 08 05135||||0|0|0|0|La position  limp home fournie au reste de l'applicatif peut etre celle mesurées sur le capteur n°1 lorsque l'automate est dans l'état "NORMAL" ou "SINGLE_1"ou celle du capteur n°2 à l'état "SINGLE_2" ou par défaut calibrable à l'état "FAILURE".
THRSECUMNG_vidSelectThrotThrusts|D|();|FCT1.3|THRSECUMNG|0|V02 NT 08 05135||||0|0|0|0|Les butées fournies au reste de l'applicatif peuvent etre ceux mesurées sur le capteur n°1 lorsque l'automate est dans l'état "NORMAL" ou "SINGLE_1"ou ceux du capteur n°2 lorsque l'automate est dans l'état "SINGLE_2". Les butées sont rafraîchies au Reset.
THRSECUMNG_vidSelectThrottlePos|D|();|FCT1.2|THRSECUMNG|0|V02 NT 08 05135||||0|0|0|0|La position fournie au reste de l'applicatif peut etre celle issue du capteur n°1 lorsque l'automate est dans l'état "NORMAL" ou "SINGLE_1", celle du capteur n°2 lorsque l'automate est dans l'état "SINGLE_2" ou par défaut calibrable à  l'état "FAILURE".
THRSECUMNG_vidSFControlPart|D|();|FCT1.1|THRSECUMNG|0|V02 NT 08 05135||||0|0|0|0|L'automate de gestion des voies d'acquisition de la position papillon motorisé comporte 4 états: Normal (pas de pannes), Single_1/Single_2 (Détection d'une panne électrique mémorisée sur l’un des 2 capteurs), Failure (mesure invalide/panne cohérence).
THRSERVO_vidAdjustVelocity|B|();|FCT2.1|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Le calcul de la dérivée est basé sur la taille estimée de la fenêtre. Les coefficients utilisés pour le calcul de la dérivée sont basés sur la méthode du "Best-fit-FOAW"|
THRSERVO_vidBatteryVoltageGain|B|();|FCT3.9|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Calcul du gain sur la tension de commande fonction de la tension batterie.|
THRSERVO_vidCompGloblAttenuation|B|();|FCT3.5|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Calcul du gain d'atténuation autour de la position limp home.|
THRSERVO_vidCompStateFeedbackCtl|D|();|FCT2.10|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce sous-système réalise le calcul du produit scalaire [K1 K2 K3]*[x1 x2 x3] , où K1, K2 et K3 sont les gains du retour d’état respectivement appliqués à la position (état x1), à la vitesse (état x2) et au courant (état x3).|
THRSERVO_vidComputeCtrlVoltage|C|();|FCT3.6|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Calcul de la commande de l'actionneur PAPMOT.|
THRSERVO_vidComputeCtrlVoltLin|C|();|FCT3.3|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce sous-système spécifie le calcul de la partie linéaire de la commande (Tpac_control_voltage_lin) qui  correspond à la différence entre le terme intégral (Tpac_integral_output) et le retour d’état (Tpac_state_feedback_control).|
THRSERVO_vidComputeCurrent|B|();|FCT2.8|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|estimation de l’état non mesuré du système (calcul du courant)|
THRSERVO_vidComputeCurrentCall|A|();|FCT2.7|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Cette fonction définit les conditions d'appel de la fonction qui estime le courant circulant dans le papillon.|
THRSERVO_vidComputeFeedForward|A|();|FCT3.4|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce module décrit l'activation ou la désactivation de la stratégie de compensation des  frottements secs.|
THRSERVO_vidComputeFrictCompens|C|();|FCT4.5|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce module calcul la valeur du feedforward à appliquer sur la commande afin de compenser les frottements secs. Cette compensation est réalisée en considérant le couple de frottements secs comme une tension.|
THRSERVO_vidComputeInitTasks|A|();|FCT1.2|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce sous-système réalise les tâches d’initialisation de la stratégie de pilotage du papillon motorisé.|
THRSERVO_vidComputeInnerLoop|A|();|FCT1.6|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce sous-système réalise le calcul de la boucle interne de la loi de commande|
THRSERVO_vidComputeIntegrOutput|E|();|FCT3.2|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce sous-système produit la valeur du terme intégral de la stratégie de contrôle par retour d’état (Tpac_integral_output).|
THRSERVO_vidComputeOutterLoop|A|();|FCT3.1|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce sous-système spécifie le traitement de la boucle externe de la stratégie|
THRSERVO_vidComputePhysicalState|B|();|FCT1.7|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Estimation de l’état non mesuré du système (calcul de la vitesse du papillon, calcul du courant), du couple ressort et de sa dérivée (en vue du calcul du feedforward)|
THRSERVO_vidComputePositionError|B|();|FCT3.8|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce sous-système spécifie le calcul de l’erreur de position (Tpac_position_error) entre la consigne de position (Tpac_throttle_position_reference) et la position (Ssm_raw_filt_throttle_position).|
THRSERVO_vidComputeVelocity|A|();|FCT1.8|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce sous-système calcule l’estimation de la vitesse du papillon motorisé (Tpac_estimated_velocity) par dérivation numérique de la position (Ssm_raw_filt_throttle_position)|
THRSERVO_vidControlSwitchMode|C|();|FCT3.7|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Calcul de l'RCO du PWM de commande papillon en sortie de l'asservissement générique JCAE|
THRSERVO_vidDecTempo|B|();|FCT1.5|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce sous-système décrémente la temporisation d’initialisation de la stratégie de contrôle|
THRSERVO_vidFiltCompensFeedBack|B|();|FCT4.7|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce bloc applique un filtrage de la consigne de feedforward. L'idée est de compenser les effets induits par le retour d'état en courant.|
THRSERVO_vidFiltering|B|();|FCT4.6|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce bloc applique un filtrage de la consigne de feedforward.|
THRSERVO_vidFrictConstCounter|B|();|FCT4.3|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce bloc décompte des temporisation avant l'activation ou la désactivation de la stratégie de compensation des frottements secs.|
THRSERVO_vidFrictionCompensation|B|();|FCT4.1|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Stratégie de compensation des  frottements secs.|
THRSERVO_vidFrictionDetection|C|();|FCT4.2|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce bloc défini la détection d’accrochage du papillon dû à des frottements secs.|
THRSERVO_vidInitControlVariables|C|();|FCT1.3|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|initialisation des variables des algorithmes de l’asservissement|
THRSERVO_vidInitOutput|D|();|FCT1.1|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Fonction d'initialisation|
THRSERVO_vidInitTempo|A|();|FCT1.4|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|initialisation d’une temporisation durant laquelle le calcul d’estimation du courant est inhibé|
THRSERVO_vidIntegInitOnSetGainIO|C|();|FCT5.4|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce bloc réinitialise le terme intégral pour garantir la continuité de la commande, lors d’un changement de gains.|
THRSERVO_vidManageLimpHome|C|();|FCT2.9|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|La stratégie de franchissement du limp-home consiste à adapter les 4 gains du retour d’état à l’intérieur d’une zone calibrable autour du limp-home.|
THRSERVO_vidManagerThrottleState|A|();|FCT5.1|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Stateflow qui définit l’état de l’asservissement papillon selon la position de ce dernier et gère les événements relatifs à la commutation des gains fortsou faibles.|
THRSERVO_vidMedianFilter|B|();|FCT2.6|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Les entrées du filtre médian sont les trois dernières valeurs de la vitesse.  La sortie du filtre médian est la valeur non extrême des trois entrées. Un gain de retard permet de filtrer les valeurs de la vitesse pour éviter de trop brusques variations.|
THRSERVO_vidSetControlGainsIn|A|();|FCT5.3|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce bloc positionnne les gains du retour d’état sur les valeurs fortes (dans la  zone "limp-home")|
THRSERVO_vidSetControlGainsOut|A|();|FCT5.2|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Ce bloc positionnne  les gains du  retour d’état  sur  les valeurs  faibles  (en  dehors de la zone "limp-home")|
THRSERVO_vidSetFrictStatus|B|();|FCT4.4|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Automate de la stratégie de frottements secs.|
THRSERVO_vidSetWindowSize|C|();|FCT1.10|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|L'algorithme utilisé pour déterminer la taille de la fenêtre se base sur la dispersion des positions autour d'une valeur moyenne estimée de la dérivée et sur l'amplitude des variations de la position.|
THRSERVO_vidUpdatePositionValues|B|();|FCT1.9|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|Mise à jour des valeurs retardées de la position papillon utilisées dans l'algorithme de détermination de la taille de la fenêtre|
THRSERVO_vidVelocityWindow1|B|();|FCT2.2|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|calcul de la vitesse du rotor estimée avec une fenêtre de taille 1|
THRSERVO_vidVelocityWindow2|B|();|FCT2.3|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|calcul de la vitesse du rotor estimée avec une fenêtre de taille 2|
THRSERVO_vidVelocityWindow3|B|();|FCT2.4|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|calcul de la vitesse du rotor estimée avec une fenêtre de taille 3|
THRSERVO_vidVelocityWindow4|B|();|FCT2.5|THRSERVO|0|V02 NT 08 04514||||0|0|0|0|calcul de la vitesse du rotor estimée avec une fenêtre de taille 4|
THRSERVODIAG_vidDifThrDgDataCal|A|();|FCT1.3|THRSERVODIAG|0|V02 NT 08 04530||||0|0|0|0|Ce bloc engendre les données et les conditions nécessaires à la réalisation des diagnostics de l’asservissement du papillon motorisé.|
THRSERVODIAG_vidDifThrPoDgFrAfSl|A|();|FCT1.4|THRSERVODIAG|0|V02 NT 08 04530||||0|0|0|0|La surveillance de l’écart de boucle pour les services après vente est réalisée par une comparaison de la valeur absolue de l’erreur (ou de l’intégrale de l’erreur) d’asservissement à un seuil calibrable.|
THRSERVODIAG_vidDifThrPosDiag|A|();|FCT1.5|THRSERVODIAG|0|V02 NT 08 04530||||0|0|0|0|ce diagnostic permet de prévenir contre les dérives positives et négatives de l’écart (consigne-mesure) de commande du BPM.|
THRSERVODIAG_vidEntryInit|B|();|SCH.1|THRSERVODIAG|1|V02 NT 08 04530||||0|0|0|0|Evénement Reset ECU|
THRSERVODIAG_vidInitOutput|E|();|FCT1.1|THRSERVODIAG|0|V02 NT 08 04530||||0|0|0|0|Initialisation des variables internes au module|
THRSERVODIAG_vidSerFailDetection|D|();|FCT1.2|THRSERVODIAG|0|V02 NT 08 04530||||0|0|0|0|Pour empêcher des pannes intempestives en apprentissage de butées ou en fin d’apprentissage, on autorise le diagnostic d’asservissement du papillon lorsque l'automate est passé en état TPAC_CONTROL(boucle fermée) depuis une temporisation.|
THRSFTYCPUIFINH_vidBswAbortcount|B|();|FCT2.2|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|cette fonction permet de compter le nombre d’abandon (Abort) par le basic software lors des tests d’inhibit safety.|
THRSFTYCPUIFINH_vidFuncGenerator|D|();|FCT1.8|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|Génération de l'événement Thr_EveChkLih_MngServo.|
THRSFTYCPUIFINH_vidInit|C|();|FCT1.1|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|Initialisation des sorties|
THRSFTYCPUIFINH_vidInitOutput|I|();|FCT1.2|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|Initialisation des variables internes du module THRSFTYCPUIFINH.|
THRSFTYCPUIFINH_vidMcwdgInhTest1|G|();|FCT1.4|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|Le defaut "ReadPinEnaThr_Cpu" correspond à une incohérence au niveau de la relecture par le MCP du statut de la PIN DI2 (ou EN)  (valeur attentue durant le test EN=MCWDG_bMCW_INHIBIT_ACTIVE1 pour couper le papillon).|
THRSFTYCPUIFINH_vidMcwdgInhTest2|H|();|FCT1.5|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|Le defaut “ InhThr_cpuSfty” correspond à une incohérence au niveau de la relecture par le MCP de la position papillon( valeur attentue durant le test = position de Limp Home).|
THRSFTYCPUIFINH_vidMcwdgInhThr|A|();|FCT2.3|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|Durant la durée du test 1 on vérifie si le Pin d’inhibition du MCW est différent de l’état inhibition.Le cas échéant on monte le défaut Thr_bDgoReadPinInhThr_Cpu.|
THRSFTYCPUIFINH_vidMcwIhBswTstEd|B|();|FCT1.9|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|Sortie du booléen sur événement de fin de test envoyé par le basic software.|
THRSFTYCPUIFINH_vidMcwInhApiMngt|J|();|FCT1.6|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|L’appel à l’API "MCWDG_vidStartInhibitState" permet de demander au LDB de  désactiver le pont H en imposant « ENA » du Mcw à 0.L’appel à l’API "MCWDG_vidStopInhibitState" permet de réactiver le pont en  H à la fin du test.|
THRSFTYCPUIFINH_vidMcwInhTstEnd|C|();|FCT1.10|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|Calcul de la variable Thr_bEndTestInh_CpuSfty|
THRSFTYCPUIFINH_vidOldStructMang|E|();|FCT1.7|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|Ce block gère la compatibilité avec une architecture précédente.|
THRSFTYCPUIFINH_vidReadMcwInhib|D|();|FCT1.3|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|L’appel à l’API MCWDG_bReadInhibitState retourne la valeur de l’ inhibition status du microcontrolleur watchdog ( PIN DI2( ou EN)).|
THRSFTYCPUIFINH_vidRnitBswAbtcnt|B|();|FCT2.1|THRSFTYCPUIFINH|0|PTS_DOC_5060895||||0|0|0|0|cette fonction permet de réinitialiser le compteur d’abandon (Abort).|
THRSFTYMNG_vidDfltApplicLimpHome|D|();|FCT1.6|THRSFTYMNG|0|V02 NT 11 03549||||0|0|0|0|Cette fonction permet de diagnostiquer une éventuelle non application d’un demande de retour à la position limp-home du BPM.|
THRSFTYMNG_vidDfltMCWDGFuncTest|B|();|FCT1.7|THRSFTYMNG|0|V02 NT 11 03549||||0|0|0|0|Ce bloc permet la transmission des pannes à l'application via le composant DGOHAL.|
THRSFTYMNG_vidInitOutput|B|();|FCT1.1|THRSFTYMNG|0|V02 NT 11 03549||||0|0|0|0|Setting Outputs at Reset|
THRSFTYMNG_vidMCWDGFuncTestRslt|A|();|FCT1.5|THRSFTYMNG|0|V02 NT 11 03549||||0|0|0|0|Ce bloc est inhibé si FRM_bInhDiag_inhThrCpuSfty=1.|
THRSFTYMNG_vidMcwdgInhTestAbort|A|();|FCT1.8|THRSFTYMNG|0|V02 NT 11 03549||||0|0|0|0|abandon du Test d'inhibition pour retourner à l'état intial|
THRSFTYMNG_vidMcwdgInhTestCdn|C|();|FCT1.4|THRSFTYMNG|0|V02 NT 11 03549||||0|0|0|0|Ce block définit les conditions de réalisation du diagnostic.  Le diagnostic peut être désactivé en cas de défaut système ou de reset à chaud (on se protège contre une fermeture papillon en roulage).|
THRSFTYMNG_vidMcwdgInhTestStrt|B|();|FCT1.3|THRSFTYMNG|0|V02 NT 11 03549||||0|0|0|0|La fin de l’initialisation du hard est détectée pour autoriser le commencement du test.|
THRSFTYMNG_vidMcwdgInit|A|();|FCT1.2|THRSFTYMNG|0|V02 NT 11 03549||||0|0|0|0|Après un reste, il est impératif de s’assurer que le test ne commence pas avant la fin de l’initialisation du hard.|
THRSPPOSN_vidComputeDtcThrPos|G|();|FCT1.2|THRSPPOSN|0|PTS_DOC_6095099||||0|0|0|0|Si un défaut de niveau 3 est issu de la sécurité de fonctionnement, l’objectif de section efficace papillon est limité, ainsi que sa vitesse d’ouverture, afin de limiter les performances moteurs.|
THRSPPOSN_vidComputeDtcThrPosRef|H|();|FCT1.3|THRSPPOSN|0|PTS_DOC_6095099||||0|0|0|0|En mode banc manuel, l’ouverture du papillon est donnée par une calibration spécifique, sinon on limite la pente des modifications en fonction des caractéristiques mécanique du boîtier papillon.|
THRSPPOSN_vidCounter|A|();|FCT1.10|THRSPPOSN|0|PTS_DOC_6095099||||0|0|0|0|Fonction qui compte le nombre d'autorisation de fermeture complète du papillon|
THRSPPOSN_vidDeadBandLH|E|();|FCT1.4|THRSPPOSN|0|PTS_DOC_6095099||||0|0|0|0|En cours de fonctionnement, le Limp-home se déplace (en fonction de la température, Afin de s’affranchir de ses variations, ce module définit une zone interdite pour la consigne de position papillon centrée autour de la valeur apprise du Limp-home.|
THRSPPOSN_vidDiffEstimation|E|();|FCT1.7|THRSPPOSN|0|PTS_DOC_6095099||||0|0|0|0|Ce bloc permet de calculer la valeur absolue de l’écart entre l’ancienne valeur et la nouvelle, à chaque transition.|
THRSPPOSN_vidInitOutput|C|();|FCT1.1|THRSPPOSN|0|PTS_DOC_6095099||||0|0|0|0|Fonction d'initialisation des sorties.|
THRSPPOSN_vidInitThrottleRef|E|();|FCT1.5|THRSPPOSN|0|PTS_DOC_6095099||||0|0|0|0|Lors d’un reset du calculateur ou d’un passage de la commande en boucle ouverte à la commande en boucle fermée (front descendant de Tpac_open_loop_control), la consigne relative de position papillon est initialisée à la position mesurée.|
THRSPPOSN_vidStopEngineCase|B|();|FCT1.9|THRSPPOSN|0|PTS_DOC_6095099||||0|0|0|0|la fonction présente  les conditions pour passer en fermeture complète du papillon|
THRSPPOSN_vidSwitchingTransients|E|();|FCT1.8|THRSPPOSN|0|PTS_DOC_6095099||||0|0|0|0|Ce bloc permet de limiter la « fenêtre » d’application du « slew_rate » sur la valeur utilisée|
THRSPPOSN_vidSwitchMgtMcut|E|();|FCT1.6|THRSPPOSN|0|PTS_DOC_6095099||||0|0|0|0|En cas de détection de micro-coupure, la consigne relative de position papillon prend la valeur de la position « mesurée », si Throttle_pos_ref_freeze_manu_inh = 0, avec une pente de variation limitée (filtrage de type « slew-rate ».|
THRSTOPCLCN_vidCalc_Lih_prec|B|();|FCT2.10|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Production des variables précédentes des variables Tpac_1_limp_home_pos et Tpac_2_limp_home_pos.
THRSTOPCLCN_vidCalcLoThrustLHNeg|C|();|FCT2.3|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|La position d’écoulement mini, dite de butée basse d’asservissement, correspond à la position de repos mécanique finale plus un offset de position, noté « Tpac_lhome_to_closed_thrust_cal ».
THRSTOPCLCN_vidCheckLimpHome|D|();|FCT2.1|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Le microcontrôleur principal vérifie que la fonction d’inhibit du microcontrôleur watchdog est opérationnelle. Il procède à la lecture de la position de repos. Il s'assure ainsi que le papillon est bien en position de limp-home.
THRSTOPCLCN_vidClosedThrusts|D|();|FCT1.5|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Ce processus est « triggé » par l'automate de gestion de l'asservissement du papillon motorisé lorsque la butée basse est trouvée. La butée basse devient alors le minimum de position lu au cours de la recherche de butée.
THRSTOPCLCN_vidEndStopDiag|B|();|FCT2.5|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Fonction positionnant les paramètres de diagnostic (GDU) avant l'appel au GDU.
THRSTOPCLCN_vidFailureCounting|C|();|FCT1.5|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Si le papillon est à limp home négatif et que les valeurs maximales sont hors-gamme, une panne «Tpac_thrusts» est mémorisée immédiatement ou à la fin de l’apprentissage de butée basse.
THRSTOPCLCN_vidFilter|C|();|FCT1.6|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|L’évolution importante de la butée basse apprise du papillon motorisé d’un roulage à un autre peut conduire à des problèmes pour assurer la régulation ralenti. Pour remédier à cela, on filtre la position apprise par un filtre de premier ordre.
THRSTOPCLCN_vidInhibTps2LHomeMcw|C|();|FCT3.6|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|La détection d’une mesure hors-gamme sur le capteur n°2 est mémorisée dans une variable temporaire. Elle sera lue à la fin de la procédure d’acquisition des butées afin de diagnostiquer l’état général des capteurs et du papillon.
THRSTOPCLCN_vidIniLrnLimpHome|A|();|FCT2.7|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|
THRSTOPCLCN_vidInitEndStopHiLow|C|();|FCT1.2|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Les valeurs maximales et minimales lues sur les deux  capteurs sont initialisées à une valeur intermédiaire avant que l’apprentissage ne débute
THRSTOPCLCN_vidInitOutput|D|();|FCT1.1|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Fonction d'initialisation des variables produites le composant software THRSTOPCLCN.
THRSTOPCLCN_vidLihDiag|B|();|FCT2.4|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Positionne les paramètres de diagnostic (GDU) avant de réaliser l'appel au GDU.
THRSTOPCLCN_vidLimpHome|F|();|FCT2.2|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Cette fonction est appelée par l’automate d'asservissement. Elle procède à la lecture de la position de repos, dite de limp-home, sur les capteurs n°1 e t n°2. Si les valeurs de position obtenues sont hor s gamme, une panne « tpac_lhome » est mémorisée.
THRSTOPCLCN_vidNoFilter|C|();|FCT1.8|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Le filtrage de la butée basse ne sera pas activé lors du premier apprentissage en usine ou lors des demandes d’apprentissage en APV.
THRSTOPCLCN_vidOpenThrusts|C|();|FCT1.4|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Si ces valeurs maximales sont hors-gamme, une panne « Tpac_thrusts » est mémorisée immédiatement, dans le cas d’un papillon à limp home négatif (Tpac_throttle_lh_pos = 0). La mesure est dite hors gamme et la butée  haute conserve sa précédente valeur.
THRSTOPCLCN_vidPositionFiltering|C|();|FCT1.3|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Les positions fournies par les deux capteurs sont filtrées par un filtre médian. Les maxima et minima sont enregistrés en permanence pour la recherche et l'apprentissage des butées. Elles sont réinitialisées à chaque début d’apprentissage de butée.
THRSTOPCLCN_vidRefLearning|C|();|FCT1.7|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Lors du premier apprentissage en usine ou lors des demandes d’apprentissage en APV, on mémorise la première butée basse apprise en E2PROM. Tpac_x_closed_throttle_ref n’est ensuite pas remise à jour lors des apprentissages sous power-down.
THRSTOPCLCN_vidReinitSrvDiag|B|();|FCT2.8|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|L’événement Thr_EveRstThr_stopClcn correspond à un service après-vente permettant le recentrage des adaptatifs.
THRSTOPCLCN_vidReinitThrust|C|();|FCT1.10|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Les booléens « Tpac_1_thrust_inh_temp » et « Tpac_2_thrust_inh_temp » doivent être initialisés à 0 au début de la recherche de butée et de la position de repos. Pas de recherche que la butée haute est bien la première étape de la procédure d’apprentissage
THRSTOPCLCN_vidStuckThr|B|();|FCT2.6|THRSTOPCLCN|0|V02 NT 08 04799||||0|0|0|0|Si les mesures sur les deux pistes sont hors-gamme alors le papillon est considéré bloqué mécaniquement. Le booléen « Tpac_throttle_locked » est placé à 1, ce qui déclenche le mode dégradé limp-home
THRTHERMOPROT_vidDiag|B|();|FCT1.6|THRTHERMOPROT|0|V02 NT 10 00381||||0|0|0|0|La calibration permet de choisir d’effectuer le diagnostic sur la valeur de la tension de commande ou sur la valeur estimée de la température du moteur.
THRTHERMOPROT_vidDiagCdn|B|();|FCT1.4|THRTHERMOPROT|0|V02 NT 10 00381||||0|0|0|0|C'est la  fonction de diagnostic sur la commande filtrée du BPM qui  doit permettre de  protéger de l’échauffement thermique le moteur électrique dans toutes les  situations de vie.
THRTHERMOPROT_vidEngTEstim|A|();|FCT1.5|THRTHERMOPROT|0|V02 NT 10 00381||||0|0|0|0|Cette fonction permet de calculer L’estimation de la température du moteur réalisée en utilisant le principe suivant lequel le gradient de température vaut la différence entre la chaleur apportée et la chaleur évacuée.
THRTHERMOPROT_vidFilThrVolt|A|();|FCT1.3|THRTHERMOPROT|0|V02 NT 10 00381||||0|0|0|0|Filtrage de la tension de commande du papillon avec réinitialisation du filtre à la tension courante.
THRTHERMOPROT_vidInit|A|();|FCT1.2|THRTHERMOPROT|0|V02 NT 10 00381||||0|0|0|0|Initialisation de la sortie "Thr_tEngEstim".
THRTHERMOPROT_vidInitOutput|B|();|FCT1.1|THRTHERMOPROT|0|V02 NT 10 00381||||0|0|0|0|initialisation des sorties
TIENGSTOP_vidAlarmClockCalc|C|();|FCT1.4|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Cette fonction permet d'enregistrer la  " Date de dernier Réveil ".|
TIENGSTOP_vidChangeOfMind|D|();|FCT1.5|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|" durée d'arrêt moteur avec Reset" se comportera de la même manière que " durée  d'arrêt moteur ", sauf dans le cas particulier, sur détection d'un " Change of Mind ", "durée d'arrêt moteur avec Reset" sera remis à zéro.|
TIENGSTOP_vidDegradedPeriodEstim|F|();|FCT1.6|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Dès que les acquisitions de température d'air et d'eau sont réalisées et que toutes les  informations nécessaires au calcul sont disponibles, on appelle la fonction d'estimation du temps d'arrêt dégradée.|
TIENGSTOP_vidEmfActiveDate|C|();|FCT2.6|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Quand le régime moteur devient non nul le CMM met à zéro " date arrêt volatile " et fige " durée d'arrêt moteur ".|
TIENGSTOP_vidEmfDate|D|();|FCT2.1|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Si  l'information  temporelle provenant du véhicule est  invalide, La durée d'arrêt ne pourra pas être évaluée de manière nominale. Par conséquent, la valeur " durée d'arrêt moteur " aura en  interne de  la fonction une valeur invalide|
TIENGSTOP_vidEmfDateCalc|E|();|FCT2.2|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|A partir de l'arrêt moteur (N=0), le CMM évalue en temps réel la durée écoulée entre le  dernier arrêt moteur (suite à un calage, une demande conducteur, ou une demande STT) et le nouveau passage de dents vilebrequin.|
TIENGSTOP_vidEmfDateCoh|C|();|FCT2.8|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Le CMM validera l'information sur les 3 premières valeurs de cette information temporelle qui devront être successives et cohérentes. En cas d'incohérence sur ces 3 valeurs de l'information temporelle reçue, la valeur retenue sera invalide.|
TIENGSTOP_vidEmfDateSinceStall|E|();|FCT2.5|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|A partir de l'arrêt moteur (N=0), le CMM évalue en temps réel la durée écoulée entre le  dernier arrêt moteur (suite à un calage, une demande conducteur, ou une demande STT) et le nouveau passage de dents vilebrequin.|
TIENGSTOP_vidEmfInvalidCrankDate|C|();|FCT2.9|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Cette fonction permet le sauvegarde de la date de le dernier démarrage "Date valide".|
TIENGSTOP_vidEmfSaveLastAlarmClk|C|();|FCT1.3|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|On mémorisera, l'information temporelle envoyée par le véhicule contenue dans la  dernière trame reçue valide en mémoire non volatile, c'est la " Date de dernier Réveil ".|
TIENGSTOP_vidEmfSaveLastStopDate|D|();|FCT1.8|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|A la perte du réveil principal et si un démarrage a eu lieu depuis la dernière apparition du réveil principal, le CMM doit enregistrer en mémoire non volatile la valeur de " date arrêt volatile " ou " date actuelle ".|
TIENGSTOP_vidEmfValidCrankDate|C|();|FCT2.7|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Cette fonction permet le sauvegarde de la date de le dernier démarrage "Date valide"|
TIENGSTOP_vidFrameTairCAN|A|();|FCT1.9|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Cette fonction indique la réception de l'évènement CAN relatif à la mesure de la température d'air.|
TIENGSTOP_vidInitialisation|D|();|FCT1.2|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|A l’initialisation, on va lire en EEPROM les dates de dernier réveil, de dernier arrêt et date de démarrage.On met aussi à 0 l’indicateur de calcul de la date du démarrage.|
TIENGSTOP_vidInitOutput|D|();|FCT1.1|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Initialisation des sorties|
TIENGSTOP_vidInitTimeSinceStall|F|();|FCT2.4|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Après le réveil du CMM et jusqu'au passage des premières dents vilebrequin, on déduit  la durée d'arrêt moteur, nommée " durée d'arrêt moteur ", calculée ainsi : " date actuelle " - " date arrêt NON volatile ".|
TIENGSTOP_vidRazTimeSinceStall|C|();|FCT1.7|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Quand le régime moteur devient nul le CMM enregistre la " date actuelle " en mémoire  volatile, cette date est appelée " date arrêt volatile ".|
TIENGSTOP_vidTimeBuffer|C|();|FCT2.3|TIENGSTOP|0|PTS_DOC_5329313||||0|0|0|0|Cette fonction permet d'enregistrer la date dans les buffeurs de sauvegarde.|
TIGBTACQ_vidAcquisition|A|();|FCT1.2|TIGBTACQ|0|PTS_DOC_5257921||||0|0|0|0|The voltage sent by the sensor is converted into the IGBT temperature with a linear interpolation based on the characteristic behavior of the sensor.|
TIGBTACQ_vidDiagnosis|A|();|FCT1.3|TIGBTACQ|0|PTS_DOC_5257921||||0|0|0|0|The IGBT temperature electrical diagnoses are carried out if there is no downgraded mode inhibition.|
TIGBTACQ_vidElectrical_Diagnosis|A|();|FCT1.4|TIGBTACQ|0|PTS_DOC_5257921||||0|0|0|0|The voltage sent by the IGBT temperature sensor is compared to high and low thresholds; if it is out of this range,  error flags are produced: short circuit to ground and short circuit to the power source, respectively.|
TIGBTACQ_vidInit|A|();|FCT1.1|TIGBTACQ|0|PTS_DOC_5257921||||0|0|0|0|At reset the IGBT temperature is set to a configurable initialization value.|
TOILEST_vidCalcThuilBruteMotTour|B|();|FCT1.5|TOILEST|0|PTS_DOC_5050596||||0|0|0|0|La température d’huile estimée moteur tournant est fonction de la température d’eau, selon l’activation ou non de la pompe à eau pilotée. Ensuite, cette température est corrigée en fonction de la charge du moteur et des conditions extérieures.|
TOILEST_vidCalcThuileInit|G|();|FCT2.2|TOILEST|0|PTS_DOC_5050596||||0|0|0|0|Cette fonction estime la température de l'huile à l’initialisation du calculateur.|
TOILEST_vidCalcThuileMoteurCoupe|G|();|FCT1.6|TOILEST|0|PTS_DOC_5050596||||0|0|0|0|Cette fonction estime la température d'huile moteur coupé.|
TOILEST_vidCalcThuileMotTournant|H|();|FCT1.4|TOILEST|0|PTS_DOC_5050596||||0|0|0|0|Cette fonction permet de calculer la température d’huile moteur tournant.|
TOILEST_vidCalculerThuile|E|();|FCT1.3|TOILEST|0|PTS_DOC_5050596||||0|0|0|0|Une fois le calculateur initialisé, le calcul est effectué dans 2 situations distinctes : 1. Moteur tournant, 2. Moteur coupé.|
TOILEST_vidCalculEtatEstimateur|B|();|FCT2.1|TOILEST|0|PTS_DOC_5050596||||0|0|0|0|Cette fonction permet de déterminer l’état de calcul de l’estimateur de température d’huile ainsi qu’un flag activant l’initialisation du modèle.|
TOILEST_vidInitialiser|B|();|FCT1.2|TOILEST|0|PTS_DOC_5050596||||0|0|0|0|Cette sous-fonction positionne la température d’huile à une valeur calibrable à l’initialisation du calculateur|
TOILEST_vidInitOutput|H|();|FCT1.1|TOILEST|0|PTS_DOC_5050596||||0|0|0|0|Initialisation des sorties du module.|
TOILEST_vidPowerLatch|D|();|FCT1.9|TOILEST|0|PTS_DOC_5050596||||0|0|0|0|Cette sous-fonction permet de recopier les dernières valeurs de la température d’huile estimée, de la température d’eau et de la température extérieure de l'air avant leur sauvegarde en EEPROM lors du power-latch.|
TOILEST_vidReconfigurerThuile|J|();|FCT1.8|TOILEST|0|PTS_DOC_5050596||||0|0|0|0|Cette fonction permet de saturer et/ou de reconfigurer la température d’huile estimée. Si elle atteint le maximum admissible, elle est saturée et un défaut est remonté au GD-GAR. Si on ne peut l'estimer correctement, elle bascule sur une valeur de repli.|
TOILEST_vidSelectionnerThuile|F|();|FCT1.7|TOILEST|0|PTS_DOC_5050596||||0|0|0|0|Cette sous-fonction permet de sélectionner la température d’huile correspondant à l’état du moteur.|
TQACRES_vidAC3|A|();|FCT1.3|TQACRES|0|V02 NT 10 04980||||0|0|0|0|Fonction traitant la climatisation de type 3.|
TQACRES_vidAC4|B|();|FCT1.6|TQACRES|0|V02 NT 10 04980||||0|0|0|0|Fonction traitant la climatisation de type 4|
TQACRES_vidActivation_Calcul|A|();|FCT2.7|TQACRES|0|V02 NT 10 04980||||0|0|0|0|Le choix du trigger pour l’appel de la fonction se fait en fonction du régime moteur|
TQACRES_vidCalcul_Reserve|A|();|FCT1.10|TQACRES|0|V02 NT 10 04980||||0|0|0|0|La réserve de couple climatisation est le maximum entre la valeur 0 et la soustraction de la réserve de couple demandée et le couple compensé.|
TQACRES_vidCondition_reserve_AC3|A|();|FCT1.4|TQACRES|0|V02 NT 10 04980||||0|0|0|0|La condition Clim 3 est active si Ext_bACCluDem = 1 et l’embrayage climatisation est non actif. Elle se désactive après une temporisation calibrable si l’embrayage climatisation est actif, ou si Ext_bACCluDem = 1.|
TQACRES_vidCondition_reserve_AC4|B|();|FCT2.1|TQACRES|0|V02 NT 10 04980||||0|0|0|0|Fonction qui traite la condition réserve Climatisation 4|
TQACRES_vidEntryInit|C|();|SCH.1|TQACRES|1|V02 NT 10 04980||||0|0|0|0|Fonction d'initialisation au Reset|
TQACRES_vidGestion_Type_Clim|A|();|FCT1.8|TQACRES|0|V02 NT 10 04980||||0|0|0|0|La fonction gestion type clim est prévue pour trois types de clim : clim 3, clim 4 et clim 5. En cas d’absence de clim la condition clim et réserve de couple clim sont forcés à la valeur nulle.|
TQACRES_vidInitOutput|D|();|FCT1.1|TQACRES|0|V02 NT 10 04980||||0|0|0|0|Initialisation des sorties au Reset|
TQACRES_vidPriorite_Fan|A|();|FCT1.9|TQACRES|0|V02 NT 10 04980||||0|0|0|0|Le groupe moto ventilateur est priorité par rapport à la climatisation dans certains cas.|
TQACRES_vidReserveCoupleClim|B|();|FCT1.2|TQACRES|0|V02 NT 10 04980||||0|0|0|0|La fonction traite trois types de climatisation : clim 3, clim 4 et clim 5.  La fonction est activée que si une climatisation est présente sur le véhicule.|
TQACRES_vidTransAttDebrayage|C|();|FCT2.5|TQACRES|0|V02 NT 10 04980||||0|0|0|0|Fonction de transition de l'etat  ATTENTE_DEBRAYAGE|
TQACRES_vidTransAttEmbrayage|C|();|FCT2.3|TQACRES|0|V02 NT 10 04980||||0|0|0|0|Fonction de transition de l'etat ATTENTE_EMBRAYAGE|
TQACRES_vidTransDefSeqEmbrayage|C|();|FCT2.4|TQACRES|0|V02 NT 10 04980||||0|0|0|0|Fonction de transition de l'etat DEFAUT_SEQUENCE_EMBRAYAGE|
TQACRES_vidTransHorsRes|C|();|FCT2.2|TQACRES|0|V02 NT 10 04980||||0|0|0|0|Fonction de transition de l'etat HORS_RESERVE|
TQACRES_vidTransMaintReserve|C|();|FCT2.6|TQACRES|0|V02 NT 10 04980||||0|0|0|0|Fonction de transition de l'etat MAINTIEN_RESERVE|
TQACRES_vidValeur_reserve_AC3|A|();|FCT1.5|TQACRES|0|V02 NT 10 04980||||0|0|0|0|La réserve de couple Clim 3, varie en fonction de la pression demandée par le compresseur de climatisation dans une table calibrable.|
TQACRES_vidValeur_reserve_AC4|A|();|FCT1.7|TQACRES|0|V02 NT 10 04980||||0|0|0|0|La réserve de couple Clim 4 varie en fonction d’une table de couple calibrables issue du calcul suivant : Couple = 30/pi*AC_pwrAC/Eng_nCkFil|
TQADVMIN_vidEntryInit|A|();|SCH.1|TQADVMIN|1|V02 NT 11 05439||||0|0|0|0|Fonction moniteur Reset
TQADVMIN_vidInitOutput|B|();|FCT1.1|TQADVMIN|0|V02 NT 11 05439||||0|0|0|0|Fonction d'initialisation des variables.
TQADVMIN_vidRqestClosedLopTqmin1|A|();|FCT1.2|TQADVMIN|0|V02 NT 11 05439||||0|0|0|0|determines the condition to require the closed loop for low torque
TQADVMIN_vidRqestClosedLopTqmin2|A|();|FCT1.3|TQADVMIN|0|V02 NT 11 05439||||0|0|0|0|determines the value of the torque increment and the maximum time allowed to reach the driver torque (transition)
TQALTRES_vidCalculReserveALT|C|();|FCT1.4|TQALTRES|0|V02 NT 11 02660||||0|0|0|0|Le calcul de la réserve de couple alternateur dépend du type d’alternateur (alternateur ICCP,alternateur piloté,  alternateur Urban Hybrid)|
TQALTRES_vidCalculReserveAltGap|C|();|FCT1.6|TQALTRES|0|V02 NT 11 02660||||0|0|0|0|Cette fonction effectue le calcul de la réserve de couple pour un alternateur de type Gap.|
TQALTRES_vidCalculReserveAltICCP|C|();|FCT1.5|TQALTRES|0|V02 NT 11 02660||||0|0|0|0|Cette fonction effectue le calcul de la réserve de couple pour un alternateur standard.|
TQALTRES_vidConditionReserveALT|C|();|FCT1.3|TQALTRES|0|V02 NT 11 02660||||0|0|0|0|La condition de l’alternateur dépend du régime moteur et de la condition au ralenti, elle s’active si le régime est supérieur à un seuil minimum calibrable et inférieur à un seuil maximum calibrable et la condition au ralenti est active.|
TQALTRES_vidEntryInit|D|();|SCH.1|TQALTRES|1|V02 NT 11 02660||||0|0|0|0|Scheduler Reset|
TQALTRES_vidInitOutput|F|();|FCT1.1|TQALTRES|0|V02 NT 11 02660||||0|0|0|0|Fonction d'initialisation de la variable de sortie.|
TQALTRES_vidReserveCoupleALT|C|();|FCT1.2|TQALTRES|0|V02 NT 11 02660||||0|0|0|0|fonction réserve de couple alternateur|
TQANTISTALLBVM_vidActivAntical|B|();|FCT1.3|TQANTISTALLBVM|0|V02 NT 10 04974||||0|0|0|0|Fonction permettant le calcul des conditions d'autorisation de la fonction anti-calage|
TQANTISTALLBVM_vidAnticalBVM|B|();|FCT1.2|TQANTISTALLBVM|0|V02 NT 10 04974||||0|0|0|0|La fonction d’anti-calage ralenti envoie un ordre d’activation à la gestion de richesse qui permet de prendre en compte une consigne de richesse spécifique à l’anti-calage.|
TQANTISTALLBVM_vidAutActAntiCal|C|();|FCT1.7|TQANTISTALLBVM|0|V02 NT 10 04974||||0|0|0|0|on retraite IdlSys_bAcvAntiStall dans cette fonction afin d’empêcher une autre activation de l’anti-calage.|
TQANTISTALLBVM_vidConditionActiv|B|();|FCT1.8|TQANTISTALLBVM|0|V02 NT 10 04974||||0|0|0|0|on fait la synthèse de toutes les informations dans cette fonction afin de déterminer la demande d’activation de la stratégie anti-calage.|
TQANTISTALLBVM_vidEntryInit|B|();|SCH.1|TQANTISTALLBVM|1|V02 NT 10 04974||||0|0|0|0|Fonction d'accroche au moniteur reset|
TQANTISTALLBVM_vidGestionAntical|B|();|FCT1.4|TQANTISTALLBVM|0|V02 NT 10 04974||||0|0|0|0|Fonction permettant le calcul des conditions d'activation de la fonction anti-calage|
TQANTISTALLBVM_vidInhibAntical|A|();|FCT1.9|TQANTISTALLBVM|0|V02 NT 10 04974||||0|0|0|0|Lorsque IdlSys_bEnaAntiStall = 0, IdlSys_bAcvAntiStall est maintenue à la valeur 0.|
TQANTISTALLBVM_vidInitOutput|C|();|FCT1.1|TQANTISTALLBVM|0|V02 NT 10 04974||||0|0|0|0|Fonction qui initialise les sorties|
TQANTISTALLBVM_vidSeuilsActiv|C|();|FCT1.5|TQANTISTALLBVM|0|V02 NT 10 04974||||0|0|0|0|Fonction qui calcule l’offset de régime permettant de déterminer le seuil de régime d’activation de l’anti-calage et le nombre de PMH à prendre en compte entre l’initialisation du test et l’instant où l’on doit activer ou non la stratégie anti-calage.|
TQANTISTALLBVM_vidSigActivFrein|B|();|FCT1.6|TQANTISTALLBVM|0|V02 NT 10 04974||||0|0|0|0|Fonction qui retraite le signal d’appui frein afin de tenir compte d’une volonté de freiner du conducteur lorsque l’on détermine les conditions de calage.|
TQCATHEATRES_vidCalibration1|A|();|FCT1.7|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Cette réserve de couple est calculée si et seulement si le booléen TqRes_bAcvEOMResMod1 le demande.|
TQCATHEATRES_vidCalibration2|A|();|FCT1.8|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Cette réserve de couple est calculée si et seulement si le booléen TqRes_bAcvEOMResMod2 le demande.|
TQCATHEATRES_vidCalibration3|A|();|FCT1.9|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Cette réserve de couple est calculée si et seulement si le booléen TqRes_bAcvEOMResMod3 le demande.|
TQCATHEATRES_vidCalibration4|A|();|FCT1.10|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Cette réserve de couple est calculée si et seulement si le booléen TqRes_bAcvEOMResMod4 le demande.|
TQCATHEATRES_vidCalibration5|A|();|FCT2.1|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Cette réserve de couple est calculée si et seulement si le booléen TqRes_bAcvEOMResMod5 le demande.|
TQCATHEATRES_vidCalibration6|A|();|FCT2.2|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Cette réserve de couple est calculée si et seulement si le booléen TqRes_bAcvEOMResMod6 le demande.|
TQCATHEATRES_vidCalibration7|A|();|FCT2.3|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Cette réserve de couple est calculée si et seulement si le booléen TqRes_bAcvEOMResMod7 le demande.|
TQCATHEATRES_vidCalibration8|A|();|FCT2.4|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Cette réserve de couple est calculée si et seulement si le booléen TqRes_bAcvEOMResMod8 le demande.|
TQCATHEATRES_vidCalibrations|A|();|FCT1.5|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|D’après le vecteur TqRes_prm_bAcvEOMResMod les calibrations strictement nécessaires sont calculées.|
TQCATHEATRES_vidDeterminSetpoint|A|();|FCT1.3|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|La réserve de couple chauffe catalyseur est calculée en 4 étapes en prenant en compte les entrées EOM:Mode_Mask,Calibrations,Select_Modes,Interpolation.|
TQCATHEATRES_vidEntryInit|A|();|SCH.1|TQCATHEATRES|1|V02 NT 10 08577||||0|0|0|0|Output initialization|
TQCATHEATRES_vidInitOutput|A|();|FCT1.1|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Fonction d'initialisation|
TQCATHEATRES_vidInterpolation|B|();|FCT2.7|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Deux interpolations successives permettent de calculer la réserve de couple finale à appliquer pour la chauffe catalyseur.|
TQCATHEATRES_vidModeMask|A|();|FCT1.4|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Les numéros de calibrations à calculer définissent les indices du vecteur TqRes_prm_bAcvEOMResMod qui doivent valoir « true ».|
TQCATHEATRES_vidSelectModes|A|();|FCT2.6|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Les calibrations actives sont utilisées d’après les flux en provenance du manager de mode de fonctionnement EOM pour chacun des quatre modes.|
TQCATHEATRES_vidUnvectActiveBool|A|();|FCT1.6|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Le vecteur TqRes_prm_bAcvEOMResMod définissant les calibrations à calculer définit les flux d’activation de calcul.|
TQCATHEATRES_vidUnvectorizeMode|B|();|FCT1.2|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|La composante 7 relative à la réserve de couple chauffe catalyseur est sélectionnée pour chaque vecteur d’entrée EOM.|
TQCATHEATRES_vidVectCalibrations|A|();|FCT2.5|TQCATHEATRES|0|V02 NT 10 08577||||0|0|0|0|Cette fonction crée un vecteur de réserves de couple applicables.|
TQCKEFCFIL_vidCalcCntDecIPOutRng|C|();|FCT3.5|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Comparaison du compteur avec le délai maximum permissible d’activation du filtrage en décélération. Remonte un défaut.|
TQCKEFCFIL_vidCalcDecAcvOutOfRng|B|();|FCT3.7|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Reconstruction de l’activation de la décélération au niv 2 et comparaison au niv1. Si l’activation est confirmée au niv2 mais non active au niv 1 au niv1 on remonte au défaut.|
TQCKEFCFIL_vidCalcDiffCplePPhase|B|();|FCT2.1|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Calcule Des différentiels de couple pour toutes les phases.|
TQCKEFCFIL_vidCalcDrivFilOutRnge|B|();|FCT3.3|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Compare le couple niveau 1 en sortie agrément préventif au couple permissible maximum. Sort un défaut.|
TQCKEFCFIL_vidCalcDureeDesPhases|C|();|FCT2.2|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Calcule des délais pour toutes les phases.|
TQCKEFCFIL_vidCalcEtCoordPentes|B|();|FCT2.3|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Calcule des pentes pour toutes les phases.|
TQCKEFCFIL_vidCalcPfDecelInit|C|();|FCT1.6|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Prend les valeurs correspondant à l’index lors du front d’activation du filtrage de la décélération.|
TQCKEFCFIL_vidCalcPfDecelParam|C|();|FCT1.7|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Calcule les paramètres de seuils, de temps et la pente correspondant à la maximisation du filtrage.|
TQCKEFCFIL_vidCalcPfTqFiltre|C|();|FCT2.10|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Calcule le filtre en couple maximal permissible au niveau 2 en décélération et accélération. Applique les conditions initiales de couples lors de l’activation du filtrage de la décélération.|
TQCKEFCFIL_vidCalcPfTqNonfiltere|D|();|FCT1.3|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Sort le minimum entre la pédale non filtrée et la sortie filtrée pour prendre en compte une dynamique de la pédale lors d’un filtrage (accélération non aboutie suivie d’une décélération)|
TQCKEFCFIL_vidCalcPrevfDecelInit|B|();|FCT1.4|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Calcule le régime moteur et le couple lors de l’activation exacte du filtrage en décélération au niv1|
TQCKEFCFIL_vidCalcSeuilCpleDecIp|B|();|FCT1.9|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Calcule les différents seuils des pentes de manière simplifiée|
TQCKEFCFIL_vidCalculEstimation|B|();|FCT1.2|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Fonction qui enveloppe max simplifiée de la partie applicative|
TQCKEFCFIL_vidCalculPenteDeceIp|B|();|FCT1.10|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Décomposition du calcul des pentes, des tempos et de la coordination.|
TQCKEFCFIL_vidCalculTempoDeceIp|C|();|FCT1.8|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Calcule les différents temps des pentes de manière simplifiée|
TQCKEFCFIL_vidcalIdxFacPreLookup|A|();|FCT4.2|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Calcule les index et les facteurs d’interpolation linéaire des carto utilisées (pré lookup)|
TQCKEFCFIL_vidChoiPteDecIPCalCpt|B|();|FCT2.4|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Synthèse de la pente maximale permissible et calcul du compteur de temps passé en phase de décélération.|
TQCKEFCFIL_vidComptDrivFilDeceIP|C|();|FCT2.5|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Défaut sur le dépassement temporel de l’activation du filtrage de la décélération.|
TQCKEFCFIL_vidCptInctDrvFilDecIP|B|();|FCT2.7|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|remise à zéro du compteur de durée d'activation de filtrage de décélération|
TQCKEFCFIL_vidDbncDfDrvFilDcIPCn|C|();|FCT3.6|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Débounce le défaut sur le temps maximal permissible en phase d’activation de filtrage de dédélération.|
TQCKEFCFIL_vidDbnceDeftTqDrivFil|C|();|FCT3.4|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Débounce le défaut sur le couple.|
TQCKEFCFIL_vidDebounceDeftDecAcv|C|();|FCT3.8|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Débounce le défaut sur la détection de la phase d’activation de filtrage de décélération.|
TQCKEFCFIL_vidEntryInit|B|();|SCH.1|TQCKEFCFIL|1|V02 NT 10 01236||||0|0|0|0|Evenement Reset du calculateur|
TQCKEFCFIL_vidIFTHENComptDeceAcv|B|();|FCT2.6|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Démarre et raz le compteur|
TQCKEFCFIL_vidIncCptDrivFilDecIP|C|();|FCT2.8|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|calcul de la durée de la phase d'activation de filtrage en décél en cours|
TQCKEFCFIL_vidInitOutput|C|();|FCT1.1|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|fonction qui initialise les sorties|
TQCKEFCFIL_vidPriseCmptRapportBV|A|();|FCT4.1|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Choix de la valeur du rapport de boite utilisée dans le filtrage|
TQCKEFCFIL_vidSyntheseDefTqCkEfc|B|();|FCT3.9|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Fonction qui coordonne les défauts|
TQCKEFCFIL_vidSyntPtDrivFilDecIP|C|();|FCT2.9|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Choisit la pente en fonction du temps passé en décélération. Peut aussi prendre la pente maximale par calibration indépendamment du temps passé.|
TQCKEFCFIL_vidTreatSdlNiv1VNiv2|B|();|FCT1.5|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Gère la dynamique d’activation du niveau 1 qui a lieu lors de deux appels de la fonction de surveillance au niveau 2|
TQCKEFCFIL_vidValidation|B|();|FCT3.1|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Valide le couple et le temps d’activation du filtrage en décélération du niveau 1 par rapports aux seuils de couple et de temps permissible maximum calculés. Sors le défaut et le flux de couple en sortie agrément préventif du niveau 1 sécurisé.|
TQCKEFCFIL_vidValidtqCkEfcFil|B|();|FCT3.2|TQCKEFCFIL|0|V02 NT 10 01236||||0|0|0|0|Fonction de gestion de generation des défauts relatifs à la phase de décélération|
TQCMPMANGBX_vidEntryInit|B|();|SCH.1|TQCMPMANGBX|1|PTS_DOC_5199347||||0|0|0|0|Evenement d'initialisation des sorties|
TQCMPMANGBX_vidInitOutput|B|();|FCT1.1|TQCMPMANGBX|0|PTS_DOC_5199347||||0|0|0|0|Fonction d'initialisation des outputs|
TQCMPMANGBX_vidManualGearBoxLoss|B|();|FCT1.2|TQCMPMANGBX|0|PTS_DOC_5199347||||0|0|0|0|Function that estimates gearbox losses torque based on a simulated gearbox  temperature.|
TQCNVRES_vidCalcul_Reserve|B|();|FCT1.5|TQCNVRES|0|V02 NT 10 08543||||0|0|0|0|La réserve de couple BVA est le maximum entre la valeur 0 et la soustraction de la réserve de couple demandée et le couple compensé. La réserve de couple demandée s’active lorsque la condition engagement ou la condition réduction de trainée s’active.|
TQCNVRES_vidCondition_Engagement|B|();|FCT1.3|TQCNVRES|0|V02 NT 10 08543||||0|0|0|0|La condition engagement s’active après un front montant au passage du neutre à un rapport cible BVA <> 0, à condition que l’état réduction de trainée soit différent de la valeur 3.|
TQCNVRES_vidCondition_Sortie_Rdt|B|();|FCT1.4|TQCNVRES|0|V02 NT 10 08543||||0|0|0|0|Dans le cas ou la l’état de la BVA est en « réduction de la trainée » , la condition s’active sur la détection du passage de l’état de la BVA à « Embrayé » , ou sur détection d’une sortie d’appui frein.|
TQCNVRES_vidEntry_10ms|C|();|SCH.2|TQCNVRES|1|V02 NT 10 08543||||0|0|0|0|Fonction d'accroche de réserve de couple BVA|
TQCNVRES_vidEntryInit|C|();|SCH.1|TQCNVRES|1|V02 NT 10 08543||||0|0|0|0|Fonction d'accroche moniteur Reset|
TQCNVRES_vidInitOutput|C|();|FCT1.1|TQCNVRES|0|V02 NT 10 08543||||0|0|0|0|Initialisation de toutes les sorties du module ainsi que les états précédentes des bascules.|
TQCNVRES_vidReserve_Couple_BVA|B|();|FCT1.2|TQCNVRES|0|V02 NT 10 08543||||0|0|0|0|La compensation de la réserve de couple BVA dépend de deux conditions : condition d’engagement et condition réduction de trainée. La fonction n’est activée que sur les applications BVA.|
TQCOHEATRES_vidEntryInit|D|();|SCH.1|TQCOHEATRES|1|V02 NT 11 02653||||0|0|0|0|évènement Reset ECU|
TQCOHEATRES_vidInitOutput|C|();|FCT1.1|TQCOHEATRES|0|V02 NT 11 02653||||0|0|0|0|fonction d'initialisation des sorties|
TQCOHEATRES_vidReserveThrmHabit|C|();|FCT1.2|TQCOHEATRES|0|V02 NT 11 02653||||0|0|0|0|La réserve de couple chauffage habitacle est issue du produit de la dégradation chauffage habitacle et de deux cartographie (régime, remplissage et température de l’eau, température de l’air).|
TQCOMON_vidConversion_CME_CMI|A|();|FCT1.6|TQCOMON|0|V02 NT 10 01231||||0|0|0|0|Cette fonction permet de convertir les labels relevés de CME en CMI par ajout des pertes totales aux couples CME.
TQCOMON_vidCoordonner_Agrement|A|();|FCT1.3|TQCOMON|0|V02 NT 10 01231||||0|0|0|0|Cette fonction intègre le filtrage de l’agrément préventif. Par calibration on peut choisir l’application ou non de ce filtrage.
TQCOMON_vidCoordonner_Couple_BV|A|();|FCT1.5|TQCOMON|0|V02 NT 10 01231||||0|0|0|0|Cette fonction injecte la consigne de couple des boites de vitesse pilotées dans la chaîne en couple. Une calibration permet la prise en compte ou non de la consigne boite.
TQCOMON_vidCoordonner_Couple_ESP|B|();|FCT1.4|TQCOMON|0|V02 NT 10 01231||||0|0|0|0|Cette fonction est composée de deux sous fonctions: La première permet de déterminer le déclenchement d’une demande MSR. La seconde intègre les consignes de couples ESP dans la chaîne en couple.
TQCOMON_vidCoordonner_XVV|A|();|FCT1.2|TQCOMON|0|V02 NT 10 01231||||0|0|0|0|Cette fonction intègre la consigne de couple RVV dans la chaîne en couple en appliquant un max entre la couple conducteur issue du bloc amont et la consigne de couple RVV.
TQCOMON_vidCoordonnerLimRalenti|A|();|FCT1.8|TQCOMON|0|V02 NT 10 01231||||0|0|0|0|Cette fonction permet la prise en compte des couples de limitations safety ainsi que le couple de consigne issu de la régulation ralenti.
TQCOMON_vidCoordRelanceRegimeBV|A|();|FCT1.7|TQCOMON|0|V02 NT 10 01231||||0|0|0|0|Cette fonction assure la coordination avec le couple de régulation de régime pour la relance en régime des boites de vitesse. Par calibration, on choisi ou non de prendre en compte le couple de relance.
TQCOMON_vidEntryInit|A|();|SCH.1|TQCOMON|1|V02 NT 10 01231||||0|0|0|0|Accroche moniteur pour la fonction Reset de calculateur
TQCOMON_vidInitOutput|A|();|FCT1.1|TQCOMON|0|V02 NT 10 01231||||0|0|0|0|Fonction d'initialisation des sorties
TQCOMP_vidComparer_Couples|D|();|FCT1.2|TQCOMP|0|PTS_DOC_5050623||||0|0|0|0|Cette fonction a pour but de comparer le couple autorisé issu de la coordination en couple avec le couple réalisé, issu de l’estimateur.|
TQCOMP_vidEntryInit|C|();|SCH.1|TQCOMP|1|PTS_DOC_5050623||||0|0|0|0|Fonction d'accroche au moniteur Reset|
TQCOMP_vidInitOutput|C|();|FCT1.1|TQCOMP|0|PTS_DOC_5050623||||0|0|0|0|fonction d'initialisation|
TQCRWLRES_vidCalcResRampageDyn|C|();|FCT1.4|TQCRWLRES|0|V02 NT 10 04975||||0|0|0|0|Fonction de Calcul de la reserve de rampage dynamique|
TQCRWLRES_vidCalcResRampageStat|C|();|FCT1.5|TQCRWLRES|0|V02 NT 10 04975||||0|0|0|0|Fonction de Calcul de la reserve de rampage statique|
TQCRWLRES_vidEntryInit|B|();|SCH.1|TQCRWLRES|1|V02 NT 10 04975||||0|0|0|0|Evenement Reset|
TQCRWLRES_vidFilterCplBVMP|B|();|FCT1.3|TQCRWLRES|0|V02 NT 10 04975||||0|0|0|0|Un traitement des couples issues de la BVMP est réalisée, ceci afin d’éviter d’introduire du bruit sur le couple de réserve rampage.|
TQCRWLRES_vidInitOutput|B|();|FCT1.1|TQCRWLRES|0|V02 NT 10 04975||||0|0|0|0|Fonction d'initialisation des sorties|
TQCRWLRES_vidReserveRampBVMP|C|();|FCT1.2|TQCRWLRES|0|V02 NT 10 04975||||0|0|0|0|Fonction de calcul de la reserve de couple rampage|
TQDRIVMON_vidCalcCoupleSorIVC1|E|();|FCT1.4|TQDRIVMON|0|V02 NT 10 01230||||0|0|0|0|Ce bloc a la même fonctionnalité que l’IVC1 dans la partie applicative. Elle permet de prendre en compte les adaptations en pied levé ainsi que le couple d’anti-course morte.|
TQDRIVMON_vidEntryInit|D|();|SCH.1|TQDRIVMON|1|V02 NT 10 01230||||0|0|0|0|Fonction d'accroche au moniteur Reset|
TQDRIVMON_vidEnveloppeCoupleMaxi|D|();|FCT1.2|TQDRIVMON|0|V02 NT 10 01230||||0|0|0|0|Le couple maxi sortant de cette fonction est l’enveloppe de couple maximum absolue  admissible d’après la synthèse des cartographies pédales de la partie applicative.|
TQDRIVMON_vidGenererrDrivTakeOff|H|();|FCT1.3|TQDRIVMON|0|V02 NT 10 01230||||0|0|0|0|Génération du signal SftyMgt_rDrivTakeOff et bDrivTakeOff (équivalent à TqDem_rDrivTakeOff et bDrivTakeOff au niveau applicatif)|
TQDRIVMON_vidInitOutput|E|();|FCT1.1|TQDRIVMON|0|V02 NT 10 01230||||0|0|0|0|Initialisation des parametres|
TQDRIVMON_vidValAideDecollage|E|();|FCT1.7|TQDRIVMON|0|V02 NT 10 01230||||0|0|0|0|Cette fonction valide qu’en pied levé, le couple de décollage calculé est inférieur ou égal à moins les pertes globales du moteur majoré d’un offset|
TQDRIVMON_vidValAntiCourseMorte|E|();|FCT1.6|TQDRIVMON|0|V02 NT 10 01230||||0|0|0|0|Cette fonction sécurise le calcul de l’offset d’anti course morte. On vérifie la nullité de l’offset lors d’un levé de pied.  Dans les autres cas de vie, une éventuelle erreur de calcul de l’offset est contrôlable au pied.|
TQDRIVMON_vidValCoupleNivAppli|H|();|FCT1.5|TQDRIVMON|0|V02 NT 10 01230||||0|0|0|0|Cette sous-fonction compare les couples de l’IVC de l’ACS à leurs enveloppes équivalentes calculées dans F01. Un défaut est levé si un au moins des couples de la partie applicative dépasse le critère d’accélération intempestive.|
TQEIPMPRES_vidEntry_10ms|C|();|SCH.2|TQEIPMPRES|1|V02 NT 10 05003||||0|0|0|0|Evènement qui se déclenche chaque 10 ms|
TQEIPMPRES_vidEntryInit|C|();|SCH.1|TQEIPMPRES|1|V02 NT 10 05003||||0|0|0|0|Evénement Reset|
TQEIPMPRES_vidInitOutput|C|();|FCT1.1|TQEIPMPRES|0|V02 NT 10 05003||||0|0|0|0|Initialisation des variables de sortie|
TQEIPMPRES_vidPmpGrpDelay|C|();|FCT1.3|TQEIPMPRES|0|V02 NT 10 05003||||0|0|0|0|Activation de la condition après un certain délai|
TQEIPMPRES_vidReserve_couple_GEP|A|();|FCT1.2|TQEIPMPRES|0|V02 NT 10 05003||||0|0|0|0|La réserve du couple GEP varie entre la valeur 0 et une valeur maximum calibrable. Elle se dégrade progressivement si la condition réserve du couple GEP est non active.|
TQENGRES_vidActResAnticipRalenti|A|();|FCT1.8|TQENGRES|0|PTS_DOC_5135152||||0|0|0|0|Cette fonction permet de choisir le critère d’activation de la réserve d’anticipation des entrées ralenti.|
TQENGRES_vidCalCplResAntiRalenti|A|();|FCT1.9|TQENGRES|0|PTS_DOC_5135152||||0|0|0|0|Fonction de calcule le couple de réserve pour anticiper les entrées au ralenti.|
TQENGRES_vidCond_reserve_dyn|E|();|FCT1.5|TQENGRES|0|PTS_DOC_5135152||||0|0|0|0|Production de la condition de réserve de couple dynamique.|
TQENGRES_vidDegradation_de_base|E|();|FCT1.3|TQENGRES|0|PTS_DOC_5135152||||0|0|0|0|La dégradation de base est issue soit d’une cartographie calibrable en fonction du régime moteur et du remplissage, soit du rendement d’avance maximum.   La dégradation est saturée par un seuil maximum.|
TQENGRES_vidEntryInit|F|();|SCH.1|TQENGRES|1|PTS_DOC_5135152||||0|0|0|0|Evénement Reset du calculateur.|
TQENGRES_vidFilResAnticipRalenti|A|();|FCT1.10|TQENGRES|0|PTS_DOC_5135152||||0|0|0|0|Ce bloc filtre le couple de réserve d’anticipation des entrées ralenti pour ne pas bruiter la consigne AIR.|
TQENGRES_vidInitOutput|F|();|FCT1.1|TQENGRES|0|PTS_DOC_5135152||||0|0|0|0|initialisation des variables de sorie.|
TQENGRES_vidResAnticipRalenti|A|();|FCT1.7|TQENGRES|0|PTS_DOC_5135152||||0|0|0|0|Fonction pour calculer la réserve de couple d’anticipation des entrées au ralenti. Ce calcule se fait en 3 temps : Activation de la réserve, Calcul du couple de réserve brut et Filtrage du couple de réserve brut|
TQENGRES_vidReserve_au_ralenti|G|();|FCT1.4|TQENGRES|0|PTS_DOC_5135152||||0|0|0|0|La  réserve de  couple au  ralenti est  la  somme de  la  réserve de  couple  statique et de  la  réserve de couple dynamique.|
TQENGRES_vidReserve_moteur|F|();|FCT1.2|TQENGRES|0|PTS_DOC_5135152||||0|0|0|0|La fonction réserve de couple moteur contient deux types de réserves :Une réserve de base et Une  réserve  de  couple  calibrée  en  fonction  de  la  température  de  l’eau,  de  la  température  d’air ambiant et du rapport de boîte|
TQENGRES_vidTqResTqIdlResStat|D|();|FCT1.6|TQENGRES|0|PTS_DOC_5135152||||0|0|0|0|fonction de calcul de l'offset de réserve couple ralenti statique fonction de la température d'air  et fonction de la température d'eau.|
TQESTMAX_TqSys_EveSync|E|();|SCH.2|TQESTMAX|1|PTS_DOC_5795522||||0|0|0|0|Event TqSys_EveSync|
TQESTMAX_vidActivation_Filtrage|E|();|FCT1.8|TQESTMAX|0|PTS_DOC_5795522||||0|0|0|0|Le filtrage hors changement de rapport sera activé sous trois conditions.|
TQESTMAX_vidAcvFiltrageProc|C|();|FCT1.5|TQESTMAX|0|PTS_DOC_5795522||||0|0|0|0|Le calcul de l’activation du filtrage du couple potentiel est divisé en trois sous-fonctions.|
TQESTMAX_vidAcvFiltrageSIP_ESP|D|();|FCT1.6|TQESTMAX|0|PTS_DOC_5795522||||0|0|0|0|Le filtrage en changement de rapport et en intervention ASR sera activé si la consigne de couple air après intervention boite est inférieure à la consigne de couple air avant intervention BV/ESP pendant un SIP ou une régulation ASR.|
TQESTMAX_vidCalcul_cpl_pot_brut|E|();|FCT1.3|TQESTMAX|0|PTS_DOC_5795522||||0|0|0|0|Le couple potentiel hors intervention boites et ASR est basé sur la consigne de couple après intervention EasyMove, coordonné avec les interventions MSR et auquel on ajoute les réserves.|
TQESTMAX_vidCalcul_gain_filtrage|D|();|FCT1.7|TQESTMAX|0|PTS_DOC_5795522||||0|0|0|0|A l’activation de la demande de filtrage, le facteur converge vers 1 via une rampe calibrable. Lorsque les interventions BV et ESP sont terminées, le facteur converge vers 0 via une rampe calibrable.|
TQESTMAX_vidCalculCplPotDephase|F|();|FCT1.4|TQESTMAX|0|PTS_DOC_5795522||||0|0|0|0|Le couple potentiel brut est déphasé via un retard variable fonction du régime moteur.|
TQESTMAX_vidCalculCplPotEstime|E|();|FCT1.10|TQESTMAX|0|PTS_DOC_5795522||||0|0|0|0|Le couple max pris en compte dans la stratégie d’agrément préventif transite entre le couple max moteur courant et l’estimation de couple max avec le facteur de transition calculé dans les fonctions précédentes.|
TQESTMAX_vidCalculCplPotFiltre|F|();|FCT1.9|TQESTMAX|0|PTS_DOC_5795522||||0|0|0|0|Le couple potentiel déphasé est filtré en fonction du régime moteur.|
TQESTMAX_vidEntryInit|E|();|SCH.1|TQESTMAX|1|PTS_DOC_5795522||||0|0|0|0|Evenement reset ECU|
TQESTMAX_vidInitOutput|E|();|FCT1.1|TQESTMAX|0|PTS_DOC_5795522||||0|0|0|0|Initialisation des sorties|
TQESTMAX_vidModele_cpl_pot|E|();|FCT1.2|TQESTMAX|0|PTS_DOC_5795522||||0|0|0|0|Cette fonction réalise une estimation du couple potentiel moteur en excluant les réductions de couple demandées par les BVA/BVMP et par l’ESP.|
TQFANRES_vidCalculReserveGMV|F|();|FCT1.9|TQFANRES|0|V02 NT 10 05001||||0|0|0|0|La réserve de couple demandée varie entre la valeur 0 et le produit du facteur  d’atténuation GMV  et  d’une  valeur  calibrable suivant  le  type  de GMV. Elle se  dégrade  progressivement  si  la  condition  réserve GMV  est  non  active.|
TQFANRES_vidConditionReserveGMV|D|();|FCT1.5|TQFANRES|0|V02 NT 10 05001||||0|0|0|0|La condition réserve de couple GMV est active si au moins une des trois conditions est valide.|
TQFANRES_vidCoupleTransitoireGMV|E|();|FCT1.4|TQFANRES|0|V02 NT 10 05001||||0|0|0|0|Le couple GMV compensé est le produit d’une valeur de couple calibrable sélectionnée suivant le type de GMV et le facteur d’atténuation qui varie en fonction du régime moteur et la vitesse véhicule dans une cartographie calibrable.|
TQFANRES_vidEntry_10ms|B|();|SCH.2|TQFANRES|1|V02 NT 10 05001||||0|0|0|0|Evènement 10 ms.|
TQFANRES_vidEntryInit|B|();|SCH.1|TQFANRES|1|V02 NT 10 05001||||0|0|0|0|Evènement de Reset.|
TQFANRES_vidHiSpdDelayOn|B|();|FCT1.7|TQFANRES|0|V02 NT 10 05001||||0|0|0|0|Produit le booléen d'activation de la grande vitesse (GV) du GMV.|
TQFANRES_vidInitOutput|D|();|FCT1.1|TQFANRES|0|V02 NT 10 05001||||0|0|0|0|Fonction d'initialisation des sorties.|
TQFANRES_vidLoSpdDelayOn|B|();|FCT1.6|TQFANRES|0|V02 NT 10 05001||||0|0|0|0|Produit le booléen d'activation de la petite vitesse (PV) du GMV.|
TQFANRES_vidReserveGMV|B|();|FCT1.2|TQFANRES|0|V02 NT 10 05001||||0|0|0|0|La fonction traite trois types de GMV : GMV classe B1 à vitesse continue, GMV classe B2 à deux vitesses variables et le GMV classe C à vitesse variable.|
TQFANRES_vidStFanDelayOff|C|();|FCT1.8|TQFANRES|0|V02 NT 10 05001||||0|0|0|0|Produit le booléen d'activation du GMV de type C.|
TQFANRES_vidTraitementEntreesGMV|E|();|FCT1.3|TQFANRES|0|V02 NT 10 05001||||0|0|0|0|La fonction retraite les commandes des GMV quelque soit leur type. Lorsque Ext_stCfFan = 1, le GMV tourne à grande vitesse. Lorsque Ext_stCfFan = 2, le GMV peut tourner à deux vitesses différentes. Lorsque Ext_stCfFan = 0, le GMV est en vitesse continue|
TQIDCENGREAL_vidCalcRendmntAvanc|B|();|FCT1.7|TQIDCENGREAL|0|V02 NT 10 01238||||0|0|0|0|Cette fonction réalise la différence entre l’avance optimale et l’avance appliquée puis en déduit le rendement d’avance à appliquer sur le couple optimum, pour prendre en compte cet écart par rapport à l’avance optimale.|
TQIDCENGREAL_vidEntryInit|A|();|SCH.1|TQIDCENGREAL|1|V02 NT 10 01238||||0|0|0|0|Evenement Reset du calculateur|
TQIDCENGREAL_vidEstimAvcOptimal|B|();|FCT1.6|TQIDCENGREAL|0|V02 NT 10 01238||||0|0|0|0|Cette fonction estime l’avance optimale appliquée pour le point de régime et de pression admission courant.|
TQIDCENGREAL_vidEstimcpleminimum|B|();|FCT1.9|TQIDCENGREAL|0|V02 NT 10 01238||||0|0|0|0|Cette fonction estime le couple minimal réalisable du régime moteur et de la pression d’admission.|
TQIDCENGREAL_vidEstimCpleOptimum|A|();|FCT1.4|TQIDCENGREAL|0|V02 NT 10 01238||||0|0|0|0|Cette fonction permet d’évaluer le couple optimum en fonction du régime et du  remplissage en air estimé.|
TQIDCENGREAL_vidEstimCplIndiqRel|A|();|FCT1.2|TQIDCENGREAL|0|V02 NT 10 01238||||0|0|0|0|Cette fonction estime le couple réel|
TQIDCENGREAL_vidEstimCplRelRdmnt|C|();|FCT1.8|TQIDCENGREAL|0|V02 NT 10 01238||||0|0|0|0|Cette fonction applique le rendement d’avance au couple optimum calculé|
TQIDCENGREAL_vidEstimRendmAvance|A|();|FCT1.5|TQIDCENGREAL|0|V02 NT 10 01238||||0|0|0|0|Cette fonction calcul l’avance optimale en fonction du régime et de la pression admission. Puis à partir de l’avance appliquée par l’ACS, elle calcule le rendement d’avance à appliquer dans le calcul du couple indiqué estimé par la TMS.|
TQIDCENGREAL_vidEstimRmplissgAir|B|();|FCT1.3|TQIDCENGREAL|0|V02 NT 10 01238||||0|0|0|0|Cette fonction estime le remplissage en air frais à partir d’une cartographie Régime / Pression admission.|
TQIDCENGREAL_vidInitOutput|B|();|FCT1.1|TQIDCENGREAL|0|V02 NT 10 01238||||0|0|0|0|Initialisation des sorties|
TQIDLCHK_vidEntryInit|A|();|SCH.1|TQIDLCHK|1|V02 NT 10 01242||||0|0|0|0|evenement reset du calculateur
TQIDLCHK_vidInitOutput|A|();|FCT1.1|TQIDLCHK|0|V02 NT 10 01242||||0|0|0|0|Fonction d'initialisation des sorties au reset
TQIDLCHK_vidValidGlobaleRalenti|B|();|FCT1.4|TQIDLCHK|0|V02 NT 10 01242||||0|0|0|0|fait la synthèse des défauts de la fonction ralenti
TQIDLCHK_vidValidRegulRalenti|B|();|FCT1.3|TQIDLCHK|0|V02 NT 10 01242||||0|0|0|0|valide la régulation de régime
TQIDLCHK_vidValRalentiDecollage|B|();|FCT1.2|TQIDLCHK|0|V02 NT 10 01242||||0|0|0|0|valide l’offset de consigne de ralenti produit par la fonction d’aide au décollage
TQLIMSFTY_vidEcuReset|B|();|FCT1.1|TQLIMSFTY|0|V02 NT 08 07804||||0|0|0|0|Reset ECU
TQLIMSFTY_vidPreviousCalc|B|();|FCT1.4|TQLIMSFTY|0|V02 NT 08 07804||||0|0|0|0|Calcul de la valeur precedente
TQLIMSFTY_vidStaticLimit|B|();|FCT1.3|TQLIMSFTY|0|V02 NT 08 07804||||0|0|0|0|Une information de rapport de boite spécifique aux besoins de la sureté de fonctionnement devra être mise à disposition par les fonctions créatrices du rapport de boite.
TQLIMSFTY_vidTorqueLimitSafety|C|();|FCT1.2|TQLIMSFTY|0|V02 NT 08 07804||||0|0|0|0|Ce module permet à tout défaut du système d’engendrer une limitation de couple sécuritaire. L’activation de la limitation s’effectue d’une manière progressive et donc sécuritaire. Pour cela, le sytème devra fournir la valeur du couple courant.
TQLNCHRES_vidAccPedLnchCdn|A|();|FCT1.9|TQLNCHRES|0|V02 NT 10 04984||||0|0|0|0|Production de TqRes_bCdnAccLnchRes_MP.|
TQLNCHRES_vidCalcul_reserve|D|();|FCT1.6|TQLNCHRES|0|V02 NT 10 04984||||0|0|0|0|La  variable  réserve  de  couple  décollage  varie  entre  la  valeur  0  et  une  valeur  maximum  déduite  d’une cartographie calibrable dont les entrées sont le régime moteur et la température de l’eau.|
TQLNCHRES_vidCluPedLnchCdn|B|();|FCT1.7|TQLNCHRES|0|V02 NT 10 04984||||0|0|0|0|Production de TqRes_bCdnCluLnchRes_MP.|
TQLNCHRES_vidCondition_decollage|D|();|FCT1.4|TQLNCHRES|0|V02 NT 10 04984||||0|0|0|0|Cette fonction évalue les différentes conditions d'activation de la condition de décollage.|
TQLNCHRES_vidCondition_vitesse|D|();|FCT1.5|TQLNCHRES|0|V02 NT 10 04984||||0|0|0|0|La condition de la vitesse s’active si la vitesse est inférieure à un seuil minimum calibrable. Elle se désactive après une temporisation calibrable si la vitesse devient supérieure à un seuil maximum calibrable aussi.|
TQLNCHRES_vidEngRunLnchCdn|D|();|FCT1.10|TQLNCHRES|0|V02 NT 10 04984||||0|0|0|0|Production de TqRes_bCdnNEngLnchRes_MP.|
TQLNCHRES_vidEntry_10ms|C|();|SCH.2|TQLNCHRES|1|V02 NT 10 04984||||0|0|0|0|Fonction d'accroche au moniteur 10ms.|
TQLNCHRES_vidEntryInit|C|();|SCH.1|TQLNCHRES|1|V02 NT 10 04984||||0|0|0|0|Fonction d'accroche au moniteur Reset.|
TQLNCHRES_vidInitOutput|D|();|FCT1.1|TQLNCHRES|0|V02 NT 10 04984||||0|0|0|0|Cette fonction permet l'initialisation des variables de sortie.|
TQLNCHRES_vidReserve_decollage|C|();|FCT1.3|TQLNCHRES|0|V02 NT 10 04984||||0|0|0|0|La  réserve  de  couple  spécifique  au  décollage  dépend  de  la  température  d’eau  et  du  régime,  cette réserve est activée suivant un des quatre critères  : switch embrayage, vitesse véhicule, pied  levé et moteur en sous régime|
TQLNCHRES_vidReserveCplDecollage|B|();|FCT1.2|TQLNCHRES|0|V02 NT 10 04984||||0|0|0|0|Cette fonction autorise l'application de la fonction "Réserve de Couple Décollage" sous la condition Ext_stGBxCf = 0.|
TQLNCHRES_vidSpdVehLnchCdn|B|();|FCT1.8|TQLNCHRES|0|V02 NT 10 04984||||0|0|0|0|Production de TqRes_bCdnSpdLnchRes_MP.|
TQLOSSMON_vidCalculer_Couple|B|();|FCT2.7|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction permet de convertir la puissance en couple via une cartographie fonction du régime moteur et de la puissance filtrée.|
TQLOSSMON_vidChoisir_Type_Clim|A|();|FCT2.5|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction retient le signal correspondant au type de clim du véhicule.|
TQLOSSMON_vidConvertir_P_Couple|A|();|FCT2.4|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction se décompose en trois sous fonctions  : Sélectionner le type de clim, Filtrer le signal, Déterminer le couple prélevé|
TQLOSSMON_vidCoord_Pertes_Access|B|();|FCT3.9|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction somme les contributions des différents blocs de pertes accessoires.|
TQLOSSMON_vidCoordonner_pertes|A|();|FCT5.7|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction somme les contributions des différentes sous fonctions de calcul des pertes.|
TQLOSSMON_vidDet_Adaptatif_Perte|A|();|FCT4.7|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction permet de valider l’adaptation des pertes réal isée par l’ACS. Pour être accepté, le couple de recalage doit être inférieur à un seuil calibrable.|
TQLOSSMON_vidDet_Coef_Filtre|A|();|FCT5.4|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction permet de déterminer l e coefficient de filtrage du couple en fonction du régime moteur et de l’estimation du couple prélevé.|
TQLOSSMON_vidDet_Consigne_Couple|A|();|FCT5.3|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|La valeur max du couple prélevé par le convertisseur est pondérée par la vitesse.|
TQLOSSMON_vidDet_Demande_Altern|A|();|FCT1.5|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction permet de déterminer le couple maximum que l’alternateur peut demander. Ce couple maximum dépend du type d’alternateur.|
TQLOSSMON_vidDet_P_Conso_Type3|B|();|FCT2.2|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Le calcul de la puissance prélevée par la clim de type 3 se compose de deux modules : le couple de base et le couple à l’enclenchement.|
TQLOSSMON_vidDet_P_Conso_Type4|A|();|FCT2.3|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Ne redondant pas le booléen d’embrayage du compresseur de clim les filtrages ne peuvent être pris en compte. Pour cette raison la puissance sortant de cette fonction est la puissance maximale autorisée.|
TQLOSSMON_vidDet_Pertes_Access|B|();|FCT1.2|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction détermine les prélèvements de couple des accessoires. Elle est composée de 4 sous fonctions|
TQLOSSMON_vidDet_Pertes_Altern|A|();|FCT1.3|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction permet de valider l’estimation du couple prélevé par l’alternateur.|
TQLOSSMON_vidDet_Pertes_BVA|A|();|FCT5.1|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction calcule une enveloppe max des pertes BVA.|
TQLOSSMON_vidDet_Pertes_BVM|A|();|FCT3.8|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction fait la synthèse des levées de défauts et valide le couple final des pertes.|
TQLOSSMON_vidDet_Pertes_Clim|A|();|FCT2.1|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Le calcul qui permet de déterminer le couple prélevé par la climatisation est composé de deux étapes|
TQLOSSMON_vidDet_Pertes_DA|A|();|FCT3.1|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction permet  de valider que le couple prélevée calculé par l’ACS est inférieur au couple maximal que peut demander la DA raffiné en fonction de la vitesse et du régime.|
TQLOSSMON_vidDet_Pertes_DA_Lin|A|();|FCT3.4|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette sous fonction permet de déterminer l’enveloppe max de la DA de type linéaire.|
TQLOSSMON_vidDet_Pertes_DA_OnOff|A|();|FCT3.3|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette sous fonction détermine l’enveloppe max de la DA de type On-Off principalement en fonction du régime moteur.|
TQLOSSMON_vidDet_Pertes_Max_Dem|B|();|FCT4.4|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Les pertes au démarrage sont ajoutées pendant une courte durée après le démarrage. L’enveloppe max est calculée pendant cette durée et une fois le temps écoulé, elle est égale à zéro.|
TQLOSSMON_vidDet_Pertes_Max_Fric|A|();|FCT4.2|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Pour affiner l’enveloppe max des pertes par friction, on tient compte de leurs dépendances avec le régime moteur.|
TQLOSSMON_vidDet_Pertes_Max_Pomp|A|();|FCT4.3|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|On détermine les pertes maximales par pompage. Celles-ci correspondent à la somme de l’offset max et de l’enveloppe max des pertes par pompage nominales en fonction du régime moteur.|
TQLOSSMON_vidDet_Pertes_Mot_Glob|A|();|FCT4.6|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction somme les différentes contributions des pertes moteur et applique une  saturation au signal obtenu.|
TQLOSSMON_vidDet_Pertes_Moteur|A|();|FCT4.1|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction permet la validation des pertes moteur. Elle réalise la comparaison des pertes calculées par l’ACS avec celles calculées par la TMS pour chacune des sous fonctions.|
TQLOSSMON_vidEntryInit|B|();|SCH.1|TQLOSSMON|1|V02 NT 10 01233||||0|0|0|0|Accroche moniteur de l'evenement reset|
TQLOSSMON_vidFiltrer_consigne|A|();|FCT5.5|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction filtre le couple prélevé estimé.|
TQLOSSMON_vidFiltrer_Pertes_DA|A|();|FCT3.6|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette sous fonction redonde le filtrage des pertes DA effectué dans l’ACS.|
TQLOSSMON_vidFiltrer_redond_ACS|A|();|FCT2.6|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction de filtrage est redondée de l’ACS.|
TQLOSSMON_vidInitOutput|C|();|FCT1.1|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Initialisation des parametres|
TQLOSSMON_vidSelectioner_Type_DA|A|();|FCT3.5|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette sous fonction permet de déterminer le signal à utiliser en fonction du type de DA.|
TQLOSSMON_vidTraiter_entrees|A|();|FCT5.2|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction réalise le traitement de l’info vitesse véhicule. En cas de défaut de cette  vitesse, elle passe à une valeur refuge.|
TQLOSSMON_vidTraiter_Vveh|B|();|FCT3.2|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette sous fonction réalise le traitement de la vitesse  véhicule en cas de défaut de signal.|
TQLOSSMON_vidVal_Demande_Altern|B|();|FCT1.6|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction permet de valider que le couple prélevé par l’alternateur est inférieur à son enveloppe maximale.|
TQLOSSMON_vidVal_Pertes_Pompe_HP|A|();|FCT4.5|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Les pertes de la pompe haute pression sont validées par comparaison avec une valeur max.|
TQLOSSMON_vidValider_consigne|A|();|FCT5.6|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction valide l’estimation du couple prélevé par le convertisseur.|
TQLOSSMON_vidValider_Pertes_Clim|A|();|FCT2.8|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction permet de valider la sortie du couple clim en s’assurant que ce couple est inférieur au couple max calculé par son équivalent dans l’ACS.|
TQLOSSMON_vidValider_Pertes_Glob|C|();|FCT5.8|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction fait la synthèse des levées de défauts et valide le couple final des pertes.|
TQLOSSMON_vidValider_Reserve_GMV|A|();|FCT1.4|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette fonction détermine la borne max du couple de réserves GMV et valide que le couple de réserves calculé au niveau ACS est inférieur à cette valeur.|
TQLOSSMON_vidValider_signal_ACS|A|();|FCT3.7|TQLOSSMON|0|V02 NT 10 01233||||0|0|0|0|Cette sous fonction permet de valider le signal de l’ACS en fonction de l’enveloppe max calculée dans la TMS.|
TqRes_Sdl10ms_tqACRes|A|();|SCH.2|TQACRES|1|V02 NT 10 04980||||0|0|0|0|Fonction d'accroche au moniteur 10 ms|
TqRes_Sdl10ms_tqAltRes|A|();|SCH.2|TQALTRES|1|V02 NT 11 02660||||0|0|0|0|Scheduler 10 ms|
TqRes_Sdl10ms_tqAltResIf|C|();|SCH20.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur 10ms.|
TqRes_Sdl10ms_tqCoHeatRes|B|();|SCH.2|TQCOHEATRES|1|V02 NT 11 02653||||0|0|0|0|Fonction d'accroche au moniteur 10ms|
TqRes_Sdl10ms_tqCrawlRes|A|();|SCH.2|TQCRWLRES|1|V02 NT 10 04975||||0|0|0|0|Evenement d'activation du bloc|
TqRes_Sdl10ms_tqEOMRes|A|();|SCH.2|TQCATHEATRES|1|V02 NT 10 08577||||0|0|0|0|Moniteur rapide|
TqRes_Sdl10ms_tqIdlRes|C|();|SCH.2|TQENGRES|1|PTS_DOC_5135152||||0|0|0|0|Evénement périodique toutes les 10 ms|
TqRes_Sdl10ms_tqMaxRes|A|();|SCH.2|TQRESCORD|1|V02 NT 11 02659||||0|0|0|0|Fonction d'accroche au moniteur 10ms|
TqRes_Sdl20ms_tqACRes|A|();|SCH.3|TQACRES|1|V02 NT 10 04980||||0|0|0|0|Fonction d'accroche au moniteur 20 ms|
TQRESCORD_vidCoord_degradations|H|();|FCT1.2|TQRESCORD|0|V02 NT 11 02659||||0|0|0|0|Cette fonction calcule le couple de compensation à appliquer sur la branche air lorsque le rendement d’avance maximum n’est pas à 1, ainsi que le couple de réserve pour la purge canister.|
TQRESCORD_vidCoord_reserves|G|();|FCT1.3|TQRESCORD|0|V02 NT 11 02659||||0|0|0|0|Le couple des réserves totales est le maximum de l’ensemble des couples réserve. Un flag est ajouté à la sortie du couple des réserves totales pour boucler la structure couple.|
TQRESCORD_vidEntryInit|E|();|SCH.1|TQRESCORD|1|V02 NT 11 02659||||0|0|0|0|Fonction d'accroche Reset|
TQRESCORD_vidInitOutput|H|();|FCT1.1|TQRESCORD|0|V02 NT 11 02659||||0|0|0|0|Initialisation des variables de sortie|
TQSTGPMPRES_vidCalculReserve|D|();|FCT1.6|TQSTGPMPRES|0|V02 NT 10 04991||||0|0|0|0|Fonction qui calcule la réserve de couple DA finale qui est le maximum entre la valeur 0 et la différence entre la réserve de couple et le couple compensé.|
TQSTGPMPRES_vidConditionDA|D|();|FCT1.4|TQSTGPMPRES|0|V02 NT 10 04991||||0|0|0|0|Fonction qui traite la condition d'activation de la direction assistée|
TQSTGPMPRES_vidConditionReserve|A|();|FCT1.3|TQSTGPMPRES|0|V02 NT 10 04991||||0|0|0|0|L’activation de la condition manoeuvre sollicite la validation de quatre conditions suivantes : La vitesse véhicule doit être inférieure à un seuil de vitesse calibrable ou défaut vitesse,temps après démarrage est supérieur à une valeur calibrable.|
TQSTGPMPRES_vidConditionVolant|B|();|FCT1.5|TQSTGPMPRES|0|V02 NT 10 04991||||0|0|0|0|La condition angle volant est active si la valeur de l’angle au volant est supérieure à une valeur d’angle fonction de la vitesse de l’angle au volant. La condition angle volant se désactive après une temporisation calibrable.|
TQSTGPMPRES_vidEntry_10ms|D|();|SCH.2|TQSTGPMPRES|1|V02 NT 10 04991||||0|0|0|0|Scheduler 10 ms|
TQSTGPMPRES_vidEntryInit|D|();|SCH.1|TQSTGPMPRES|1|V02 NT 10 04991||||0|0|0|0|Scheduler reset|
TQSTGPMPRES_vidInitOutput|E|();|FCT1.1|TQSTGPMPRES|0|V02 NT 10 04991||||0|0|0|0|Fonction d'initialisations des sorties au reset.|
TQSTGPMPRES_vidReserveDeCoupleDA|A|();|FCT1.2|TQSTGPMPRES|0|V02 NT 10 04991||||0|0|0|0|La fonction réserve de couple direction assistée concerne uniquement la réserve de couple en condition de manoeuvre.|
TqSys_EveBDC_TqSysVld|B|();|SCH.3|TQSYSVLD|1|V02 NT 09 04105||||0|0|0|0|Interruption PMB|
TqSys_EveRst_ChaAdvMinUnlim|A|();|SCH.1|CHAADVMINUNLIM|1|V02 NT 11 05440||||0|0|0|0|Evénement reset du calculateur .
TqSys_EveRst_MuxTqReq|A|();|SCH.1|MUXTQREQ|1|V02 NT 11 08258||||0|0|0|0|Evénement reset du calculateur
TqSys_EveRst_SpBenchMod|A|();|SCH.1|TQSYSSPBENCHMOD|1|V02 NT 09 08176||||0|1|0|0|Event Reset
TqSys_EveRst_tqLimSfty|A|();|SCH.1|TQLIMSFTY|1|V02 NT 08 07804||||0|0|0|0|Evènement d'initialisation du calculateur.
TqSys_EveRst_tqLimSftyIf|C|();|SCH7.4|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evènement d'initialisation du calculateur.|
TqSys_EveRst_TqSysIdc|A|();|SCH.1|TQSYSIDC|1|V02 NT 08 05347||||0|0|0|0|Evénement reset du calculateur|
TqSys_EveRst_TqSysVld|B|();|SCH.1|TQSYSVLD|1|V02 NT 09 04105||||0|0|0|0|Evénement reset du calculateur|
TqSys_EveSync_SBPA|A|();|SCH.2|SBPAGEN|1|V02 NT 08 07560||||0|0|0|0|Scheduler de la fonction
TqSys_EveTDC_SpBenchMod|A|();|SCH.3|TQSYSSPBENCHMOD|1|V02 NT 09 08176||||0|1|0|0|Event TDC
TqSys_EveTDC_TqSysIdc|A|();|SCH.3|TQSYSIDC|1|V02 NT 08 05347||||0|0|0|0|Interruption PMH|
TqSys_Sdl10ms_BrkAsi|B|();|SCH.2|BRKASIACT|1|V02 NT 10 03258||||0|0|0|0|accroche moniteur chaque 10 ms|
TqSys_Sdl10ms_nTarIdl|A|();|SCH.2|TARIDLSTA|1|V02 NT 10 08533||||0|0|0|0|Fonction scheduler de récurrence 10ms.|
TqSys_Sdl10ms_nTarIdlCmbMod|A|();|SCH.2|IDLCMDMOD|1|V02 NT 10 08588||||0|0|0|0|Scheduler de la fonction IDLCMDMOD.|
TqSys_Sdl10ms_SptMod|A|();|SCH.2|SPTMOD|1|V02 NT 11 04668||||0|0|0|0|Schéduling de la fonction / Function's scheduling|
TqSys_Sdl10ms_TqCha|B|();|SCH.2|CHATQAIRCORD|1|PTS_DOC_5139605||||0|0|0|0|Fonction d'accroche au moniteur 10ms.|
TqSys_Sdl10ms_TqEfcCordLim|B|();|SCH.2|ENGLIMEFCCORD|1|V02 NT 10 03267||||0|0|0|0|Fonction d'accroche moniteur 10ms|
TqSys_Sdl20ms_TqAdvMin|A|();|SCH.2|TQADVMIN|1|V02 NT 11 05439||||0|0|0|0|Trigger of the function
TqSys_Sdl20ms_TqCmpManGBx|B|();|SCH.2|TQCMPMANGBX|1|PTS_DOC_5199347||||0|0|0|0|Function scheduling|
TqSys_Sdl40ms_ProtManClu|A|();|SCH.2|PROTMANCLU|1|V02 NT 11 04687||||0|0|0|0|Event 40ms of the function .|
TqSys_SdlFast_ChaAdvMinUnlim|A|();|SCH.2|CHAADVMINUNLIM|1|V02 NT 11 05440||||0|0|0|0|Moniteur rapide de la fonction
TqSys_SdlFast_SpBenchMod|A|();|SCH.2|TQSYSSPBENCHMOD|1|V02 NT 09 08176||||0|1|0|0|Fast scheduler of the torque function in Bench mode
TqSys_SdlFast_tqLimSfty|A|();|SCH.2|TQLIMSFTY|1|V02 NT 08 07804||||0|0|0|0|Moniteur moyen pour la fonction EngLim.
TqSys_SdlFast_tqLimSftyIf|C|();|SCH7.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur moyen pour la fonction EngLim.|
TqSys_SdlFast_TqSysIdc|A|();|SCH.2|TQSYSIDC|1|V02 NT 08 05347||||0|0|0|0|Moniteur rapide pour la fonction TqSys|
TqSys_SdlFast_TqSysVld|B|();|SCH.2|TQSYSVLD|1|V02 NT 09 04105||||0|0|0|0|Moniteur rapide pour la fonction TqSys|
TqSys_SdlMid_MuxTqReq|A|();|SCH.2|MUXTQREQ|1|V02 NT 11 08258||||0|0|0|0|Moniteur rapide de la fonction
TQSYSIDC_vidTqSysFast|C|();|FCT1.2|TQSYSIDC|0|V02 NT 08 05347||||0|0|0|0|Pour le calcul de la consigne de couple finale de la chaîne d'avance, on ajoutera à la consigne de couple coordonnée à la correction curative, le couple de compensation puis on applique les limitations.|
TQSYSIDC_vidTqSysSlow|D|();|FCT1.1|TQSYSIDC|0|V02 NT 08 05347||||0|0|0|0|Dans le calcul de la consigne du couple finale de la chaîne d'air, on ajoutera à la consigne de couple coordonnée avec toutes les limitations branche air, le couple de compensation généré puis on applique les limitations|
TQSYSSPBENCHMOD_vidComput_TqAirSpBenchMod|A|();|FCT.1.4|TQSYSSPBENCHMOD|0|V02 NT 09 08176||||0|1|0|0|
TQSYSSPBENCHMOD_vidComput_TqIgnSpBenchMod|A|();|FCT.1.6|TQSYSSPBENCHMOD|0|V02 NT 09 08176||||0|1|0|0|
TQSYSSPBENCHMOD_vidInit_TqSpBenchMod|A|();|FCT.1.1|TQSYSSPBENCHMOD|1|V02 NT 09 08176||||0|1|0|0|Outputs initializations
TQSYSSPBENCHMOD_vidManage_TqAirSpBenchMod|A|();|FCT.1.3|TQSYSSPBENCHMOD|1|V02 NT 09 08176||||0|1|0|0|
TQSYSSPBENCHMOD_vidManage_TqIgnSpBenchMod|A|();|FCT.1.5|TQSYSSPBENCHMOD|1|V02 NT 09 08176||||0|1|0|0|
TQSYSSPBENCHMOD_vidSet_TqSpBenchModParam|A|();|FCT.1.2|TQSYSSPBENCHMOD|1|V02 NT 09 08176||||0|1|0|0|
TQSYSVLD_vidDiagMisfire|B|();|FCT1.2|TQSYSVLD|0|V02 NT 09 04105||||0|0|0|0|A partir de l'information " taux de ratés de combustion" produite par le diagnostic Misfire(200tr), cette fonction produit et consomme en interne les informations suivantes: Diag_misfire_bas_EM, Diag_misfire_haut_EM, Diag_misfire_bas et Diag_misfire_haut.|
TQSYSVLD_vidInit|B|();|FCT1.1|TQSYSVLD|0|V02 NT 09 04105||||0|0|0|0|Fonction d'initialisation des variables produites par la Spec.|
TQSYSVLD_vidNoWght|B|();|FCT1.3|TQSYSVLD|0|V02 NT 09 04105||||0|0|0|0|Dans ce module on définie un système de poids qui quantifie l’effet plus ou moins important de chaque paramètre sur la précision des couples reconstruits.|
TQSYSVLD_vidNoWght1|B|();|FCT2.1|TQSYSVLD|0|V02 NT 09 04105||||0|0|0|0|Fonction qui consomme les Flux suivants issus du GAR : Information couple incertain et couple invalide, Information couple Easy Move incertain et couple Easy Move invalide et Réalisation consignes ESP impossible et consignes ESP imprécise|
TQSYSVLD_vidNoWght2|B|();|FCT2.2|TQSYSVLD|0|V02 NT 09 04105||||0|0|0|0|Cette fonction consomme les flux issus de l'inter système qui sont des défaillances portant sur les informations suivantes : vitesse véhicule, position pédale d'embrayage, puissance consommée par le compresseur de climatisation et charge alternateur.|
TQSYSVLD_vidNoWght3|B|();|FCT2.3|TQSYSVLD|0|V02 NT 09 04105||||0|0|0|0|Cette fonction permet la consommation des lignes de défaut actionneurs suivants : Commande BPM et Commande " déphaseurs arbre à cames " admission et échappement.|
TQSYSVLD_vidNoWght4|B|();|FCT2.4|TQSYSVLD|0|V02 NT 09 04105||||0|0|0|0|Fonction qui permet la consommation des lignes de défaut capteurs.|
TQSYSVLD_vidNoWght5|C|();|FCT2.5|TQSYSVLD|0|V02 NT 09 04105||||0|0|0|0|Fonction qui permet la consommation des informations liées à la gestion carburant|
TQSYSVLD_vidStDiagESPReq|B|();|FCT1.6|TQSYSVLD|0|V02 NT 09 04105||||0|0|0|0|Fonction de calcul de l'Etat réalisation de la consigne ASR/MSR :0 = fonctionnement normal, 1 = Moteur géré en boucle ouverte, 2 = fonctionnement dégradé et 3 = aucune action possible.|
TQSYSVLD_vidTqCkEngReal|B|();|FCT1.4|TQSYSVLD|0|V02 NT 09 04105||||0|0|0|0|Fonction de calcul de l'Information couple incertain et Information couple invalide.|
TQSYSVLD_vidTqEM|B|();|FCT1.5|TQSYSVLD|0|V02 NT 09 04105||||0|0|0|0|Fonction de calcul de l'Information couple Easy Move invalide et l'Information couple Easy Move incertain.|
TQVSCTLCHK_vidDesacRVVAppuiFrein|E|();|FCT1.2|TQVSCTLCHK|0|V02 NT 11 01190||||0|0|0|0|Elle intègre la consigne de couple RVV dans la chaîne en couple en appliquant un max entre la couple conducteur issue du bloc amont et la consigne de couple RVV.|
TQVSCTLCHK_vidEntryInit|B|();|SCH.1|TQVSCTLCHK|1|V02 NT 11 01190||||0|0|0|0|Evénement Reset du calculateur|
TQVSCTLCHK_vidInitOutput|C|();|FCT1.1|TQVSCTLCHK|0|V02 NT 11 01190||||0|0|0|0|initialisation des sorties|
TRBWAPMP_vidCmdRCOCor|C|();|FCT1.5|TRBWAPMP|0|PTS_DOC_6851428||||0|0|0|0|Cette fonction permet de corriger puis calculer le cycle d'utilisation de la commande de la pompe à eau.|
TRBWAPMP_vidConversionInPercent|D|();|FCT1.4|TRBWAPMP|0|PTS_DOC_6851428||||0|0|0|0|Cette fonction permet de convertir la pourcentage de la commande de la pompe à eau et de filtrer la tension de la batterie.|
TRBWAPMP_vidDiagnosis|C|();|FCT1.7|TRBWAPMP|0|PTS_DOC_6851428||||0|0|0|0|Cette fonction permet de réaliser le diagnostic des échecs.|
TRBWAPMP_vidDrvCmd|F|();|FCT1.6|TRBWAPMP|0|PTS_DOC_6851428||||0|0|0|0|Cette fonction permet d'effectuer la transmission de la commande de pompe à eau à travers la couche de base via le Service PWDHAL.|
TRBWAPMP_vidInit|C|();|FCT1.1|TRBWAPMP|0|PTS_DOC_6851428||||0|0|0|0|Cette fonction donne les valeurs d'initialisation des sorties.|
TRBWAPMP_vidInitOutput|E|();|FCT1.2|TRBWAPMP|0|PTS_DOC_6851428||||0|0|0|0|fonction d'initialisation des sorties|
TRBWAPMP_vidTreatment|C|();|FCT1.3|TRBWAPMP|0|PTS_DOC_6851428||||0|0|0|0|cette fct permet la réalisation des étapes du fonctionnement de la pompe à eau.|
TUNCFG_vidAltClassSel|A|();|FCT2.8|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Gestion de la classe d'alternateur.|
TUNCFG_vidALTSel|F|();|FCT1.7|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|configuration des sorties CMM  par défaut , Partie Alternateur|
TUNCFG_vidBVSel|G|();|FCT1.6|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|configuration des sorties CMM  par défaut, Partie boîte de vitesse|
TUNCFG_vidCANAdapt|A|();|FCT2.7|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|cette fonction permet de produire la configuration BVV paramétrable.|
TUNCFG_vidCARSel|F|();|FCT1.8|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Le type de carrosserie est sélectionné parmis les classes possibles par télécodage|
TUNCFG_vidCHASel|F|();|FCT1.9|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Le type de chauffage additionnel est sélectionné parmis les classes possibles par télécodage|
TUNCFG_vidCLIMSel|F|();|FCT1.5|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Le type de climatisation est sélectionné parmis les types possibles par télécodage.|
TUNCFG_vidDAGMPSel|C|();|FCT2.5|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|La configuration DAGMP dépend de l’architecture électrique de véhicule et de la présence d’une clé ou un push.|
TUNCFG_vidDCTSel|D|();|FCT2.6|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Gestion de la diversité des pièces de la fonction chauffage additionnel|
TUNCFG_vidFRICSel|F|();|FCT1.4|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|configuration des sorties CMM  par défaut Partie Fric|
TUNCFG_vidGEESel|D|();|FCT2.4|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Le type d’alternateur (standard, pilotée, réversible, convertisseur DC/DC)|
TUNCFG_vidProdCfg|E|();|FCT1.3|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Appel des fonctions de configuration des sorties CMM  par défaut|
TUNCFG_vidSelCfg|D|();|FCT2.3|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Cette fonction permet de spécifier le type de DAGMP et le type d’alternateur embarqués sur le véhicule.|
TUNCFG_vidTunCfg|J|();|FCT1.1|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Configuration des variables: type  de  carburant ,  nombre  de  cylindres  ainsi que le type de boite automatique ou piloté|
TUNCFG_vidTunCfg1|E|();|FCT1.2|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Configuration des variables: type  de  carburant ,  nombre  de  cylindres  ainsi que le type de boite automatique ou piloté|
TUNCFG_vidUCSelLsb|I|();|FCT2.1|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Les fonctions ABS, BVV, DSG, ESP ASR, FSE, LVV et RVV sont sélectionnées et créent les flux associés.|
TUNCFG_vidUCSelMsb|H|();|FCT2.2|TUNCFG|0|PTS_DOC_5304544||||0|1|0|0|Les fonctions ABS, BVV, DSG, ESP ASR, FSE, LVV et RVV sont sélectionnées et créent les flux associés.|
TWCMgt_EveIni_TWCMgt|A|();|SCH.1|TWCMGT|1|V02 NT 11 02024||||0|0|0|0|Initialization event of the function Three Way Catalyst Heating Manager|
TWCMgt_SdlFast_TWCMgt|A|();|SCH.2|TWCMGT|1|V02 NT 11 02024||||0|0|0|0|Calculation event of the function Three Way Catalyst Heating Manager|
TWCMgt_SdlFast_TWCMgtIf|A|();|SCH.2|IFCATMDLSYS|1|V02 NT 11 06970||||0|0|0|0|Fast monitor of TWCMgt interface.|
TWCMGT_VidAuthorizeActivCondCalc|A|();|FCT1.5|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block allows the activation of the calculus of the block F02_Check_Activation_Conditions”. It checks that the engine is really started. This function is based on an engine speed threshold|
TWCMGT_VidAuthorizeLightOffCompt|A|();|FCT2.8|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block authorizes the computation of the light-off status and allows that the computation goes on if the catalyst heating is deactivated.|
TWCMGT_VidCheckActivationCond|A|();|FCT1.6|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block manages the activation conditions which are necessary to authorize a catalyst heating.|
TWCMGT_VidCheckDeactivationCond|A|();|FCT1.10|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block manages the deactivation conditions of catalyst heating. When at least one of a deactivation condition is true, TWCMgt_bDeacHeatPha” also becomes true. Therefore, the catalyst heating is stopped.|
TWCMGT_VidCheckTheEveryTimeActCd|A|();|FCT1.8|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block checks heating authorization conditions which have to be check every time. It is calculated only when the block “F01_Once_Checking_Activation_Conditions” authorizes it; that is to say only if all the start conditions are satisfied.|
TWCMGT_VidCheckTheOnceActivCond|A|();|FCT1.7|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This blocks checks the conditions which are required at start of the engine to authorize a catalyst heating. It is calculated once at start when the flag TWCMgt_bAcvNEng_AcvCdnBeg” enables its operation.|
TWCMGT_VidCount_Light_Off_Time|A|();|FCT3.1|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block calculates the duration since the beginning of the TWC heating. If the heating is deactivated, the counter still goes on.|
TWCMGT_VidEstimAndSaveTimOfPhas1|A|();|FCT2.3|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This bloc is composed of 2 subsystems: The first saves the current value of the estimated time of phase 1 and feed.The second stimates the value of the phase1 according to several catalyst ageing factors.|
TWCMGT_VidEstimate_Phase_Time_1|A|();|FCT2.4|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This bloc allows determining the duration of the phase (phase corresponding to the maximum heating catalyst)|
TWCMGT_VidEstNormCondLightOffTim|A|();|FCT2.10|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block estimates the time of phase 1 for a normal situation (no three way catalyst heating deactivation during the running)|
TWCMGT_VidInitOutput|A|();|FCT1.1|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|fonction d'initialisation des variables produites|
TWCMGT_VidInitThreeWayCatHeatMng|A|();|FCT1.2|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|fonction d'initialisation des sorties|
TWCMGT_VidManage_Light_Off|A|();|FCT2.9|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|The goal of this block is to feed the flag “TWCMgt_bLiOffDone”. This one indicates the state of the catalyst: true when the catalyst is efficient, false in other case.|
TWCMGT_VidManage_Output|A|();|FCT3.5|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|The goal of this function is to set the variable TWCMgt_stTrbActPosnReq” and TWCMgt_stHeatPhaReq to 0 when the catalyst heating is finished (TWCMgt_bTWCHeatReq = 0).|
TWCMGT_VidManageActivationCond|A|();|FCT1.9|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block manages the required conditions to authorize a catalyst heating and allow applying a delay before activation.|
TWCMGT_VidManageLightOff|A|();|FCT3.3|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block manages the light-off depending on the current situation. Several parameters are taking into account:Cold or warm temperature, Catalyst heating activation status and Time since start of catalyst heating or catalyst temperature threshold.|
TWCMGT_VidManageThresholdPhase3|A|();|FCT2.6|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|The goal of this block is to manage the transition between phase 3 and the precedent heating phase based on a temperature or duration criteria.|
TWCMGT_VidMng_Progressive_Heat|A|();|FCT2.2|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This bloc allows managing the modulation heating strategy which consists in having different heat phase of catalyst heating. Each phase is associated to a heat power and has different duration according to the situation.|
TWCMGT_VidMngActivAndDeactivCond|A|();|FCT2.1|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block manages the activation and deactivation conditions.|
TWCMGT_VidMngHeatAuthorization|A|();|FCT1.4|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block manages the authorization of catalyst heating.|
TWCMGT_VidMngWaste_Gate_Position|A|();|FCT3.4|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|The goal of this block is to determine the state of the variable TWCMgt_stTrbActPosnReq”. This variable is used to command the turbocharger waste gate.|
TWCMGT_VidSaveAndInitPhaseTime1|A|();|FCT2.5|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|Maximum duration of all the estimated phase 1 duration values (from deterioration factors) becomes the estimated duration of the phase 1.|
TWCMGT_VidSelect_Phase|A|();|FCT2.7|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|The goal of this block is to manage the selection of the different phases: 0 (No heating), 1( Maximum Catalyst ), 2(Normal Catalyst ), 3(Reduced Catalyst) and 4(Maximum Catalyst Heating phase in cold temperature area)|
TWCMGT_VidThreeWayCatHeatMngVal|A|();|FCT1.3|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|The function is composed of 6 blocks:F01_Manage_Heating_Authorization, F02_Manage_Progressive_Heating, F03_Authorize_Light_Off_Computation , F04_Manage_Light_Off , F05_Manage_Waste_Gate_Position and F06_Manage_output.|
TWCMGT_VidTWCEstHeatDeactLgOfTim|A|();|FCT3.2|TWCMGT|0|V02 NT 11 02024||||0|0|0|0|This block estimates the duration before light-off 1 which has to be applied if the three way catalyst heating has been deactivated.|
UPLSACQ_vidExtremeSenO2VoltMngt|A|();|FCT4.7|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Management des tensions extremums de la sondes amont
UPLSACQ_vidFilteringStallEngine|A|();|FCT3.5|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|filtrage de la sonde en moteur cale
UPLSACQ_vidFilteringSyncEngine|C|();|FCT3.4|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|filtrage de la Tension sonde amont brute
UPLSACQ_vidInitDeadZoneCount|A|();|FCT1.4|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Initialisation de Compteur d'occurrences pendant lesquelles la tension sonde est dans la bande morte de détection CO
UPLSACQ_vidInitOutput|B|();|FCT1.1|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Initialisation des variables produites dans ce module
UPLSACQ_vidLeanToRichSensor|A|();|FCT4.4|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Transition de la sonde amont de l'etat pauvre a l'etat riche
UPLSACQ_vidNoFaultSenO2VoltMngt|A|();|FCT4.8|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Management de la tension sonde sans defaut
UPLSACQ_vidRichToLeanSensor|A|();|FCT4.5|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Transition de la sonde amont de l'etat riche a l'etat pauvre
UPLSACQ_vidRunKeyOff|A|();|FCT1.6|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Run clef off
UPLSACQ_vidSenO2StateKeyOff|A|();|FCT3.3|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Etat de la sonde en cle off
UPLSACQ_vidSenO2UsAcquiTreatment|A|();|FCT1.3|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Run Sonde à oxigène amont
UPLSACQ_vidSenO2UsCounterInhib|A|();|FCT4.1|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Calcul des extrema des sondes
UPLSACQ_vidSenO2UsCountInhibInit|A|();|FCT4.2|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Initialsation du compteur d'inhibition du calcul des extrema des sondes lors d'une coupure injection
UPLSACQ_vidSenO2UsDefault|A|();|FCT3.2|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Défaut circuit ouvert
UPLSACQ_vidSenO2UsDefaultMngt|A|();|FCT1.5|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Management du defaut de sonde amont
UPLSACQ_vidSenO2UsDiagGroundMngt|B|();|FCT2.4|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Detection d'un court-circuit à la masse sur la sonde amont
UPLSACQ_vidSenO2UsFiltStallEng|A|();|FCT2.3|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Fonctionnement en moteur cale
UPLSACQ_vidSenO2UsFiltSyncEngine|C|();|FCT2.2|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|fonctionnement de la sonde en moteur synchronisé
UPLSACQ_vidSenO2UsFreeze|A|();|FCT4.6|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Etat pauvre mesuré par la sonde
UPLSACQ_vidSenO2UsInitialization|A|();|FCT1.2|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Initialisation des variables internes et des sortie du module
UPLSACQ_vidSenO2UsManagement|A|();|FCT3.1|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|management de la tension sonde amont
UPLSACQ_vidSenO2UsVoltageCalc|A|();|FCT4.3|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Calcul de la tension sonde amont
UPLSACQ_vidSO2UsDefaultCountDec|A|();|FCT2.1|UPLSACQ|0|PTS_DOC_6562315||||0|0|0|0|Calcul du temps minimal après démarrage moteur à partir duquel la sonde est considérée comme chaude
UsThrM_EvePwrl_AmbPEstimnIf|E|();|SCH7.2|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement powerlatch du module d'interface|
VEHMNG_vidCanTranSpeedManagement|D|();|FCT1.4|VEHMNG|0|V02 NT 08 05610||||0|0|0|0|La vitesse doit, pour le RCD, être nominalement lue sur la trame 38D.
VEHMNG_vidClcDistTraveledViaCAN|A|();|FCT1.7|VEHMNG|0|V02 NT 08 05610||||0|0|0|0|Calcul de la distance Distance_parcourue.
VEHMNG_vidClcDistTraveledViaWire|A|();|FCT1.9|VEHMNG|0|V02 NT 08 05610||||0|0|0|0|Calcul de Distance_parcourue
VEHMNG_vidCmmTranSpeedManagement|C|();|FCT1.5|VEHMNG|0|V02 NT 08 05610||||0|0|0|0|La vitesse véhicule est l’image de la vitesse filaire calculée par le CMM.On ne peut s'y trouver que si le véhicule est équipé d'un capteur filaire et que l'ABS/ESP ne sont pas disponibles.
VEHMNG_vidDistTraveledViaCAN|C|();|FCT1.8|VEHMNG|0|V02 NT 08 05610||||0|0|0|0|La distance_parcourue_prev est rafraîchie en permanence tandis que lors des variations de FRM_bInhClcnDstCovered, le flux Distance_parcourue est figé durant un pas de calcul afin de garantir au pas suivant que les 2 variables sont dans le même référentiel
VEHMNG_vidDistTraveledViaWire|B|();|FCT1.10|VEHMNG|0|V02 NT 08 05610||||0|0|0|0|Calcul de Distance_parcourue par le capteur filaire
VEHMNG_vidVehDstClcMng|K|();|FCT2.1|VEHMNG|0|V02 NT 08 05610||||0|0|0|0|La distance parcourue depuis le dernier clé ON  est visualisable sous ADES par la variable Distance_parcourue_hectometre. Si l’on ne dispose pas de cette information en interne CMM, on prend l’information disponible sur le CAN.
VEHMNG_vidVehicleSpeedFiltered|A|();|FCT1.6|VEHMNG|0|V02 NT 08 05610||||0|0|0|0|Filtrage de la vitesse vehicule
VEHMNG_vidVehSdpMngInit|J|();|FCT1.1|VEHMNG|0|V02 NT 08 05610||||0|0|0|0|Initialisation de la stratégie
VEHMNG_vidVehSpdInformation|B|();|FCT1.2|VEHMNG|0|V02 NT 08 05610||||0|0|0|0|Pour le RCD la vitesse doit nominalement être lue sur la trame 38D en cas d'absence de cette trame.
VEHMNG_vidVehSpdMngCanCmm|A|();|FCT1.3|VEHMNG|0|V02 NT 08 05610||||0|0|0|0|La vitesse doit, pour le RCD, être nominalement lue sur la trame 38D.
VEHMUX_vidAcquisFrame552|B|();|FCT1.7|VEHMUX|0|V02 NT 08 05607||||0|0|0|0|Acquisation of the frame 552.
VEHMUX_vidAcquisFrame7F2|C|();|FCT1.5|VEHMUX|0|V02 NT 08 05607||||0|0|0|0|Acquisation of the frame 7F2.
VEHMUX_vidAcquisition38D|C|();|FCT1.2|VEHMUX|0|V02 NT 08 05607||||0|0|0|0|Acquisition of speed and the acceleration of the vehicle when presence of ABS mux and ESP.
VEHMUX_vidAcquisSpeedAccelMux|B|();|FCT1.3|VEHMUX|0|V02 NT 08 05607||||0|0|0|0|Acquisition of speed and the acceleration of the vehicle.
VEHMUX_vidCalcDist552|E|();|FCT1.6|VEHMUX|0|V02 NT 08 05607||||0|0|0|0|The system compute the Distance_parcourue_mux via Km_vehicle_mux received from the frame 552
VEHMUX_vidCalcDist7F2|D|();|FCT1.4|VEHMUX|0|V02 NT 08 05607||||0|0|0|0|The system compute the Distance_parcourue_mux via Km_vehicle_mux received from the frame 7F2
VEHMUX_vidTravaledDistanceCalc|A|();|FCT1.8|VEHMUX|0|V02 NT 08 05607||||0|0|0|0|The production of Distance_parcourue_mux through Km_vehicle_mux.
VEHMUX_vidVehSpdMuxInit|A|();|FCT1.1|VEHMUX|0|V02 NT 08 05607||||0|0|0|0|Outputs initialisation
VehSpd_EveRst_AcqVehSpdSen|C|();|SCH.1|VEHSPDACQ|1|PTS_DOC_5455394||||0|0|0|0|Reset|
VehSpd_EveRst_MonVehSpd|C|();|SCH.1|VEHSPDDIAG|1|V02 NT 09 01664||||0|0|0|0|Evènement reset de l'ECU.|
VehSpd_EveRst_VehMng|A|();|SCH.1|VEHMNG|1|V02 NT 08 05610||||0|0|0|0|Evénement Reset du calculateur
VehSpd_EveRst_VehMux|A|();|SCH.1|VEHMUX|1|V02 NT 08 05607||||0|0|0|0|Reset of VehSpd function.
VehSpd_EveRxn552_VehMux|B|();|SCH.4|VEHMUX|1|V02 NT 08 05607||||0|0|0|0|Receiving 552 Frame
VehSpd_EveRxn7F2_VehMux|B|();|SCH.3|VEHMUX|1|V02 NT 08 05607||||0|0|0|0|Receiving 7F2 frame
VehSpd_EveVSTop_AcqVehSpdSen|B|();|SCH.2|VEHSPDACQ|1|PTS_DOC_5455394||||0|0|0|0|Evènement Top notifiant de la détection par le LDB (bloc SPDHAL) d'une nouvelle impulsion du capteur vitesse|
VehSpd_SdlFast_AcqVehSpdSen|B|();|SCH.3|VEHSPDACQ|1|PTS_DOC_5455394||||0|0|0|0|Moniteur rapide de la fonction acquisition vitesse véhicule|
VehSpd_SdlFast_VehMng|E|();|SCH.2|VEHMNG|1|V02 NT 08 05610||||0|0|0|0|Moniteur rapide de la fonction VehSpd.
VehSpd_SdlFast_VehMngIf|D|();|SCH1.5|IFAIRSYS|1|PTS_DOC_5199971||||0|0|0|0|eve d'interface.|
VehSpd_SdlMid_MonVehSpd|C|();|SCH.2|VEHSPDDIAG|1|V02 NT 09 01664||||0|0|0|0|Moniteur moyen|
VehSpd_SdlMid_VehMng|C|();|SCH.3|VEHMNG|1|V02 NT 08 05610||||0|0|0|0|Moniteur moyen de la fonction VehSpd.
VehSpd_SdlMid_VehMux|B|();|SCH.2|VEHMUX|1|V02 NT 08 05607||||0|0|0|0|Periodic event
VehSpd_SdlSfty_MonVehSpd|A|();|SCH.3|VEHSPDDIAG|1|V02 NT 09 01664||||0|0|0|0|Evènement de calcul des fonctions safety de niveau 2.|
VEHSPDACQ_vidAccelComputation|E|();|FCT2.8|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Le calcul de l’accélération est obtenu en faisant le rapport entre la différence de vitesse entre deux impulsions et le temps écoulé entre ces deux impulsions.|
VEHSPDACQ_vidAccelMoyenCompt|C|();|FCT2.9|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|elle permet le calcul de l’accélération en faisant le rapport entre la différence de vitesse entre deux impulsions et le temps écoulé entre ces deux impulsions puis la  moyenne des huit dernières valeurs obtenues|
VEHSPDACQ_vidAcvEveVSTopCall|E|();|FCT1.2|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|L’évènement VehSpd_EveVSTop_SpdAcq n’est propagé que si l’on n’est ni en ABS ni en ESP.|
VEHSPDACQ_vidAcvSdlFastCall|E|();|FCT1.3|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|L’évènement VehSpd_SdlFast_AcqVehSpdSen n’est propagé que si l’on n’est ni en ABS ni en ESP.|
VEHSPDACQ_vidChkBatt|C|();|FCT1.6|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|La calibration VehSpd_bEnaChkBattVolt_C, lorsqu’elle vaut 1, permet d’activer la vérification des conditions d’alimentation de la batterie. Lorsqu’elle vaut 0, la vérification n’est pas faite et le booléen VehSpd_bBattVoltOK est mis à 1.|
VEHSPDACQ_vidChkCondCalc|C|();|FCT1.7|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Ici, on vérifie que la tension d’alimentation du capteur se situe entre un seuil bas et un seuil haut que l’on peut régler par calibration. Le résultat est stocké dans un booléen.|
VEHSPDACQ_vidCoveredDistance|B|();|FCT2.10|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Le calcul de la distance parcourue est fait en additionnant à la valeur précédente la distance parcourue depuis la dernière impulsion vue.|
VEHSPDACQ_vidDataAcquisition|C|();|FCT1.8|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Le premier bloc permet de faire l’acquisition des informations relatives aux impulsions qui sont transmises par le LDB. Le second permet de calculer l’intervalle de temps entre les deux dernières impulsions.|
VEHSPDACQ_vidDateOvfMng|C|();|FCT2.4|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Ce bloc permet le calcul de l’intervalle de temps entre deux impulsions dans le cas où un Overflow serait survenu.|
VEHSPDACQ_vidDynFil|E|();|FCT3.3|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Ce bloc réalise une moyenne glissante sur les VehSpd_NbPlsCalcMean_C derniers signaux.|
VEHSPDACQ_vidInit|E|();|FCT1.4|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Les différentes variables sont initialisées à 0.|
VEHSPDACQ_vidInitDistance|B|();|FCT1.5|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Initialisation de la distance parcourue. Celle si n’est faite qu’au reset, et pas lors de la détection d’un arrêt véhicule comme c’est le cas pour les autres variables.|
VEHSPDACQ_vidInitOutput|E|();|FCT1.1|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Initialisation des variables internes de la spec.|
VEHSPDACQ_vidMeanComputation|D|();|FCT3.4|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Ce bloc réalise une moyenne glissante sur les VehSpd_NbPlsCalcMean_SC derniers signaux.|
VEHSPDACQ_vidReadCtrAndDate|C|();|FCT1.9|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Lorsque les conditions d’alimentation du capteur sont bonnes, la date et le compteur d’impulsion sont transmis par le Logiciel de Base vers l’applicatif.|
VEHSPDACQ_vidSpdComputation|C|();|FCT2.7|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Ici, on réalise le calcul de la vitesse en réalisant un filtrage dynamique. Lorsque le Buffer est réinitialisé, par exemple après un reset, le calcul de la vitesse ne peut se faire que lorsqu’on a reçu au moins deux impulsions ;|
VEHSPDACQ_vidSPDHALAcq|E|();|FCT2.3|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Compteur et date correspondent à la dernière impulsion|
VEHSPDACQ_vidSPDHALDis|B|();|FCT2.2|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Désactivation du driver du capteur vitesse filaire.|
VEHSPDACQ_vidSPDHALEna|B|();|FCT2.1|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Activation du driver du capteur vitesse filaire.|
VEHSPDACQ_vidStopDetection|E|();|FCT3.1|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Ce bloc permet d’effectuer la détection d’un arrêt du véhicule.|
VEHSPDACQ_vidTiIntlComputation|C|();|FCT1.10|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Si l’on en est à la première impulsion reçue, on ne peut pas réaliser de calcul d’intervalle de temps ; on renvoie donc 0.|
VEHSPDACQ_vidTransmission|D|();|FCT3.2|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Ici, on effectue la transmission du signal à la fréquence VehSpd_SdlFast_SpdAcq_1.|
VEHSPDACQ_vidVehSpdBuf|F|();|FCT2.6|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Ce bloc effectue la gestion du Buffer.|
VEHSPDACQ_vidVehSpdComputation|D|();|FCT2.5|VEHSPDACQ|0|PTS_DOC_5455394||||0|0|0|0|Le premier bloc gère le traitement du Buffer et le second le calcul de la vitesse.  Plus bas, on calcule la distance parcourue par le véhicule.|
VEHSPDDIAG_vidActivateDiag|B|();|FCT1.5|VEHSPDDIAG|0|V02 NT 09 01664||||0|0|0|0|Gère l'activation et l'inhibition du diagnostic du capteur de vitesse véhicule.|
VEHSPDDIAG_vidCheckStabilityCond|B|();|FCT1.4|VEHSPDDIAG|0|V02 NT 09 01664||||0|0|0|0|Vérifie les conditions de stabilité du régime véhicule et celles la stabilité de la charge.|
VEHSPDDIAG_vidConsistDetectActiv|A|();|FCT1.6|VEHSPDDIAG|0|V02 NT 09 01664||||0|0|0|0|La détection du défaut revient à tester si la vitesse est insuffisante par rapport aux conditions de fonctionnement  moteur.|
VEHSPDDIAG_vidConsistency_Test|A|();|FCT1.2|VEHSPDDIAG|0|V02 NT 09 01664||||0|0|0|0|Le diagnostic de cohérence peut être inhibé manuellement si VehSpd_bInhMonVehSpd_C = 1.|
VEHSPDDIAG_vidInit|B|();|FCT1.1|VEHSPDDIAG|0|V02 NT 09 01664||||0|0|0|0|Au reset, on initialise les compteurs de points de mesures sur les conditions de stabilités du régime et de la charge.|
VEHSPDDIAG_vidMaxValDetectActiv|A|();|FCT1.8|VEHSPDDIAG|0|V02 NT 09 01664||||0|0|0|0|La détection du défaut revient à tester si la vitesse est supérieur à un seuil calibrable.|
VEHSPDDIAG_vidMaxValueTested|B|();|FCT1.7|VEHSPDDIAG|0|V02 NT 09 01664||||0|0|0|0|Le diagnostic du capteur de vitesse véhicule est activé si : -  Auncune demande d’inhibition provenant du GAR  -  Pas d’inhibition manuelle|
VEHSPDDIAG_vidRunDiag|C|();|FCT1.3|VEHSPDDIAG|0|V02 NT 09 01664||||0|0|0|0|Le diagnostic du capteur de vitesse est activé si les conditions de stabilité du régime dans une zone spécifique et celles de la charge dans une zone spécifique sont remplies. Il sera inhibé par une demande spécifique du GAR via FRM_bInhMonVehSpd.|
VEHSPDDIAG_vidSafetyLev2|A|();|FCT1.9|VEHSPDDIAG|1|V02 NT 09 01664||||0|0|0|0| Le but de cette stratégie est de sécuriser l’entrée de mesure (vitesse véhicule) via une stratégie de niveau 2 afin de se prémunir contre les fautes latentes. Cette stratégie est appliquée sur le Test avec un seuil max de vitesse véhicule.|
VEHST_vidCompThr|C|();|FCT1.1|VEHST|0|PTS_DOC_5404370||||0|0|0|0|Les seuils Crank_to_run_engine_rpm_low et Crank_to_run_engine_rpm_high sont calculés sur la transition Moteur_tournant, aussi en interpolant les variables : coefficient de qualité carburant et température eau sur une cartographie 2D.|
VEHST_vidInitStart|B|();|FCT1.6|VEHST|0|PTS_DOC_5404370||||0|0|0|0|Initialisation des variables produites.|
VEHST_vidManageEngineCranking|B|();|FCT1.4|VEHST|0|PTS_DOC_5404370||||0|0|0|0|Fonction qui permet le traitement de l'état CRANKING|
VEHST_vidManageEngineRunning|A|();|FCT1.5|VEHST|0|PTS_DOC_5404370||||0|0|0|0|Fonction qui permet le traitement de l'état RUNNING|
VEHST_vidManageEngineStalled|B|();|FCT1.3|VEHST|0|PTS_DOC_5404370||||0|0|0|0|Fonction qui permet le traitement de l'état STALL.|
VEHST_vidStartCondition|B|();|FCT1.7|VEHST|0|PTS_DOC_5404370||||0|0|0|0|Ce bloc permet de déterminer si un démarrage est en cours et sert principalement à la fonction de délestage gérée par le BSI.|
VEHST_vidVehStateControl|B|();|FCT1.2|VEHST|0|PTS_DOC_5404370||||0|0|0|0|Fonction de commande de l'état véhicule|
vidCmdeAltScale|E|();|FCT1.11|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
vidFaultFilteringManagement|A|(argin DGOHAL_tudtChannel udtChannel,argin DGOHAL_tbfStatus bfStatus );|0xFF|DGOHAL|0|PTS_DOC_5395989||||0|0|0|1|Static API for the Filtering Feature handling.
vidLinStatusInit|E|();|FCT1.12|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
vidLinStatusNormal|E|();|FCT1.14|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
vidLinStatusShut|G|();|FCT1.15|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
vidLinStatusWakeUp|F|();|FCT1.13|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
VidMainFunction_StackCom_10MS|A|();|FCT1.8|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Call Main function: task OSTSK_C_10MS_7
VidMainFunction_StackCom_20MS|A|();|FCT1.9|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Call Main function: task OSTSK_C_20MS_5
VidMainFunction_StackCom_2_5MS|A|();|FCT1.7|COMSTMNG|0|PTS_DOC_6832731||||0|0|0|0|Call Main function: task OSTSK_C_2_5MS_1
vidSendTrame|G|();|FCT1.10|ISLIN|0|V02 NT 09 03043||||0|0|0|0|
VlvAct_EveCkSnOn_ExAcq|I|();|SCH.3|VLVACTEXACQ|1|PTS_DOC_6588648||||0|0|0|0|Fonction d'accroche à l'evenement VlvAct_EveCkSnOn_ExAcq|
VlvAct_EveCkSnOn_ExEndStop|K|();|SCH.4|VLVACTEXENDSTOP|1|PTS_DOC_5885665||||0|0|0|0|Evénement de synchronisation|
VlvAct_EveCkSnOn_InAcq|I|();|SCH.3|VLVACTINACQ|1|PTS_DOC_6588653||||0|0|0|0|Fonction d'accroche à l'evenement VlvAct_EveCkSnOn_InAcq|
VlvAct_EveCkSnOn_InEndStop|K|();|SCH.4|VLVACTINENDSTOP|1|PTS_DOC_5883893||||0|0|0|0|Evénement de synchronisation|
VlvAct_EveExCam_ExAcq|C|();|SCH.6|VLVACTEXACQ|1|PTS_DOC_6588648||||0|0|0|0|Evénement "ExCam" pour l'arbre à cames échappement.|
VlVAct_EveExCmToo_AcqVlVActPos|A|();|SCH2.11|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement dent AAC échappemen
VlvAct_EveExCmToo_ExAcq|I|();|SCH.2|VLVACTEXACQ|1|PTS_DOC_6588648||||0|0|0|0|Fonction d'accroche à l'evenement VlvAct_EveExCmToo_ExAcq|
VlvAct_EveExCmToo_ExEndStop|L|();|SCH.5|VLVACTEXENDSTOP|1|PTS_DOC_5885665||||0|0|0|0|Evènement dent AAC  échappement.|
VlvAct_EveExCmToo_ExEstim|B|();|SCH.3|VLVACTEXESTIM|1|V02 NT 09 02851||||0|0|0|0|Evènement dent AAC admission|
VlvAct_EveExCmToo_ExIf|J|();|SCH.2|VLVACTEXIF|1|PTS_DOC_5320145||||0|0|0|0|Evènement dent AAC échappement|
VlvAct_EveExCmToo_ExServo|H|();|SCH.2|VLVACTEXSERVO|1|PTS_DOC_5060920||||0|0|0|0|Evènement dent AAC admission|
VlvAct_EveInCam_InAcq|D|();|SCH.6|VLVACTINACQ|1|PTS_DOC_6588653||||0|0|0|0|Evénement "InCam" pour l'arbre à cames admission.|
VlVAct_EveInCmToo_AcqVlVActPos|A|();|SCH2.12|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement dent AAC admission
VlvAct_EveInCmToo_InAcq|I|();|SCH.2|VLVACTINACQ|1|PTS_DOC_6588653||||0|0|0|0|Fonction d'accroche à l'evenement VlvAct_EveInCmToo_InAcq|
VlvAct_EveInCmToo_InEndStop|L|();|SCH.5|VLVACTINENDSTOP|1|PTS_DOC_5883893||||0|0|0|0|Evènement dent AAC  admission.|
VlvAct_EveInCmToo_InEstim|C|();|SCH.3|VLVACTINESTIM|1|V02 NT 09 01756||||0|0|0|0|Evènement dent AAC admission|
VlvAct_EveInCmToo_InIf|G|();|SCH.2|VLVACTINIF|1|PTS_DOC_5320155||||0|0|0|0|Evènement dent AAC admission|
VlvAct_EveInCmToo_InServo|H|();|SCH.2|VLVACTINSERVO|1|PTS_DOC_5060915||||0|0|0|0|Evènement dent AAC admission|
VlvAct_EveKOf_ExCln|C|();|SCH.3|VLVACTEXCLN|1|V02 NT 08 08235||||0|0|0|0|Evénement associé au passage de clef ON à clef OFF
VlvAct_EveKOf_InCln|C|();|SCH.3|VLVACTINCLN|1|V02 NT 08 08234||||0|0|0|0|Evénement associé au passage de clef ON à clef OFF
VlvAct_EveKOn_ExAcq|I|();|SCH.5|VLVACTEXACQ|1|PTS_DOC_6588648||||0|0|0|0|Fonction d'accroche à l'evenement VlvAct_EveKOn_ExAcq|
VlvAct_EveKOn_ExEndStop|J|();|SCH.2|VLVACTEXENDSTOP|1|PTS_DOC_5885665||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON|
VlvAct_EveKOn_ExServo|H|();|SCH.4|VLVACTEXSERVO|1|PTS_DOC_5060920||||0|0|0|0|Clef on|
VlvAct_EveKOn_InAcq|I|();|SCH.5|VLVACTINACQ|1|PTS_DOC_6588653||||0|0|0|0|Fonction d'accroche à l'evenement VlvAct_EveKOn_InAcq|
VlvAct_EveKOn_InEndStop|K|();|SCH.2|VLVACTINENDSTOP|1|PTS_DOC_5883893||||0|0|0|0|Evénement associé au passage de clef OFF à clef ON|
VlvAct_EveKOn_InServo|H|();|SCH.4|VLVACTINSERVO|1|PTS_DOC_5060915||||0|0|0|0|Clef on|
VlvAct_EvePwrl_ExEndStop|E|();|SCH.8|VLVACTEXENDSTOP|1|PTS_DOC_5885665||||0|0|0|0|Evénement powerlatch|
VlvAct_EvePwrl_InEndStop|D|();|SCH.8|VLVACTINENDSTOP|1|PTS_DOC_5883893||||0|0|0|0|Evénement powerlatch|
VlvAct_EveRst_AcqVlVActPos|A|();|SCH2.10|LAYERSYNC|1|PTS_DOC_6944973||||0|0|0|0|Evènement Reset
VlvAct_EveRst_ExActrTest|D|();|SCH.2|VLVACTEXACTRTEST|1|V02 NT 09 05825||||0|0|0|0|Evènement reset du calculateur|
VlvAct_EveRst_ExCln|A|();|SCH.1|VLVACTEXCLN|1|V02 NT 08 08235||||0|0|0|0|Evènement reset du calculateur
VlvAct_EveRst_ExCmd|D|();|SCH.1|VLVACTEXCMD|1|PTS_DOC_6588622||||0|0|0|0|Evènement reset du calculateur|
VlvAct_EveRst_ExEndStop|J|();|SCH.1|VLVACTEXENDSTOP|1|PTS_DOC_5885665||||0|0|0|0|Evènement reset du calculateur|
VlvAct_EveRst_ExIf|C|();|SCH.1|VLVACTEXIF|1|PTS_DOC_5320145||||0|0|0|0|Fonction d'accroche moniteur à l'évenement Reset|
VlvAct_EveRst_ExServo|G|();|SCH.1|VLVACTEXSERVO|1|PTS_DOC_5060920||||0|0|0|0|Evènement reset du calculateur|
VlvAct_EveRst_ExVlvSpBenchMod|B|();|SCH.1|VLVACTEXVLVBENCHMOD|1|V02 NT 09 08224||||0|0|0|0|Event Reset|
VlvAct_EveRst_InActrTest|D|();|SCH.2|VLVACTINACTRTEST|1|V02 NT 09 05822||||0|0|0|0|Evènement reset du calculateur|
VlvAct_EveRst_InCln|A|();|SCH.1|VLVACTINCLN|1|V02 NT 08 08234||||0|0|0|0|Evènement reset du calculateur
VlvAct_EveRst_InCmd|C|();|SCH.1|VLVACTINCMD|1|PTS_DOC_6588664||||0|0|0|0|Evènement reset du calculateur|
VlvAct_EveRst_InEndStop|J|();|SCH.1|VLVACTINENDSTOP|1|PTS_DOC_5883893||||0|0|0|0|Evènement reset du calculateur.|
VlvAct_EveRst_InIf|B|();|SCH.1|VLVACTINIF|1|PTS_DOC_5320155||||0|0|0|0|Evènement reset du calculateur .|
VlvAct_EveRst_InServo|G|();|SCH.1|VLVACTINSERVO|1|PTS_DOC_5060915||||0|0|0|0|Evènement reset du calculateur|
VlvAct_EveRst_InVlvSpBenchMod|B|();|SCH.1|VLVACTINVLVBENCHMOD|1|V02 NT 09 07770||||0|0|0|0|Event Reset|
VlvAct_EveRstVVT_ExEndStop|D|();|SCH.7|VLVACTEXENDSTOP|1|PTS_DOC_5885665||||0|0|0|0|Runnable Demande de reset apprentissage VVT|
VlvAct_EveRstVVT_InEndStop|D|();|SCH.7|VLVACTINENDSTOP|1|PTS_DOC_5883893||||0|0|0|0|Runnable Demande de reset apprentissage VVT.|
VlvAct_EveTDC_ExAcq|I|();|SCH.4|VLVACTEXACQ|1|PTS_DOC_6588648||||0|0|0|0|Fonction d'accroche à l'evenement VlvAct_EveTDC_ExAcq|
VlvAct_EveTDC_InAcq|I|();|SCH.4|VLVACTINACQ|1|PTS_DOC_6588653||||0|0|0|0|Fonction d'accroche à l'evenement VlvAct_EveTDC_InAcq|
VlvAct_SdlFast_CmdDiagVlvActEx|A|();|SCH1.4|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Moniteur rapide pour la fonction VVT échappement.
VlvAct_SdlFast_CmdDiagVlvActIn|A|();|SCH1.5|ACQDGOHAL|1|PTS_DOC_6669624||||0|0|0|0|Moniteur rapide pour la fonction VVT admission.
VlvAct_SdlFast_CmdPwmVlvActEx|A|();|SCH.2|CMDPWM|1|PTS_DOC_6669891||||0|0|0|0|Evènement moniteur rapide de la fonction VVT échappement.
VlvAct_SdlFast_CmdPwmVlvActIn|A|();|SCH.1|CMDPWM|1|PTS_DOC_6669891||||0|0|0|0|Evènement moniteur rapide de la fonction VVT admission.
VlvAct_SdlFast_ExAcq|B|();|SCH.7|VLVACTEXACQ|1|PTS_DOC_6588648||||0|0|0|0|Moniteur rapide.|
VlvAct_SdlFast_ExActrTest|D|();|SCH.1|VLVACTEXACTRTEST|1|V02 NT 09 05825||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_ExCln|D|();|SCH.2|VLVACTEXCLN|1|V02 NT 08 08235||||0|0|0|0|Moniteur rapide de la fonction VVT
VlvAct_SdlFast_ExCmd|D|();|SCH.3|VLVACTEXCMD|1|PTS_DOC_6588622||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_ExEndStop|J|();|SCH.6|VLVACTEXENDSTOP|1|PTS_DOC_5885665||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_ExEstim|B|();|SCH.2|VLVACTEXESTIM|1|V02 NT 09 02851||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_ExIf_1|H|();|SCH.3|VLVACTEXIF|1|PTS_DOC_5320145||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_ExIf_2|H|();|SCH.4|VLVACTEXIF|1|PTS_DOC_5320145||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_ExMng_1|D|();|SCH.2|VLVACTEXMNG|1|V02 NT 08 07819||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_ExMng_2|D|();|SCH.3|VLVACTEXMNG|1|V02 NT 08 07819||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_Sdlfast_ExMon|C|();|SCH.2|VLVACTEXMON|1|V02 NT 09 06481||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_ExServo|H|();|SCH.3|VLVACTEXSERVO|1|PTS_DOC_5060920||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_ExVlvSpBenchMod|B|();|SCH.2|VLVACTEXVLVBENCHMOD|1|V02 NT 09 08224||||0|0|0|0|Fast schedule of the valve actuator function|
VlvAct_SdlFast_InAcq|C|();|SCH.7|VLVACTINACQ|1|PTS_DOC_6588653||||0|0|0|0|Moniteur rapide pour la fonction VLVACTINACQ.|
VlvAct_SdlFast_InActrTest|D|();|SCH.1|VLVACTINACTRTEST|1|V02 NT 09 05822||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_InCln|E|();|SCH.2|VLVACTINCLN|1|V02 NT 08 08234||||0|0|0|0|Moniteur rapide de la fonction VVT
VlvAct_SdlFast_InCmd|C|();|SCH.3|VLVACTINCMD|1|PTS_DOC_6588664||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_InEndStop|I|();|SCH.6|VLVACTINENDSTOP|1|PTS_DOC_5883893||||0|0|0|0|Moniteur rapide pour la fonction VVT.|
VlvAct_SdlFast_InEstim|C|();|SCH.2|VLVACTINESTIM|1|V02 NT 09 01756||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_InIf_1|C|();|SCH.3|VLVACTINIF|1|PTS_DOC_5320155||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_InIf_2|C|();|SCH.4|VLVACTINIF|1|PTS_DOC_5320155||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_InIf_3|B|();|SCH.5|VLVACTINIF|1|PTS_DOC_5320155||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_InMng_1|D|();|SCH.2|VLVACTINMNG|1|V02 NT 08 07174||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_InMng_2|D|();|SCH.3|VLVACTINMNG|1|V02 NT 08 07174||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_Sdlfast_InMon|B|();|SCH.2|VLVACTINMON|1|V02 NT 09 06381||||0|1|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_InServo|H|();|SCH.3|VLVACTINSERVO|1|PTS_DOC_5060915||||0|0|0|0|Moniteur rapide pour la fonction VVT|
VlvAct_SdlFast_InVlvSpBenchMod|B|();|SCH.2|VLVACTINVLVBENCHMOD|1|V02 NT 09 07770||||0|0|0|0|Fast schedule of the valve actuator function|
VlvAct_SdlMid_ExCmd|D|();|SCH.2|VLVACTEXCMD|1|PTS_DOC_6588622||||0|0|0|0|Moniteur moyen pour la fonction VVT|
VlvAct_SdlMid_InCmd|C|();|SCH.2|VLVACTINCMD|1|PTS_DOC_6588664||||0|0|0|0|Moniteur moyen pour la fonction VVT|
VlvAct_SdlSlow_ExEndStop|J|();|SCH.3|VLVACTEXENDSTOP|1|PTS_DOC_5885665||||0|0|0|0|Moniteur Lent pour la fonction VVT|
VlvAct_SdlSlow_InEndStop|K|();|SCH.3|VLVACTINENDSTOP|1|PTS_DOC_5883893||||0|0|0|0|Moniteur Lent pour la fonction VVT|
VLVACTEXACQ_vidCamTargetState|E|();|FCT1.6|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction pour la la lecture de l’état de la cible de l’arbre à cames échappement à partir des basses couches logicielles (LDB).|
VLVACTEXACQ_vidCurrentShift|F|();|FCT1.4|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Processus de mesure du décalage|
VLVACTEXACQ_vidCurrentVelo|H|();|FCT3.1|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Ce bloc calcule la valeur de la vitesse de décalage de l’AAC d’échappement|
VLVACTEXACQ_vidCurrentVelocity|D|();|FCT1.5|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction de calcul de la valeur de la vitesse de décalage de l’AAC d'échappement|
VLVACTEXACQ_vidEntryInit|A|();|SCH.1|VLVACTEXACQ|1|PTS_DOC_6588648||||0|0|0|0|Foction d'accroche moniteur pour le Reset du calculateur|
VLVACTEXACQ_vidExCamEngineSpd|C|();|FCT2.6|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction pour la reconstitution du  régime moteur à partir de l’intervalle  de temps et de l’écart angulaire théorique entre deux évènements dents AAC échappement.|
VLVACTEXACQ_vidExhaustCalcul|B|();|FCT2.4|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction de calcul de la valeur de la vitesse de décalage de l’AAC d’échappement|
VLVACTEXACQ_vidExhaustCaptCalc|C|();|FCT2.3|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction de calcul du décalage à partir des mesures sur les fronts dents AAC|
VLVACTEXACQ_vidExhaustDiagnosis|D|();|FCT2.5|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Cette fonction réalise le diagnostic pmh|
VLVACTEXACQ_vidExhaustPmhCounter|E|();|FCT3.4|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Cette fonction réalise  le  diagnostic  sur  le  nombre  de  pmh  vu   successivement (c'est à dire sans événement dent AAC intercalé)|
VLVACTEXACQ_vidExhaustPmhDiag|D|();|FCT1.8|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction pour éviter les problèmes de synchronisation lors des démarrages à froid .|
VLVACTEXACQ_vidExhaustResyn|D|();|FCT3.3|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction de resynchronisation du compteur dent AAC sur une panne présente pmh ou/et décalage|
VLVACTEXACQ_vidExhaustResynchro|B|();|FCT1.7|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction de resynchronisation du compteur dent AAC sur une panne présente pmh ou/et décalage|
VLVACTEXACQ_vidExhaustRisingCapt|K|();|FCT2.1|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction  de prise en compte du nombre de dents de la cible AAC|
VLVACTEXACQ_vidExhautsDiagnosis|B|();|FCT2.5|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Cette fonction réalise le diagnostic pmh|
VLVACTEXACQ_vidInit|C|();|FCT1.3|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Ce bloc initialise, sur front montant de Moteur_synchronisé, les variables suivantes : - Vta_exhaust_camshaft_shift et Vta_exhaust_tooth_counter (compteur de dents )|
VLVACTEXACQ_vidInitOutput|J|();|FCT1.1|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Initialisation des variables de sortie|
VLVACTEXACQ_vidInitPannes|B|();|FCT1.2|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Les pannes VVT présentes sont initialisées sur clé off/on afin de ne pas rester figées entre le clé on et le démarrage du moteur.|
VLVACTEXACQ_vidIntCamshaftEdge|B|();|FCT3.5|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Sur l’événement ExCam, le compteur de fronts utiles est incrémenté.|
VLVACTEXACQ_vidMissToothbMonRun|A|();|FCT3.8|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction de calcul de la variable VlvAct_bMonRunMissToothVlvActEx.|
VLVACTEXACQ_vidORngShiftbMonRun|A|();|FCT3.7|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction de calcul de la variable VlvAct_bMonRunORngShiftVlvActEx.|
VLVACTEXACQ_vidORngSpdVlvbMonRun|A|();|FCT3.6|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction de calcul de la variable VlvAct_bMonRunORngSpdVlvActEx.|
VLVACTEXACQ_vidSecondOrderFilter|H|();|FCT3.2|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction de calcul d'un filtre du second d'ordre|
VLVACTEXACQ_vidTDCDiagbMonRun|A|();|FCT3.9|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Fonction de calcul de la variable VlvAct_bMonRunTDCDiagVlvActEx.|
VLVACTEXACQ_vidTraitementXDent|E|();|FCT2.2|VLVACTEXACQ|0|PTS_DOC_6588648||||0|0|0|0|Detection d'un  fonctionnement  sur une dent  ratée   en contrôlant  le  temps entre deux dents consécutives.|
VLVACTEXACTRTEST_vidAgregatedErr|C|();|FCT1.5|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|Dans ce bloc est calculée l’erreur statique cumulée pour chaque phase stabilisée de la consigne envoyée lors  du test actionneur de la VVT échappement|
VLVACTEXACTRTEST_vidCalcSdlFast|B|();|FCT1.2|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule de l'evenement SdlFast.|
VLVACTEXACTRTEST_vidCriteriaCalc|B|();|FCT1.3|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|Ce bloc calcule deux types de critère :Pour les rampes ou échelons on calcule le retard ( erreur de vitesse ) ET Pour les phases stabilisées du profil, on calcule l’erreur statique.|
VLVACTEXACTRTEST_vidEndStTrans|B|();|FCT3.6|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule de l'etat  EXVLVACT_ACTRTST_END|
VLVACTEXACTRTEST_vidFstSpdErrClc|C|();|FCT1.9|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule du retard.|
VLVACTEXACTRTEST_vidIdleStTrans|B|();|FCT2.5|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule de l'etat EXVLVACT_ACTRTST_IDLE|
VLVACTEXACTRTEST_vidInitializati|C|();|FCT1.1|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|initialisation des variables de sorties et de l'automate.|
VLVACTEXACTRTEST_vidMeaCriTiComp|B|();|FCT2.1|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule du temps nécessaire pour atteindre la valeur final.(Pour la mesure)|
VLVACTEXACTRTEST_vidPhase10Trans|B|();|FCT3.5|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule de l'etat INVLVACT_ACTRTST_PHASE10|
VLVACTEXACTRTEST_vidPhase1Trans|B|();|FCT2.6|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule de l'etat EXVLVACT_ACTRTST_PHASE1|
VLVACTEXACTRTEST_vidPhase2Trans|B|();|FCT2.7|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule de l'etat EXVLVACT_ACTRTST_PHASE2|
VLVACTEXACTRTEST_vidPhase3Trans|B|();|FCT2.8|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule de l'etat EXVLVACT_ACTRTST_PHASE3|
VLVACTEXACTRTEST_vidPhase4Trans|C|();|FCT2.9|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule  de l'etat EXVLVACT_ACTRTST_PHASE4|
VLVACTEXACTRTEST_vidPhase5Trans|B|();|FCT2.10|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule  de l'etat EXVLVACT_ACTRTST_PHASE5|
VLVACTEXACTRTEST_vidPhase6Trans|B|();|FCT3.1|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule de l'etat EXVLVACT_ACTRTST_PHASE6|
VLVACTEXACTRTEST_vidPhase7Trans|B|();|FCT3.2|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule de l'etat EXVLVACT_ACTRTST_PHASE7|
VLVACTEXACTRTEST_vidPhase8Trans|B|();|FCT3.3|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule de l'etat EXVLVACT_ACTRTST_PHASE8|
VLVACTEXACTRTEST_vidPhase9Trans|B|();|FCT3.4|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|calcule de l'etat EXVLVACT_ACTRTST_PHASE9|
VLVACTEXACTRTEST_vidSetpointComp|C|();|FCT2.4|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|Ce bloc génère le profil de consigne envoyé lors du test actionneur de la VVT échappement.|
VLVACTEXACTRTEST_vidSetpointCrit|B|();|FCT1.10|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|on calcule du temps nécessaire pour atteindre la valeur finale .(Pour la consigne  )|
VLVACTEXACTRTEST_vidSpdErrExCalc|C|();|FCT2.3|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|Dans ce bloc sont calculées les indicateurs d’erreurs de vitesse sur les différentes rampes de  la consigne  envoyée lors du test actionneur de la VVT échappement.|
VLVACTEXACTRTEST_vidSpeedErrorCo|B|();|FCT1.8|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|Pour les phases stabilisées du profil, on calcule l’erreur statique.|
VLVACTEXACTRTEST_vidSpeedErrorMe|B|();|FCT2.2|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|Dans ce bloc sont calculées les différents coefficients intervenant dans le calcul du seuil utilisé pour le calcul de  l’erreur de vitesse.|
VLVACTEXACTRTEST_vidStatErrorCom|B|();|FCT1.4|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|Dans ce bloc sont calculées les erreurs statiques.|
VLVACTEXACTRTEST_vidStatErrorMea|C|();|FCT1.6|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|Dans ce bloc sont calculées pour chaque phases stabilisées du profil de consigne envoyé lors du test  actionneur de la VVT échappement, les indices de temps utilisés dans le calcul de l’erreur statique moyenne.|
VLVACTEXACTRTEST_vidStErrCritClc|C|();|FCT1.7|VLVACTEXACTRTEST|0|V02 NT 09 05825||||0|0|0|0|Dans ce bloc sont calculées les indicateurs d’erreurs statiques sur les différentes portions stabilisées de  la  consigne envoyée lors du test actionneur de la VVT échappement.|
VLVACTEXCLN_vidClnAlgCalc|C|();|FCT2.1|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|calculer la durée de chaque impulsion de la commande envoyée pour le nettoyage et selectionner le mode (préventif ou curatif).
VLVACTEXCLN_vidClnCnd|E|();|FCT2.2|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|selectionner le mode curatif ou préventif.
VLVACTEXCLN_vidClnInCnteFrstcln|A|();|FCT1.5|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Ce bloc incrémente l’index de temps utilisé dans la cartographie générant la commande de nettoyage en mode préventif.
VLVACTEXCLN_vidClnIndTiCnt|C|();|FCT1.2|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Index du compteur pour le mode curatif et le mode préventif.
VLVACTEXCLN_vidClnIndTmCntPct|A|();|FCT1.4|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Ce bloc incrémente l’index de temps utilisé dans la cartographie générant la commande de nettoyage en mode préventif.
VLVACTEXCLN_vidClnIndTmCntRct|A|();|FCT1.3|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Ce bloc incrémente l’index de temps utilisé dans la cartographie générant la commande de nettoyage en mode curatif.
VLVACTEXCLN_vidCmdCalc|F|();|FCT1.9|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Le nettoyage (mode préventif, mode curatif, sortie usine) se fait suivant un profil de commande définit par les cartographies VlvAct_ExNormClnCmd_M, VlvAct_ExHealClnCmd_M et VlvAct_ExFrstClnCmd_M.
VLVACTEXCLN_vidCmdcmp|D|();|FCT1.8|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Activation du nettoyage de l'électrovanne VVT échappement
VLVACTEXCLN_vidErrCntRst|B|();|FCT2.4|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Quand l’erreur Vcpe_cam_position_error est revenue dans des limites acceptables le compteur de nettoyages en mode curatif est réinitialisé.
VLVACTEXCLN_vidErrCountRst|C|();|FCT1.6|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|remise à zero de la variable VlvAct_CtInHealClnErr
VLVACTEXCLN_vidFrstCleaCond|A|();|FCT1.10|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Le mode de nettoyage sortie usine « nettoyage moteur neuf » doit permettre l’élimination des copeaux d’usinage présents dans le circuit d’huile qui n’auraient pas pu être supprimés lors du nettoyage réalisé après le montage du moteur à l’usine moteur.
VLVACTEXCLN_vidFrstCleanVarUpdte|A|();|FCT2.10|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Mise à jour de VlvAct_ctExFrstClnCyc
VLVACTEXCLN_vidhealClnMngTimeRst|A|();|FCT3.1|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Réinitialisation de la durée de surveillance de l'erreur pour la VVT échappement en mode curatif
VLVACTEXCLN_vidInitOutput|I|();|FCT1.1|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|initialisation
VLVACTEXCLN_vidManCleanVarUpdate|A|();|FCT2.9|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Mise à jour de la variable  VlvAct_bExManClnEnaIdc
VLVACTEXCLN_vidPctClnVarUdt|C|();|FCT2.8|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|mise à jour des variables VlvAct_tiExNormClnIdc et VlvAct_bExNormClnEnd.
VLVACTEXCLN_vidPctcnd|F|();|FCT2.7|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Le nettoyage en mode préventif se déroule lors de phases impactant peu le fonctionnement moteur (ralenti,coupure d’injection).Il est lancé suivant une récurrence définit par la calibration VlvAct_tiExNormClnDly_C.
VLVACTEXCLN_vidRctClnUdt|A|();|FCT1.7|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Mise à jour des variables liées aux nettoyages curatifs
VLVACTEXCLN_vidRctClnVarUdt|E|();|FCT2.5|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|A chaque fois qu’un cycle de nettoyage en mode curatif se termine on incrémente le compteur VlvAct_CtExHealClnErr.
VLVACTEXCLN_vidRctCnd|I|();|FCT2.3|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Le nettoyage en mode curatif est lancé lorsque l’erreur Vcpe_cam_position_error est supérieure à un seuil durant une certaine période.
VLVACTEXCLN_vidRctCndFrtcln|D|();|FCT2.6|VLVACTEXCLN|0|V02 NT 08 08235||||0|0|0|0|Le nettoyage en mode curatif est lancé lorsque l’erreur Vcpe_cam_position_error est supérieure à un seuil.
VLVACTEXCMD_vidBatteryComp|D|();|FCT1.4|VLVACTEXCMD|0|PTS_DOC_6588622||||0|0|0|0|Pour éviter que les variations de la tension batterie ne perturbent la commande on a trois mode de compensation: pas de compensation, compensation linéaire, compensation du second ordre.|
VLVACTEXCMD_vidDiagnostic|B|();|FCT1.6|VLVACTEXCMD|0|PTS_DOC_6588622||||0|0|0|0|Fonction de diagnostique défaut du driver de la VVT échappement.|
VLVACTEXCMD_vidEnablePwm|D|();|FCT1.3|VLVACTEXCMD|0|PTS_DOC_6588622||||0|0|0|0|Lors de la demande de fonctionnement de la VVT echappement (Demande_vvt_adm_dormant = 0), on active le driver de la VVT echappement (Autorisation_pwm_echap = 1) si la tension batterie se situe dans la plage de fonctionnement prédéfinie.|
VLVACTEXCMD_vidInitialization|C|();|FCT1.2|VLVACTEXCMD|0|PTS_DOC_6588622||||0|0|0|0|A l’initialisation de l’ECU, la valeur de consigne RCO appliquée est nulle ; la fréquence du signal RCO est configurable par calibration et mise à jour uniquement à ce moment.|
VLVACTEXCMD_vidInitOutput|A|();|FCT1.1|VLVACTEXCMD|0|PTS_DOC_6588622||||0|0|0|0|Initialisation des sorties|
VLVACTEXCMD_vidPwmCommand|E|();|FCT1.5|VLVACTEXCMD|0|PTS_DOC_6588622||||0|0|0|0|Lorsque le driver est activé, le module PWM correspondant à la commande VVT echappement est réglé pour générer le signal RCO désiré.|
VLVACTEXENDSTOP_ExtOffIndUpdate|C|();|FCT2.10|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Mise à jour de l'etat de l'apprentissage des butées de l'AAC échappement.|
VLVACTEXENDSTOP_ExtOffIndUpdate1|E|();|FCT3.2|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Cette fonction permet le forçage à 1 de l'indicateur Vcpe_cam_offsets_are_learned lorsque les conditions d'apprentissage sont perdues.|
VLVACTEXENDSTOP_vidEepromWrite|C|();|FCT3.1|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Fonction d'écriture dans EEPROM|
VLVACTEXENDSTOP_vidExhaustOff|L|();|FCT2.1|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Ce bloc calcule la valeur de décalage de l’AAC de l'échappement en soustrayant à la dernière valeur acquise de l’angle vilebrequin une valeur de référence apprise ou calibrée pour chacune des dents de la cible AAC.|
VLVACTEXENDSTOP_vidExOffReset|E|();|FCT1.9|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|exhaust offset reset.|
VLVACTEXENDSTOP_vidExOffsets|M|();|FCT2.2|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Lors  d'un  apprentissage  en  fonctionnement  si  le  contrôle  moteur  demande  un  décalage  on  sort  de l'apprentissage  pour  revenir  en  mode  asservi. L'apprentissage  en  fonctionnement  se  fera  lors  du  prochain passage au ralenti.|
VLVACTEXENDSTOP_vidExtAllowLearn|I|();|FCT1.8|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Ce bloc détermine quand peut commencer l'apprentissage des offsets après démarrage. Il y a trois conditions calibrables: un seuil de régime, un délai après synchronisation et un délai après que la consigne soit nulle.|
VLVACTEXENDSTOP_vidExtAllowLrng|H|();|FCT1.7|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Condition pour commencer l'apprentissage des offsets après démarrage.|
VLVACTEXENDSTOP_vidFrstOffLrnCon|J|();|FCT2.9|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Le premier apprentissage est réalisé si et seulement si plusieurs conditions (température  et pression d’huile, température d’eau, régime et pas de mode dégradé pour la VVT  admission)  sont réalisées.|
VLVACTEXENDSTOP_vidFrtLrnWtDfCpt|B|();|FCT3.3|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Cette   fonction est active dés que FRM_bInhVlvActExFrstLrnIdc égale à 0.|
VLVACTEXENDSTOP_vidInitDiagSrv|D|();|FCT1.10|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Ce bloc procède à l’initialisation des variables suivantes suite à une demande APV : - Valeur apprentissage butée basse déphaseur AAC échappement - Etat apprentissage déphaseur AAC échappement - Etat apprentissage roulage en cours échappement|
VLVACTEXENDSTOP_vidInitFailure|D|();|FCT1.2|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Les pannes VVT présentes sont initialisées sur clé off-on afin de ne pas rester figées entre le clé on et le démarrage du moteur.|
VLVACTEXENDSTOP_vidInitOutput|H|();|FCT1.1|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Initialisation des sorties au reset.|
VLVACTEXENDSTOP_vidLearningDiag|K|();|FCT2.3|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Les offsets mesurés sont appris en EEPROM si on n'a pas eu de panne, si le moteur est chaud et si on pas eu de fonctionnement 3 dents pendant cet apprentissage. Cette fonction permet d'actualiser la variable offset.|
VLVACTEXENDSTOP_vidLearningReset|D|();|FCT1.4|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|apprentissage des offsets en cours d'utilisation|
VLVACTEXENDSTOP_vidLstLrnTmpCntr|D|();|FCT1.5|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|On décrémente la temporisation depuis le dernier apprentissage.|
VLVACTEXENDSTOP_vidMemoirisaCond|D|();|FCT2.7|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|condition de mémoirisation|
VLVACTEXENDSTOP_vidMemoirisation|B|();|FCT2.8|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Mémoirisation des valeurs de la butée  de repos de la VVT admission pour chaque dent came du précédent apprentissage.|
VLVACTEXENDSTOP_vidOffAvrgComp|B|();|FCT2.6|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Offsets average computation.|
VLVACTEXENDSTOP_vidOffCons|B|();|FCT2.5|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|On  réalise  dans  ce  bloc  un  test  pour  vérifier  que  l'écart  entre  les  valeurs  précédemment  acquises  et  les actuelles reste dans les tolérances fixées.|
VLVACTEXENDSTOP_vidOffLrnErrDet|C|(argin uint16 u16Margin,argin uint16 *u16ExhaustAngle,uint16 *u16OffMes,argout boolean *bErrDet);|FCT2.4|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Controler l'écart entre les valeurs précédemment acquises et les actuelles pour détecter un problème.|
VLVACTEXENDSTOP_vidOffsetsReset|K|();|FCT1.3|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Possibilités pour lancer un apprentissage des offsets en cours d'utilisation|
VLVACTEXENDSTOP_vidPrvLrnErDetec|B|();|FCT3.4|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Cette fonction réalize un test pour vérifier que  l'écart entre les valeurs précédemment acquises et  les actuelles reste dans les tolérances fixées.|
VLVACTEXENDSTOP_vidReset|L|();|FCT1.6|VLVACTEXENDSTOP|0|PTS_DOC_5885665||||0|0|0|0|Vcpe_cam_offsets: angles de référence ou offsets appris précédemment --> offsets de position. Vcpe_cam_offsets_are_learned: flag fin d’apprentissage|
VLVACTEXESTIM_vidDeadZone|C|();|FCT1.4|VLVACTEXESTIM|0|V02 NT 09 02851||||0|0|0|0|Calcul de la consigne RCO de commande normalisée de la VVT échappement.|
VLVACTEXESTIM_vidEntryInit|B|();|SCH.1|VLVACTEXESTIM|1|V02 NT 09 02851||||0|0|0|0|Initialisation function|
VLVACTEXESTIM_vidEstimGainCmp|B|();|FCT1.5|VLVACTEXESTIM|0|V02 NT 09 02851||||0|0|0|0|Calcul du gain du dénominateur et du numérateur de la fonction de transfert du modèle VVT échappement.|
VLVACTEXESTIM_vidExPosnEstimCmp|D|();|FCT1.2|VLVACTEXESTIM|0|V02 NT 09 02851||||0|0|0|0|L’estimation temporelle du décalage AAC peut être inhibée totalement ou partiellement|
VLVACTEXESTIM_vidExPosnEstimUpd|E|();|FCT1.7|VLVACTEXESTIM|0|V02 NT 09 02851||||0|0|0|0|La seconde variable d’état (variable du décalage) du filtre estimateur est mise à jour à chaque évènement d’acquisition.|
VLVACTEXESTIM_vidExPosnEstimVar|C|();|FCT1.8|VLVACTEXESTIM|0|V02 NT 09 02851||||0|0|0|0|Après chaque mesure du décalage AAC échappement, on calcule les variations suivantes, qui donnent une indication sur la précision et le comportement du filtre estimateur par rapport à la simple mesure.|
VLVACTEXESTIM_vidFilCmp|A|();|FCT1.3|VLVACTEXESTIM|0|V02 NT 09 02851||||0|0|0|0|Calculer la variation de l'estimation et de la mesure du décalage AAC échappement..|
VLVACTEXESTIM_vidInitOutput|A|();|FCT1.1|VLVACTEXESTIM|0|V02 NT 09 02851||||0|0|0|0|Exitialisation of the component outputs|
VLVACTEXESTIM_vidKalmanFil|C|();|FCT1.6|VLVACTEXESTIM|0|V02 NT 09 02851||||0|0|0|0|Calcul de la Variable d'état position et d'état vitesse du filtre d'estimation du décalage AAC échapprment|
VLVACTEXIF_vidCalcSatSetpoint|F|();|FCT1.9|VLVACTEXIF|0|PTS_DOC_5320145||||0|0|0|0|En cas d’incursion en dehors de la plage fonctionnelle définie par les calibrations, on renvoie à la boucle d’air les valeurs des consignes saturées qui sont mises  toutes  les deux à la même valeur de reconfiguration.|
VLVACTEXIF_vidCmOfsCmp|F|();|FCT1.4|VLVACTEXIF|0|PTS_DOC_5320145||||0|0|0|0|Le calcul du décalage de montage de l’ensemble cible AAC + actionneur VVT est déterminé lorsque l’ensemble des dents de la cible AAC sont décalés dans le même sens par rapport à leur position théorique dans le référentiel moteur.|
VLVACTEXIF_vidInitialisation|C|();|FCT1.2|VLVACTEXIF|0|PTS_DOC_5320145||||0|0|0|0|initialisations des sorties.|
VLVACTEXIF_vidInitOutput|H|();|FCT1.1|VLVACTEXIF|0|PTS_DOC_5320145||||0|0|0|0|Initialisation des sorties|
VLVACTEXIF_vidVlvActCmToothOfs|D|();|FCT1.5|VLVACTEXIF|0|PTS_DOC_5320145||||0|0|0|0|Calcul du parametre VlvAct_agCkExCmToothOfs|
VLVACTEXIF_vidVlvActOfsCmp|E|();|FCT1.6|VLVACTEXIF|0|PTS_DOC_5320145||||0|0|0|0|Lorsqu’il est activé, ce bloc permet d’estimer le décalage de montage de l’actionneur VVT à partir de l’offset de décalage constaté pour l’ensemble cible AAC + actionneur VVT|
VLVACTEXIF_vidVVTPosition|H|();|FCT1.7|VLVACTEXIF|0|PTS_DOC_5320145||||0|0|0|0|La position réelle de fermeture des soupapes d’échappement dans le référentiel moteur est calculée à partir de la valeur estimée du décalage d’AAC, issue de la loi de commande VVT échappement.|
VLVACTEXIF_vidVVTSetpoint|S|();|FCT1.8|VLVACTEXIF|0|PTS_DOC_5320145||||0|0|0|0|La consigne de décalage AAC échappement, utilisée par la loi de commande VVT échappement est calculée à  partir de la consigne en position de fermeture des soupapes à l’échappement dans le référentiel moteur.|
VLVACTEXIF_vidVVTToothErrDet|C|();|FCT1.3|VLVACTEXIF|0|PTS_DOC_5320145||||0|0|0|0|Le calcul des erreurs de géométrie ainsi que des offsets de décalage de montage de la cible et de l’actionneur VVT est effectué après chaque apprentissage des butées de repos.|
VLVACTEXMNG_vidClnStEnaCdn|D|();|FCT1.6|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|La stratégie de nettoyage de l’électrovanne de commande de l’actionneur de décalage AAC échappement n’est activée que lorsqu’une requête de nettoyage a été émise par la stratégie dédiée; cette stratégie peut également être activée manuellement.|
VLVACTEXMNG_vidEngStopAuth|C|();|FCT1.10|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|La LdC VVT échappement doit informer à tout moment les autres fonctions du contrôle moteur si la position du déphaseur VVT admission permet l’arrêt du moteur|
VLVACTEXMNG_vidEntryInit|E|();|SCH.1|VLVACTEXMNG|1|V02 NT 08 07819||||0|0|0|0|sched reset|
VLVACTEXMNG_vidInitOutput|H|();|FCT1.1|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|initialisation des sorties|
VLVACTEXMNG_vidInitStEnaCdn|E|();|FCT1.2|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|Quelque soit l’état de l’automate de gestion de la fonction VVT échappement, le décaleur doit pouvoir revenir à sa position de repos dés que les conditions de fonctionnement nominal ne sont plus réunies, afin de protéger l’actionneur de décalage.|
VLVACTEXMNG_vidLrnStEnaCdn|F|();|FCT1.4|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|L’apprentissage de la butée basse de l’actionneur de décalage AAC échappement n’est autorisé que lorsque toutes les conditions adéquates de fonctionnement moteur sont réunies|
VLVACTEXMNG_vidMngStCmd|F|();|FCT1.8|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|La commande envoyée au driver de pilotage RCO de l’électrovanne de commande VVT échappement est nulle|
VLVACTEXMNG_vidServoStEnaCdn|F|();|FCT1.5|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|Le pilotage en boucle fermé de l’actionneur de décalage AAC échappement n’est autorisé que lorsque toutes les conditions adéquates de fonctionnement moteur sont réunies|
VLVACTEXMNG_vidStMng|G|();|FCT1.7|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|Gestion de la fonction VVT échappement|
VLVACTEXMNG_vidTimer1|A|();|FCT1.3|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|Calcul des sorties des Timers 1 et 2|
VLVACTEXMNG_vidTimer2|B|();|FCT1.9|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|Calcul des sorties des Timers 3 et 4|
VLVACTEXMNG_vidUnlckStr|C|();|FCT2.1|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|Stratégie de désengagement du pion de blocage VVT échappement.|
VLVACTEXMNG_vidUnlockStrategy|B|();|FCT2.2|VLVACTEXMNG|0|V02 NT 08 07819||||0|0|0|0|Automate de la stratégie de désengagement du pion de blocage VVT échappement.|
VLVACTEXMON_vidColdDefServoDet|B|();|FCT1.7|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc calcule la valeur absolue de la différence entre l'angle mesurée et l’angle de consigne à froid de la VVT échappement|
VLVACTEXMON_vidColdDiagActCond|B|();|FCT1.5|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc calcule l’activation du diagnostic fonctionnel temps de réponse à froid de la VVT échappement|
VLVACTEXMON_vidColdDiagCalc|A|();|FCT1.6|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc calcule le diagnostic fonctionnel temps de réponse à froid de la VVT échappement|
VLVACTEXMON_vidColdDiagComp|A|();|FCT1.4|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc vérifie le temps de réponse de la VVT échappement à froid|
VLVACTEXMON_vidEntryInit|A|();|SCH.1|VLVACTEXMON|1|V02 NT 09 06481||||0|0|0|0|Fonction d'accroche Reset|
VLVACTEXMON_vidFstColdTempTest|C|();|FCT1.8|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le premier test de temporisation à froid|
VLVACTEXMON_vidFstHotStkTempTest|C|();|FCT3.5|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de départ à un seuil minimum d'écart de boucle pour le premier test de temporisation si la VVT échappement est bloquée à chaud|
VLVACTEXMON_vidFstHotTempTest|C|();|FCT2.5|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le premier test de temporisation à chaud|
VLVACTEXMON_vidHotDefServoDet|B|();|FCT2.4|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc calcule la valeur absolue de la différence entre l'angle mesurée et l’angle de consigne à chaud de la VVT échappement|
VLVACTEXMON_vidHotDiagActCond|B|();|FCT2.2|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc calcule l’activation du diagnostic fonctionnel temps de réponse à chaud de la VVT échappement|
VLVACTEXMON_vidHotDiagCalc|A|();|FCT2.3|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc calcule le diagnostic fonctionnel temps de réponse à chaud de la VVT échappement|
VLVACTEXMON_vidHotDiagComp|A|();|FCT2.1|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc vérifie le temps de réponse de la VVT échappement à chaud|
VLVACTEXMON_vidHotStkDefServoDet|B|();|FCT3.4|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc calcule la valeur absolue de la différence entre l'angle mesurée et l’angle de départ si la VVT échappement est bloquée à chaud|
VLVACTEXMON_vidHotStkDiagActCond|B|();|FCT3.2|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc calcule l’activation du diagnostic fonctionnel déphaseur bloqué à chaud de la VVT échappement|
VLVACTEXMON_vidHotStkDiagCalc|B|();|FCT3.3|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc calcule le diagnostic fonctionnel si la VVT échappement est bloquée à chaud|
VLVACTEXMON_vidHotStkDiagComp|A|();|FCT3.1|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc vérifie si la VVT échappement est bloquée à chaud|
VLVACTEXMON_vidInitialization|C|();|FCT1.1|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Initialisation des variables|
VLVACTEXMON_vidInitOffValComp|B|();|FCT1.3|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc met à jour la valeur initiale de l'offset|
VLVACTEXMON_vidNegStatErrorDiag|A|();|FCT3.8|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|ce module calcule la différence entre la consigne et la position du déphaseur cette différence est ensuite comparée à deux seuils et en fonction de la valeur de la différence par rapport aux seuils les diagnostics sont levés.|
VLVACTEXMON_vidOffsetSetPtComp|B|();|FCT1.2|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc calcule la valeur de l'offset initiale|
VLVACTEXMON_vidPosStatErrorDiag|A|();|FCT3.6|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|ce bloc calcule la différence entre la position du déphaseur AAC échappement mesurée et la consigne et en fonction de la valeur de la différence par rapport à l’un ou l’autre des seuils les diagnostics sont levés.|
VLVACTEXMON_vidSndColdTempTest|C|();|FCT1.9|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le deuxième test de temporisation à froid|
VLVACTEXMON_vidSndHotTempTest|C|();|FCT2.6|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le deuxième test de temporisation à chaud|
VLVACTEXMON_vidThrdColdTemp|C|();|FCT1.10|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le troisième test de temporisation à froid|
VLVACTEXMON_vidThrdHotTemp|C|();|FCT2.7|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le troisième test de temporisation à froid|
VLVACTEXMON_vidTime_index_reset|A|();|FCT3.7|VLVACTEXMON|0|V02 NT 09 06481||||0|0|0|0|ce module initialise l'intervalle de temps pour le déclenchement des diagnostics.|
VLVACTEXSERVO_vidCalPeakToPNoise|D|();|FCT1.4|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|On commande le système sur sa butée basse et on relève les mesures min et max. Au bout de Kfvcpe_noise_learn_count mesures on fait la différence entre le max et le min et on obtient le bruit de mesure.|
VLVACTEXSERVO_vidControlAlgo|J|();|FCT2.1|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|L'algorithme de commande se décompose en deux parties:1_Determine_PID_Terms qui calcule des actions du PID; 2_Evaluate_PID_Duty_Cycle qui calcule la Somme des actions du correcteur,|
VLVACTEXSERVO_vidDetPIDTerms|C|();|FCT2.3|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Le correcteur PID est logiquement partagé en trois, un bloc pour le calcul de chacune de ces actions.|
VLVACTEXSERVO_vidDiagnosis|H|();|FCT2.10|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|La surveillance de l'erreur de position du décaleur n'est active que lorsque le système est en asservissement sur la position de consigne de l'applicatif.|
VLVACTEXSERVO_vidEvalDerivTerm|G|();|FCT2.6|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Suivant la valeur du booléen Vta_exhaust_der_mod l'action dérivée est faite sur l'erreur de vitesse ou sur la vitesse.|
VLVACTEXSERVO_vidEvalIntegVal|I|();|FCT2.4|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|L'action intégrale est active à l'intérieur d'une bande (Vta_exhaust_band), à l'interieur de laquelle, on actualise la valeur intégrale|
VLVACTEXSERVO_vidEvalPIDDutCycle|F|();|FCT2.7|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Pour le calcul du RCO PID on ajoute les actions proportionnelle et dérivée à la valeur intégrale. De meme, on impose la commande en boucle ouverte pour des consignes très proches des butées, afin d'éviter les contacts répétés avec les butées physiques.|
VLVACTEXSERVO_vidEvalPropTerm|H|();|FCT2.5|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|L'action proportionnelle à l'intérieur de la bande (Vta_exhaust_band) est calculée de manière classique .|
VLVACTEXSERVO_vidInitFailure|B|();|FCT1.10|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Les pannes présentes sont initialisées sur clé off --> on afin qu’elles ne restent pas figées à ON entre le clé off --> on et le démarrage du moteur.|
VLVACTEXSERVO_vidInitialize|E|();|FCT1.6|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Dans le cadre de l’apprentissage de la valeur RCO d’équilibre, on incrémente la commande et on teste si il y a eu du mouvement.|
VLVACTEXSERVO_vidInitIntegral|D|();|FCT1.3|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|L'action intégrale est active à l'intérieur d'une bande (Vta_exhaust_band), dans cette bande on actualise la valeur intégrale (qui suit les variations lentes du RCO d'équilibre)|
VLVACTEXSERVO_vidInitOutput|F|();|FCT1.2|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Initialisation des variables produites.|
VLVACTEXSERVO_vidInitRst|E|();|FCT1.1|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Initialisation des variables au reset.|
VLVACTEXSERVO_vidLearnNoise|C|();|FCT1.5|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Au bout de Kfvcpe_noise_learn_count mesures on fait la différence entre le max et le min et on obtient le bruit de mesure.|
VLVACTEXSERVO_vidSelDutyCycl|C|();|FCT1.8|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|fonction de Selection de Duty_Cycle|
VLVACTEXSERVO_vidSelectPWM|C|();|FCT1.9|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Choix du RCO à appliquer: apprentissage initial du RCO d'équilibre, mode banc, valeur RCO issue du régulateur PID.|
VLVACTEXSERVO_vidServoError|C|();|FCT2.2|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Afin de pouvoir maîtriser les dépassements lors des fortes variations de consignes (échelons), un degré de liberté est ajouté sur la consigne de position VVT.|
VLVACTEXSERVO_vidServoError_2|A|();|FCT2.8|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Correction du mauvais calcul de l'erreur d'asservissement lors des passage BF-->BO près des butées.|
VLVACTEXSERVO_vidSetpVelocity|E|();|FCT1.7|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Fonction qui calcule la dérivée de la  consigne  utilisée  par l'action dérivée de l'asservissement VVT.|
VLVACTEXSERVO_vidVcpeDiagnosis|G|();|FCT2.9|VLVACTEXSERVO|0|PTS_DOC_5060920||||0|0|0|0|Le diagnostic est inhibé lorsque: le mode banc pwm est actif, le régime est en dessous du seuil minimum, les offsets ne sont pas encore appris, une panne fonction vient d'être détectée.|
VLVACTEXVLVBENCHMOD_vidCalcExVlv|A|();|FCT1.3|VLVACTEXVLVBENCHMOD|0|V02 NT 09 08224||||0|0|0|0|Compute the exhaust valve setpoint in bench mode|
VLVACTEXVLVBENCHMOD_vidExVlv|A|();|FCT1.2|VLVACTEXVLVBENCHMOD|0|V02 NT 09 08224||||0|0|0|0|Inhibit the calculation of the exhaust valve bench mode setpoint when the bench mode is not enabled|
VLVACTEXVLVBENCHMOD_vidIniExVlv|A|();|FCT1.1|VLVACTEXVLVBENCHMOD|0|V02 NT 09 08224||||0|0|0|0|Outputs Initialization|
VLVACTINACQ_vidCamEngineSpeed|A|();|FCT2.6|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Cette fonction reconstitue le régime moteur à partir de l’intervalle de temps entre deux évènements dents AAC admission et l’écart angulaire théorique entre deux évènements dents AAC admission.|
VLVACTINACQ_vidCamTargetState|C|();|FCT1.6|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction pour la la lecture de l’état de la cible de l’arbre à cames admission à partir des basses couches logicielles (LDB).|
VLVACTINACQ_vidCurrentShift|F|();|FCT1.4|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Processus de mesure du décalage|
VLVACTINACQ_vidCurrentVelo|G|();|FCT3.1|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Ce bloc calcule la valeur de la vitesse de décalage de l’AAC d’admission|
VLVACTINACQ_vidCurrentVelocity|D|();|FCT1.5|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction de calcul de la valeur de la vitesse de décalage de l’AAC d’admission|
VLVACTINACQ_vidEntryInit|A|();|SCH.1|VLVACTINACQ|1|PTS_DOC_6588653||||0|0|0|0|Fonction d'accroche moniteur pour le Reset du calculateur|
VLVACTINACQ_vidInCamEngineSpd|C|();|FCT2.7|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction pour la reconstitution du  régime moteur à partir de l’intervalle  de temps et de l’écart angulaire théorique entre deux évènements dents AAC admission.|
VLVACTINACQ_vidInit|C|();|FCT1.3|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Ce bloc initialise, sur front montant de Moteur_synchronisé, les variables suivantes : - Vta_intake_camshaft_shift et Vta_intake_tooth_counter (compteur de dents )|
VLVACTINACQ_vidInitOutput|L|();|FCT1.1|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Initialisation des variables de sortie|
VLVACTINACQ_vidInitPannes|B|();|FCT1.2|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Les pannes VVT présentes sont initialisées sur clé off/on afin de ne pas rester figées entre le clé on et le démarrage du moteur.|
VLVACTINACQ_vidIntakeCalcul|B|();|FCT2.4|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction de calcul de la valeur de la vitesse de décalage de l’AAC d’admission|
VLVACTINACQ_vidIntakeCaptCalc|C|();|FCT2.3|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction de calcul du décalage à partir des mesures sur les fronts dents AAC|
VLVACTINACQ_vidIntakeDiagnosis|E|();|FCT2.5|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Cette fonction réalise le diagnostic pmh|
VLVACTINACQ_vidIntakePmhCounter|E|();|FCT3.4|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Cette fonction réalise  le  diagnostic  sur  le  nombre  de  pmh  vu   successivement (c'est à dire sans événement dent AAC intercalé)|
VLVACTINACQ_vidIntakePmhDiag|D|();|FCT1.8|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction pour éviter les problèmes de synchronisation lors des démarrages à froid .|
VLVACTINACQ_vidIntakeResyn|D|();|FCT3.3|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction de resynchronisation du compteur dent AAC sur une panne présente pmh ou/et décalage|
VLVACTINACQ_vidIntakeResynchro|B|();|FCT1.7|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction de resynchronisation du compteur dent AAC sur une panne présente pmh ou/et décalage|
VLVACTINACQ_vidIntakeRisingCapt|K|();|FCT2.1|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction  de prise en compte du nombre de dents de la cible AAC|
VLVACTINACQ_vidIntCamshaftEdge|B|();|FCT3.5|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Sur l’événement InCam, le compteur de fronts utiles est incrémenté.|
VLVACTINACQ_vidMissToothbMonRun|A|();|FCT3.8|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction de calcul de la variable VlvAct_bMonRunMissToothVlvActIn.|
VLVACTINACQ_vidORngShiftbMonRun|A|();|FCT3.7|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction de calcul de la variable VlvAct_bMonRunORngShiftVlvActIn.|
VLVACTINACQ_vidORngSpdVlvbMonRun|A|();|FCT3.6|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction de calcul de la variable VlvAct_bMonRunORngSpdVlvActIn.|
VLVACTINACQ_vidSecondOrderFilter|H|();|FCT3.2|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction de calcul d'un filtre du second d'ordre|
VLVACTINACQ_vidTDCDiagbMonRun|A|();|FCT3.9|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Fonction de calcul de la variable VlvAct_bMonRunTDCDiagVlvActIn.|
VLVACTINACQ_vidTraitementXDent|E|();|FCT2.2|VLVACTINACQ|0|PTS_DOC_6588653||||0|0|0|0|Detection d'un  fonctionnement  sur une dent  ratée   en contrôlant  le  temps entre deux dents consécutives.|
VLVACTINACTRTEST_vidAgregatedErr|C|();|FCT1.5|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|Dans ce bloc est calculée l’erreur statique cumulée pour chaque phase stabilisée de la consigne envoyée lors  du test actionneur de la VVT admission.|
VLVACTINACTRTEST_vidCalcSdlFast|B|();|FCT1.2|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule de l'evenement SdlFast.|
VLVACTINACTRTEST_vidCriteriaCalc|B|();|FCT1.3|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|Ce bloc calcule deux types de critère :Pour les rampes ou échelons on calcule le retard ( erreur de vitesse ) ET Pour les phases stabilisées du profil, on calcule l’erreur statique.|
VLVACTINACTRTEST_vidEndStTrans|B|();|FCT3.6|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule de l'etat  INVLVACT_ACTRTST_END|
VLVACTINACTRTEST_vidFstSpdErrClc|C|();|FCT1.9|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule du retard.|
VLVACTINACTRTEST_vidIdleStTrans|B|();|FCT2.5|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule de l'etat INVLVACT_ACTRTST_IDLE|
VLVACTINACTRTEST_vidInitializati|C|();|FCT1.1|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|initialisation des variables de sorties et de l'automate.|
VLVACTINACTRTEST_vidMeaCriTiComp|B|();|FCT2.1|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule du temps nécessaire pour atteindre la valeur final.(Pour la mesure)|
VLVACTINACTRTEST_vidPhase10Trans|B|();|FCT3.5|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule de l'etat INVLVACT_ACTRTST_PHASE10|
VLVACTINACTRTEST_vidPhase1Trans|B|();|FCT2.6|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule de l'etat INVLVACT_ACTRTST_PHASE1|
VLVACTINACTRTEST_vidPhase2Trans|B|();|FCT2.7|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule de l'etat INVLVACT_ACTRTST_PHASE2|
VLVACTINACTRTEST_vidPhase3Trans|B|();|FCT2.8|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule de l'etat INVLVACT_ACTRTST_PHASE3|
VLVACTINACTRTEST_vidPhase4Trans|C|();|FCT2.9|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule  de l'etat INVLVACT_ACTRTST_PHASE4|
VLVACTINACTRTEST_vidPhase5Trans|B|();|FCT2.10|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule  de l'etat INVLVACT_ACTRTST_PHASE5|
VLVACTINACTRTEST_vidPhase6Trans|B|();|FCT3.1|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule de l'etat INVLVACT_ACTRTST_PHASE6|
VLVACTINACTRTEST_vidPhase7Trans|B|();|FCT3.2|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule de l'etat INVLVACT_ACTRTST_PHASE7|
VLVACTINACTRTEST_vidPhase8Trans|B|();|FCT3.3|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule de l'etat INVLVACT_ACTRTST_PHASE8|
VLVACTINACTRTEST_vidPhase9Trans|B|();|FCT3.4|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|calcule de l'etat INVLVACT_ACTRTST_PHASE9|
VLVACTINACTRTEST_vidSetpointComp|C|();|FCT2.4|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|Ce bloc génère le profil de consigne envoyé lors du test actionneur de la VVT admission.|
VLVACTINACTRTEST_vidSetpointCrit|B|();|FCT1.10|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|on calcule du temps nécessaire pour atteindre la valeur finale .(Pour la consigne  )|
VLVACTINACTRTEST_vidSpdErrInCalc|C|();|FCT2.3|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|Dans ce bloc sont calculées les indicateurs d’erreurs de vitesse sur les différentes rampes de  la consigne  envoyée lors du test actionneur de la VVT admission.|
VLVACTINACTRTEST_vidSpeedErrorCo|B|();|FCT1.8|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|Pour les phases stabilisées du profil, on calcule l’erreur statique.|
VLVACTINACTRTEST_vidSpeedErrorMe|B|();|FCT2.2|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|Dans ce bloc sont calculées les différents coefficients intervenant dans le calcul du seuil utilisé pour le calcul de  l’erreur de vitesse.|
VLVACTINACTRTEST_vidStatErrorCom|B|();|FCT1.4|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|Dans ce bloc sont calculées les erreurs statiques.|
VLVACTINACTRTEST_vidStatErrorMea|C|();|FCT1.6|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|Dans ce bloc sont calculées pour chaque phases stabilisées du profil de consigne envoyé lors du test  actionneur de la VVT admission, les indices de temps utilisés dans le calcul de l’erreur statique moyenne.|
VLVACTINACTRTEST_vidStErrCritClc|C|();|FCT1.7|VLVACTINACTRTEST|0|V02 NT 09 05822||||0|0|0|0|Dans ce bloc sont calculées les indicateurs d’erreurs statiques sur les différentes portions stabilisées de  la  consigne envoyée lors du test actionneur de la VVT admission.|
VLVACTINCLN_vidClnAlgCalc|B|();|FCT2.1|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|calculer la durée de chaque impulsion de la commande envoyée pour le nettoyage et selectionner le mode (préventif ou curatif).
VLVACTINCLN_vidClnCnd|E|();|FCT2.2|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|selectionner le mode curatif ou préventif.
VLVACTINCLN_vidClnInCnteFrstcln|A|();|FCT1.5|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Ce bloc incrémente l’index de temps utilisé dans la cartographie générant la commande de nettoyage en mode préventif.
VLVACTINCLN_vidClnIndTiCnt|C|();|FCT1.2|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|index du compteur pour le mode curatif et le mode préventif.
VLVACTINCLN_vidClnIndTmCntPct|A|();|FCT1.4|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Ce bloc incrémente l’index de temps utilisé dans la cartographie générant la commande de nettoyage en mode préventif.
VLVACTINCLN_vidClnIndTmCntRct|A|();|FCT1.3|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Ce bloc incrémente l’index de temps utilisé dans la cartographie générant la commande de nettoyage en mode curatif.
VLVACTINCLN_vidCmdCalc|G|();|FCT1.9|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Le nettoyage (mode préventif, mode curatif, sortie usine) se fait suivant un profil de commande défini par les cartographies VlvAct_InNormClnCmd_M, VlvAct_InHealClnCmd_M et VlvAct_InFrstClnCmd_M.
VLVACTINCLN_vidCmdcmp|C|();|FCT1.8|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Le calcul du consigne RCO de commande se fait à travers le booléen d'activation du nettoyage de l'EV VVT admission( VlvAct_bInClnEna).
VLVACTINCLN_vidErrCntRst|A|();|FCT2.4|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Quand l’erreur Vcpe_cam_position_error est revenue dans des limites acceptables le compteur de nettoyages en mode curatif est réinitialisé.
VLVACTINCLN_vidErrCountRst|C|();|FCT1.6|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|remise à zero de la variable VlvAct_CtInHealClnErr
VLVACTINCLN_vidFrstCleaCond|B|();|FCT1.10|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Le mode de nettoyage sortie usine « nettoyage moteur neuf » doit permettre l’élimination des copeaux d’usinage présents dans le circuit d’huile qui n’auraient pas pu être supprimés lors du nettoyage réalisé après le montage du moteur à l’usine moteur.
VLVACTINCLN_vidFrstCleanVarUpdte|A|();|FCT2.10|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Mise à jour de VlvAct_ctInFrstClnCyc et VlvAct_tiInFrstClnIdc.
VLVACTINCLN_vidhealClnMngTimeRst|A|();|FCT3.1|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Réinitialisation de la durée de surveillance de l'erreur pour la VVT échappement en mode curatif
VLVACTINCLN_vidInitOutput|J|();|FCT1.1|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|initialisation
VLVACTINCLN_vidManCleanVarUpdate|A|();|FCT2.9|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Mise à jour de la variable VlvAct_bInManClnEnaIdc.
VLVACTINCLN_vidPctClnVarUdt|C|();|FCT2.8|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|mise à jour des variables VlvAct_tiInNormClnIdc, VlvAct_bInNormClnEnd et VlvAct_bInManClnEnaIdc.
VLVACTINCLN_vidPctcnd|F|();|FCT2.7|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Le nettoyage en mode préventif se déroule lors de phases impactant peu le fonctionnement moteur (ralenti,coupure d’injection).Il est lancé suivant une récurrence définit par la calibration VlvAct_tiInNormClnDly_C.
VLVACTINCLN_vidRctClnUdt|A|();|FCT1.7|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Mise à jour des variables liées aux nettoyages curatifs
VLVACTINCLN_vidRctClnVarUdt|D|();|FCT2.5|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|A chaque fois qu’un cycle de nettoyage en mode curatif se termine on incrémente le compteur VlvAct_CtInHealClnErr.
VLVACTINCLN_vidRctCnd|K|();|FCT2.3|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Le nettoyage en mode curatif est lancé lorsque l’erreur Vcpe_cam_position_error est supérieure à un seuil durant une certaine période.
VLVACTINCLN_vidRctCndFrtcln|C|();|FCT2.6|VLVACTINCLN|0|V02 NT 08 08234||||0|0|0|0|Le nettoyage en mode curatif est lancé lorsque l’erreur Vcpe_cam_position_error est supérieure à un seuil.
VLVACTINCMD_vidBatteryComp|D|();|FCT1.4|VLVACTINCMD|0|PTS_DOC_6588664||||0|0|0|0|Pour éviter que les variations de la tension batterie ne perturbent la commande on a trois mode de compensation: pas de compensation, compensation linéaire, compensation du second ordre.|
VLVACTINCMD_vidDiagnostic|D|();|FCT1.6|VLVACTINCMD|0|PTS_DOC_6588664||||0|0|0|0|Fonction de diagnostique défaut du driver de la VVT admission.|
VLVACTINCMD_vidEnablePwm|C|();|FCT1.3|VLVACTINCMD|0|PTS_DOC_6588664||||0|0|0|0|Lors de la demande de fonctionnement de la VVT admission (Demande_vvt_adm_dormant = 0), on active le driver de la VVT admission (Autorisation_pwm_adm = 1) si la tension batterie se situe dans la plage de fonctionnement prédéfinie.|
VLVACTINCMD_vidInitialization|B|();|FCT1.2|VLVACTINCMD|0|PTS_DOC_6588664||||0|0|0|0|A l’initialisation de l’ECU, la valeur de consigne RCO appliquée est nulle ; la fréquence du signal RCO est configurable par calibration et mise à jour uniquement à ce moment.|
VLVACTINCMD_vidInitOutput|A|();|FCT1.1|VLVACTINCMD|0|PTS_DOC_6588664||||0|0|0|0|Initialisation des sorties.|
VLVACTINCMD_vidPwmCommand|F|();|FCT1.5|VLVACTINCMD|0|PTS_DOC_6588664||||0|0|0|0|Lorsque le driver est activé, le module PWM correspondant à la commande VVT admission est réglé pour générer le signal RCO désiré.|
VLVACTINENDSTOP_IntOffIndUpdate|C|();|FCT2.10|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Mise à jour de l'etat de l'apprentissage des butées de l'AAC admission|
VLVACTINENDSTOP_IntOffIndUpdate1|F|();|FCT3.2|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Cette fonction permet le forçage à 1 de l'indicateur Vcpi_cam_offsets_are_learned lorsque les conditions d'apprentissage sont perdues.|
VLVACTINENDSTOP_vidEepromWrite|C|();|FCT3.1|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Fonction d'écriture dans EEPROM|
VLVACTINENDSTOP_vidFrstOffLrnCon|K|();|FCT2.9|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Le premier apprentissage est réalisé si et seulement si plusieurs conditions (température  et pression d’huile, température d’eau, régime et pas de mode dégradé pour la VVT  admission)  sont réalisées.|
VLVACTINENDSTOP_vidFrtLrnWtDfCpt|B|();|FCT3.3|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Cette fonction est active si la variable FRM_bInhVlvActInFrstLrnIdc prend 0.|
VLVACTINENDSTOP_vidInitDiagSrv|D|();|FCT1.10|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Ce bloc procède à l’initialisation des variables suivantes suite à une demande APV : - Valeur apprentissage butée basse déphaseur AAC admission - Etat apprentissage déphaseur AAC admission - Etat apprentissage roulage en cours admission|
VLVACTINENDSTOP_vidInitFailure|D|();|FCT1.2|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Les pannes VVT présentes sont initialisées sur clé off-on afin de ne pas rester figées entre le clé on et le démarrage du moteur.|
VLVACTINENDSTOP_vidInitOutput|G|();|FCT1.1|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Initialisation des sorties au reset.|
VLVACTINENDSTOP_vidInOffReset|F|();|FCT1.9|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Intake offset reset.|
VLVACTINENDSTOP_vidInOffsets|M|();|FCT2.2|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Lors  d'un  apprentissage  en  fonctionnement  si  le  contrôle  moteur  demande  un  décalage  on  sort  de l'apprentissage  pour  revenir  en  mode  asservi. L'apprentissage  en  fonctionnement  se  fera  lors  du  prochain passage au ralenti.|
VLVACTINENDSTOP_vidIntakeOff|L|();|FCT2.1|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Ce bloc calcule la valeur de décalage de l’AAC d’admission en soustrayant à la dernière valeur acquise de l’angle vilebrequin une valeur de référence apprise ou calibrée pour chacune des dents de la cible AAC.|
VLVACTINENDSTOP_vidIntAllowLearn|I|();|FCT1.8|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Ce bloc détermine quand peut commencer l'apprentissage des offsets après démarrage. Il y a trois conditions calibrables: un seuil de régime, un délai après synchronisation et un délai après que la consigne soit nulle.|
VLVACTINENDSTOP_vidIntAllowLrng|H|();|FCT1.7|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Condition pour commencer l'apprentissage des offsets après démarrage.|
VLVACTINENDSTOP_vidLearningDiag|K|();|FCT2.3|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Les offsets mesurés sont appris en EEPROM si on n'a pas eu de panne, si le moteur est chaud et si on pas eu de fonctionnement 3 dents pendant cet apprentissage. Cette fonction permet d'actualiser la variable offset.|
VLVACTINENDSTOP_vidLearningReset|D|();|FCT1.4|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|apprentissage des offsets en cours d'utilisation|
VLVACTINENDSTOP_vidLstLrnTmpCntr|D|();|FCT1.5|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|On décrémente la temporisation depuis le dernier apprentissage.|
VLVACTINENDSTOP_vidMemoirisaCond|C|();|FCT2.7|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|condition de mémoirisation|
VLVACTINENDSTOP_vidMemoirisation|B|();|FCT2.8|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Mémoirisation des valeurs de la butée  de repos de la VVT admission pour chaque dent came du précédent apprentissage.|
VLVACTINENDSTOP_vidOffAvrgComp|B|();|FCT2.6|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Offsets average computation.|
VLVACTINENDSTOP_vidOffCons|B|();|FCT2.5|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|On  réalise  dans  ce  bloc  un  test  pour  vérifier  que  l'écart  entre  les  valeurs  précédemment  acquises  et  les actuelles reste dans les tolérances fixées.|
VLVACTINENDSTOP_vidOffLrnErrDet|C|(argin uint16 u16Margin,argin uint16 *u16IntakeAngle,argin uint16 *u16OffMes ,argout boolean *bErrDet);|FCT2.4|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Controler l'écart entre les valeurs précédemment acquises et les actuelles pour détecter un problème.|
VLVACTINENDSTOP_vidOffsetsReset|L|();|FCT1.3|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Possibilités pour lancer un apprentissage des offsets en cours d'utilisation|
VLVACTINENDSTOP_vidPrevOfLrnErDt|B|();|FCT3.4|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Cette fonction réalise un test pour vérifier que l'écart entre les valeurs précédemment acquises et les actuelles reste dans les tolérances fixées.|
VLVACTINENDSTOP_vidReset|M|();|FCT1.6|VLVACTINENDSTOP|0|PTS_DOC_5883893||||0|0|0|0|Vcpi_cam_offsets: angles de référence ou offsets appris précédemment --> offsets de position. Vcpi_cam_offsets_are_learned: flag fin d’apprentissage|
VLVACTINESTIM_vidDeadZone|C|();|FCT1.4|VLVACTINESTIM|0|V02 NT 09 01756||||0|0|0|0|Calcul de la consigne RCO de commande normalisée de la VVT admission|
VLVACTINESTIM_vidEntryInit|C|();|SCH.1|VLVACTINESTIM|1|V02 NT 09 01756||||0|0|0|0|Initialisation function|
VLVACTINESTIM_vidEstimGainCmp|B|();|FCT1.5|VLVACTINESTIM|0|V02 NT 09 01756||||0|0|0|0|Calcul du gain du dénominateur et du numérateur de la fonction de transfert du modèle VVT admission|
VLVACTINESTIM_vidFilCmp|A|();|FCT1.3|VLVACTINESTIM|0|V02 NT 09 01756||||0|0|0|0|Calculer la variation de l'estimation et de la mesure du décalage AAC admisson.|
VLVACTINESTIM_vidInitOutput|A|();|FCT1.1|VLVACTINESTIM|0|V02 NT 09 01756||||0|0|0|0|Initialisation of the component outputs|
VLVACTINESTIM_vidInPosnEstimCmp|D|();|FCT1.2|VLVACTINESTIM|0|V02 NT 09 01756||||0|0|0|0|L’estimation temporelle du décalage AAC peut être inhibée totalement ou partiellement|
VLVACTINESTIM_vidInPosnEstimUpd|F|();|FCT1.7|VLVACTINESTIM|0|V02 NT 09 01756||||0|0|0|0|La seconde variable d’état (variable du décalage) du filtre estimateur est mise à jour à chaque évènement d’acquisition.|
VLVACTINESTIM_vidInPosnEstimVar|D|();|FCT1.8|VLVACTINESTIM|0|V02 NT 09 01756||||0|0|0|0|Après chaque mesure du décalage AAC admission, on calcule les variations suivantes, qui donnent une indication sur la précision et le comportement du filtre estimateur par rapport à la simple mesure.|
VLVACTINESTIM_vidKalmanFil|C|();|FCT1.6|VLVACTINESTIM|0|V02 NT 09 01756||||0|0|0|0|Calcul de la Variable d'état position et d'état vitesse du filtre d'estimation du décalage AAC admission|
VLVACTINIF_vidCalcSatSetpoint|C|();|FCT1.9|VLVACTINIF|0|PTS_DOC_5320155||||0|0|0|0|En cas d’incursion en dehors de la plage fonctionnelle définie par les calibrations, on renvoie à la boucle d’air les valeurs des consignes saturées qui sont mises  toutes  les deux à la même valeur de reconfiguration.|
VLVACTINIF_vidCmOfsCmp|E|();|FCT1.4|VLVACTINIF|0|PTS_DOC_5320155||||0|0|0|0|Le calcul du décalage de montage de l’ensemble cible AAC + actionneur VVT est déterminé lorsque l’ensemble des dents de la cible AAC sont décalés dans le même sens par rapport à leur position théorique dans le référentiel moteur.|
VLVACTINIF_vidInitialisation|B|();|FCT1.2|VLVACTINIF|0|PTS_DOC_5320155||||0|0|0|0|Initialisation des sorties.|
VLVACTINIF_vidInitOutput|J|();|FCT1.1|VLVACTINIF|0|PTS_DOC_5320155||||0|0|0|0|Initialisation des sorties|
VLVACTINIF_vidVlvActCmToothOfs|D|();|FCT1.5|VLVACTINIF|0|PTS_DOC_5320155||||0|0|0|0|Calcul du parametre VlvAct_agCkInCmToothOfs|
VLVACTINIF_vidVlvActOfsCmp|E|();|FCT1.6|VLVACTINIF|0|PTS_DOC_5320155||||0|0|0|0|Lorsqu’il est activé, ce bloc permet d’estimer le décalage de montage de l’actionneur VVT à partir de l’offset de décalage constaté pour l’ensemble cible AAC + actionneur VVT|
VLVACTINIF_vidVVTDiagInhFlagCal|C|();|FCT1.10|VLVACTINIF|0|PTS_DOC_5320155||||0|0|0|0|On parle de croissement de soupape lorsque le RFE a lieu avant l’ AOA et si la différence des pression admission et échappement est supérieure à un seuil auquel cas le booléen indiquant un balayage des soupapes est positionné à 1.|
VLVACTINIF_vidVVTPosition|I|();|FCT1.7|VLVACTINIF|0|PTS_DOC_5320155||||0|0|0|0|La position réelle d’ouverture des soupapes d’admission dans le référentiel moteur est calculée à partir de la valeur estimée du décalage d’AAC, issue de la loi de commande VVT admission.|
VLVACTINIF_vidVVTSetpoint|N|();|FCT1.8|VLVACTINIF|0|PTS_DOC_5320155||||0|0|0|0|La consigne de décalage AAC admission, utilisée par la loi de commande VVT admission est calculée à partir de la consigne en position d’ouverture des soupapes à l’admission dans le référentiel moteur.|
VLVACTINIF_vidVVTToothErrDet|C|();|FCT1.3|VLVACTINIF|0|PTS_DOC_5320155||||0|0|0|0|Le calcul des erreurs de géométrie ainsi que des offsets de décalage de montage de la cible et de l’actionneur VVT est effectué après chaque apprentissage des butées de repos.|
VLVACTINMNG_vidClnStEnaCdn|D|();|FCT1.6|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|La stratégie de nettoyage de l’électrovanne de commande de l’actionneur de décalage AAC admission n’est activée que lorsqu’une requête de nettoyage a été émise par la stratégie dédiée; cette stratégie peut également être activée manuellement.|
VLVACTINMNG_vidEngStopAuth|C|();|FCT1.10|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|La LdC VVT admission doit informer à tout moment les autres fonctions du contrôle moteur si la position du déphaseur VVT admission permet l’arrêt du moteur|
VLVACTINMNG_vidEntryInit|E|();|SCH.1|VLVACTINMNG|1|V02 NT 08 07174||||0|0|0|0|sched reset|
VLVACTINMNG_vidInitOutput|G|();|FCT1.1|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|initialisation des sorties|
VLVACTINMNG_vidInitStEnaCdn|E|();|FCT1.2|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|Quelque soit l’état de l’automate de gestion de la fonction VVT admission, le décaleur doit pouvoir revenir à sa position de repos dés que les conditions de fonctionnement nominal ne sont plus réunies, afin de protéger l’actionneur de décalage.|
VLVACTINMNG_vidLrnStEnaCdn|F|();|FCT1.4|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|L’apprentissage de la butée basse de l’actionneur de décalage AAC admission n’est autorisé que lorsque toutes les conditions adéquates de fonctionnement moteur sont réunies|
VLVACTINMNG_vidMngStCmd|E|();|FCT1.8|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|La commande envoyée au driver de pilotage RCO de l’électrovanne de commande VVT admission est nulle|
VLVACTINMNG_vidServoStEnaCdn|E|();|FCT1.5|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|Le pilotage en boucle fermé de l’actionneur de décalage AAC admission n’est autorisé que lorsque toutes les conditions adéquates de fonctionnement moteur sont réunies|
VLVACTINMNG_vidStMng|I|();|FCT1.7|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|Gestion de la fonction VVT admission|
VLVACTINMNG_vidTimer1|A|();|FCT1.3|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|Calcul des sorties des Timers 1 et 2|
VLVACTINMNG_vidTimer2|D|();|FCT1.9|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|Calcul des sorties Timers 3 et 4|
VLVACTINMNG_vidUnlckStr|C|();|FCT2.1|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|Automate de la stratégie de désengagement du pion de blocage VVT admission|
VLVACTINMNG_vidUnlockStrategy|B|();|FCT2.2|VLVACTINMNG|0|V02 NT 08 07174||||0|0|0|0|Stratégie de désengagement du pion de blocage VVT admission|
VLVACTINMON_vidColdDefServoDet|A|();|FCT1.7|VLVACTINMON|0|V02 NT 09 06381||||0|1|0|0|Ce bloc calcule la valeur absolue de la différence entre l'angle mesurée et l’angle de consigne à froid de la VVT admission|
VLVACTINMON_vidColdDiagActCond|A|();|FCT1.5|VLVACTINMON|0|V02 NT 09 06381||||0|1|0|0|Ce bloc calcule l’activation du diagnostic fonctionnel temps de réponse à froid de la VVT admission|
VLVACTINMON_vidColdDiagCalc|A|();|FCT1.6|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc calcule le diagnostic fonctionnel temps de réponse à froid de la VVT admission|
VLVACTINMON_vidColdDiagComp|A|();|FCT1.4|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc vérifie le temps de réponse de la VVT admission à froid|
VLVACTINMON_vidEntryInit|A|();|SCH.1|VLVACTINMON|1|V02 NT 09 06381||||0|0|0|0|Fonction d'accroche Reset|
VLVACTINMON_vidFstColdTempTest|B|();|FCT1.8|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le premier test de temporisation à froid|
VLVACTINMON_vidFstHotStkTempTest|B|();|FCT3.5|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de départ à un seuil minimum d'écart de boucle pour le premier test de temporisation si la VVT admission est bloquée à chaud|
VLVACTINMON_vidFstHotTempTest|B|();|FCT2.5|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le premier test de temporisation à chaud|
VLVACTINMON_vidHotDefServoDet|A|();|FCT2.4|VLVACTINMON|0|V02 NT 09 06381||||0|1|0|0|Ce bloc calcule la valeur absolue de la différence entre l'angle mesurée et l’angle de consigne à chaud de la VVT admission|
VLVACTINMON_vidHotDiagActCond|A|();|FCT2.2|VLVACTINMON|0|V02 NT 09 06381||||0|1|0|0|Ce bloc calcule l’activation du diagnostic fonctionnel temps de réponse à chaud de la VVT admission|
VLVACTINMON_vidHotDiagCalc|A|();|FCT2.3|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc calcule le diagnostic fonctionnel temps de réponse à chaud de la VVT admission|
VLVACTINMON_vidHotDiagComp|A|();|FCT2.1|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc vérifie le temps de réponse de la VVT admission à chaud|
VLVACTINMON_vidHotStkDefServoDet|A|();|FCT3.4|VLVACTINMON|0|V02 NT 09 06381||||0|1|0|0|Ce bloc calcule la valeur absolue de la différence entre l'angle mesurée et l’angle de départ si la VVT admission est bloquée à chaud|
VLVACTINMON_vidHotStkDiagActCond|A|();|FCT3.2|VLVACTINMON|0|V02 NT 09 06381||||0|1|0|0|Ce bloc calcule l’activation du diagnostic fonctionnel déphaseur bloqué à chaud de la VVT admission|
VLVACTINMON_vidHotStkDiagCalc|B|();|FCT3.3|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc calcule le diagnostic fonctionnel si la VVT admission est bloquée à chaud|
VLVACTINMON_vidHotStkDiagComp|A|();|FCT3.1|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc vérifie si la VVT admission est bloquée à chaud|
VLVACTINMON_vidInitialization|B|();|FCT1.1|VLVACTINMON|0|V02 NT 09 06381||||0|1|0|0|Initialisation des variables|
VLVACTINMON_vidInitOffValComp|B|();|FCT1.3|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc met à jour la valeur initiale de l'offset|
VLVACTINMON_vidNegStatErrorDiag|A|();|FCT3.8|VLVACTINMON|0|V02 NT 09 06381||||0|1|0|0|ce module calcule la différence entre la consigne et la position du déphaseur cette différence est ensuite comparée à deux seuils et en fonction de la valeur de la différence par rapport aux seuils les diagnostics sont levés.|
VLVACTINMON_vidOffsetSetPtComp|B|();|FCT1.2|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc calcule la valeur de l'offset initiale|
VLVACTINMON_vidPosStatErrorDiag|A|();|FCT3.6|VLVACTINMON|0|V02 NT 09 06381||||0|1|0|0|ce bloc calcule la différence entre la position du déphaseur AAC admission mesurée et la consigne et en fonction de la valeur de la différence par rapport à l’un ou l’autre des seuils les diagnostics sont levés.|
VLVACTINMON_vidSndColdTempTest|B|();|FCT1.9|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le deuxième test de temporisation à froid|
VLVACTINMON_vidSndHotTempTest|B|();|FCT2.6|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le deuxième test de temporisation à chaud|
VLVACTINMON_vidThrdColdTemp|B|();|FCT1.10|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le troisième test de temporisation à froid|
VLVACTINMON_vidThrdHotTemp|B|();|FCT2.7|VLVACTINMON|0|V02 NT 09 06381||||0|0|0|0|Ce bloc compare la différence entre l'angle mesurée et l'angle de consigne à un seuil maximal d'écart de boucle pour le troisième test de temporisation à froid|
VLVACTINMON_vidTime_index_reset|A|();|FCT3.7|VLVACTINMON|0|V02 NT 09 06381||||0|1|0|0|ce module initialise l'intervalle de temps pour le déclenchement des diagnostics.|
VLVACTINSERVO_vidCalPeakToPNoise|D|();|FCT1.4|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|On commande le système sur sa butée basse  et on relève les mesures min et max. Au bout de Kfvcpi_noise_learn_count mesures on fait la différence entre le max et le min et on obtient le bruit de mesure.|
VLVACTINSERVO_vidControlAlgo|J|();|FCT2.1|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|L'algorithme de commande se décompose en deux parties:1_Determine_PID_Terms qui calcule des actions du PID; 2_Evaluate_PID_Duty_Cycle qui calcule la Somme des actions du correcteur,|
VLVACTINSERVO_vidDetPIDTerms|D|();|FCT2.3|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Le correcteur PID est logiquement partagé en trois, un bloc pour le calcul de chacune de ces actions.|
VLVACTINSERVO_vidDiagnosis|H|();|FCT2.10|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|La surveillance de l'erreur de position du décaleur n'est active que lorsque le système est en asservissement sur la position de consigne de l'applicatif.|
VLVACTINSERVO_vidEvalDerivTerm|I|();|FCT2.6|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Suivant la valeur du booléen Vta_intake_der_mod l'action dérivée est faite sur l'erreur de vitesse ou sur la vitesse.|
VLVACTINSERVO_vidEvalIntegVal|I|();|FCT2.4|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|L'action intégrale est active à l'intérieur d'une bande (Vta_intake_band), à l'interieur de laquelle  on actualise la valeur intégrale|
VLVACTINSERVO_vidEvalPIDDutCycle|I|();|FCT2.7|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Pour le calcul du RCO PID on ajoute les actions proportionnelle et dérivée à la valeur intégrale. De meme, on impose la commande en boucle ouverte pour des consignes très proches des butées, afin d'éviter les contacts répétés avec les butées physiques.|
VLVACTINSERVO_vidEvalPropTerm|I|();|FCT2.5|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|L'action proportionnelle à l'intérieur de la bande (Vta_intake_band) est calculée de manière classique.|
VLVACTINSERVO_vidInitFailure|B|();|FCT1.10|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Les pannes présentes sont initialisées sur clé off --> on afin qu’elles ne restent pas figées à ON entre le clé off --> on et le démarrage du moteur.|
VLVACTINSERVO_vidInitialize|F|();|FCT1.6|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Dans le cadre de l’apprentissage de la valeur RCO d’équilibre, on incrémente la commande et on teste si il y a eu du mouvement.|
VLVACTINSERVO_vidInitIntegral|E|();|FCT1.3|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|L'action intégrale est active à l'intérieur d'une bande (Vta_intake_band), dans cette bande on actualise la valeur intégrale (qui suit les variations lentes du RCO d'équilibre)|
VLVACTINSERVO_vidInitOutput|F|();|FCT1.2|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Initialisation des variables produites.|
VLVACTINSERVO_vidInitRst|E|();|FCT1.1|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Initialisation des variables au reset.|
VLVACTINSERVO_vidLearnNoise|C|();|FCT1.5|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Au bout de Kfvcpi_noise_learn_count mesures on fait la différence entre le max et le min et on obtient le bruit de mesure.|
VLVACTINSERVO_vidSelDutyCycl|C|();|FCT1.8|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|fonction  de Selection de Duty_Cycle|
VLVACTINSERVO_vidSelectPWM|C|();|FCT1.9|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Choix du RCO à appliquer: apprentissage initial du RCO d'équilibre, mode banc, valeur RCO issue du régulateur PID.|
VLVACTINSERVO_vidServoError|D|();|FCT2.2|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Afin de pouvoir maîtriser les dépassement lors des fortes variation de consignes (échelons), un degré de liberté est ajouté sur la consigne de position VVT|
VLVACTINSERVO_vidServoError_2|A|();|FCT2.8|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|calcul de l'erreur d'asservissement lors des passage BF-->BO près des butées|
VLVACTINSERVO_vidSetpVelocity|E|();|FCT1.7|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Fonction qui calcule la dérivée de la consigne  utilisée par l'action dérivée de l'asservissement VVT.|
VLVACTINSERVO_vidVcpiDiagnosis|H|();|FCT2.9|VLVACTINSERVO|0|PTS_DOC_5060915||||0|0|0|0|Le diagnostic est inhibé lorsque: le mode banc pwm est actif, le régime est en dessous du seuil minimum, les offsets ne sont pas encore appris, une panne fonction vient d'être détectée.|
VLVACTINVLVBENCHMOD_vidClcInVlv|A|();|FCT1.3|VLVACTINVLVBENCHMOD|0|V02 NT 09 07770||||0|0|0|0|Compute the intake valve setpoint in bench mode|
VLVACTINVLVBENCHMOD_vidIniInVlv|A|();|FCT1.1|VLVACTINVLVBENCHMOD|0|V02 NT 09 07770||||0|0|0|0|output initialization|
VLVACTINVLVBENCHMOD_vidInVlv|A|();|FCT1.2|VLVACTINVLVBENCHMOD|0|V02 NT 09 07770||||0|0|0|0|Inhibit the calculation of the intake valve bench mode setpoint when the bench mode is not enabled|
VLVEXSPMGT_vidCalibration_1|A|();|FCT2.1|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 1.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_10|A|();|FCT2.10|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 10.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_11|A|();|FCT3.1|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 11.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_12|A|();|FCT3.2|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 12.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_13|A|();|FCT3.3|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 13.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_14|A|();|FCT3.4|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 14.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_15|A|();|FCT3.5|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 15.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_16|A|();|FCT3.6|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 16.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_17|A|();|FCT3.7|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 17.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_18|A|();|FCT3.8|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 18.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_2|A|();|FCT2.2|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 2.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_3|A|();|FCT2.3|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 3.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_4|A|();|FCT2.4|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 4.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_5|A|();|FCT2.5|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 5.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_6|A|();|FCT2.6|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 6.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_7|A|();|FCT2.7|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 7.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_8|A|();|FCT2.8|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 8.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibration_9|A|();|FCT2.9|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 9.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVEXSPMGT_vidCalibrations|A|();|FCT1.7|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc permet d'effectuer uniquement  les calculs des cartographies correspondants aux modes de combustion activés.|
VLVEXSPMGT_vidInit|A|();|FCT1.1|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Initialisation de la consigne VVT à la butée de repos.|
VLVEXSPMGT_vidInitOutput|A|();|FCT1.2|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Fonction d'initialisation des variables internes.|
VLVEXSPMGT_vidInterpolation|A|();|FCT1.9|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc permet d'effectuer un barycentre sur  les différentes consignes VVT correspondantes à chaque mode de combustion afin d'assurer les transitions entre modes de combustion.|
VLVEXSPMGT_vidMode_Mask|A|();|FCT1.6|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc a pour but de concaténer sur un seul flux l'ensemble des modes de combustion activés par le gestionnaire.|
VLVEXSPMGT_vidSelect_Modes|A|();|FCT1.8|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc permet de récupérer les consignes VVT correspondantes aux modes de combustion.|
VLVEXSPMGT_vidUnvect_Activ_Bool|A|();|FCT1.10|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc sert à dévectoriser le flux contenant l'ensemble des modes de combustion activés.|
VLVEXSPMGT_vidUnvectorize_Mode|B|();|FCT1.5|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce  bloc  permet  de  récupérer  les  informations  servant  à  l'élaboration  des  consignes  VVT    et  provenant  du gestionnaire de modes de combustion.|
VLVEXSPMGT_vidVectorize_Calibs|A|();|FCT3.9|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc permet de concaténer sur un seul flux l'ensemble des consignes VVT issues des cartographies.|
VLVEXSPMGT_vidVlvEx|A|();|FCT1.4|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce bloc permet d'élaborer les consignes VVT à appliquer au système en fonction des modes de combustions. Les modes de combustion tiennent compte de l'état moteur (chaud/froid, chauffe catalyseur, anticipation du ralenti, ...)|
VLVEXSPMGT_vidVlvExEna|A|();|FCT1.3|VLVEXSPMGT|0|V02 NT 11 02167||||0|0|0|0|Ce  bloc  servant  à  l’élaboration  des  consignes  VVT  peut  être  désactivé  par  l’intermédiaire  du  booléen VlvSys_bPresExServo_C dans le cas où le moteur n’est pas équipé d’un système VVT à l’échappement.|
VLVINSPMGT_vidCalibration_1|A|();|FCT2.1|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 1.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_10|A|();|FCT2.10|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 10.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_11|A|();|FCT3.1|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 11.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_12|A|();|FCT3.2|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 12.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_13|A|();|FCT3.3|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 13.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_14|A|();|FCT3.4|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 14.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_15|A|();|FCT3.5|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 15.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_16|A|();|FCT3.6|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 16.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_17|A|();|FCT3.7|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 17.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_18|A|();|FCT3.8|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 18.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_2|A|();|FCT2.2|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 2.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_3|A|();|FCT2.3|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 3.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_4|A|();|FCT2.4|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 4.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_5|A|();|FCT2.5|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 5.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_6|A|();|FCT2.6|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 6.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_7|A|();|FCT2.7|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 7.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_8|A|();|FCT2.8|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 8.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibration_9|A|();|FCT2.9|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc contient la calibration des consignes VVT du mode 9.  Le calcul de ce bloc est effectué seulement si le mode associé est activé.|
VLVINSPMGT_vidCalibrations|A|();|FCT1.7|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc permet d'effectuer uniquement  les calculs des cartographies correspondants aux modes de combustion activés.|
VLVINSPMGT_vidInit|A|();|FCT1.1|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Initialisation de la consigne VVT à la butée de repos.|
VLVINSPMGT_vidInitOutput|A|();|FCT1.2|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Fonction d'initialisation des variables internes.|
VLVINSPMGT_vidInterpolation|A|();|FCT1.9|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc permet d'effectuer un barycentre sur  les différentes consignes VVT correspondantes à chaque mode de combustion afin d'assurer les transitions entre modes de combustion.|
VLVINSPMGT_vidMode_Mask|A|();|FCT1.6|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc a pour but de concaténer sur un seul flux l'ensemble des modes de combustion activés par le gestionnaire.|
VLVINSPMGT_vidSelect_Modes|A|();|FCT1.8|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc permet de récupérer les consignes VVT correspondantes aux modes de combustion.|
VLVINSPMGT_vidUnvect_Activ_Bool|A|();|FCT1.10|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc sert à dévectoriser le flux contenant l'ensemble des modes de combustion activés.|
VLVINSPMGT_vidUnvectorize_Mode|B|();|FCT1.5|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce  bloc  permet  de  récupérer  les  informations  servant  à  l'élaboration  des  consignes  VVT    et  provenant  du gestionnaire de modes de combustion.|
VLVINSPMGT_vidVectorize_Calibs|A|();|FCT3.9|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc permet de concaténer sur un seul flux l'ensemble des consignes VVT issues des cartographies.|
VLVINSPMGT_vidVlvIn|A|();|FCT1.4|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce bloc permet d'élaborer les consignes VVT à appliquer au système en fonction des modes de combustions. Les modes de combustion tiennent compte de l'état moteur (chaud/froid, chauffe catalyseur, anticipation du ralenti, ...)|
VLVINSPMGT_vidVlvInEna|A|();|FCT1.3|VLVINSPMGT|0|V02 NT 11 02166||||0|0|0|0|Ce  bloc  servant  à  l’élaboration  des  consignes  VVT  peut  être  désactivé  par l’intermédiaire  du  booléen VlvSys_bPresInServo_C dans le cas où le moteur n’est pas équipé d’un système VVT à l’admission.|
VlvSys_EveIni_VlvArb|A|();|SCH.1|OFSVLV|1|V02 NT 11 02164||||0|0|0|0|Evenement d'initialisation|
VlvSys_EveIni_VlvEx|A|();|SCH.1|VLVEXSPMGT|1|V02 NT 11 02167||||0|0|0|0|Fonction d'appel de l'initialisation de la fonction VlvEx|
VlvSys_EveIni_VlvExIf|D|();|SCH6.6|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement reset de la fonction VlvEx pour l'interface.|
VlvSys_EveIni_VlvIn|A|();|SCH.1|VLVINSPMGT|1|V02 NT 11 02166||||0|0|0|0|Fonction d'appel de l'initialisation de la fonction VlvIn|
VlvSys_EveIni_VlvInIf|D|();|SCH6.5|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Evenement reset de la fonction VlvIn pour l'interface.|
VlvSys_SdlFast_AltiCor|A|();|SCH.2|ALDALTCOR|1|V02 NT 11 02165||||0|0|0|0|Fonction d'accroche à l'event VlvSys_SdlFast_AltiCor|
VlvSys_SdlFast_VlvArb|A|();|SCH.2|OFSVLV|1|V02 NT 11 02164||||0|0|0|0|Evènement scheduler rapide de la fonctionVlvSys.|
VlvSys_SdlFast_VlvEx|A|();|SCH.2|VLVEXSPMGT|1|V02 NT 11 02167||||0|0|0|0|Fonction d'appel de la fonction VlvEx|
VlvSys_SdlFast_VlvExIf|D|();|SCH9.10|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide de la fonction VlvEx pour l'interface.|
VlvSys_SdlFast_VlvIn|A|();|SCH.2|VLVINSPMGT|1|V02 NT 11 02166||||0|0|0|0|Fonction d'appel de la fonction VlvIn|
VlvSys_SdlFast_VlvInIf|D|();|SCH10.1|IFAIRSYSIGSYS|1|PTS_DOC_5076182||||0|0|0|0|Moniteur rapide de la fonction VlvIn pour l'interface.|
Volt_EveInj_InjVoltAdj|B|();|SCH.2|INJVOLTADJ|1|PTS_DOC_5074748||||0|0|0|0|Injection Event for InjVoltAdj|
Volt_EveSpl_InjVoltAdj|B|();|SCH.3|INJVOLTADJ|1|PTS_DOC_5074748||||0|0|0|0|Spill Event for InjVoltAdj|
Volt_SdlFast_IgVoltAdj|B|();|SCH.2|IGVOLTADJ|1|PTS_DOC_6444206||||0|0|0|0|SdlFast for IgVoltAdj|
VSC_vidInit|A|();|FCT1.1|VSC|0|V02 NT 12 04370||||0|1|0|0|Variables initialization|
VSC_vidInit_Output|A|();|FCT1.2|VSC|0|V02 NT 12 04370||||0|1|0|0|Variables Initilizition.|
VSC_vidRecHis1|A|();|FCT1.3|VSC|0|V02 NT 12 04370||||0|1|0|0|Calculation of the new values for VSCtl_prmLstCrsCtlDeacCaus1 when a new memorization is effective (part1 of the function)|
VSC_vidRecHis2|A|();|FCT1.4|VSC|0|V02 NT 12 04370||||0|1|0|0|Calculation of the new values for VSCtl_prmLstCrsCtlDeacCaus1 when a new memorization is effective (part2 of the function)|
VSC_vidRecLstCrsCtlDeacCaus1|A|();|FCT1.5|VSC|0|V02 NT 12 04370||||0|1|0|0|When a new memorization is effective, all the previous one are shifted and VSCtl_prmLstCrsCtlDeacCaus1 is updated|
VSC_vidRecLstCrsCtlDeacCaus2|A|();|FCT1.6|VSC|0|V02 NT 12 04370||||0|1|0|0|When a new memorization is effective, all the previous one are shifted and VSCtl_prmLstCrsCtlDeacCaus1 is updated|
VSCTL_EveRst_LstCrsCtlDeacCaus|A|();|SCH.1|VSC|1|V02 NT 12 04370||||0|1|0|0|Evenement Reset|
VSCTL_SdlMid_LstCrsCtlDeacCaus|A|();|SCH.2|VSC|1|V02 NT 12 04370||||0|1|0|0|Event SdlMid|
VSSNWDMTRACV_vidCallMng|B|();|FCT1.2|VSSNWDMTRACV|0|PTS_DOC_6525894||||0|0|0|0|Si le flux de contrôle Pwr_bAcvDMTRAcq est actif alors la fonction Software "demande de maintien tension réseau" est activée sinon elle n'est pas activée.
VSSNWDMTRACV_vidDiag|E|();|FCT1.5|VSSNWDMTRACV|0|PTS_DOC_6525894||||0|0|0|0|Diagnostic de la panne Court-circuit
VSSNWDMTRACV_vidDMTR_AcvReq|E|();|FCT1.3|VSSNWDMTRACV|0|PTS_DOC_6525894||||0|0|0|0|la consigne de commande pour le driver de la demande de maintien tension réseau DMTR
VSSNWDMTRACV_vidDMTR_Cmd|C|();|FCT1.4|VSSNWDMTRACV|0|PTS_DOC_6525894||||0|0|0|0|Pour piloter l'actionneur, l'ECU ramène la masse (et oui, du courant va circuler entre le 12V et la masse à travers l'actionneur). L'état de la sortie est ' 0 '. Pour ne pas piloter l'actionneur, l'ECU laisse la pin en circuit ouvert.
VSSNWDMTRACV_vidEntryInit|B|();|SCH.1|VSSNWDMTRACV|1|PTS_DOC_6525894||||0|0|0|0|evènement d'initialisation des variables
VSSNWDMTRACV_vidInitOutput|B|();|FCT1.1|VSSNWDMTRACV|0|PTS_DOC_6525894||||0|0|0|0|Initialisation des variables
VVTSPLIMCORD_vidCalibration_1|A|();|FCT1.7|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_10|A|();|FCT2.6|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_11|A|();|FCT2.7|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_12|A|();|FCT2.8|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_13|A|();|FCT2.9|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_14|A|();|FCT2.10|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des calibrations de la fonction. Ce scalaire n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite un appel de cette calibration.|
VVTSPLIMCORD_vidCalibration_2|A|();|FCT1.8|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_3|A|();|FCT1.9|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_4|A|();|FCT1.10|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_5|A|();|FCT2.1|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_6|A|();|FCT2.2|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_7|A|();|FCT2.3|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_8|A|();|FCT2.4|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibration_9|A|();|FCT2.5|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc contient une des cartographies de la fonction. Il n’est calculé que lorsque le mode de fonctionnement courant ou celui de consigne nécessite une interpolation dans cette cartographie.|
VVTSPLIMCORD_vidCalibrations|A|();|FCT1.5|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc regroupe les différentes calibrations de la fonction|
VVTSPLIMCORD_vidEntryInit|A|();|SCH.1|VVTSPLIMCORD|1|V02 NT 11 02903||||0|0|0|0|Evénement reset du calculateur.|
VVTSPLIMCORD_vidExOfs|A|();|FCT1.2|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|La fonction est constituée de 5 blocs permettant de calculer l’offset de la température des gaz d’échappement à la sortie culasse.|
VVTSPLIMCORD_vidInitOutput|B|();|FCT1.1|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Initialisation des sorties|
VVTSPLIMCORD_vidInterpolation|B|();|FCT3.3|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc permet d’interpoler l’offset de la température des gaz d’échappement à la sortie culasse entre les valeurs pour les modes courants et de consigne.|
VVTSPLIMCORD_vidMode_Mask|A|();|FCT1.4|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc permet de sélectionner le numéro des cartographies utiles|
VVTSPLIMCORD_vidSelect_Modes|A|();|FCT3.2|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc permet de calculer l’offset de la température des gaz d’échappement à la sortie culasse pour les modes courants et de consigne|
VVTSPLIMCORD_vidUnvect_Act_Bool|A|();|FCT1.6|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc permet la démultiplication des flux de sélection des cartographies utiles.|
VVTSPLIMCORD_vidUnvectorize_Mode|B|();|FCT1.3|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc permet de sélectionner les informations provenant du gestionnaire de modes de fonctionnements|
VVTSPLIMCORD_vidVectorize_Calib|A|();|FCT3.1|VVTSPLIMCORD|0|V02 NT 11 02903||||0|0|0|0|Ce bloc permet de calculer l’offset de la température des gaz d’échappement à la sortie culasse.|
WdgM_CheckpointReached|A|(argin WdgM_SupervisedEntityIdType SEID, argin WdgM_CheckpointIdType CheckpointID)argout Std_ReturnType;|3|HEADER|1|NONE||||0|0|0|0||
WdgM_GetLocalStatus|A|(argin WdgM_SupervisedEntityIdType SEID, argout WdgM_LocalStatusType * Status) argout Std_ReturnType;|4|HEADER|1|NONE||||0|0|0|0||
WdgM_Init|A|(argin WdgM_ConfigType * ConfigPtr);|2|HEADER|1|NONE||||0|0|0|0||
Wg_CmdBenchMod_vidCalcWgCmdOplBenchMod|B|();|FCT1.2|WG_CMDBENCHMOD|0|V02 NT 09 08184||||0|0|0|0|The computation of the wastegate solenoid valve open loop command bench mode setpoint can be inhibited by an enable.|
Wg_CmdBenchMod_vidIniWgCmdOplSpBenchMod|B|();|FCT1.1|WG_CMDBENCHMOD|0|V02 NT 09 08184||||0|0|0|0|The wastegate solenoid valve open loop command setpoint is initialised by a calibration at reset.|
Wg_CmdBenchMod_vidWgCmd|B|();|FCT1.3|WG_CMDBENCHMOD|0|V02 NT 09 08184||||0|0|0|0|The wastegate solenoid valve open loop command setpoint in bench mode is computed then filtered for smoothing|
Wg_CmdBenchMod_vidWgCmdCutOff|B|();|FCT1.5|WG_CMDBENCHMOD|0|V02 NT 09 08184||||0|0|0|0|The wastegate solenoid valve command setpoint is filtered for smoothing.|
Wg_CmdBenchMod_vidWgCmdRaw|C|();|FCT1.4|WG_CMDBENCHMOD|0|V02 NT 09 08184||||0|0|0|0|There are three methods to compute the wastegate solenoid valve open loop command setpoint in bench mode|
Wg_EveRst_CmdPwmAct|A|();|SCH.1|CMDPWMACT_DT|1|PTS_DOC_6913248||||0|0|0|0|Reset event|
Wg_EveRst_FctDiagWg|B|();|SCH.1|FCTDIAGWG|1|PTS_DOC_5070705||||0|0|0|0|Reset event for the ECU|
Wg_EveRst_WgActrTest|A|();|SCH.1|WGACTRTEST|1|PTS_DOC_5621841||||0|0|0|0|Evenement Reset|
Wg_EveRst_WgcCmd|C|();|SCH.1|WGCCMD|1|PTS_DOC_6851415||||0|0|0|0|Evénement reset du calculateur|
Wg_EveRst_WgCmdOplBenchMod|B|();|SCH.1|WG_CMDBENCHMOD|1|V02 NT 09 08184||||0|0|0|0|Event Reset|
Wg_EveRst_WgCmdSp|D|();|SCH.1|WGCMDSP|1|PTS_DOC_5070689||||0|0|0|0|Event reset|
Wg_EveRst_WgCmdSpArb|C|();|SCH.1|WGCMDSPARB|1|V02 NT 10 02950||||0|0|0|0|Event reset|
Wg_SdlFast_FctDiagWg|C|();|SCH.2|FCTDIAGWG|1|PTS_DOC_5070705||||0|0|0|0|Fast monitoring for Waste Gate function|
Wg_SdlMid_CmdPwmAct|A|();|SCH.6|CMDPWMACT_DT|1|PTS_DOC_6913248||||0|0|0|0|Middle monitor for AirPres function|
Wg_SdlMid_WgcCmd|C|();|SCH.2|WGCCMD|1|PTS_DOC_6851415||||0|0|0|0|Moniteur moyen pour la fonction AirPres|
Wg_SdlMid_WgcCmdDiag|A|();|SCH.9|ACQDGOHAL_DT|1|PTS_DOC_6854092||||0|0|0|0|Middle monitor for AirPres function|
Wg_SdlMid_WgCmdOplBenchMod|C|();|SCH.2|WG_CMDBENCHMOD|1|V02 NT 09 08184||||0|0|0|0|Middle schedule of the wastegate function|
Wg_SdlMid_WgCmdSp|D|();|SCH.2|WGCMDSP|1|PTS_DOC_5070689||||0|0|0|0|Middle schedule of the wastegate function|
Wg_SdlMid_WgCmdSpArb|C|();|SCH.2|WGCMDSPARB|1|V02 NT 10 02950||||0|0|0|0|Middle schedule of the wastegate function|
Wg_SdlSlow_WgActrTest|A|();|SCH.2|WGACTRTEST|1|PTS_DOC_5621841||||0|0|0|0|SdlSlow pour WgActrTest|
WGACTRTEST_vidInitOutput|A|();|FCT1.1|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Initialisation des variables appelées au reset.|
WGACTRTEST_vidState_END|A|();|FCT1.10|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Inclut le traitement relatif à l'état WG_ACTRTST_END|
WGACTRTEST_vidState_IDLE|A|();|FCT1.4|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Inclut le traitement relatif à l'état WG_ACTRTST_IDLE|
WGACTRTEST_vidState_PHASE1|A|();|FCT1.5|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Inclut le traitement relatif à l'état WG_ACTRTST_PHASE1|
WGACTRTEST_vidState_PHASE2|A|();|FCT1.6|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Inclut le traitement relatif à l'état WG_ACTRTST_PHASE2|
WGACTRTEST_vidState_PHASE3|A|();|FCT1.7|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Inclut le traitement relatif à l'état WG_ACTRTST_PHASE3|
WGACTRTEST_vidState_PHASE4|A|();|FCT1.8|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Inclut le traitement relatif à l'état WG_ACTRTST_PHASE4|
WGACTRTEST_vidState_PHASE5|A|();|FCT1.9|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Inclut le traitement relatif à l'état WG_ACTRTST_PHASE5|
WGACTRTEST_vidTestTrbActMgr|A|();|FCT1.3|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Inclut un flux d'état pour contrôler le processus de test et génère une série de signaux progressifs comme consignes.|
WGACTRTEST_vidTrbDynTest|A|();|FCT2.1|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Détermine le comportement dynamique du Wastegate une durée après un changement de consigne.|
WGACTRTEST_vidTrbStabTest|A|();|FCT2.2|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Observe l'erreur statique entre la consigne et la mesure pour déterminer si l'actionneur est obstrué.|
WGACTRTEST_vidWgActrTest|A|();|FCT1.2|WGACTRTEST|0|PTS_DOC_5621841||||0|0|0|0|Contient les blocs de génération de consigne, de détermination du comportement statique et dynamique du wastegate.|
WgcCmd_vidBat_Volt_Filtering|B|();|FCT1.3|WGCCMD|0|PTS_DOC_6851415||||0|0|0|0|The battery voltage is filtered on the two last values|
WgcCmd_vidDiagnostic|C|();|FCT1.8|WGCCMD|0|PTS_DOC_6851415||||0|0|0|0|Diagnostic Function for wastegate command|
WgcCmd_vidDuty_cycle_conversion|C|();|FCT1.6|WGCCMD|0|PTS_DOC_6851415||||0|0|0|0|The duty cycle signal of the wastegate actuator (Ext_TrbAct_rCtl) is clamped between these tow calibrations (Minimum duty cycle control and Maximum duty cycle control)|
WgcCmd_vidInitOutput|B|();|FCT1.1|WGCCMD|0|PTS_DOC_6851415||||0|0|0|0|Init function|
WgcCmd_vidP_Trb_PwrSup_calcul|B|();|FCT1.4|WGCCMD|0|PTS_DOC_6851415||||0|0|0|0|According to the chosen calibrations the power supply received by the wastegate ( Ext_uTrbAct ) will be : - Filtered in voltage -  Filtered in current -  Filtered in voltage and current -  Filtered on the two last values of the battery voltage measured|
WgcCmd_vidRequest_CorrecLimit|C|();|FCT1.5|WGCCMD|0|PTS_DOC_6851415||||0|0|0|0|According to the chosen calibrations, the duty cycle signal of the wastegate actuator is corrected or not, and bounded between 0 and 100 percent.|
WgcCmd_vidWgcCmdApplication|E|();|FCT1.7|WGCCMD|0|PTS_DOC_6851415||||0|0|0|0|According to the chosen calibrations the wastegate actuator is commanded on normal or bench mode. The wastegate signal command (PWM frequency and duty cycle) is transmitted through the basic layer via the PWMHAL service.|
WgcCmd_vidWgcTreatment|B|();|FCT1.2|WGCCMD|0|PTS_DOC_6851415||||0|0|0|0|The main function of the bloc is the processing of the wastegate control signal (PWM signal frequency and duty cycle).|
WgCmdSp_vidCdnApplAdpv|D|();|FCT1.10|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|This module checks the different conditions required to apply the adaptive part of the PWM command.|
WgCmdSp_vidCdnOpenLoop|B|();|FCT1.8|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|This module checks the absolutely required conditions to applying any PWM command (even for open loop command)|
WgCmdSp_vidCdnServoCmd|D|();|FCT1.9|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|This module checks the conditions to satisfy when applying the PWM closed loop part|
WgCmdSp_vidClcAdpv|E|();|FCT2.7|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|The adaptive part is saturated thanks to minimum and maximum adjustable thresholds.|
WgCmdSp_vidClcElm_A|D|();|FCT2.4|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|The adaptive part is computed by filtering the integral part every at the end of the down counter. Its value is stored in EEPROM momory in order to be able to detect any damage (soiling, excessive ageing…) of the solenoid valve or of the Wastegate.|
WgCmdSp_vidClcElm_D|E|();|FCT2.9|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|The main aim of the derivative part is preventing the supercharging pressure setpoint from overshooting. If the  first derivative of the raw feedback error is too significant a correction is computed.|
WgCmdSp_vidClcElm_I|E|();|FCT2.8|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|The computation of the integral part is preceded by a detection of saturation; this detection avoids the integral part from increasing when the valve is next to its thrusts.|
WgCmdSp_vidClcElm_P|E|();|FCT2.3|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|The computation of the proportional part is not null until the boost pressure is regulated. This part is the boost pressure error multiplied by a gain; however, the error is considered as null inside an adjustable dead zone.|
WgCmdSp_vidClcOfsAlti|B|();|FCT1.5|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|The pressure offset due to altitude variations concerns the pressure inputs of the strategy lead to the supercharging pressure feedback control.|
WgCmdSp_vidClcPID|B|();|FCT2.2|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|A four-part correction is added to the open loop PWM command|
WgCmdSp_vidClcPwmOpenLoop|F|();|FCT1.6|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|The open loop PWM setpoint is estimated from a map, considering the engine speed and the manifold pressure setpoint adjusted to take in account the variation of atmospheric pressure.|
WgCmdSp_vidClcPwmOpenLoopCmd|B|();|FCT1.4|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|This module computes the PWM open loop setpoint, which is also filtered for the Wastegate feedback.|
WgCmdSp_vidClcPwmWg|C|();|FCT1.1|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|The computation of the PWM setpoint|
WgCmdSp_vidFmtAdpv|D|();|FCT2.6|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|This module computes a lay-out of the integral part before computing the adaptive part. It enables the integral part to converge (thanks to the adaptive part) to a setpoint value comprised in a dead zone.|
WgCmdSp_vidInit|F|();|FCT2.1|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|This module set the initial values of some variables, to be updated on Reset event of the ECU.|
WgCmdSp_vidMemrSdl|D|();|FCT2.5|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|This module enables the strategy to update the integral part at the end of the down counter Wg_ctDownSampleTiClcAdpv.|
WgCmdSp_vidSumElmPIDA|F|();|FCT2.10|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|The final PWM command is issued from the boost pressure regulation.|
WgCmdSp_vidTranDetnClcErr|D|();|FCT1.3|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|The pressure feedback error is computed considering the setpoint and the measure of the supercharging pressure.|
WgCmdSp_vidWgServoCdn|B|();|FCT1.7|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|This module check three Wastegate working conditions, used to compute different parts of the PWM command|
WgCmdSp_vidWgSysMng|B|();|FCT1.2|WGCMDSP|0|PTS_DOC_5070689||||0|0|0|0|The computation of the main parameters applying to  the wastegate regulation|
WGCMDSPARB_vidWgArb|E|();|FCT1.1|WGCMDSPARB|0|V02 NT 10 02950||||0|0|0|0|Wastegate arbitration between the nominal mode and the bench mode|
WKU_vidAPCFirstKeyOn|A|();|FCT3.5|WKU|0|PTS_DOC_6765172||||0|0|0|0|Generation of a Key ON at the end of initialization in the case of +APC application.|
WKU_vidBlcPartWkADCAntCase|G|();|FCT2.3|WKU|0|PTS_DOC_6765172||||0|0|0|0|Cas réveil partiel bloqué anticipation ADC|
WKU_vidBlcPartWkEngOilMesPrep|G|();|FCT2.5|WKU|0|PTS_DOC_6765172||||0|0|0|0|Cas réveil partiel bloqué préparation mesures huile moteur|
WKU_vidBlcPartWkEngPostVent|G|();|FCT2.6|WKU|0|PTS_DOC_6765172||||0|0|0|0|Cas réveil partiel bloqué préparation post-ventilation moteur|
WKU_vidBlcPartWkEngStartPrep|H|();|FCT2.4|WKU|0|PTS_DOC_6765172||||0|0|0|0|Cas réveil partiel bloqué préparation démarrage moteur|
WKU_vidBlocPartWkEngOilMeas|G|();|FCT1.7|WKU|0|PTS_DOC_6765172||||0|0|0|0|Mise à jour des variables liées au réveil partiel pour mesure du niveau d'huile|
WKU_vidCaseRcdSignalEqual0|C|();|FCT3.4|WKU|0|PTS_DOC_6765172||||0|0|0|0|the value of Boolean Clef_de_contact_ss_coh and counter Rcd_tempo_boot_count whenRCD signal is equal to 0.|
WKU_vidCaseRcdSignalEqual1|C|();|FCT3.3|WKU|0|PTS_DOC_6765172||||0|0|0|0|the value of Boolean Clef_de_contact_ss_coh and counter Rcd_tempo_boot_count when RCD signal is equal to 1.|
WKU_vidElectronicIntegration|E|();|FCT3.1|WKU|0|PTS_DOC_6765172||||0|0|0|0|Intégration Electronique|
WKU_vidForcMainWkAtReqDiag|G|();|FCT2.9|WKU|0|PTS_DOC_6765172||||0|0|0|0|Forçage réveil principal sur requête diagnostic|
WKU_vidFrameMonitoring|J|();|FCT1.3|WKU|0|PTS_DOC_6765172||||0|0|0|0|Sur moniteur fixe EcuSt_SdlMid_Wku, on calcule le nombre de trames reçues, qui doit être de 1 ou 2 trames (trame 50 ms). Si ce n'est pas le cas, la panne d'absence de trame est comptée avant d'appeler le mode dégradé correspondant|
WKU_vidFrameReception|J|();|FCT1.2|WKU|0|PTS_DOC_6765172||||0|0|0|0|Réception de la trame 432H|
WKU_vidInitWku|I|();|FCT1.1|WKU|0|PTS_DOC_6765172||||0|0|0|0|Au reset, on différencie le cas d'une gestion +APC ou RCD afin que le calculateur ne reste pas verrouillé.|
WKU_vidInterface|E|();|FCT3.2|WKU|0|PTS_DOC_6765172||||0|0|0|0|Affectation de valeurs aux sorties selon la valeur du boolean indiquant l'integration du composant RCD.|
WKU_vidMainGradToPass|H|();|FCT2.7|WKU|0|PTS_DOC_6765172||||0|0|0|0|Sortie du réveil principal dégradé vers la phase transitoire|
WKU_vidMainWkCohDmdWku|F|();|FCT2.1|WKU|0|PTS_DOC_6765172||||0|0|0|0|Reveil principal du contrôle de cohérence des demandes RCD|
WKU_vidMainWkIncoh|J|();|FCT2.2|WKU|0|PTS_DOC_6765172||||0|0|0|0|Contrôle de cohérence entre Clef_de_contact et Rcd_signal|
WKU_vidMainWkPassCANOutOfOrd|J|();|FCT2.8|WKU|0|PTS_DOC_6765172||||0|0|0|0|Passage en réveil principal en cas de CAN hors service|
WKU_vidMainWku|G|();|FCT1.9|WKU|0|PTS_DOC_6765172||||0|0|0|0|Mise à jour des variables liées au réveil principal|
WKU_vidMgmtCntPowerOnDefault|G|();|FCT1.10|WKU|0|PTS_DOC_6765172||||0|0|0|0|Gérer le compteur de passage en POWER_ON_DEFAULT|
WKU_vidPartWkADCAnticip|G|();|FCT1.5|WKU|0|PTS_DOC_6765172||||0|0|0|0|Mise à jour des variables liées au réveil partiel anticipation ADC. En cas de réveils partiels multiples le CMM effectue l'ensemble des réveils partiels activés.|
WKU_vidPartWkEngPostVent|G|();|FCT1.8|WKU|0|PTS_DOC_6765172||||0|0|0|0|Mise à jour des variables liées au réveil partiel pour post-ventilation moteur|
WKU_vidPartWkEngStartPrep|H|();|FCT1.6|WKU|0|PTS_DOC_6765172||||0|0|0|0|Mise à jour des variables liées au réveil partiel préparation moteur|
WKU_vidRstRcdCount|D|();|FCT2.10|WKU|0|PTS_DOC_6765172||||0|0|0|0|Ré-initialisation de Rcd_bascule_vers_principal_count sur l'événement Clef_off_on|
WKU_vidTimerFlow|G|();|FCT1.4|WKU|0|PTS_DOC_6765172||||0|0|0|0|Ecoulement du timer Rcd_tempo_boot_count pour que le comptage des pannes FRM_bAcvPwrOnDftModRVRxn432 et FRM_bAcvDft_EcuSt_CohBsi soit possible.|
WUC_vidF02_tCoRefFrz|C|();|01.2|WUC|0|V02 NT 08 04191||||0|0|0|0|Fix the WUC reference temperature at the engine cooling liquid when the engine start.|
WUC_vidF03_F01_WupStDet|C|();|01.4|WUC|0|V02 NT 08 04191||||0|0|0|0|Update the warm up status (WUC_bWupSt).|
WUC_vidF03_F02_CtWupDftClr|B|();|01.5|WUC|0|V02 NT 08 04191||||0|0|0|0|Update the WUC meter (WUC_ctWupDftClr).|
WUC_vidF03_WupPrmUpd|C|();|01.3|WUC|0|V02 NT 08 04191||||0|0|0|0|Update the warm up status and the Warm Up meter.|
WUC_vidF05_WupPrmClrTool|C|();|01.6|WUC|0|V02 NT 08 04191||||0|0|0|0|Set data when there is an erausre.|
WUC_vidMngEveGlobDCStrt|B|();|API.1|WUC|1|V02 NT 08 04191||||0|0|0|0|API calls on the event Global DC start (New global DC). Launch all actions which must be done by the module on the event.|
WUC_vidMngEvePrmClrAfts|B|();|API.3|WUC|1|V02 NT 08 04191||||0|0|0|0|API calls on the event clear prm (erasure default request) from a afts. Launch all actions which must be done by the module on the event.|
WUC_vidMngEvePrmClrAftsScanTool|B|();|API.2|WUC|1|V02 NT 08 04191||||0|0|0|0|API calls on the event clear prm (erasure default request) from a afts scan tools. Launch all actions which must be done by the module on the event.|
WUC_vidMngEveRst|D|();|SCH.2|WUC|1|V02 NT 08 04191||||0|0|0|0|Load the parameter WUC_tCoRefEep save in EEPROM in the working parameter WUC_tCoRef.|
WUC_vidMngEveSldSlow|D|();|SCH.1|WUC|1|V02 NT 08 04191||||0|0|0|0|API calls on the event which occurs every 1024 ms. Launch all actions which must be done by the module on the event.|
WUC_vidWupInit|C|();|FCT1.1|WUC|0|V02 NT 08 04191||||0|0|0|0|Initialize the WUC parameters.|
